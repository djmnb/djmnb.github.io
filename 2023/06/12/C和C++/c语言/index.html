<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>c语言学习 | 戴晶明的个人博客</title><meta name="author" content="戴晶明"><meta name="copyright" content="戴晶明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 两年前学的c语言,好久没用了, 忘得差不多了, 现在重新学习一下,用博客记录下来,常回来复习复习    发布时间 通称 备注     1972 - C语言的原始版本由Dennis Ritchie在贝尔实验室开发。   1978 K&amp;R C Brian Kernighan和Dennis Ritchie发布《C程序设计语言》第一版，介绍了C语言的经典版本。   1989 ANSI C (">
<meta property="og:type" content="article">
<meta property="og:title" content="c语言学习">
<meta property="og:url" content="https://djmnb.github.io/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="戴晶明的个人博客">
<meta property="og:description" content="前言 两年前学的c语言,好久没用了, 忘得差不多了, 现在重新学习一下,用博客记录下来,常回来复习复习    发布时间 通称 备注     1972 - C语言的原始版本由Dennis Ritchie在贝尔实验室开发。   1978 K&amp;R C Brian Kernighan和Dennis Ritchie发布《C程序设计语言》第一版，介绍了C语言的经典版本。   1989 ANSI C (">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://djmnb.github.io/img/site/touxiang.gif">
<meta property="article:published_time" content="2023-06-11T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-19T08:25:10.328Z">
<meta property="article:author" content="戴晶明">
<meta property="article:tag" content="需要复习">
<meta property="article:tag" content="c语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://djmnb.github.io/img/site/touxiang.gif"><link rel="shortcut icon" href="/img/site/icon.jfif"><link rel="canonical" href="https://djmnb.github.io/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c语言学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-19 16:25:10'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/site/touxiang.gif" onerror="onerror=null;src='/404.html'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/why"><i class="fa-fw fas fa-question"></i><span> 十万个为什么</span></a></div><div class="menus_item"><a class="site-page" href="/goodarticle"><i class="fa-fw fas fa-book"></i><span> 好文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: /img/site/beijing.jfif"><nav id="nav"><span id="blog-info"><a href="/" title="戴晶明的个人博客"><span class="site-name">戴晶明的个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/why"><i class="fa-fw fas fa-question"></i><span> 十万个为什么</span></a></div><div class="menus_item"><a class="site-page" href="/goodarticle"><i class="fa-fw fas fa-book"></i><span> 好文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c语言学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-11T16:00:00.000Z" title="发表于 2023-06-12 00:00:00">2023-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-19T08:25:10.328Z" title="更新于 2024-09-19 16:25:10">2024-09-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>68分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="c语言学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>前言</h1>
<p>两年前学的c语言,好久没用了, 忘得差不多了, 现在重新学习一下,用博客记录下来,常回来复习复习</p>
<table>
<thead>
<tr>
<th style="text-align:left">发布时间</th>
<th style="text-align:left">通称</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1972</td>
<td style="text-align:left">-</td>
<td style="text-align:left">C语言的原始版本由Dennis Ritchie在贝尔实验室开发。</td>
</tr>
<tr>
<td style="text-align:left">1978</td>
<td style="text-align:left">K&amp;R C</td>
<td style="text-align:left">Brian Kernighan和Dennis Ritchie发布《C程序设计语言》第一版，介绍了C语言的经典版本。</td>
</tr>
<tr>
<td style="text-align:left">1989</td>
<td style="text-align:left">ANSI C (C89)</td>
<td style="text-align:left">美国国家标准学会（ANSI）发布C语言的第一个官方标准，ANSI X3.159-1989，通常被称为ANSI C。</td>
</tr>
<tr>
<td style="text-align:left">1990</td>
<td style="text-align:left">ISO C</td>
<td style="text-align:left">国际标准化组织（ISO）采纳ANSI C标准，发布ISO/IEC 9899:1990。</td>
</tr>
<tr>
<td style="text-align:left">1999</td>
<td style="text-align:left">C99</td>
<td style="text-align:left">发布新标准，引入了新的语言特性，如//注释和长整型。</td>
</tr>
<tr>
<td style="text-align:left">2011</td>
<td style="text-align:left">C11</td>
<td style="text-align:left">最新的C语言标准，引入了对并发的支持和其他一些新特性。</td>
</tr>
</tbody>
</table>
<h1>预处理器</h1>
<h2 id="定义">定义</h2>
<p>在C语言中，预处理器（preprocessor）是一个在<strong>编译阶段前执行的程序</strong>，它可以对源代码做一些预处理工作。预处理器通过预处理指令（preprocessor directives）来完成这些工作，预处理指令都以<code>#</code>符号开头。</p>
<p>以下是一些常见的预处理指令：</p>
<ol>
<li>
<p><strong>#include</strong>：这个指令用于包含头文件。例如，<code>#include &lt;stdio.h&gt;</code>会在当前源代码文件中插入stdio.h头文件的内容。这样，我们就可以使用在stdio.h中声明的函数和宏了。</p>
</li>
<li>
<p><strong>#define</strong>：这个指令用于定义宏。<strong>宏可以看作是一个文本替换工具</strong>，预处理器会在编译前将所有宏替换为其定义的内容。例如，<code>#define PI 3.14</code>定义了一个宏PI，预处理器会把源代码中所有的PI替换为3.14。</p>
</li>
<li>
<p><strong>#undef</strong>：这个指令用于取消已定义的宏。例如，<code>#undef PI</code>会取消PI宏的定义，之后的代码就不能使用PI宏了。</p>
</li>
<li>
<p><strong>#if, #else, #elif, #endif</strong>：这些指令用于条件编译。预处理器会根据条件来决定是否编译某段代码。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Debug information...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果DEBUG被定义为1，那么printf语句会被编译和执行。如果DEBUG被定义为0，那么printf语句会被忽略。</p>
</li>
<li>
<p><strong>#ifdef, #ifndef</strong>：这些指令也用于条件编译，但它们检查的是某个宏是否已被定义。例如，<code>#ifdef DEBUG</code>会检查DEBUG宏是否已定义，如果已定义，就编译随后的代码。</p>
</li>
</ol>
<p>预处理器还有一些其他的功能，如错误处理、源文件包含等。预处理器的作用虽然不如编译器和链接器显著，<strong>但它在处理源代码、改善代码复用性、模块化等方面起着重要作用。</strong></p>
<h2 id="功能">功能</h2>
<p>预处理器的主要功能包括：</p>
<ol>
<li><strong>文件包含（Inclusion of Files）</strong>：预处理器通过<code>#include</code>指令包含头文件。这使得程序员可以将程序的各个部分分开在不同的文件中编写，并通过这个功能将他们链接在一起。</li>
<li><strong>宏替换（Macro Replacement）</strong>：预处理器通过<code>#define</code>指令定义宏，然后在程序中替换这些宏。这是一种非常有效的方式来定义程序中要使用的常量。<strong>这个东西非常好用,很多框架也在用, 这个能帮我们少写很多代码, 所以看起来他就是个文本替换工具</strong></li>
<li><strong>条件编译（Conditional Compilation）</strong>：预处理器通过<code>#if</code>，<code>#elif</code>，<code>#else</code>和<code>#endif</code>等指令进行条件编译。这使得程序员可以根据特定的条件选择性地编译代码的一部分。</li>
<li><strong>编译错误和警告的处理</strong>：预处理器可以通过<code>#error</code>和<code>#warning</code>指令来发出编译错误和警告。这对于程序调试非常有用。</li>
<li><strong>行控制（Line Control）</strong>：预处理器通过<code>#line</code>指令来控制<code>__LINE__</code>和<code>__FILE__</code>这两个内置宏的值。这使得程序员可以控制在错误报告中显示的行号和文件名。</li>
<li><strong>定义判断</strong>：预处理器通过<code>#ifdef</code>，<code>#ifndef</code>和<code>#undef</code>指令来判断一个宏是否已经定义，并据此决定是否编译某部分代码。</li>
</ol>
<p>通过以上功能，预处理器为C语言提供了丰富的编程灵活性，有助于模块化编程，提高代码复用性，使得源代码更易于阅读和维护。</p>
<p>举个例子吧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AAA_AAA_</span></span><br><span class="line">你好啊, 我不会被编译</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _AAA_AAA_</span></span><br><span class="line">我也不会被编译</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ifdef 和 if的区别在于  if是检查后面这个东西有没有被定义和它的值是不是真,  而infdef是看后面这个东西有没有被定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我会被编译&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gcc预编译一下可以发现确实如此</p>
<p><img src="/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/../img/c%E8%AF%AD%E8%A8%80assets/image-20230615193432089.png" alt="image-20230615193432089"></p>
<h2 id="define">#define</h2>
<p>这个东西太好用了,以至于要单独拿一个部分出来总结</p>
<p><code>#define</code>是C语言预处理器中的一个非常有用的指令，主要用于定义宏（macros）。它可以有两种基本形式：对象式宏（object-like macros）和函数式宏（function-like macros）。</p>
<ol>
<li>
<p><strong>对象式宏</strong>：这是最简单的宏定义形式，它将一个名称定义为一个特定的值。例如：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，PI就被定义为3.14159。在预处理阶段，预处理器会将代码中所有的PI替换为3.14159。</p>
</li>
<li>
<p><strong>函数式宏</strong>：函数式宏可以带有参数，看起来更像一个函数。例如：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) ((X) * (X))</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，SQUARE就被定义为一个计算其参数平方的宏。使用SQUARE(2)会被预处理器替换为((2) * (2))，结果是4。</p>
</li>
</ol>
<p>这些宏在预处理阶段就已经展开并替换，<strong>所以它们不会像函数那样带来调用的开销</strong>。但是，过度使用宏可能会导致代码难以阅读和理解，因为宏只是简单的文本替换，不会进行类型检查。</p>
<h3 id="高级方法">高级方法</h3>
<h4 id="定义for循环">定义for循环</h4>
<p>这个是不可以很好减少我们写for循环?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FI(n) for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FJ(n) for(int j = 0; j &lt; n; j++)</span></span><br></pre></td></tr></table></figure>
<h4 id="定义多行宏">定义多行宏</h4>
<p>有时候把后面的东西写在一行有点难受,我们可以用\换行, 但是在代码中还是一行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> F(n1,n2) for(int i = 0; i &lt; n1; i++) \</span></span><br><span class="line"><span class="meta"> for (int j = 0; j &lt; n2; j++) \</span></span><br></pre></td></tr></table></figure>
<h4 id="参数类型宏">参数类型宏</h4>
<p><strong>宏的参数可以出现类型</strong>(其实也就是字符串替换), 因此我们是不是可弄一个好用的malloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(n, type) (type*)malloc(n * sizeof(type))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* nums = MALLOC(<span class="number">10</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<h4 id="none"># ##</h4>
<p>在用#define 定义时 , 斜杠(&quot;\&quot;)是用来续行的，&quot;#“将<strong>参数字符串化</strong>。”##&quot;则用来<strong>连接前后两个参数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> toString(str)  #str</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test(str) #str<span class="string">&quot;test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONCATENATE(a, b) a ## b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CONCATENATE</span><span class="params">(num, <span class="number">1</span>)</span> = <span class="number">10</span>;  <span class="comment">// 创建一个变量 num1   替换后就是 int num1 = 10</span></span><br><span class="line">print(<span class="string">&quot;%s&quot;</span>,toString(<span class="number">123</span>));  <span class="comment">//很方便的将一个数字变成字符串,但是要注意,这里填变量也会变成字符串</span></span><br><span class="line">print(<span class="string">&quot;%s&quot;</span>,toString(num1));  <span class="comment">//这里输出就是 num1这个字符串</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>#define</code>时，你应当注意到一些常见的问题。首先，因为预处理器只是进行文本替换，所以可能会出现预期外的效果。例如，<strong>函数宏中的参数如果不用括号包围，可能会因为运算符优先级的问题导致错误</strong>。其次，过度使用宏可能会使代码变得难以理解和维护。尽管宏可以提供强大的功能，但应当谨慎使用。</p>
<p>注意点:</p>
<ul>
<li>宏不能递归 #define func(a, b)  func(a,b)  比如这个, 宏只会替换一次,  但是宏可以嵌套</li>
<li><strong>宏的参数可以出现类型，但是函数做不到</strong></li>
<li>参数的副作用  比如 a++ 这种就尽量不要成为宏的参数</li>
<li>宏产生的代码是不能调试的</li>
</ul>
<p><strong>最后请记住宏就是个文本工具, 它肯定是不知道我们变量的值是什么的</strong></p>
<h2 id="error">#error</h2>
<p>在C语言中，<code>#error</code> 指令是一种预处理器指令，用于在<strong>编译时生成错误消息</strong>。当编译器遇到 <code>#error</code> 指令时，它会停止编译过程，并显示指定的错误消息。这通常用于在编译时检查代码的特定条件，以确保代码的正确性或配置的有效性。</p>
<ol>
<li><strong>示例场景</strong>:
<ul>
<li><strong>检查宏是否已定义</strong>:<br>
假设你的程序需要一个特定的宏定义来编译。你可以使用 <code>#error</code> 来确保这个宏已被定义。如果没有定义，编译过程将停止，并显示一个错误消息。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> REQUIRED_MACRO</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;REQUIRED_MACRO is not defined&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><strong>检查编译环境</strong>:<br>
如果你的代码只能在特定的编译环境下运行（例如特定的操作系统或硬件架构），你可以使用 <code>#error</code> 来确保代码不会在不支持的环境中编译。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__linux__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;This code is only for Linux&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><strong>版本检查</strong>:<br>
如果你的代码依赖于特定版本的库或编译器，你可以使用 <code>#error</code> 来检查版本并在不兼容的情况下产生编译错误。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ &lt; 199901L</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;C99 or a later version is required&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>使用 <code>#error</code> 指令是一种有效的方法来确保代码在预期的条件下被编译，从而避免潜在的运行时问题。</p>
<h1><strong>数据类型</strong></h1>
<h2 id="定义">定义</h2>
<p>C语言中的数据类型是用于声明变量或函数的关键部分。一个数据类型定义了一种数据的范围和特性。C语言主要有以下几种数据类型：</p>
<ol>
<li>
<p><strong>基本数据类型</strong>：C语言有四种基本数据类型：</p>
<ul>
<li><strong>整型(int)</strong>：用于表示无小数的数，包括正整数、负整数和0。还有短整型（short）、长整型（long）和长长整型（long long）等更具体的类型。</li>
<li><strong>浮点型(float)</strong>：用于表示有小数的数，例如3.14、0.1234等。</li>
<li><strong>双精度浮点型(double)</strong>：比浮点型具有更高的精度，适用于需要极高精度的计算。</li>
<li><strong>字符型(char)</strong>：用于表示单个字符。(<strong>无符号数</strong>)</li>
</ul>
</li>
<li>
<p><strong>派生数据类型</strong>：由基本数据类型派生出的数据类型，包括：</p>
<ul>
<li><strong>数组(Array)</strong>：存储相同类型数据的有序集合。</li>
<li><strong>指针(Pointer)</strong>：指针类型是一种特殊的数据类型，它存储的是其他数据类型的内存地址。</li>
<li><strong>结构体(struct)</strong>：结构体是一种聚合数据类型，可以包含不同类型的数据。</li>
<li><strong>联合体(union)</strong>：联合体是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。它只能存储一种类型的数据，但可以是任意类型。</li>
<li><strong>枚举(enum)</strong>：枚举是一种用户自定义的数据类型，它允许你将一组整数值赋予有意义的名字，以提高程序的可读性。</li>
</ul>
</li>
<li>
<p><strong>void类型</strong>：void类型表示没有值。这是一种特殊的数据类型，<strong>通常用于定义无返回值的函数和没有参数，或者空指针, 或者任何类型</strong>。</p>
</li>
</ol>
<p><strong>每种数据类型都有其特定的取值范围和存储需求，这些都依赖于你所使用的系统和编译器</strong>。</p>
<p>C语言还允许定义自己的数据类型，通常通过typedef关键字实现。例如，可以通过typedef创建一个新的数据类型名，然后使用这个新的数据类型名来定义变量。</p>
<p>在编写程序时，选择适当的数据类型非常重要，因为它会影响数据如何被存储在内存中，以及如何使用这些数据。</p>
<h2 id="常用数值范围宏">常用数值范围宏</h2>
<p>在C语言中，可以通过在&lt;limits.h&gt;和&lt;float.h&gt;这两个头文件中定义的一些宏来获取各种数据类型的最大值和最小值。这些值可能会因编译器或平台的不同而有所不同，但通常符合特定的标准。</p>
<p>以下是一些常见数据类型的最大值和最小值的宏：</p>
<ol>
<li><strong>整数类型（包括short、int、long、long long）</strong>：可以通过以下宏来获取：
<ul>
<li><code>INT_MIN</code> / <code>INT_MAX</code>：int类型的最小值和最大值。</li>
<li><code>LONG_MIN</code> / <code>LONG_MAX</code>：long类型的最小值和最大值。</li>
<li><code>SHORT_MIN</code> / <code>SHORT_MAX</code>：short类型的最小值和最大值。</li>
<li><code>LLONG_MIN</code> / <code>LLONG_MAX</code>：long long类型的最小值和最大值。</li>
</ul>
</li>
<li><strong>字符类型（char）</strong>：
<ul>
<li><code>CHAR_MIN</code> / <code>CHAR_MAX</code>：char类型的最小值和最大值。</li>
</ul>
</li>
<li><strong>浮点类型和双精度浮点类型（float、double）</strong>：可以通过以下宏来获取：
<ul>
<li><code>FLT_MIN</code> / <code>FLT_MAX</code>：float类型的最小正值和最大正值。</li>
<li><code>DBL_MIN</code> / <code>DBL_MAX</code>：double类型的最小正值和最大正值。</li>
</ul>
</li>
</ol>
<p>在使用这些宏之前，需要包含对应的头文件，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="常量">常量</h2>
<p>在 C 语言中，常量（constants）是固定值，它们在程序运行过程中不能被修改。常量可以是任何基本数据类型，例如整数常量、浮点常量、字符常量，还有字符串字面量等。常量必须在定义的时候就初始化好, 不然会报错</p>
<h2 id="类型转换">类型转换</h2>
<p>在C语言中，类型转换用于将一种数据类型转换为另一种。类型转换有两种基本形式：隐式类型转换（也称为自动类型转换）和显式类型转换（也称为强制类型转换或类型强制转换）。</p>
<ol>
<li>
<p><strong>隐式类型转换</strong>：当我们进行不同数据类型的混合运算时，编译器会自动进行类型转换。这种类型转换是隐式的，即程序员无需明确指定。在这种情况下，较小的数据类型会被转换为较大的数据类型。例如，如果你将一个<code>int</code>类型和一个<code>double</code>类型的值进行加法运算，<code>int</code>值会被自动转换为<code>double</code>类型，然后进行运算。</p>
</li>
<li>
<p><strong>显式类型转换</strong>：有时候，我们需要手动进行类型转换，这称为显式类型转换，或者称为强制类型转换。在C语言中，可以通过将目标类型放在括号中，并放在要转换的变量或表达式前面来实现。例如，如果你想将<code>double</code>类型的变量转换为<code>int</code>类型，可以这样做：<code>int x = (int) y;</code>，其中<code>y</code>是一个<code>double</code>类型的变量。</p>
</li>
</ol>
<p>值得注意的是，类型转换可能会引起数据丢失或溢出。例如，如果你将一个<code>double</code>类型的值强制转换为<code>int</code>类型，小数部分将会被丢弃。如果你将一个超过<code>int</code>范围的<code>long</code>类型的值强制转换为<code>int</code>类型，可能会导致数据溢出。</p>
<p>最后，C语言还有一种特殊的类型转换，叫做类型提升。当较小的整数类型（如<code>char</code>或<code>short</code>）用作算术表达式的一部分时，它们会被提升为较大的整数类型（通常是<code>int</code>）。这是C语言为了运算效率和结果精度做的一种优化。</p>
<h1>存储类别说明符</h1>
<p><code>static</code>, <code>extern</code>, 和 <code>const</code> 在 C 语言中被称为存储类别说明符（Storage Class Specifiers）。它们用于指定变量、函数或声明的范围（可见性）、生命周期、以及是否可以被修改。</p>
<p>让我们来看一下这些存储类别说明符的意义：</p>
<ol>
<li>
<p><strong>static</strong>：在变量和函数前使用 <code>static</code> 关键字，<strong>会使得它们的作用域局限于声明它们的源文件内, 跨.cpp和.c文件是无法共享和使用的</strong>。对于局部变量，<code>static</code> 也改变了它们的生命周期，使得它们在程序的整个运行期间都存在，而不仅仅是在声明它们的函数或代码块执行时存在。</p>
</li>
<li>
<p><strong>extern</strong>：<code>extern</code> 关键字用于声明一个变量或函数在别的源文件中已经被定义。这样，这个变量或函数就可以在其他文件中被使用，即使它是在另一个源文件中定义的。</p>
</li>
<li>
<p><strong>const</strong>：<code>const</code> 关键字用于指定一个变量的值不能被修改（即，这个变量是只读的）。这对于防止无意的修改非常有用，也可以让编译器进行一些优化。</p>
</li>
</ol>
<p>除了这三个关键字，C 语言中还有其他的存储类别说明符，如 <code>auto</code> 和 <code>register</code>。不过，<code>auto</code> 是默认的，不常显式地用在代码中，<code>register</code> 关键字的作用在现代编译器中已经基本被忽视。</p>
<h2 id="static">static</h2>
<p>在 C 语言中，<code>static</code>关键字有几个不同的用途，具体取决于它的使用环境：</p>
<ol>
<li>
<p><strong>静态局部变量</strong></p>
<p>当 <code>static</code> 关键字用于函数内部的变量时，它改变了该变量的存储期。通常情况下，函数内的局部变量在函数被调用时创建，函数返回时销毁。但如果局部变量被声明为 <code>static</code>，则其生命周期在程序运行时始终存在。这意味着，当函数被多次调用时，静态局部变量的值在调用之间保持不变。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>count</code> 变量每次调用 <code>foo</code> 函数时都会增加。但是你在外界是无法访问的</p>
</li>
<li>
<p><strong>静态全局变量</strong></p>
<p>如果 <code>static</code> 关键字用于函数外部的变量，它限制了该变量的链接作用域（linkage）到定义它的文件。换句话说，<code>static</code> 全局变量只能在定义它的源文件中访问，其他源文件不能访问。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// This variable is only accessible within file1.c</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>静态函数</strong></p>
<p>和静态全局变量类似，<code>static</code> 也可以用于函数，<strong>使得函数只能在定义它的源文件中访问。</strong></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;  <span class="comment">// This function is only accessible within file1.c</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>static</code> 关键字使你能够控制变量和函数的可见性，从而更好地封装代码。此外，静态局部变量还允许你保持在函数调用之间保持状态，而不必使用全局变量。</p>
<h2 id="extern">extern</h2>
<p>在 C 语言中，<code>extern</code> 关键字主要用于以下两种场景：</p>
<ol>
<li>
<p><strong>声明全局变量</strong>：如果一个全局变量在一个源文件中被定义，并且你想在另一个源文件中使用这个全局变量，那么你需要在那个源文件中用 <code>extern</code> 关键字声明这个变量。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.c</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVar; <span class="comment">// Now, globalVar can be used in File2.c</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>globalVar</code> 在 File1.c 中被定义，并在 File2.c 中通过 <code>extern</code> 关键字被声明，所以它可以在 File2.c 中使用。</p>
</li>
<li>
<p><strong>声明函数</strong>：如果一个函数在一个源文件中被定义，并且你想在另一个源文件中调用这个函数，那么你需要在那个源文件中用 <code>extern</code> 关键字声明这个函数。然而，在实际使用中，<strong>函数默认就是</strong> <code>extern</code> 的，所以一般省略不写 <code>extern</code>。通常，在头文件中声明函数，然后在源文件中包含这个头文件，就可以在源文件中调用这个函数。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File1.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>; <span class="comment">// `extern` is implicit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;File1.h&quot;</span> <span class="comment">// Now, func() can be called in File2.c</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在这个例子中，<code>func</code> 在 File1.c 中被定义，并在 File1.h 中被声明（这里 <code>extern</code> 是隐含的），所以它可以在 File2.c 中被调用。</p>
<p>总的来说，<code>extern</code> 关键字用于声明在其他地方定义的全局变量或函数。这提供了一种在多个源文件间共享变量和函数的方式。</p>
<blockquote>
<p>如果用 extern 修饰变量时赋值,  那可就是定义了  比如  extern  int a = 10;  这可就不是引入外部变量然后对他赋值了,  那就是在此处定义一个变量赋值为10  然后可以被外部引用了,</p>
</blockquote>
<h1>运算符</h1>
<p>以下是C语言运算符的优先级和结合性的一个总结。优先级从高到低排列：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>描述</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>()</code> <code>[]</code> <code>-&gt;</code> <code>.</code> <code>++</code> <code>--</code></td>
<td>函数调用、数组下标、指针运算、成员访问、自增自减</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td><code>!</code> <code>~</code> <code>+</code> <code>-</code> <code>*</code> <code>&amp;</code> <code>(类型名)&#123;列表&#125;</code> <code>sizeof</code></td>
<td>逻辑非、按位非、一元加减、解引用、取地址、复合字面量、大小</td>
<td>从右到左</td>
</tr>
<tr>
<td>3</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>乘法、除法、取模</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td><code>+</code> <code>-</code></td>
<td>加法、减法</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>左移、右移</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>小于、小于等于、大于、大于等于</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td><code>==</code> <code>!=</code></td>
<td>等于、不等于</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td><code>&amp;</code></td>
<td>按位与</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td><code>^</code></td>
<td>按位异或</td>
<td>从左到右</td>
</tr>
<tr>
<td>10</td>
<td><code>|</code></td>
<td>按位或</td>
<td>从左到右</td>
</tr>
<tr>
<td>11</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td>从左到右</td>
</tr>
<tr>
<td>12</td>
<td><code>||</code></td>
<td>逻辑或</td>
<td>从左到右</td>
</tr>
<tr>
<td>13</td>
<td><code>?:</code></td>
<td>条件运算符</td>
<td>从右到左</td>
</tr>
<tr>
<td>14</td>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td>
<td>赋值运算符</td>
<td>从右到左</td>
</tr>
<tr>
<td>15</td>
<td><code>,</code></td>
<td>逗号运算符</td>
<td>从左到右</td>
</tr>
</tbody>
</table>
<p>请注意，虽然这个表格提供了一种方便的方式来记忆运算符的优先级和结合性，但在实践中，为了避免可能的混淆和错误，最好尽可能地使用括号来明确表达你的意图。</p>
<p>运算符在编程中使用频繁，有一些重要的细节需要注意。以下是一些常见的C语言运算符相关的注意点：</p>
<ol>
<li>
<p><strong>短路行为</strong>：逻辑运算符 <code>&amp;&amp;</code>（逻辑与）和 <code>||</code>（逻辑或）有所谓的&quot;短路&quot;行为。如果 <code>&amp;&amp;</code> 运算符的左操作数为 <code>false</code>，则不会计算右操作数，因为整个表达式的结果已经可以确定为 <code>false</code>。同理，如果 <code>||</code> 运算符的左操作数为 <code>true</code>，则不会计算右操作数，因为整个表达式的结果已经可以确定为 <code>true</code>。这种行为可能会影响到代码的执行流程，特别是当操作数有副作用（如修改变量或执行函数）时。</p>
</li>
<li>
<p><strong>优先级和结合性</strong>：C语言中的运算符优先级和结合性经常引起混淆。比如，<code>&amp;&amp;</code> 的优先级比 <code>||</code> 高，这意味着 <code>a || b &amp;&amp; c</code> 等同于 <code>a || (b &amp;&amp; c)</code>，而非 <code>(a || b) &amp;&amp; c</code>。使用括号可以让代码更清晰，更易于理解。</p>
</li>
<li>
<p><strong>自增和自减</strong>：<code>++</code>（自增）和 <code>--</code>（自减）运算符有前缀和后缀两种形式，它们的行为有所不同。前缀形式（如 <code>++i</code>）先改变变量的值，然后返回改变后的值；后缀形式（如 <code>i++</code>）先返回变量当前的值，然后改变变量的值。在表达式中使用自增或自减运算符时要特别注意。</p>
</li>
<li>
<p><strong>赋值运算符</strong>：赋值运算符 <code>=</code> 会返回一个值，这个值就是被赋值的值。这意味着你可以在一个表达式中进行多重赋值，如 <code>a = b = c = 0;</code>，它会从右到左执行，首先把 <code>c</code> 设置为 <code>0</code>，然后把 <code>b</code> 设置为 <code>c</code> 的值（也就是 <code>0</code>），最后把 <code>a</code> 设置为 <code>b</code> 的值（也就是 <code>0</code>）。</p>
</li>
<li>
<p><strong>除法运算符</strong>：在整数除法中，如果除数和被除数有一个是负数，结果如何取整是由具体的实现定义的。例如，<code>-5 / 2</code> 的结果可能是 <code>-2</code> 或 <code>-3</code>，这取决于你的编译器。为了避免这种模糊性，最好始终确保除数和被除数都是正数，或者使用浮点除法。</p>
</li>
</ol>
<p>这里讲一下我以前一直疑惑的点,  看一下下面这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i,<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, ch = %c\n&quot;</span>, i, ch);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = func(<span class="number">0</span>, <span class="string">&#x27;A&#x27;</span>) || func(<span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>) &amp;&amp; func(<span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// i = 0, ch = A</span></span><br><span class="line"><span class="comment">// i = 1, ch = B</span></span><br><span class="line"><span class="comment">// i = 2, ch = C</span></span><br></pre></td></tr></table></figure>
<p>我以前的理解就是人的思维方式  既然&amp;&amp;优先级高 我就应该先过来计算&amp;&amp;的两个式子,  所以应该要先输出B,C这两个,  可是计算机内部可不是这样处理的,  <strong>我们可以简单的理解为按照顺序将中缀表达式变成后缀表达式, 并且中间这些式子比如函数啊, 都计算好了</strong></p>
<h1>数组</h1>
<p>在 C 语言中，数组是一个存储相同数据类型元素的固定大小连续内存块。以下是关于 C 语言中数组的基本总结：</p>
<ol>
<li>
<p><strong>数组声明和初始化</strong>：在 C 语言中，可以在声明数组的同时进行初始化。例如，<code>int arr[5] = &#123;1, 2, 3, 4, 5&#125;;</code> 声明了一个名为 arr 的整型数组，大小为 5，同时给它赋予了一组初始值。</p>
<p>如果没有初始化，数组的元素将默认为零（对于全局和静态数组）或<strong>垃圾值</strong>（对于局部数组）。</p>
<p>数组的大小必须是一个常量表达式。</p>
</li>
<li>
<p><strong>数组访问</strong>：可以通过索引访问数组元素。索引是在方括号中指定的整数，例如 <code>arr[0]</code> 访问的是数组的第一个元素。</p>
<p>注意，C 语言的数组索引是从 0 开始的。也就是说，对于一个大小为 n 的数组，合法的索引范围是 0 到 n-1。</p>
</li>
<li>
<p><strong>数组长度</strong>：C 语言没有内置的方式来获取数组的长度。一种常见的技巧是使用 <code>sizeof(arr) / sizeof(arr[0])</code> 来计算数组的长度。</p>
</li>
<li>
<p><strong>多维数组</strong>：C 语言支持多维数组。例如，<code>int matrix[3][4];</code> 声明了一个 3x4 的整型二维数组。</p>
</li>
<li>
<p><strong>数组作为函数参数</strong>：当数组作为函数参数时，实际上传递的是数组的引用（或者说是数组的指针），而不是数组本身。因此，函数可以修改数组的内容，但不能获取数组的长度（除非额外提供长度信息）。</p>
</li>
<li>
<p><strong>字符数组和字符串</strong>：字符数组经常被用来存储 C 风格的字符串。C 风格的字符串是字符数组的一种特殊用法，字符串以 ‘\0’ 字符结束。</p>
</li>
</ol>
<p>总的来说，数组是 C 语言中最基本的数据结构之一，用于存储和操作大量的相同类型的数据。</p>
<h1>控制结构</h1>
<p>在 C 语言中，控制流语句决定了程序的执行路径。以下是一些基本的控制流语句的总结：</p>
<ol>
<li>
<p><strong>if 语句</strong>：它用于根据条件判断是否执行某个代码块。形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 true 时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 false 时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>for 循环</strong>：用于重复执行某个代码块一定次数。形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 true 时重复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>while 循环</strong>：用于在满足条件时重复执行代码块。形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 true 时重复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>do…while 循环</strong>：它是 while 循环的变种，无论条件是否满足，都会执行一次代码块。形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>switch 语句</strong>：根据表达式的值，从多个选项中选择一条路径执行。形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:语句<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：<code>break</code> 语句用于结束 switch 结构或循环结构；<code>continue</code> 语句用于结束当前迭代，直接跳到下一次迭代。这两个也是 C 语言中常见的控制流语句。</p>
<h1>枚举</h1>
<p>好的，让我们来详细讨论一下 C 语言中的枚举。</p>
<p>在 C 语言中，枚举（enum）是一种用户定义的数据类型，它可以由一组命名的整数常量组成。枚举是一种抽象数据类型，用于创建一组命名的整数值，这些值通常表示某种特定的实际意义。</p>
<p>下面是如何定义枚举类型的一个基本示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>color</code> 是枚举的名字，<code>RED</code>、<code>GREEN</code> 和 <code>BLUE</code> 是枚举的成员。在默认情况下，<code>RED</code> 被赋值为 <code>0</code>，<code>GREEN</code> 被赋值为 <code>1</code>，<code>BLUE</code> 被赋值为 <code>2</code>。这是因为在 C 中，<strong>枚举成员的计数始终从 <code>0</code> 开始，除非你手动指定一个不同的开始值。</strong>,</p>
<p>你也可以为枚举成员指定特定的值。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> RED = <span class="number">1</span>, GREEN = <span class="number">4</span>, BLUE = <span class="number">8</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>RED</code> 被赋值为 <code>1</code>，<code>GREEN</code> 被赋值为 <code>4</code>，<code>BLUE</code> 被赋值为 <code>8</code>。<strong>没有指定值的枚举元素，其值为前一元素加 1</strong></p>
<p>定义了枚举类型之后，就可以使用它来创建变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">myColor</span>;</span></span><br><span class="line">myColor = GREEN;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>myColor</code> 是一个 <code>color</code> 枚举的变量，它被赋值为 <code>GREEN</code>，也就是 <code>4</code>。</p>
<p>枚举在编程中很有用，因为它们可以用来创建易于理解和维护的代码。通过使用枚举，你可以将一组有关的名字与一组相关的值关联起来，这些值可以在你的程序中用来表示具有特定意义的数据。</p>
<p>值得注意的是，虽然枚举类型的成员本质上是整数，但你不能直接将整数赋值给枚举变量，除非你进行类型转换。例如，下面的代码是错误的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">myColor</span> =</span> <span class="number">4</span>;  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>而应该写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">myColor</span> =</span> (<span class="keyword">enum</span> color)<span class="number">4</span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>这是因为 C 语言要求类型的严格一致。通过将整数转换为枚举类型，你告诉编译器你知道你正在做什么，所以它不会抱怨。但是，应该避免这种情况，除非你确实需要这样做，因为这可能会导致错误。</p>
<h1>指针</h1>
<p>在C语言中，指针的形式可以根据它们指向的数据类型和维度（如单个变量、数组、多维数组等）以及指针本身的级别（如指向指针的指针）来区分。下面列举了C语言中常见的不同形式的指针：</p>
<ol>
<li>
<p><strong>基本指针</strong>：指向单个变量的指针。</p>
<ul>
<li>例如：<code>int *ptr;</code> 指向一个整数。</li>
</ul>
</li>
<li>
<p><strong>数组指针</strong>：指向数组的指针。</p>
<ul>
<li>例如：<code>int (*ptr)[10];</code> 指向一个有10个整数的数组。</li>
</ul>
</li>
<li>
<p><strong>指针数组</strong>：数组，其元素为指针。</p>
<ul>
<li>例如：<code>int *ptr[10];</code> 是一个包含10个指向整数的指针的数组。</li>
</ul>
</li>
<li>
<p><strong>指向指针的指针</strong>（多级指针）：指向另一个指针的指针。</p>
<ul>
<li>例如：<code>int **ptr;</code> 是一个指向指向整数的指针的指针。</li>
</ul>
</li>
<li>
<p><strong>指向函数的指针</strong>：指向函数的指针，可以用来调用函数。</p>
<ul>
<li>例如：<code>int (*ptr)(int);</code> 指向一个接受一个整数参数并返回整数的函数。</li>
</ul>
</li>
<li>
<p><strong>指针指向动态分配的内存</strong>：使用如 <code>malloc</code> 或 <code>calloc</code> 分配的内存块的指针。</p>
<ul>
<li>例如：<code>int *ptr = malloc(10 * sizeof(int));</code> 分配了10个整数大小的内存，并将地址赋给 <code>ptr</code>。</li>
</ul>
</li>
<li>
<p><strong>结构体指针</strong>：指向结构体的指针。</p>
<ul>
<li>例如：<code>struct MyStruct *ptr;</code> 指向 <code>MyStruct</code> 类型结构体的指针。</li>
</ul>
</li>
<li>
<p><strong>指向结构体成员的指针</strong>：指向结构体成员的指针。</p>
<ul>
<li>例如：<code>int *ptr;</code> 其中 <code>ptr</code> 可以指向一个结构体的整型成员。</li>
</ul>
</li>
<li>
<p><strong>指向多维数组的指针</strong>：指向多维数组的指针。</p>
<ul>
<li>例如：<code>int (*ptr)[10][10];</code> 指向一个10x10整数数组的指针。</li>
</ul>
</li>
<li>
<p><strong>指向联合体的指针</strong>：指向联合体（union）的指针。</p>
<ul>
<li>例如：<code>union MyUnion *ptr;</code> 指向 <code>MyUnion</code> 类型联合体的指针。</li>
</ul>
</li>
<li>
<p><strong>void指针</strong>：类型不明确的指针，可以指向任何类型。</p>
<ul>
<li>例如：<code>void *ptr;</code> 可以指向任何类型的数据。</li>
</ul>
</li>
<li>
<p><strong>const指针</strong>：指向常量的指针，指向的值不能通过这个指针修改。</p>
<ul>
<li>例如：<code>const int *ptr;</code> 指向一个常整数的指针。</li>
</ul>
</li>
<li>
<p><strong>指向const的指针</strong>：指针本身是常量，不能指向其他地址。</p>
<ul>
<li>例如：<code>int * const ptr;</code> 是一个指向整数的常指针。</li>
</ul>
</li>
</ol>
<p>*  可以看做解析地址中的内容,   int* p[5] 由于[] 高于*  所以p[5]就相当于数组,  然后* 代表这个五个元素的解析地址内容是int ,  int (*p)[5]  由于改变优先级   *p 代表p指向的内容  就是一个int [5] 的数组了,  所以p指向了一个大小为5的数组</p>
<h1>函数指针</h1>
<p>函数指针是 C 语言中的一种强大工具，它们允许程序员创建更灵活的函数和数据结构。这是关于 C 语言中函数指针的基本总结：</p>
<ol>
<li>
<p><strong>函数指针的定义</strong>：函数指针就像其他指针一样，它存储了一个地址。但是，这个地址不是变量的地址，而是函数的地址。例如，如果你有一个名为 <code>foo</code> 的函数，那么表达式 <code>&amp;foo</code> 就是一个函数的地址，你可以将它赋值给一个函数指针。</p>
<p>函数指针的声明包括函数的返回类型和参数类型。例如，以下代码定义了一个指向返回类型为 <code>int</code> 且接受两个 <code>int</code> 参数的函数的指针：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>这里，<code>funcPtr</code> 是指针的名字，<code>int (int, int)</code> 描述了函数的类型。</p>
</li>
<li>
<p><strong>函数指针的使用</strong>：你可以使用函数指针来调用函数。例如：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = funcPtr(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>这会调用 <code>funcPtr</code> 指向的函数，传入参数 <code>2</code> 和 <code>3</code>，并将返回值赋值给 <code>result</code>。</p>
</li>
<li>
<p><strong>函数指针的赋值</strong>：你可以将一个函数的地址赋值给一个函数指针。例如，如果你有一个如下的函数：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以将它的地址赋值给一个函数指针：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcPtr = &amp;add;</span><br></pre></td></tr></table></figure>
<p>现在，<code>funcPtr</code> 指向了 <code>add</code> 函数，你可以通过它来调用 <code>add</code>。</p>
</li>
<li>
<p><strong>函数指针作为函数参数</strong>：函数指针可以作为其他函数的参数。这使得你可以创建更灵活的函数，这些函数可以接受不同的行为作为参数。例如，你可以创建一个接受一个函数作为参数的函数，根据这个参数来执行不同的操作。</p>
</li>
<li>
<p><strong>函数指针作为函数返回值</strong>：函数也可以返回函数指针，这可以用于创建返回函数的工厂函数等高级模式。</p>
</li>
</ol>
<p>总的来说，函数指针是一种非常强大的工具，它们可以让你的 C 程序有更高的灵活性和动态性。虽然函数指针的语法有点复杂，但一旦你理解了它们的工作原理，你就会发现它们非常有用。</p>
<h1>从源代码到可执行文件</h1>
<p>编译器在编译源代码的过程中，会经过几个步骤：预处理、编译、汇编和链接。</p>
<ol>
<li><strong>预处理</strong>：预处理器处理源代码中的 <code>#include</code>、<code>#define</code> 等预处理指令。当你在 C 代码中使用 <code>#include</code> 指令时，预处理器会将这个头文件的全部内容复制到源文件中。<strong>这一步并不涉及编译，只是文本处理</strong>。</li>
<li><strong>编译</strong>：<strong>编译器将预处理后的源代码转换成汇编语言</strong>。</li>
<li><strong>汇编</strong>：汇编器将编译器生成的汇编语言转换成目标文件，<strong>也就是机器代码</strong>。</li>
<li><strong>链接</strong>：<strong>链接器将所有的目标文件和需要的库链接成一个可执行文件</strong>。在这个过程中，链接器需要解决外部符号（extern）的引用问题，也就是确定这些符号的具体位置。</li>
</ol>
<p>这个四个步骤对应的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i       # 预处理</span><br><span class="line">gcc -S test.i -o test.s       # 编译</span><br><span class="line">gcc -c test.s -o test.o       # 汇编</span><br><span class="line">gcc test1.o test2.o -o output # 链接</span><br></pre></td></tr></table></figure>
<p>在这里我们就可以解释extern的作用了</p>
<p>在 C 语言中，<code>extern</code> 关键字用于<strong>声明一个变量或函数，而不是定义它</strong>。这意味着我们在一个文件中声明一个变量或函数，可以在其他文件中使用它。</p>
<p><strong>当我们在一个源文件中定义一个全局变量或函数</strong>，其他源文件中使用这个变量或函数的文件就必须通过 <code>extern</code> 来声明它的存在(当然,如果是在头文件里面,你也可以通过include)。实际的定义只能在一个源文件中进行，声明可以在多个文件中进行。</p>
<blockquote>
<p>当然,你也是可以不用extern关键字, 然后再别的地方做声明,  但是这个让别人不好区分,会很容易产生迷惑,  不过这个也看链接器的行为,  我的建议如果不是使用引入头文件的方式的话, 就都写上extern</p>
</blockquote>
<p>举个例子吧</p>
<p>这个是test2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>里面定义了一个函数和变量,但是我希望外部使用,这个是test.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &quot;test2.c&quot;  我们这里也可以使用include的方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是使用include的方式的话,那么是可以直接编译test.c运行的,  但是如果是使用extern的方式的话,还得编译test2.c 然后链接起来就可以了</p>
<p>这里又引出了一个点:  <strong>.h文件是不是简化了我们的代码, 让我们少用了extern关键字</strong>,</p>
<h1>更深入的从源代码到可执行文件</h1>
<h1>头文件和源文件</h1>
<p>在 C 语言中，<code>.h</code> 和 <code>.c</code> 文件在编译过程中的作用主要有以下几点：</p>
<ol>
<li><strong>头文件（.h）</strong>：头文件主要用于<strong>声明</strong>函数、变量和类型。通过这些声明，你可以在其他文件中使用这些函数、变量和类型，即使它们在其他文件中定义。通常，你会在头文件中声明函数和全局变量，然后在一个源文件中定义它们。这样，其他源文件就可以通过包含相应的头文件来使用这些函数和全局变量。<strong>头文件最终是会被展开在每一个引入它的源文件中的</strong>, 所以我们最终还是要看源文件</li>
<li><strong>源文件（.c）</strong>：<strong>源文件用于定义函数和全局变量</strong>。这是编译器真正需要去编译的代码。每个源文件通常会包含一个或多个函数和全局变量的定义。在编译过程中，编译器会为每个源文件生成一个目标文件（.o 文件）。</li>
</ol>
<p>头文件通过 <code>#include</code> 指令被包含在源文件中。当编译器看到 <code>#include &quot;file.h&quot;</code> 指令时，它会将 “file.h” 的内容插入到源文件中，然后继续编译。这样，源文件就可以访问在 “file.h” 中声明的函数和全局变量。</p>
<p>在链接阶段，链接器会将所有的目标文件链接在一起，形成一个可执行的程序。<strong>链接器需要确保每个函数和全局变量只被定义一次</strong>，否则会出现链接错误。这就是为什么你不能在多个源文件中定义同一个函数或全局变量。 <strong>所以说,我们尽量只在头文件里面做声明,不要做定义</strong>, 因为头文件引入后会把里面的变量一起带过来, 但是如果不是static这种存储类别的话, 那肯定就都是全局变量,那这不就乱套了吗? 但是函数声明和变量声明是可以在.h文件里面声明的</p>
<p>总的来说，头文件（.h）用于声明，源文件（.c）用于定义。在编译阶段，编译器编译源文件；在链接阶段，链接器将目标文件链接在一起，形成一个可执行的程序。</p>
<p><strong>在头文件中 函数的声明默认是extern  但是变量的话默认是定义</strong></p>
<h1>常用库</h1>
<h2 id="assert-h">assert.h</h2>
<p>这个库函数只包含了一个宏就是assert, 它用来检测一个东西是不是false(null和0)</p>
<p>我们来看一下宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> assert(expr)		(__ASSERT_VOID_CAST (0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> assert(expr)							\</span></span><br><span class="line"><span class="meta">  ((expr)								\</span></span><br><span class="line"><span class="meta">   ? __ASSERT_VOID_CAST (0)						\</span></span><br><span class="line"><span class="meta">   : __assert_fail (__STRING(expr), __FILE__, __LINE__, __ASSERT_FUNCTION))</span></span><br></pre></td></tr></table></figure>
<p>我们发现,如果我们在引入assert.h之前如果定义了NDEBUG的话, 那么assert宏对应的函数就不会做事情了</p>
<h2 id="ctype-h">ctype.h</h2>
<p>在 C 语言中，<code>ctype.h</code> 是一个库，它包含一些用于<strong>测试和转换字符的函数</strong></p>
<ol>
<li><code>int isalnum(int c)</code>: 检查传入的字符是否是字母或数字。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int isalpha(int c)</code>: 检查传入的字符是否是字母。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int iscntrl(int c)</code>: 检查传入的字符是否是控制字符（ASCII 值在 0x00 和 0x1f 之间，以及 0x7f 的字符）。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int isdigit(int c)</code>: 检查传入的字符是否是数字（0-9）。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int isgraph(int c)</code>: 检查传入的字符是否有图形表示（即，它是一个可打印字符，且不是空格）。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int islower(int c)</code>: 检查传入的字符是否是小写字母。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int isprint(int c)</code>: 检查传入的字符是否是可打印字符（包括空格）。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int ispunct(int c)</code>: 检查传入的字符是否是标点符号。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int isspace(int c)</code>: 检查传入的字符是否是空格字符。空格字符包括：空格(’ ‘)，换行符(’\n’)，回车(’\r’)，水平制表符(’\t’)，垂直制表符(’\v’)，换页符(’\f’)。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int isupper(int c)</code>: 检查传入的字符是否是大写字母。如果是，则返回非零值；如果不是，返回 0。</li>
<li><code>int isxdigit(int c)</code>: 检查传入的字符是否是十六进制数字。这包括：0-9，a-f 和 A-F。如果是，则返回非零值；如果不是，返回 0。</li>
</ol>
<p>转换函数：</p>
<ol>
<li><code>int tolower(int c)</code>: 如果传入的字符是大写字母，将其转换为小写字母。如果输入不是大写字母，该函数返回输入不变。</li>
<li><code>int toupper(int c)</code>: 如果传入的字符是小写字母，将其转换为大写字母。如果输入不是小写字母，该函数返回输入不变。</li>
</ol>
<h2 id="stdio-h">stdio.h</h2>
<p><code>stdio.h</code> 是 C 语言的标准输入输出库，其中包含了大量用于文件和流相关操作的函数、宏和类型。下面详细罗列了一些主要的部分：</p>
<p><strong>类型</strong></p>
<ol>
<li><code>FILE</code>: 这是一个用于文件处理的重要类型，它提供了一个输入/输出流的接口。</li>
</ol>
<p><strong>宏</strong></p>
<ol>
<li><code>EOF</code>: <strong>当达到文件末尾或者发生错误时，很多函数会返回此宏。其值通常为-1</strong>。</li>
<li><code>NULL</code>: 这是一个特殊的指针值，用于表示指针没有指向任何内容。</li>
<li><code>BUFSIZ</code>: 这个宏表示系统的文件缓冲区大小。</li>
<li><code>FILENAME_MAX</code>: 这个宏指定了文件名的最大长度。</li>
<li><code>FOPEN_MAX</code>: 这个宏定义了系统可以同时打开的文件数量。</li>
<li><code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>: 这些宏用于 <code>fseek</code> 函数，用于定位到文件的开始、当前位置或者结束位置。</li>
<li><code>TMP_MAX</code>: 这个宏定义了 <code>tmpnam</code> 函数能够返回的不同的文件名的数量。</li>
</ol>
<p><strong>全局变量</strong></p>
<ol>
<li><code>stdin</code>: 这是指向标准输入的 <code>FILE</code> 类型指针。</li>
<li><code>stdout</code>: 这是指向标准输出的 <code>FILE</code> 类型指针。</li>
<li><code>stderr</code>: 这是指向标准错误的 <code>FILE</code> 类型指针。</li>
</ol>
<p><strong>文件访问</strong></p>
<ol>
<li>
<p><code>FILE *fopen(const char *filename, const char *mode)</code>: 打开名为 filename 的文件，并返回一个与该文件关联的 FILE 对象的指针。mode 参数确定文件的访问模式。</p>
</li>
<li>
<p><code>int fclose(FILE *stream)</code>: 关闭与 FILE 对象关联的文件。如果成功，返回 0，如果出错，返回 EOF。</p>
</li>
<li>
<p><code>int remove(const char *filename)</code>: 删除名为 filename 的文件。如果成功，返回 0，如果出错，返回非零值。</p>
</li>
<li>
<p><code>int rename(const char *oldname, const char *newname)</code>: 将 oldname 文件重命名为 newname。如果成功，返回 0，如果出错，返回非零值。</p>
</li>
<li>
<p><code>FILE *tmpfile(void)</code>: 创建一个临时文件，并以读/写模式打开。返回一个与该文件关联的 FILE 对象的指针。</p>
</li>
</ol>
<p><strong>格式化输入/输出</strong></p>
<ol start="6">
<li>
<p><code>int printf(const char *format, ...)</code>: 根据指定的格式 format，输出格式化的数据到 stdout。</p>
</li>
<li>
<p><code>int fprintf(FILE *stream, const char *format, ...)</code>: 根据指定的格式 format，输出格式化的数据到指定的 FILE 流 stream。</p>
</li>
<li>
<p><code>int sprintf(char *str, const char *format, ...)</code>: <strong>根据指定的格式 format，将格式化的数据写入字符串 str</strong>。</p>
</li>
<li>
<p><code>int scanf(const char *format, ...)</code>: 从 stdin 中读取格式化输入。</p>
</li>
<li>
<p><code>int fscanf(FILE *stream, const char *format, ...)</code>: 从给定的 FILE 流 stream 中读取格式化输入。</p>
</li>
<li>
<p><code>int sscanf(const char *str, const char *format, ...)</code>: <strong>从字符串 str 中读取格式化输入</strong>。</p>
</li>
</ol>
<p><strong>字符输入/输出</strong></p>
<ol start="12">
<li>
<p><code>int fgetc(FILE *stream)</code>: 从给定的 FILE 流 stream 中获取一个字符。</p>
</li>
<li>
<p><code>char *fgets(char *str, int n, FILE *stream)</code>: <strong>从给定的 FILE 流 stream 中读取一行</strong>，并存储到 str 所指向的字符串中。</p>
</li>
<li>
<p><code>int fputc(int c, FILE *stream)</code>: 将字符 c 写入到给定的 FILE 流 stream 中。</p>
</li>
<li>
<p><code>int fputs(const char *str, FILE *stream)</code>: 将字符串 str 写入到给定的 FILE 流 stream 中。</p>
</li>
<li>
<p><code>int getc(FILE *stream)</code>: 从给定的 FILE 流 stream 中获取一个字符。</p>
</li>
<li>
<p><code>int getchar(void)</code>: 从 stdin 中获取一个字符。</p>
</li>
<li>
<p><code>char *gets(char *str)</code>: 从 stdin 读取一行，并存储到 str 所指向的字符串中,<strong>这个函数现在已经不太常用了,因为他不安全</strong>。</p>
</li>
<li>
<p><code>int putc(int c, FILE *stream)</code>: 将字符 c 写入到给定的 FILE 流 stream 中。</p>
</li>
<li>
<p><code>int putchar(int c)</code>: 将字符 c 写入到 stdout。</p>
</li>
<li>
<p><code>int puts(const char *str)</code>: 将字符串 str 和一个尾随的换行符写入 stdout。</p>
</li>
<li>
<p><code>int ungetc(int c, FILE *stream)</code>: 将字符 c 退回到给定的 FILE 流 stream。</p>
</li>
</ol>
<p><strong>直接输入/输出</strong></p>
<ol start="23">
<li>
<p><code>size_t fread(void *ptr, size_t size, size_t count, FILE *stream)</code>: 从给定的 FILE 流 stream 中读取数据，并存储到 ptr 所指向的数组。</p>
</li>
<li>
<p><code>size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream)</code>: 将 ptr 所指向的数组中的数据写入到给定的 FILE 流 stream。</p>
</li>
</ol>
<p><strong>文件定位</strong></p>
<ol start="25">
<li>
<p><code>int fseek(FILE *stream, long offset, int whence)</code>: 设置给定的 FILE 流 stream 的文件位置和偏移量。</p>
</li>
<li>
<p><code>long ftell(FILE *stream)</code>: 返回给定的 FILE 流 stream 中的当前文件位置。</p>
</li>
<li>
<p><code>void rewind(FILE *stream)</code>: 设置给定的 FILE 流 stream 的文件位置到文件开始。</p>
</li>
</ol>
<p><strong>错误处理</strong></p>
<ol start="28">
<li>
<p><code>void clearerr(FILE *stream)</code>: 清除给定的 FILE 流 stream 的文件结束和错误指示器。</p>
</li>
<li>
<p><code>int feof(FILE *stream)</code>: 检查给定的 FILE 流 stream 的文件结束指示器。</p>
</li>
<li>
<p><code>int ferror(FILE *stream)</code>: 检查给定的 FILE 流 stream 的错误指示器。</p>
</li>
<li>
<p><code>void perror(const char *str)</code>: 打印一条错误消息到 stderr。</p>
</li>
</ol>
<h1>补充</h1>
<h2 id="变量声明位置">变量声明位置</h2>
<p><strong>在 C99（1999年发布的C语言标准）及以后的版本中，你可以在代码的任何位置声明和定义变量</strong>。在此之前的C89/C90标准中，变量必须<strong>在代码块或函数的开头被声明</strong>。</p>
<p>举个例子，在C89/C90中，你需要这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在C99及以后的版本中，你可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，变量<code>i</code>就在<code>for</code>循环的初始化部分被声明和定义。</p>
<p>如果你不确定自己的编译器支持哪个版本的C语言，你可以查阅编译器的文档或者在线搜索相关信息。对于GCC和Clang这类编译器，你可以使用命令行参数<code>-std=c99</code>（或者更新的版本，如<code>-std=c11</code>，<code>-std=c17</code>等）来指定C语言的版本。</p>
<h2 id="true和false">true和false</h2>
<p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。<strong>注意字符0 可不是0, '\0’才是0</strong></p>
<h2 id="指针的运算">指针的运算</h2>
<p>指针只支持相同类型之间减运算,  而且 计算的值 =  (指针a的值 - 指针b的值)/(指针类型字节大小) ,  还有就是指针和整数之间的加法运算 计算值  = 指针地址值 + 整数*指针类型字节大小   (这里可以使用变量)</p>
<blockquote>
<p>注意, 比如 int* a = &amp;d  这里说的指针类型字节大小  是指这样的  sizeof(int)</p>
</blockquote>
<h2 id="默认初始化">默认初始化</h2>
<p>在 C 语言中，变量的默认初始化取决于它们被声明的位置。局部变量和全局变量的默认初始化是不同的：</p>
<ol>
<li><strong>局部变量</strong>：这些变量在函数内部声明。如果你不显式地初始化局部变量，那么它们的初始值是不确定的(因为它被分配在栈中的一个位置, 但是这个位置之前是有数据的)，即所谓的“垃圾值”。在使用局部变量之前，你总是应该先为它们赋值。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 局部变量 x，不确定的初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>全局变量</strong>：这些变量在函数外部声明，可在程序的任何地方访问。如果你不显式地初始化全局变量，那么<strong>编译器会为它们赋予默认</strong>值。对于不同的数据类型，这些默认值如下：
<ul>
<li>整型（int）和字符型（char）：默认值为 0</li>
<li>浮点型（float）和双精度浮点型（double）：默认值为 0.0</li>
<li>指针（pointer）：默认值为 NULL</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">// 全局变量 x，默认初始化为 0</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>静态变量</strong>：无论是静态局部变量还是静态全局变量，如果你不显式地初始化它们，<strong>那么编译器会为它们赋予默认值，规则与全局变量相同。</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x; <span class="comment">// 静态局部变量 x，默认初始化为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，对于变量的初始化，显式初始化总是一个好的编程习惯，因为它可以使你的代码更清晰，更易于理解，也可以避免由于未初始化的变量引起的不可预期的行为。</p>
<h2 id="typedef">typedef</h2>
<p><code>typedef</code> 是 C 语言中的一个关键字，用于为<strong>现有的数据类型创建一个新的名称</strong>（别名）。这可以用来增加代码的可读性和可维护性。以下是关于 <code>typedef</code> 的一些主要概念：</p>
<ol>
<li>
<p><strong>基本使用</strong>：你可以用 <code>typedef</code> 为任何数据类型定义一个新的名字。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Length;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了一个新的名字 <code>Length</code>，它是 <code>int</code> 的别名。现在，你可以使用 <code>Length</code> 来定义变量，就像使用 <code>int</code> 一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length x, y, z;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>与结构体结合使用</strong>：<code>typedef</code> 经常与结构体（<code>struct</code>）一起使用，以避免在定义结构体变量时需要写 <code>struct</code> 关键字。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> gpa;</span><br><span class="line">&#125; Student;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了一个新的名字 <code>Student</code>，它是 <code>struct Student</code> 的别名。这样，我们就可以直接使用 <code>Student</code> 来定义结构体变量，而不需要写 <code>struct</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s1, s2;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>与指针类型结合使用</strong>：你可以使用 <code>typedef</code> 为指针类型定义新的名字，这可以使代码更清晰。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* IntPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*hello)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 函数指针</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了一个新的名字 <code>IntPtr</code>，它是 <code>int*</code> 的别名。这样，我们就可以使用 <code>IntPtr</code> 来定义指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntPtr p, q;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>总的来说，<code>typedef</code> 是一个很有用的工具，可以帮助你使代码更加清晰和一致。不过，你也应该注意，过度使用 <code>typedef</code> 可能会导致代码变得难以理解和维护，因此要适度使用。</p>
<p>注意点:</p>
<p>看下面这两个代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>
<p><strong>其中第一个是 对struct node 起了一个别名node , 第二个是定义了一个结构体变量变量名字是node</strong></p>
<h2 id="typedef和define的区别">typedef和define的区别</h2>
<p><code>typedef</code>和<code>define</code>都可以用于为现有类型创建别名，但它们有一些关键的区别：</p>
<ol>
<li>
<p><strong>处理方式</strong>：<code>typedef</code>是由编译器处理的，它创建的是类型的别名。而<code>define</code>是由预处理器处理的，它创建的是宏。</p>
</li>
<li>
<p><strong>类型检查</strong>：<code>typedef</code>提供类型检查，如果你试图为不兼容的类型使用别名，编译器会给出警告或错误。但是，<code>define</code>没有类型检查，它只是在预处理阶段进行文本替换。</p>
</li>
<li>
<p><strong>作用范围</strong>：<code>typedef</code>具有作用范围，<strong>它的有效范围是从声明点到声明所在的块或源文件的结束</strong>。而<code>define</code>没有作用范围，它在定义后的所有地方都有效，直到取消定义（<code>#undef</code>）或者文件结束。</p>
</li>
<li>
<p><strong>与结构体和联合体的交互</strong>：<code>typedef</code>可以与<code>struct</code>，<code>union</code>和<code>enum</code>等关键字一起使用，从而避免在声明这些类型的变量时需要写关键字。而<code>define</code>不能实现这个功能。</p>
</li>
</ol>
<p>例如，比较以下两种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>
<p>与</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Node struct Node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然<code>define</code>也能创建别名，但是在处理类型（尤其是复杂的类型，如结构体、联合体和函数指针）时，<code>typedef</code>通常更为优秀和灵活。在许多情况下，<code>typedef</code>可以使代码更清晰、更具可读性。</p>
<h2 id="可变参数">可变参数</h2>
<h3 id="定义">定义</h3>
<p>在C语言中，当函数的参数数量是可变的，我们称之为可变参数。为了处理这种情况，C语言在 <code>&lt;stdarg.h&gt;</code> 库中提供了一组宏。以下是这些宏的概述：</p>
<ol>
<li>
<p><code>va_list</code>: 这是一个用于储存可变参数信息的类型。</p>
</li>
<li>
<p><code>va_start(va_list ap, last_arg)</code>: 这个宏初始化 <code>ap</code> 变量以供 <code>va_arg</code> 和 <code>va_end</code> 宏使用。<code>last_arg</code> 是函数中最后一个非可变的参数。</p>
</li>
<li>
<p><code>va_arg(va_list ap, type)</code>: 这个宏检索 <code>ap</code> 变量所指向的下一个参数，并以 <code>type</code> 类型返回。每次调用 <code>va_arg</code> 之后，<code>ap</code> 都会更新以指向下一个参数。</p>
</li>
<li>
<p><code>va_end(va_list ap)</code>: 这个宏清理 <code>ap</code> 变量，并使其失效。在完成所有的 <code>va_arg</code> 调用之后，你应当调用 <code>va_end</code>。</p>
</li>
</ol>
<p>以下是一个使用这些宏的示例，它接收一个整数和一个可变参数列表，然后打印出所有的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_numbers</span><span class="params">(<span class="type">int</span> n, ...)</span> &#123;</span><br><span class="line">    va_list valist;</span><br><span class="line">    va_start(valist, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = va_arg(valist, <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(valist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print_numbers(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>print_numbers</code> 函数可以接收任意数量的整数参数。它首先使用 <code>va_start</code> 初始化 <code>valist</code>，然后使用 <code>va_arg</code> 获取每个参数，最后使用 <code>va_end</code> 结束参数列表的处理。注意，程序必须知道参数的正确类型和数量，否则结果可能是不确定的。在这个例子中，参数的数量由 <code>n</code> 参数提供，参数的类型被硬编码为 <code>int</code>。</p>
<h3 id="原理">原理</h3>
<p>C语言的可变参数列表依赖于函数调用协议（calling convention），这是指<strong>编译器如何在内存中安排函数的参数、返回值，以及如何在函数调用和返回时保存和恢复状态。</strong>(<strong>取决于它怎么翻译成汇编</strong>),  所以我们使用它提供的东西能保证一致性,  如果我们贸然使用指针操作可能有时候不对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void test(int a, int b)&#123;</span><br><span class="line">    int* d = &amp;a;</span><br><span class="line">    int* f = &amp;b;</span><br><span class="line">    printf(&quot;a = %p b = %p&quot;,&amp;a,&amp;b);</span><br><span class="line">    int c = a-b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10,b = 20;</span><br><span class="line">    test(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过查看汇编发现,   它是通过寄存器传递参数的,  然后再把寄存器的值放入到栈中,然后再使用栈里面的数据,入栈顺序是 a先入栈, b在入栈(栈是从高地址往低地址增长),所以a的地址 - b的地址  = 4  (这里是参数从左往右入栈 在centos7上)</p>
<blockquote>
<p>这里其实也不严谨,  仅仅通过地址来判断的话,  其实说明不了参数的入栈顺序,  它有时候使用的是寄存器,  因为我们使用了它的地址, 所以他把这个数放到了堆栈里面,  然后再获取这个放入它位置</p>
</blockquote>
<h2 id="命令行参数">命令行参数</h2>
<p>在 C 语言中，命令行参数通过 main 函数的两个参数传递：<code>argc</code>（参数计数）和 <code>argv</code>（参数向量）。</p>
<p><code>int main(int argc, char *argv[])</code></p>
<p>这是 main 函数的另一种常见形式，用于接收命令行参数。</p>
<ol>
<li>
<p><code>argc</code>：这是一个整数，表示在命令行中输入的参数数量。这总是至少为 1，因为程序名称本身就是第一个参数。</p>
</li>
<li>
<p><code>argv</code>：这是一个字符指针的数组，其中每个指针都指向一个字符串，即在命令行中输入的一个参数。这些参数是以空格分隔的字符串。</p>
</li>
</ol>
<p>例如，如果你有一个名为 <code>program</code> 的程序，你可以在命令行中以如下方式运行它：</p>
<p><code>./program arg1 arg2 arg3</code></p>
<p>在这种情况下，<code>argc</code> 的值为 4 （包括程序名称 <code>program</code>），<code>argv</code> 是一个指向四个字符串的指针的数组，分别为 <code>&quot;./program&quot;</code>, <code>&quot;arg1&quot;</code>, <code>&quot;arg2&quot;</code> 和 <code>&quot;arg3&quot;</code>。</p>
<p>注意，<code>argv[0]</code> <strong>始终是程序的名称</strong>，<code>argv[1]</code> 是第一个参数，以此类推，<code>argv[argc]</code> <strong>是一个空指针</strong>。</p>
<p>使用这些参数，可以在运行程序时向程序传递一些特定的输入或选项。</p>
<h2 id="静态链接库">静态链接库</h2>
<h3 id="定义">定义</h3>
<p>静态链接库是一种在编译时连接的库。<strong>这种库的所有代码和数据都被编译进了最终的可执行文件中</strong>。在程序运行时，静态库中的函数或数据不需要再从其他文件或位置加载，它们已经存在于可执行文件中。</p>
<p>下面是关于静态链接库的一些关键点：</p>
<ol>
<li>
<p>编译时包含：静态库在**编译时(这里的编译是指从源代码到生成可执行文件的过程,其实说链接更准确)**就被包含到可执行文件中。这意味着，运行可执行文件不需要额外的动态链接库。</p>
</li>
<li>
<p>完整性：由于静态库被编译到可执行文件中，所以在不同的系统上，这个文件不需要依赖其他库文件就可以运行。这种特性使得静态链接库非常适合于分发软件，尤其是当你不确定目标系统是否安装了必要的库文件时。</p>
</li>
<li>
<p>大小：因为所有必要的库代码都被包含在可执行文件中，所以使用静态库的程序通常比使用动态库的程序大。</p>
</li>
<li>
<p>版本控制：<strong>使用静态库可以避免一些由于库版本不匹配导致的问题。这是因为库的特定版本在编译时就被固定了</strong>。</p>
</li>
<li>
<p>性能：<strong>静态库的另一个优势是，它们通常会提供更好的性能。这是因为静态链接的代码在编译时就已经确定了，不需要在运行时动态解析符号或进行其他运行时链接步骤。</strong></p>
</li>
<li>
<p>缺点：静态库的主要缺点是他们会增加最终可执行文件的大小。此外，<strong>如果多个应用程序都使用同一静态库，那么每个应用程序都需要包含库的副本，这可能会浪费存储空间和内存</strong>。同时，<strong>更新库的版本时，所有使用该库的程序都需要重新编译和链接</strong>。</p>
<blockquote>
<p>如果静态库函数接口,全局变量这些东西没变, 这个程序是不需要重新修改代码编译的, 但是一定需要重新链接</p>
</blockquote>
</li>
</ol>
<h3 id="不同工具集创建方式">不同工具集创建方式</h3>
<p>代码如下</p>
<p>add.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;add.h&quot;</span><br><span class="line"></span><br><span class="line">int add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>add.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">int add(int a, int b);</span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;add.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int c = add(a, b);</span><br><span class="line">    printf(&quot;a + b = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用gcc工具集">使用gcc工具集</h4>
<ol>
<li>
<p><strong>编译生成目标文件</strong>：首先，你需要编译<code>add.c</code>，生成<code>add.o</code>目标文件。在命令行中，你可以键入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>生成静态库</strong>：使用<code>ar</code>命令，你可以将<code>add.o</code>打包成静态库<code>libadd.a</code>。在命令行中，你可以键入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libadd.a add.o <span class="comment"># 后面可以跟多个目标文件</span></span><br></pre></td></tr></table></figure>
<p>这会生成一个名为<code>libadd.a</code>的静态库。</p>
</li>
<li>
<p><strong>编译并链接</strong>：然后，你需要编译<code>main.c</code>，并链接到<code>libadd.a</code>库。在命令行中，你可以键入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c -o main.o</span><br><span class="line">gcc -static main.o -L. -ladd -o main <span class="comment"># 这里使用static是为了强制使用静态库</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>-L.</code>告诉编译器去当前目录(<code>.</code>)查找库，<code>-ladd</code>表示链接名为<code>add</code>的库(即<code>libadd.a</code>)。这会生成一个名为<code>main</code>的可执行文件。</p>
</li>
<li>
<p><strong>运行</strong>：最后，你可以运行<code>main</code>。在命令行中，你可以键入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>
<p>这将会打印出<code>a + b = 30</code>。</p>
</li>
</ol>
<p>以上步骤默认所有文件都在同一目录下进行，如果文件或者库在其他目录，需要根据实际情况修改路径。同时，假设你的系统中已经正确安装了GCC和相关工具。</p>
<h4 id="使用vs工具集">使用vs工具集</h4>
<p>在Windows环境中，可以使用Microsoft提供的<code>lib</code>命令来生成静态库文件。下面是生成静态库文件的步骤：</p>
<ol>
<li>
<p><strong>编译生成目标文件</strong>：首先，你需要编译<code>add.c</code>，生成<code>add.obj</code>目标文件。在命令行中，你可以键入如下命令：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /c add.c</span><br></pre></td></tr></table></figure>
<p>这个命令将会编译<code>add.c</code>并生成<code>add.obj</code>文件。这里需要注意的是，<strong>Microsoft的编译器生成</strong>的是<code>.obj</code>文件，而不是<code>.o</code>文件。</p>
</li>
<li>
<p><strong>生成静态库</strong>：然后，你可以使用<code>lib</code>命令将<code>add.obj</code>打包成静态库<code>add.lib</code>。在命令行中，你可以键入如下命令：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib /OUT:add.lib add.obj</span><br></pre></td></tr></table></figure>
<p>这个命令将会生成<code>add.lib</code>静态库。</p>
</li>
<li>
<p><strong>编译并链接</strong>：然后，你需要编译<code>main.c</code>，并链接到<code>add.lib</code>库。在命令行中，你可以键入如下命令：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /Fe:main.exe main.c add.lib</span><br></pre></td></tr></table></figure>
<p>这个命令将会生成一个名为<code>main.exe</code>的可执行文件。</p>
</li>
<li>
<p><strong>运行</strong>：最后，你可以运行<code>main.exe</code>。在命令行中，你可以键入如下命令：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.exe</span><br></pre></td></tr></table></figure>
<p>这将会打印出<code>a + b = 30</code>。</p>
</li>
</ol>
<p>以上步骤默认所有文件都在同一目录下进行，如果文件或者库在其他目录，需要根据实际情况修改路径。同时，假设你的系统中已经正确安装了Visual Studio和相关工具，<code>cl</code>和<code>lib</code>命令能够在命令行中被正确找到。</p>
<h3 id="注意点">注意点</h3>
<p><strong>静态库的全局变量和函数 是不能跟其他静态库以及主程序冲突的</strong></p>
<h2 id="动态链接库">动态链接库</h2>
<h3 id="定义">定义</h3>
<p>动态链接库，是一种包含了程序可以在运行时调用的函数和数据的二进制文件。动态库在程序运行时被加载进内存，可以被多个正在运行的程序共享。相比静态库，动态库有以下特点和优点：</p>
<ol>
<li>
<p><strong>内存高效</strong>：由于同一动态库的单一实例可以被多个程序共享，因此动态库有助于节省内存。</p>
</li>
<li>
<p><strong>更新方便</strong>：当动态库更新时，只需替换磁盘上的动态库文件即可，不需要重新编译和链接使用该库的程序。</p>
</li>
<li>
<p><strong>动态加载</strong>：程序在运行时可以动态加载和卸载动态库。这在需要在运行时扩展功能时非常有用。</p>
</li>
<li>
<p><strong>减小二进制文件大小</strong>：使用动态库可以减小二进制文件的大小，因为库函数并未链接进二进制文件，而是在运行时动态加载。</p>
</li>
</ol>
<p>然而，动态库也有其不足之处：</p>
<ol>
<li>
<p><strong>版本兼容性问题</strong>：如果动态库的新版本改变了API或者ABI，那么旧的程序可能会因为找不到需要的函数或者数据而失败。</p>
</li>
<li>
<p><strong>分布和部署的复杂性</strong>：使用动态库的应用程序需要在分布和部署时包含动态库，或者确保目标系统已经安装了正确版本的动态库。</p>
</li>
<li>
<p><strong>性能</strong>：动态链接在一些情况下可能会比静态链接稍慢一些，因为需要在运行时进行符号解析。</p>
</li>
<li>
<p><strong>安全性</strong>：动态库可能会被恶意修改或替换，从而导致使用该库的程序行为异常。</p>
</li>
</ol>
<p>总的来说，动态库提供了一种灵活、高效的方式来共享代码和数据，但是也增加了一些复杂性。选择使用静态库还是动态库取决于你的具体需求和环境。</p>
<h3 id="变量作用域">变量作用域</h3>
<p>在 C 语言中，<strong>动态库（DLL 在 Windows 或 .so 在 Unix/Linux）与主程序之间的命名空间是分开的</strong>。这意味着，即使动态库中的全局变量与主程序中的全局变量同名，它们也是完全不同的变量，互不影响。</p>
<p>例如，如果你在主程序 <code>main.c</code> 中定义了一个全局变量 <code>int x;</code>，然后在动态库 <code>lib.c</code> 中也定义了一个全局变量 <code>int x;</code>，编译和链接过程不会产生错误或警告，因为这两个 <code>x</code> 变量在不同的命名空间中。</p>
<p>在运行时，主程序和动态库都会有各自的 <code>x</code> 变量的拷贝。主程序只能访问和修改它自己的 <code>x</code>，动态库只能访问和修改它自己的 <code>x</code>。<strong>如果你想在主程序中访问动态库中的 <code>x</code>，或者在动态库中访问主程序中的 <code>x</code>，你需要提供相应的接口函数。</strong></p>
<p><strong>需要注意的是，这个行为是 C 语言特性，与操作系统或编译器无关。</strong></p>
<blockquote>
<p>这个和静态链接库还是有很大区别的</p>
</blockquote>
<h3 id="搜索路径">搜索路径</h3>
<p>在Windows和Linux系统中，动态链接库（DLLs 在Windows，.so 在Linux）的搜索路径有所不同。以下是关于两种操作系统如何搜索这些库的简要概述：</p>
<p><strong>Windows中的DLL搜索路径</strong></p>
<ol>
<li><strong>应用程序的目录</strong>：首先，Windows会查找包含应用程序的可执行文件的目录。比如，如果你正在运行位于<code>C:\Program Files\MyApp\MyApp.exe</code>的应用程序，Windows就会首先查找<code>C:\Program Files\MyApp</code>目录下的DLL文件。</li>
<li><strong>系统目录</strong>：其次，Windows会查找系统目录，即<code>C:\Windows\System32</code>。对于64位系统，32位的DLL会在<code>C:\Windows\SysWOW64</code>目录下。</li>
<li><strong>Windows目录</strong>：然后，Windows会查找Windows目录，即<code>C:\Windows</code>。</li>
<li><strong>当前目录</strong>：此外，Windows也会查找当前工作目录。当前工作目录是指当前活动的文件路径，这个路径可以被应用程序改变。需要注意的是，从Windows XP SP2开始，为了增加系统的安全性，<strong>当前目录在默认情况下不再被包含在DLL搜索路径中</strong>。(<strong>这个目录是你执行程序的目录</strong>)</li>
<li><strong>PATH环境变量指定的目录</strong>：最后，Windows会按照它们在PATH环境变量中出现的顺序来查找这些目录。PATH环境变量包含一个或多个目录的列表，这些目录之间用分号（;）分隔。</li>
</ol>
<p>需要注意的是，这种行为可以通过一些API函数（例如 <code>SetDllDirectory</code>）或者Manifest文件进行更改。</p>
<p><strong>Linux中的.so搜索路径</strong></p>
<p>Linux系统搜索.so文件通常遵循以下顺序：</p>
<ol>
<li>LD_LIBRARY_PATH 环境变量中指定的目录。这是一个由冒号分隔的目录列表。</li>
<li><code>/etc/ld.so.cache</code> 文件中列出的目录，这个文件包含了已知动态库的列表。</li>
<li><code>/lib</code> 目录</li>
<li><code>/usr/lib</code> 目录</li>
</ol>
<p>这个过程也可以通过修改 <code>/etc/ld.so.conf</code> 文件或者添加新的 <code>.conf</code> 文件到 <code>/etc/ld.so.conf.d</code> 目录来定制。每次修改后，都需要运行 <code>ldconfig</code> 命令更新 <code>/etc/ld.so.cache</code> 文件。</p>
<p>这些只是默认行为，特定的应用程序或库可能会改变这种行为，例如通过使用 <code>dlopen</code> 函数的完全限定路径。</p>
<p><strong>无论是在Windows还是Linux系统中，如果系统在某个目录下找到了所需的动态链接库（DLL 或 .so 文件），系统就会立即停止搜索，并且加载找到的那个库文件。</strong></p>
<h2 id="整数类型的转换">整数类型的转换</h2>
<h3 id="等字长有无符号转换">等字长有无符号转换</h3>
<p>不改变二进制位, 只改变解释方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = -1</span><br><span class="line">unsigned int b = a; //4294967295   </span><br></pre></td></tr></table></figure>
<h3 id="不等字长转换">不等字长转换</h3>
<p>高到低:  高字节直接截断低位  赋值给  低字节</p>
<p>低到高(<strong>这里是看低字节是否有符号</strong>)</p>
<ol>
<li>低字节数无符号,  高字节数高位都补0,  高字节数低位直接赋值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> b = a; <span class="comment">// 65535</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>低字节数有符号,  高字节数高位补符号位, 高字节数低位直接赋值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = a; <span class="comment">//4294967295</span></span><br></pre></td></tr></table></figure>
<h2 id="文件打开模式">文件打开模式</h2>
<p>在C语言中使用 <code>fopen</code> 函数打开文件时指明是以二进制模式还是文本（字符）模式打开，主要是因为不同操作系统对文件的处理方式存在差异，<strong>特别是在处理换行符时。</strong></p>
<h3 id="文本模式-character-mode">文本模式 (Character Mode)</h3>
<p>在文本模式下打开文件时，C标准库会根据运行平台的惯例对文件的内容进行某些转换。最常见的例子是换行符的处理：</p>
<ul>
<li>在 <strong>Windows</strong> 系统中，文本文件的换行符通常表示为回车符和换行符的组合 (<code>\r\n</code>)。</li>
<li>而在 <strong>Unix/Linux</strong> 和 <strong>macOS</strong> 系统中，换行符通常只是一个换行符 (<code>\n</code>)。</li>
</ul>
<p>当您在文本模式下读取或写入文件时，C标准库会自动将这些换行符转换为适合于您的操作系统的格式。例如，在Windows上，当您从文件中读取数据时，每个 <code>\r\n</code> 序列会被转换为 <code>\n</code>；当您写入数据时，每个 <code>\n</code> 会被转换为 <code>\r\n</code>。</p>
<h3 id="二进制模式-binary-mode">二进制模式 (Binary Mode)</h3>
<p>在二进制模式下，文件被视为字节流，不进行任何转换。这对于非文本文件（如图像、音频、视频或任何自定义格式的数据文件）尤其重要，因为在这些文件中，任何字节的改变都可能导致文件损坏。</p>
<h3 id="为什么这很重要">为什么这很重要</h3>
<p>区分这两种模式很重要，因为错误地选择模式可能会导致数据不正确地读取或写入，特别是当您的程序需要在多种操作系统上运行时。例如，如果您在Windows上以文本模式打开一个二进制文件，并试图读取或写入数据，可能会不经意间改变文件中的 <code>\r\n</code> 字节序列，从而损坏文件。</p>
<h3 id="结论">结论</h3>
<p>因此，在使用 <code>fopen</code> 时指定正确的文件模式是确保文件数据正确读取和写入的关键，尤其是当您的程序需要在不同的操作系统上运行时。在处理纯文本数据时使用文本模式，在处理二进制数据（或当文件格式需要跨平台一致时）使用二进制模式。</p>
<h1>gcc的用法</h1>
<h2 id="基本参数">基本参数</h2>
<ul>
<li>-E  只做预处理</li>
<li>-S 转化成汇编</li>
<li>-c 生成目标文件</li>
<li>-o 输出文件名字 (使用上面三个参数)</li>
</ul>
<h3 id="static">static</h3>
<p>强制使用静态链接,  这意味着会链接所有使用到的库函数,   包括c语言提供的库,  一定要确保使用到的函数所在的静态库存在于  库搜索目录中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static main.o -L. -l add -o main</span><br></pre></td></tr></table></figure>
<p>比如在我centos8中执行这个命令就报错了,  因为这个系统里面没有libc.a这个静态库(它会默认链接),  所以</p>
<p>即使你的代码没有直接使用到标准库函数，<code>gcc</code> 编译和链接时仍然会引用标准 C 库（<code>libc</code>），因为一些基本的运行时支持功能（比如程序启动和退出代码）通常都在 <code>libc</code> 里面实现。</p>
<h3 id="i-i的大写">I (i的大写)</h3>
<p><strong>指定额外的头文件搜索路径,可以是相对也可以是绝对路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c add.c -I.. -o main</span><br></pre></td></tr></table></figure>
<h3 id="l-l的小写">l(L的小写)</h3>
<p>指定额外库, 后面跟库名字,当使用 <code>-l</code> 选项时，你只需要提供库的基本名称，不需要文件扩展名和<code>lib</code> 前缀。</p>
<ul>
<li>例如，对于 <code>libadd.a</code> 或 <code>libadd.so</code>，使用 <code>-ladd</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  main.o -L. -l add -o main</span><br></pre></td></tr></table></figure>
<p>不过默认情况下，<code>gcc</code> 优先链接动态库。如果你想确保链接静态库，你可以使用 <code>-static</code> 标志或明确指定库的完整名称和路径。推荐后者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc  main.o -L. -l:libadd.a -o main</span><br><span class="line">gcc  main.o /root/Code/gccTest/day02/libadd.a -o main</span><br></pre></td></tr></table></figure>
<h3 id="l">L</h3>
<p>指定额外<strong>库路径</strong>, 可以是相对路径, 也可以是绝对路径,   这个跟上面的参数搭配使用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  main.o -L. -l add -o main</span><br></pre></td></tr></table></figure>
<h2 id="生成动态库">生成动态库</h2>
<p>创建动态库（在Linux/Unix系统上通常是<code>.so</code> 文件，在Windows上是 <code>.dll</code> 文件）与创建静态库略有不同。以下是在Linux上使用 <code>gcc</code> 创建动态库的步骤：</p>
<h3 id="1-编写源代码">1. 编写源代码</h3>
<p>假设你有两个源文件 <code>file1.c</code> 和 <code>file2.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function1 from a shared library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function2 from a shared library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-编译源代码">2. 编译源代码</h3>
<p>使用 <code>-fPIC</code> 选项编译源代码文件，该选项表示生成位置无关代码（Position Independent Code）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC file1.c -o file1.o</span><br><span class="line">gcc -c -fPIC file2.c -o file2.o</span><br></pre></td></tr></table></figure>
<h3 id="3-创建共享库">3. 创建共享库</h3>
<p>使用 <code>-shared</code> 选项链接目标文件，并使用 <code>-o</code> 选项指定输出的共享库文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared file1.o file2.o -o libmysharedlib.so</span><br></pre></td></tr></table></figure>
<p>这会创建一个名为 <code>libmysharedlib.so</code> 的动态库。</p>
<h3 id="4-使用动态库">4. 使用动态库</h3>
<p>要使用这个动态库，你可以在编译你的主程序时指定这个库。例如，如果你的主程序是 <code>main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    function1();</span><br><span class="line">    function2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译主程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -lmysharedlib -o main</span><br></pre></td></tr></table></figure>
<p>这里，<code>-L.</code> 指定库的搜索路径为当前目录，<code>-lmysharedlib</code> 指定链接到名为 <code>mysharedlib</code> 的库。</p>
<h3 id="5-设置库路径">5. 设置库路径</h3>
<p>在运行你的程序前，确保系统知道在哪里找到动态库。你可以通过设置 <code>LD_LIBRARY_PATH</code> 环境变量来做这件事：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>
<p>这将当前目录添加到 <code>LD_LIBRARY_PATH</code> 环境变量中。</p>
<h3 id="6-运行你的程序">6. 运行你的程序</h3>
<p>现在你可以运行你的主程序了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>
<p>在Windows系统上，创建和使用动态库（<code>.dll</code> 文件）的过程略有不同，并且使用的是不同的工具和命令。</p>
<h3 id="什么是位置无关">什么是位置无关</h3>
<p><code>-fPIC</code> 是一个编译选项，用于生成位置无关代码（Position Independent Code, PIC）。这种代码类型可以从任何内存地址执行，不受固定地址限制，这是创建共享库所必需的。</p>
<h3 id="为什么需要位置无关代码？">为什么需要位置无关代码？</h3>
<ul>
<li>
<p><strong>共享库</strong>：<br>
当你创建一个共享库（<code>.so</code>或<code>.dll</code>）时，它可以被多个执行文件（程序）同时使用。系统不可能事先知道这些执行文件将被加载到内存的什么位置，也不可能事先知道它们将使用的共享库将被加载到什么位置。因此，共享库中的代码必须能够从任何内存地址运行，这就是为什么它们必须被编译为位置无关代码的原因。</p>
</li>
<li>
<p><strong>动态加载</strong>：<br>
另一个需要PIC的场景是动态加载，例如，当一个程序在运行时动态加载一个插件或模块。由于程序无法事先知道这些插件将被加载到什么位置，所以插件必须使用位置无关代码。</p>
</li>
</ul>
<h3 id="pic的工作原理：">PIC的工作原理：</h3>
<ul>
<li><strong>位置无关代码使用相对地址（而不是绝对地址）来访问数据和调用函数</strong>。也就是说，<strong>它不直接引用内存地址</strong>。相反，它使用基于运行时地址的偏移来访问数据和函数。</li>
<li>在运行时，动态链接器负责处理这些相对地址和偏移，以确保代码正确执行。</li>
</ul>
<h3 id="使用-fpic：">使用 <code>-fPIC</code>：</h3>
<p>使用 <code>-fPIC</code> 选项编译源文件时，编译器会生成这种类型的代码，使得生成的目标文件可以被链接到一个共享库中。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC source.c -o source.o</span><br></pre></td></tr></table></figure>
<p>这将编译 <code>source.c</code> 为一个位置无关的目标文件 <code>source.o</code>。</p>
<h2 id="简化输出汇编">简化输出汇编</h2>
<ul>
<li><strong><code>-O0</code></strong>：设置优化级别为0，表示不进行任何优化。</li>
<li><strong><code>-fverbose-asm</code></strong>：在生成的汇编代码中添加额外的注释，以更好地说明代码的来源。</li>
<li><strong><code>-masm=intel</code></strong>：使用 Intel 语法生成汇编代码，而不是默认的 AT&amp;T 语法。</li>
<li><strong><code>-nostdlib</code></strong>：不使用标准库和启动文件。这意味着你的代码不能依赖于标准C库的任何功能。</li>
<li><strong><code>-ffreestanding</code></strong>：告诉编译器代码是在一个不依赖于标准库的环境中运行的。</li>
<li><strong><code>-fno-asynchronous-unwind-tables</code></strong>：不生成用于异步异常处理的表格。这有助于减少一些平台上的额外的 <code>.cfi</code> 指令。</li>
<li><strong><code>-fno-stack-protector</code></strong>：不生成堆栈保护代码，这通常用于防止栈溢出攻击。</li>
<li><strong><code>-fomit-frame-pointer</code></strong>：不使用帧指针，这可以在某些平台上减少对某些寄存器的依赖。</li>
<li><strong><code>-fno-plt</code></strong>：避免生成过程链接表（Procedure Linkage Table, PLT）调用，这对于某些涉及动态链接的场景有意义。</li>
<li><strong><code>-fno-leading-underscore</code></strong>：在某些平台上，符号名默认可能有一个前导的下划线。这个选项告诉编译器不要添加这个下划线。</li>
<li><strong><code>-fno-builtin</code></strong>：不使用任何内建函数，即 GCC 的内部优化函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -O0 -fverbose-asm -masm=intel -nostdlib -ffreestanding -fno-asynchronous-unwind-tables -fno-stack-protector -fomit-frame-pointer -fno-plt -fno-leading-underscore -fno-builtin </span><br><span class="line">    your_source_file.c -o output_asm_file.s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="输入输出字符问题">输入输出字符问题</h2>
<h3 id="输入前的处理">输入前的处理</h3>
<ul>
<li>
<p><strong><code>scanf</code> 系列函数</strong>：这些函数在遇到非空白字符前会忽略空白字符，包括空格、制表符和换行符。所以如果输入流开始处是换行符，<code>scanf</code> 会跳过它继续寻找非空白字符。</p>
</li>
<li>
<p><strong><code>getchar</code> 和 <code>fgetc</code></strong>：这两个函数逐个字符读取输入流，包括换行符。如果下一个字符是换行符，它们会读取这个换行符。</p>
</li>
<li>
<p><strong><code>gets</code> 和 <code>fgets</code></strong>：<code>gets</code> 从输入流中读取直到换行符但不包括换行符本身，然后丢弃换行符；<code>fgets</code> 也读取直到换行符，但包括换行符本身，换行符被包含在返回的字符串中。</p>
</li>
</ul>
<h3 id="输入后的处理">输入后的处理</h3>
<ul>
<li>
<p><strong><code>scanf</code> 系列函数</strong>：如果<code>scanf</code>读取的格式不包括换行符，它会在完成读取后留下换行符在输入流中。这意味着换行符没有被消耗，还在缓冲区里等待下一个输入操作处理。</p>
</li>
<li>
<p><strong><code>getchar</code> 和 <code>fgetc</code></strong>：当这两个函数读取换行符时，它们会将其从输入流中移除。也就是说，换行符被读取并消耗掉了。</p>
</li>
<li>
<p><strong><code>gets</code> 和 <code>fgets</code></strong>：对于<code>gets</code>，换行符被读取后会被丢弃，不包含在返回的字符串中；而<code>fgets</code>会包含换行符在返回的字符串中，并从输入流中移除换行符。</p>
</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li>不同的输入函数对换行符的处理方式不同，这对于程序的行为和用户输入的处理非常关键。</li>
<li>理解每个函数如何处理换行符有助于预防输入时的错误和意外行为，特别是在连续使用多个输入函数的情况下。</li>
</ul>
<h1>一些不太好的用法</h1>
<h2 id="使用函数不声明">使用函数不声明</h2>
<blockquote>
<p>如果通过gcc是可以这样的,  g++貌似就不行了</p>
</blockquote>
<p>在C语言编程中，你可以在一个源文件（比如 <code>main.c</code>）中调用一个函数，而不需要在同一个源文件中声明或定义它。然而，为了让程序可以成功编译和链接，你必须在编译时确保链接器可以找到这个函数的定义。</p>
<p>下面是一个简单的例子：</p>
<ol>
<li>假设你有两个源文件：<code>main.c</code> 和 <code>helper.c</code>。</li>
</ol>
<ul>
<li>
<p><code>main.c</code> 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    myFunction();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>helper.c</code> 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from myFunction!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>你可以分别编译这两个源文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c      <span class="comment"># 这将生成 main.o</span></span><br><span class="line">gcc -c helper.c    <span class="comment"># 这将生成 helper.o</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>然后你可以链接这两个对象文件来创建一个可执行文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o helper.o -o myProgram</span><br></pre></td></tr></table></figure>
<p>在这个例子中，即使 <code>main.c</code> 文件中没有 <code>myFunction</code> 的声明，程序仍然可以成功编译和链接，因为 <code>myFunction</code> 的定义在 <code>helper.o</code>（从 <code>helper.c</code> 编译得到）中可用。</p>
<p>然而，即使这种方法可以工作，但在调用函数之前在源文件中提供函数声明通常是一个好习惯，因为这可以在编译时捕获类型不匹配和其他错误。如果你没有在 <code>main.c</code> 中提供 <code>myFunction</code> 的声明或定义，你应该在 <code>main.c</code> 中包含一个头文件（例如 <code>helper.h</code>），该头文件包含 <code>myFunction</code> 的声明：</p>
<ul>
<li><code>helper.h</code> 文件：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>main.c</code> 文件中包含这个头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    myFunction();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>一些有趣的尝试</h1>
<h2 id="大小端">大小端</h2>
<p>如何判断我们的电脑对于多字节数据是大端还是小端,   我当时的想法想得到所有位来判断,  这样是不行的,  因为运算的数是拿到寄存器里面来运算的, 不存在什么大小端,  因此我们得通过单字节指针char*</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int x = 1;</span><br><span class="line">    char *c = (char *)&amp;x;</span><br><span class="line"></span><br><span class="line">    if (*c)  // 如果*c是1就说明是小端</span><br><span class="line">        printf(&quot;Little-Endian\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;Big-Endian\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据的按边界存储">数据的按边界存储</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://djmnb.github.io">戴晶明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://djmnb.github.io/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/">https://djmnb.github.io/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://djmnb.github.io" target="_blank">戴晶明的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9C%80%E8%A6%81%E5%A4%8D%E4%B9%A0/">需要复习</a><a class="post-meta__tags" href="/tags/c%E8%AF%AD%E8%A8%80/">c语言</a></div><div class="post_share"><div class="social-share" data-image="/img/site/touxiang.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/12/C%E5%92%8CC++/MFC/" title="MFC学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MFC学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/" title="vs2019使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">vs2019使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/12/C%E5%92%8CC++/MFC/" title="MFC学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">MFC学习</div></div></a></div><div><a href="/2023/06/22/C%E5%92%8CC++/c++/" title="c++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-22</div><div class="title">c++</div></div></a></div><div><a href="/2023/06/27/English/%E8%AF%AD%E6%B3%95/" title="考研英语语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-27</div><div class="title">考研英语语法</div></div></a></div><div><a href="/2022/11/25/git/git%E6%80%BB%E7%BB%93/" title="git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">git</div></div></a></div><div><a href="/2024/09/19/java/thinking%20in%20java/" title="thinking in java"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-19</div><div class="title">thinking in java</div></div></a></div><div><a href="/2024/09/19/java/spring%E7%B3%BB%E5%88%97/" title="spring系列学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-19</div><div class="title">spring系列学习</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/site/touxiang.gif" onerror="this.onerror=null;this.src='/404.html'" alt="avatar"/></div><div class="author-info__name">戴晶明</div><div class="author-info__description">不积跬步,无以至千里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="/img/site/weixin.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="/img/site/qq.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define"><span class="toc-number">2.3.</span> <span class="toc-text">#define</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">高级方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89for%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">定义for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E8%A1%8C%E5%AE%8F"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">定义多行宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AE%8F"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">参数类型宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#none"><span class="toc-number">2.3.1.4.</span> <span class="toc-text"># ##</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error"><span class="toc-number">2.4.</span> <span class="toc-text">#error</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E5%AE%8F"><span class="toc-number">3.2.</span> <span class="toc-text">常用数值范围宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">存储类别说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">4.1.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern"><span class="toc-number">4.2.</span> <span class="toc-text">extern</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">控制结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">从源代码到可执行文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">更深入的从源代码到可执行文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">头文件和源文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">常用库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#assert-h"><span class="toc-number">14.1.</span> <span class="toc-text">assert.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ctype-h"><span class="toc-number">14.2.</span> <span class="toc-text">ctype.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stdio-h"><span class="toc-number">14.3.</span> <span class="toc-text">stdio.h</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%BD%8D%E7%BD%AE"><span class="toc-number">15.1.</span> <span class="toc-text">变量声明位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#true%E5%92%8Cfalse"><span class="toc-number">15.2.</span> <span class="toc-text">true和false</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">15.3.</span> <span class="toc-text">指针的运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">15.4.</span> <span class="toc-text">默认初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef"><span class="toc-number">15.5.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.6.</span> <span class="toc-text">typedef和define的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">15.7.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">15.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">15.7.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">15.8.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">15.9.</span> <span class="toc-text">静态链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">15.9.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%B7%A5%E5%85%B7%E9%9B%86%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">15.9.2.</span> <span class="toc-text">不同工具集创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8gcc%E5%B7%A5%E5%85%B7%E9%9B%86"><span class="toc-number">15.9.2.1.</span> <span class="toc-text">使用gcc工具集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8vs%E5%B7%A5%E5%85%B7%E9%9B%86"><span class="toc-number">15.9.2.2.</span> <span class="toc-text">使用vs工具集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">15.9.3.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">15.10.</span> <span class="toc-text">动态链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">15.10.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">15.10.2.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="toc-number">15.10.3.</span> <span class="toc-text">搜索路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">15.11.</span> <span class="toc-text">整数类型的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%AD%97%E9%95%BF%E6%9C%89%E6%97%A0%E7%AC%A6%E5%8F%B7%E8%BD%AC%E6%8D%A2"><span class="toc-number">15.11.1.</span> <span class="toc-text">等字长有无符号转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E5%AD%97%E9%95%BF%E8%BD%AC%E6%8D%A2"><span class="toc-number">15.11.2.</span> <span class="toc-text">不等字长转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.12.</span> <span class="toc-text">文件打开模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F-character-mode"><span class="toc-number">15.12.1.</span> <span class="toc-text">文本模式 (Character Mode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E5%BC%8F-binary-mode"><span class="toc-number">15.12.2.</span> <span class="toc-text">二进制模式 (Binary Mode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-number">15.12.3.</span> <span class="toc-text">为什么这很重要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">15.12.4.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">gcc的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0"><span class="toc-number">16.1.</span> <span class="toc-text">基本参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">16.1.1.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-i%E7%9A%84%E5%A4%A7%E5%86%99"><span class="toc-number">16.1.2.</span> <span class="toc-text">I (i的大写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-l%E7%9A%84%E5%B0%8F%E5%86%99"><span class="toc-number">16.1.3.</span> <span class="toc-text">l(L的小写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l"><span class="toc-number">16.1.4.</span> <span class="toc-text">L</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">16.2.</span> <span class="toc-text">生成动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%96%E5%86%99%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">16.2.1.</span> <span class="toc-text">1. 编写源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">16.2.2.</span> <span class="toc-text">2. 编译源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">16.2.3.</span> <span class="toc-text">3. 创建共享库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">16.2.4.</span> <span class="toc-text">4. 使用动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AE%BE%E7%BD%AE%E5%BA%93%E8%B7%AF%E5%BE%84"><span class="toc-number">16.2.5.</span> <span class="toc-text">5. 设置库路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">16.2.6.</span> <span class="toc-text">6. 运行你的程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3"><span class="toc-number">16.2.7.</span> <span class="toc-text">什么是位置无关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">16.2.8.</span> <span class="toc-text">为什么需要位置无关代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pic%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">16.2.9.</span> <span class="toc-text">PIC的工作原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-fpic%EF%BC%9A"><span class="toc-number">16.2.10.</span> <span class="toc-text">使用 -fPIC：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E8%BE%93%E5%87%BA%E6%B1%87%E7%BC%96"><span class="toc-number">16.3.</span> <span class="toc-text">简化输出汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98"><span class="toc-number">16.4.</span> <span class="toc-text">输入输出字符问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%89%8D%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">16.4.1.</span> <span class="toc-text">输入前的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">16.4.2.</span> <span class="toc-text">输入后的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">16.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">一些不太好的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8D%E5%A3%B0%E6%98%8E"><span class="toc-number">17.1.</span> <span class="toc-text">使用函数不声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">一些有趣的尝试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF"><span class="toc-number">18.1.</span> <span class="toc-text">大小端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%89%E8%BE%B9%E7%95%8C%E5%AD%98%E5%82%A8"><span class="toc-number">18.2.</span> <span class="toc-text">数据的按边界存储</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/29/python/yolo%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="yolo框架学习">yolo框架学习</a><time datetime="2024-11-28T16:00:00.000Z" title="发表于 2024-11-29 00:00:00">2024-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/12/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95%E8%AE%BA/" title="论文阅读方法论">论文阅读方法论</a><time datetime="2024-11-11T16:00:00.000Z" title="发表于 2024-11-12 00:00:00">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/01/python/pytorch/" title="pytorch学习">pytorch学习</a><time datetime="2024-10-31T16:00:00.000Z" title="发表于 2024-11-01 00:00:00">2024-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/30/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="深度学习">深度学习</a><time datetime="2024-09-29T16:00:00.000Z" title="发表于 2024-09-30 00:00:00">2024-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/19/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/" title="plantuml">plantuml</a><time datetime="2024-09-19T08:25:10.368Z" title="发表于 2024-09-19 16:25:10">2024-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 戴晶明</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BkV10wtzbo9nuKwtsBG04Idw-gzGzoHsz',
      appKey: 'CLv4OkdYGyropWktyqSDf2af',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>