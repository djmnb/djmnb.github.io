<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python编程快速上手 总结 | 戴晶明的个人博客</title><meta name="author" content="戴晶明"><meta name="copyright" content="戴晶明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编程是一项创造性任务  前言  程序开发要学会 站在巨人的肩膀上 。动手写代码前，先调研一番，看是否有现成的解决方案。 切忌重复造轮子 ，浪费时间不说，可能代码质量还差，效果也不好。  这个是基于python 3.8 总结的 在 Python 中，一切皆对象，基本数据类型也是如此 第一部分 python 基础 基本运算符  这里介绍python独特的运算符  算数运算符    操作符 操作">
<meta property="og:type" content="article">
<meta property="og:title" content="Python编程快速上手 总结">
<meta property="og:url" content="https://djmnb.github.io/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/index.html">
<meta property="og:site_name" content="戴晶明的个人博客">
<meta property="og:description" content="编程是一项创造性任务  前言  程序开发要学会 站在巨人的肩膀上 。动手写代码前，先调研一番，看是否有现成的解决方案。 切忌重复造轮子 ，浪费时间不说，可能代码质量还差，效果也不好。  这个是基于python 3.8 总结的 在 Python 中，一切皆对象，基本数据类型也是如此 第一部分 python 基础 基本运算符  这里介绍python独特的运算符  算数运算符    操作符 操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://djmnb.github.io/img/site/touxiang.gif">
<meta property="article:published_time" content="2023-03-03T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-19T08:25:10.344Z">
<meta property="article:author" content="戴晶明">
<meta property="article:tag" content="需要复习">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://djmnb.github.io/img/site/touxiang.gif"><link rel="shortcut icon" href="/img/site/icon.jfif"><link rel="canonical" href="https://djmnb.github.io/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python编程快速上手 总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-19 16:25:10'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/site/touxiang.gif" onerror="onerror=null;src='/404.html'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/why"><i class="fa-fw fas fa-question"></i><span> 十万个为什么</span></a></div><div class="menus_item"><a class="site-page" href="/goodarticle"><i class="fa-fw fas fa-book"></i><span> 好文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: /img/site/beijing.jfif"><nav id="nav"><span id="blog-info"><a href="/" title="戴晶明的个人博客"><span class="site-name">戴晶明的个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/why"><i class="fa-fw fas fa-question"></i><span> 十万个为什么</span></a></div><div class="menus_item"><a class="site-page" href="/goodarticle"><i class="fa-fw fas fa-book"></i><span> 好文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python编程快速上手 总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-03T16:00:00.000Z" title="发表于 2023-03-04 00:00:00">2023-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-19T08:25:10.344Z" title="更新于 2024-09-19 16:25:10">2024-09-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python编程快速上手 总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>编程是一项创造性任务</p>
</blockquote>
<h1>前言</h1>
<blockquote>
<p>程序开发要学会 <strong>站在巨人的肩膀上</strong> 。动手写代码前，先调研一番，看是否有现成的解决方案。 <strong>切忌重复造轮子</strong> ，浪费时间不说，可能代码质量还差，效果也不好。</p>
</blockquote>
<p>这个是基于python 3.8 总结的</p>
<p>在 <em>Python</em> 中，一切皆对象，基本数据类型也是如此</p>
<h1>第一部分 python 基础</h1>
<h2 id="基本运算符">基本运算符</h2>
<blockquote>
<p>这里介绍python独特的运算符</p>
</blockquote>
<h3 id="算数运算符">算数运算符</h3>
<table>
<thead>
<tr>
<th>操作符</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>数字相乘求积,字符串,列表这些跟整数相乘是复制</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
</tr>
<tr>
<td>//</td>
<td>除法取整,但是<strong>结果的数据类型是两个操作数中表示范围最大的一个的数据类型</strong></td>
</tr>
<tr>
<td>+</td>
<td>字符串,列表这些加法拼接,数字加法求和</td>
</tr>
</tbody>
</table>
<blockquote>
<p>整数如果在数值上与浮点数是相同的,用==比较时,他们就是相同的,不用管浮点数误差问题</p>
<p>记住python 没有 ++ --这种操作符</p>
</blockquote>
<h2 id="逻辑运算符">逻辑运算符</h2>
<table>
<thead>
<tr>
<th>操作符</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>两边表达式都为真才返回真</td>
</tr>
<tr>
<td>or</td>
<td>两边表达式有一边为真就返回真</td>
</tr>
<tr>
<td>not</td>
<td>返回表达式的相反情况</td>
</tr>
</tbody>
</table>
<h2 id="特殊运算符">特殊运算符</h2>
<table>
<thead>
<tr>
<th>操作符</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>判断前面这个对象是否存在后面的对象中</td>
</tr>
<tr>
<td>not in</td>
<td>自然是in的相反</td>
</tr>
<tr>
<td>is</td>
<td>判断地址值是否相同</td>
</tr>
<tr>
<td>==</td>
<td>通过调用__eq__方法得到结果</td>
</tr>
</tbody>
</table>
<p>三元运算符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>( <span class="number">1</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="number">10</span>)  <span class="comment"># 如果flag 为 True则返回 1否则返回 10</span></span><br></pre></td></tr></table></figure>
<p>只有0 空字符串 和 None 还有 nan 为False</p>
<h2 id="常用函数">常用函数</h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>str()</td>
<td>将其他数据类型变成字符串</td>
</tr>
<tr>
<td>int()</td>
<td>将其他数据类型变成整数</td>
</tr>
<tr>
<td>float()</td>
<td>将其他数据类型变成浮点数</td>
</tr>
<tr>
<td>list()</td>
<td>将其他可迭代数据(字符串,元组)变成列表</td>
</tr>
<tr>
<td>tuple()</td>
<td>将其他可迭代数据(字符串,列表)变成元组</td>
</tr>
<tr>
<td>set()</td>
<td>将其他可迭代数据(字符串,列表)变成集合</td>
</tr>
<tr>
<td>range(start,stop,step)</td>
<td>产生一个序列 [ start,stop), 步长为step</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="代码块">代码块</h2>
<blockquote>
<p>代码块就是出于同一个块里面的代码,他们要么一起执行,要么都不执行</p>
</blockquote>
<p>在python中 以缩进表示一个代码块, 相同缩进的且所有父代码都相同代码是处于同一个代码块的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= b:</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 代码块1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(b)  <span class="comment"># 代码块2</span></span><br><span class="line"><span class="comment">#虽然他们 有着相同的缩进,但是父代码不同</span></span><br></pre></td></tr></table></figure>
<h2 id="控制流语句">控制流语句</h2>
<h3 id="if">if</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> :</span><br><span class="line"><span class="keyword">elif</span> :</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="while">while</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true:</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h3 id="for">for</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个for 要特别注意,它和c++,java 这些里面的for不同,这里的for <strong>只能用来遍历后面的数据,里面用的是迭代器</strong></p>
</blockquote>
<h2 id="包和模块">包和模块</h2>
<h3 id="模块">模块</h3>
<p><a target="_blank" rel="noopener" href="http://xn--4gqvd7y.py">一个以.py</a> 结尾的文件就是一个模块,模块让你能够有逻辑地组织你的 Python 代码段，把相关的代码分配到一个模块里能让你的代码更好用，更易懂</p>
<p>模块需要注意的是 __ name__ 这个属性, 当我们执行的是这个模块的时候,它的值  是 __ main__ 如果是被导入的时候 那就是 模块名</p>
<h4 id="导入模块">导入模块</h4>
<p>import 模块名</p>
<p>import 用于导入某个模块</p>
<p>from  import 用于导入某个模块的某些东西</p>
<p>import  a.b as b = from a import b</p>
<p>上面都是绝对路径,还有相对路径的</p>
<p>import .a  导入当前模块下的a</p>
<p>import …a  导入上层模块下的a</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> r</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你导入模块的时候，Python解释器会把模块的代码编译成字节码，并放入 <code>__pycache__</code>文件夹中。这样以后再次运行的话，如果被调用的模块未发生改变，那就直接跳过编译这一步，直接去<code>__pycache__</code>文件夹中去运行相关的 *.pyc 文件，大大缩短了项目运行前的准备时间。</p>
<h3 id="包">包</h3>
<p>在早一点的 Python 版本（Python 3.3 之前）中，如果一个文件夹下有一个 <strong><code>__init__.py</code></strong> 文件，那我们就称之为包，英文名 Package。</p>
<p>在后来的 Python 版本（Python 3.3 开始）中，就没有这个要求了，<strong>只要是文件夹就可以当做包</strong>，我们称之为空间命名包，为做区分，我把上面那种包称之为 传统包。</p>
<p>今天这节里主要讲讲传统包的内容。</p>
<p>传统包里的 <code>__init__.py</code> 可以为空文件，但一定要有该文件，它是包的标志性文件，在需要情况下可以在里面进行一些包的初始化工作。</p>
<p>一个包里可以有多个模块，比如一个 demo 包包含<code>foo.py</code> 和 <code>bar.py</code>,那么在引用的时候就需要:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> demo.foo</span><br><span class="line"><span class="keyword">import</span> demo.bar</span><br></pre></td></tr></table></figure>
<h3 id="库">库</h3>
<p>Python 库是指一定功能的代码集合，通常认为他是一个完整的项目打包。</p>
<p>库-&gt;包-&gt;模块，是从大到小的层级关系！</p>
<ul>
<li>库：一个库可能由多个包和模块组成</li>
<li>包：一个包可能由多个模块组成</li>
<li>模块：一堆函数、类、变量的集合</li>
</ul>
<h3 id="小结">小结</h3>
<p>from module import * 这样的导入将会导入所有不以下划线开头的东西, 如果我们在模块里面声明了 __all__ 的话,则只会导入这里面包含的东西</p>
<h2 id="列表">列表</h2>
<p>列表就是一些数据的集合,他可以使用负数作为下标访问,也可以使用切片,s[a:b] = [s[a],…s[b-1]] ,这些切片都是浅拷贝出来的,字符串,元组也有这些特性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">s[-<span class="number">1</span>] <span class="comment"># 3</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">1</span>] <span class="comment"># [1]</span></span><br><span class="line">s[<span class="number">0</span>:-<span class="number">1</span>] <span class="comment">#[1,2]</span></span><br><span class="line">s[:] <span class="comment"># [1,2,3]</span></span><br><span class="line">s[<span class="number">0</span>:] <span class="comment"># [1,2,3]</span></span><br><span class="line">s[:<span class="number">1</span>] <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305185214450.png" alt="image-20230305185214450"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305185233509.png" alt="image-20230305185233509"></p>
<h2 id="元组">元组</h2>
<p>元组用()把数据包起来,而且如果数据只有一个的时候,我们必须以逗号结尾,不然python会以为我们是一个数据带了个括号而已</p>
<p>元组是Python中的不可变序列，它有以下几个方法：</p>
<ol>
<li><code>count(x)</code>：返回元组中出现x的次数。</li>
<li><code>index(x)</code>：返回元组中第一次出现x的位置。</li>
</ol>
<p>因为元组是不可变序列，所以它没有像列表那样的方法来添加、删除或修改元素</p>
<p>我们可以使用切片来做一些转化,比如翻转元组   a[::-1]</p>
<h2 id="集合">集合</h2>
<p>集合是一种无序、不重复的数据结构，集合中的元素必须是可哈希的。下面是一些常用的集合方法：</p>
<ol>
<li><code>add(elem)</code>：向集合中添加一个元素。</li>
<li><code>clear()</code>：清空集合中的所有元素。</li>
<li><code>copy()</code>：返回集合的一个浅拷贝。</li>
<li><code>difference(*others)</code>：返回集合与其他一个或多个集合的差集。</li>
<li><code>difference_update(*others)</code>：移除集合中与其他一个或多个集合重叠的元素。</li>
<li><code>discard(elem)</code>：移除集合中指定元素。如果元素不存在，不会发生任何变化。</li>
<li><code>intersection(*others)</code>：返回集合与其他一个或多个集合的交集。</li>
<li><code>intersection_update(*others)</code>：修改集合，使其只包含与其他一个或多个集合相同的元素。</li>
<li><code>isdisjoint(other)</code>：如果集合与另一个集合没有交集，返回True，否则返回False。</li>
<li><code>issubset(other)</code>：如果集合是另一个集合的子集，返回True，否则返回False。</li>
<li><code>issuperset(other)</code>：如果集合是另一个集合的超集，返回True，否则返回False。</li>
<li><code>pop()</code>：移除并返回集合中的任意一个元素。如果集合为空，会引发KeyError异常。</li>
<li><code>remove(elem)</code>：移除集合中指定元素。如果元素不存在，会引发KeyError异常。</li>
<li><code>symmetric_difference(other)</code>：返回集合与另一个集合的对称差集。</li>
<li><code>symmetric_difference_update(other)</code>：修改集合，使其只包含与另一个集合不相同的元素。</li>
<li><code>union(*others)</code>：返回集合与其他一个或多个集合的并集。</li>
<li><code>update(*others)</code>：将其他一个或多个集合中的元素添加到集合中。</li>
</ol>
<p>这些方法可以让我们方便地对集合进行操作，例如合并两个集合、求两个集合的交集或差集等。同时，集合也支持使用<code>len()</code>函数获取集合的大小，以及使用<code>in</code>和<code>not in</code>关键字来检查集合中是否包含某个元素。</p>
<h2 id="字典">字典</h2>
<p>一个键对应一个值,跟c++里面的map一样,字典不是连续摆放键值对的,因此无法像列表那样使用切片</p>
<p><strong>创建空字典的方式是使用 {}</strong></p>
<p>Python中的字典是一种无序的键值对数据结构，下面是一些常用的字典方法：</p>
<ol>
<li><code>clear()</code>：清空字典中的所有元素。</li>
<li><code>copy()</code>：返回字典的一个浅拷贝。</li>
<li><code>fromkeys(seq[, value])</code>：创建一个新字典，使用给定的序列作为键，可选的给定值作为值。</li>
<li><code>get(key[, default])</code>：返回字典中给定键的值。如果键不存在，则返回指定的默认值。</li>
<li><code>items()</code>：返回一个包含所有字典项的列表，每个元素是一个(key, value)的元组。</li>
<li><code>keys()</code>：返回一个包含所有字典键的列表。</li>
<li><code>pop(key[, default])</code>：如果键存在，则移除并返回指定键的值，否则返回指定的默认值。</li>
<li><code>popitem()</code>：移除并返回字典中的一项，以 (key, value) 的形式返回。如果字典为空，则引发 KeyError 异常。</li>
<li><code>setdefault(key[, default])</code>：如果键存在，则返回对应的值；如果不存在，则将键插入字典中，并返回给定的默认值（默认为 None）。</li>
<li><code>update([other])</code>：使用另一个字典或可迭代对象中的键值对更新字典。</li>
<li><code>values()</code>：返回一个包含所有字典值的列表。</li>
</ol>
<p>这些方法可以让我们方便地对字典进行操作，例如获取某个键的值、添加或删除键值对、获取字典中的所有键或值等。除此之外，字典也支持使用<code>len()</code>函数获取字典的大小，以及使用<code>in</code>和<code>not in</code>关键字来检查字典中是否包含某个键。</p>
<h3 id="in-字典和-in-keys-的区别">in 字典和 in keys()的区别</h3>
<p>对于字典来说，<code>in</code>运算符可以用来判断一个键（key）是否在字典中存在。当我们使用<code>in</code>运算符来检查一个键是否在字典中时，可以直接使用<code>in</code>后面跟上字典对象，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line">print(&#x27;a&#x27; in d)    # 输出 True</span><br><span class="line">print(&#x27;d&#x27; in d)    # 输出 False</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>in</code>后面跟上字典的<code>keys()</code>方法，来判断一个键是否在字典中存在，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bashCopy coded = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line">print(&#x27;a&#x27; in d.keys())    # 输出 True</span><br><span class="line">print(&#x27;d&#x27; in d.keys())    # 输出 False</span><br></pre></td></tr></table></figure>
<p>这两种方式本质上是一样的，都是在字典中查找指定的键，判断其是否存在。但是从效率上来看，<strong>直接使用<code>in</code>运算符来判断键是否存在更加高效</strong>，<strong>因为它会利用字典内部的哈希表（hash table）,也就是set集合,算法来快速查找键</strong>，而使用<code>keys()</code>方法会先创建一个键的列表，再进行查找，效率会相对低一些。</p>
<p>因此，<strong>如果只是判断一个键是否存在</strong>，建议直接使用<code>in</code>运算符；<strong>如果需要遍历字典的所有键，可以使用<code>keys()</code>方法获取所有的键</strong>，并进行遍历。</p>
<blockquote>
<p>如果是 in items() 的话和 in keys() 差别不大</p>
</blockquote>
<h2 id="字符串">字符串</h2>
<p>字符串可以用单引号,双引号,三引号包裹,前两个没有什么区别,第三个可以用来表示注释,也可以换行写字符串,对于那些有很多行的字符串,我们可以使用三引号包裹,如果字符串里面有引号的话,需要使用转义字符 \ 来转义,或者使用原始字符串的格式 r’’</p>
<p>Python字符串是一种不可变的序列类型，字符串对象有许多内置方法，下面列出一些常用的字符串方法：</p>
<ol>
<li><code>capitalize()</code>：将字符串的第一个字符转换为大写字母，其他字符转换为小写字母。</li>
<li><code>casefold()</code>：将字符串转换为小写并删除所有标点符号和空格，用于忽略大小写的比较。</li>
<li><code>center(width[, fillchar])</code>：返回一个指定宽度的字符串，原字符串居中，并使用指定的字符（默认为空格）在两侧进行填充。</li>
<li><code>count(sub[, start[, end]])</code>：<strong>返回指定子字符串在字符串中出现的次数</strong>。</li>
<li><code>endswith(suffix[, start[, end]])</code>：检查字符串是否以指定的后缀结尾，返回True或False。</li>
<li><code>find(sub[, start[, end]])</code>：<strong>在字符串中查找指定子字符串的第一次出现，返回索引值，未找到则返回-1</strong>。</li>
<li><code>index(sub[, start[, end]])</code>：在字符串中查找指定子字符串的第一次出现，返回索引值，未找到则引发ValueError异常。</li>
<li><code>isalnum()</code>：检查字符串是否只包含字母和数字，返回True或False。</li>
<li><code>isalpha()</code>：检查字符串是否只包含字母，返回True或False。</li>
<li><code>isdigit()</code>：检查字符串是否只包含数字，返回True或False。</li>
<li><code>islower()</code>：检查字符串中所有字母是否都是小写，返回True或False。</li>
<li><code>isspace()</code>：检查字符串是否只包含空格，返回True或False。</li>
<li><code>istitle()</code>：检查字符串中每个单词的首字母是否都是大写，返回True或False。</li>
<li><code>isupper()</code>：检查字符串中所有字母是否都是大写，返回True或False。</li>
<li><code>join(iterable)</code>：<strong>将可迭代对象中的所有字符串拼接成一个字符串，使用当前字符串作为分隔符</strong>。</li>
<li><code>lstrip([chars])</code>：返回去掉左侧指定字符（默认为空格）的字符串。</li>
<li><code>replace(old, new[, count])</code>：返回将指定旧子字符串替换为新子字符串的字符串，可指定替换次数。</li>
<li><code>rstrip([chars])</code>：返回去掉右侧指定字符（默认为空格）的字符串。</li>
<li><code>split([sep[, maxsplit]])</code>：<strong>将字符串以指定分隔符（默认为空格）分割成多个子字符串，并返回一个列表</strong>。</li>
<li><code>startswith(prefix[, start[, end]])</code>：检查字符串是否以指定的前缀开头，返回True或False。</li>
<li><code>strip([chars])</code>：返回去掉左右两侧指定字符（默认为空格）的字符串。</li>
<li><code>title()</code>：返回所有单词的首字母大写的字符串。</li>
<li><code>upper()</code>：将字符串中所有字母转换为大写。</li>
<li><code>lower()</code>：将字符串中所有字母转换为小写。</li>
</ol>
<h2 id="可变数据与不可变数据">可变数据与不可变数据</h2>
<p>在Python中，可变（mutable）<strong>对象指的是可以修改其内部状态的对象</strong>，例如列表、字典和集合等。而不<strong>可变（immutable）对象指的是不能修改其内部状态的对象</strong>，例如数字、字符串和元组等。</p>
<p>对于可变对象，我们可以通过修改对象的内部状态来改变对象本身，例如向列表中添加或删除元素、修改字典中的键值对等。而对于不可变对象，我们不能修改对象的内部状态，但是可以通过创建新的对象来代替原有对象，从而实现对象的修改。</p>
<p>需要注意的是，<strong>Python中的变量实际上是对象的引用（reference），而不是对象本身</strong>。当我们给一个变量赋值时，实际上是将变量指向一个对象的内存地址。如果这个对象是可变的，我们可以修改其内部状态，但是变量指向的对象仍然是同一个，即对象的内存地址没有改变。如果这个对象是不可变的，我们不能修改其内部状态，但是可以将变量指向一个新的对象，从而实现变量的修改。</p>
<h2 id="del语句">del语句</h2>
<p>在Python中，<code>del</code>是一个关键字，<strong>用于删除Python对象</strong>。以下是<code>del</code>的一些用法：</p>
<ol>
<li>
<p><strong>删除变量</strong>：你可以使用<code>del</code>来删除一个或多个变量。例如：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line"><span class="keyword">del</span> x, y</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>x</code>和<code>y</code>在<code>del</code>语句执行后将不再存在。</p>
</li>
<li>
<p><strong>删除列表元素</strong>：你可以使用<code>del</code>来删除列表中的一个或多个元素。例如：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，列表中的第二个元素（索引为1）将被删除，所以<code>list</code>现在是<code>['a', 'c', 'd', 'e']</code>。</p>
</li>
<li>
<p><strong>删除字典元素</strong>：你可以使用<code>del</code>来删除字典中的一个或多个元素。例如：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[<span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，字典中的键为<code>'b'</code>的元素将被删除，所以<code>dict</code>现在是<code>&#123;'a': 1, 'c': 3&#125;</code>。</p>
</li>
<li>
<p><strong>删除对象属性</strong>：你可以使用<code>del</code>来删除一个对象的属性。例如：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="keyword">del</span> obj.x</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>obj.x</code>在<code>del</code>语句执行后将不再存在。</p>
</li>
</ol>
<p>注意，<code>del</code>只是删除了名称和对象之间的引用，而不是删除对象本身。如果对象没有其他引用，它将在垃圾收集过程中被删除。</p>
<h2 id="多重赋值">多重赋值</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">9</span></span><br><span class="line">a,b = b,a</span><br><span class="line"></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a,b = s</span><br></pre></td></tr></table></figure>
<h2 id="copy模块">copy模块</h2>
<p>它包含了浅拷贝copy和深拷贝deepcopy两个函数</p>
<h2 id="关于缩进">关于缩进</h2>
<p>对于列表,元组这种数据定义的时候,缩进其实是没有用的,还有就是如果我们想把语句分成多行可以使用 \ 这个字符来续行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\</span></span><br><span class="line"><span class="string">world&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="漂亮打印pprint">漂亮打印pprint</h2>
<p>如果列表,元组,字典里面数据较多或者相互嵌套的话,那么使用print打印出来的就比较丑,这个时候我们可以使用pprint 模块</p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230304165050060.png" alt="image-20230304165050060"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230304165059827.png" alt="image-20230304165059827"></p>
<p>对比一下吧,而且我们还可以使用它的pformat将其变成字符串格式</p>
<h2 id="pass">pass</h2>
<p>在 Python3.x 的时候 pass 可以写或不写。</p>
<p>python2.x：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="comment"># 空函数在Python2.x版本中pass是必须的</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>python3.x</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="comment"># 在Python3.x的时候pass可以写或不写</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">args</span>):</span><br><span class="line">	<span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>默认返回None</p>
<h3 id="参数问题">参数问题</h3>
<p>个人把参数问题分为两类:</p>
<ul>
<li>定义的时候参数问题</li>
<li>传递的时候参数问题</li>
</ul>
<p>在定义的时候有这几种:</p>
<h4 id="必选参数">必选参数</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b</span>): <span class="comment"># 这样定义的参数就叫必选参数</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">func(<span class="number">10</span>,<span class="number">20</span>)  <span class="comment"># 这样传递的参数就是位置参数</span></span><br><span class="line">func(<span class="number">10</span>,b=<span class="number">30</span>) <span class="comment"># b =30 这样就是关键字参数</span></span><br></pre></td></tr></table></figure>
<h4 id="默认参数">默认参数</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b=<span class="number">10</span></span>):  <span class="comment"># 必须在必选参数后面</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="不定长参数">不定长参数</h4>
<p>超出的<strong>位置参数</strong>当成元组放入argv中,超出的 关键字参数放入kwd</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*argv,**kwd</span>):</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="特殊参数">特殊参数</h4>
<p>/ 和 *</p>
<p>/代表之前的参数只能用位置参数,* 代表之后的参数只能用关键字参数</p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305190550055.png" alt="image-20230305190550055"></p>
<p>要注意下面的规则:</p>
<ol>
<li>
<p><strong>传递参数的时候</strong>位置参数必须出现在关键字参数前面</p>
</li>
<li>
<p>定义函数的时候 , **kwd这种参数必须放在*argv这种参数后面,因为上一条规则,普通参数必须放在默认参数前面,这也就意味着, kwd一定是放在最后面了</p>
</li>
<li>
<p>定义的时候*argv这中参数可以放在必选参数前面，但是在调用时，必选参数必须要指定参数名来传入，否则会报错</p>
</li>
<li>
<p>不定长参数中的关键字参数不能跟函数定义参数名字相同,否则会冲突</p>
</li>
</ol>
<h3 id="参数解析">参数解析</h3>
<p>比如说我们一个函数可以传递位置参数,我们可以解析列表进去,如果一个函数可以传递关键字参数,我们可以解析字典进去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(a,b,c,d,sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">func(*[<span class="number">1</span>,<span class="number">2</span>],**&#123;<span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这样确实可以省点事</p>
<h2 id="lambda表达式">lambda表达式</h2>
<p>第一个位置是参数,第二个是表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y: x+y  <span class="comment"># 求和</span></span><br><span class="line"><span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y <span class="comment"># 比大小</span></span><br><span class="line">func = <span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">else</span> n * func(n-<span class="number">1</span>) <span class="comment"># 递归</span></span><br></pre></td></tr></table></figure>
<h2 id="高阶函数">高阶函数</h2>
<h3 id="map-映射">map(映射)</h3>
<p>它是将可迭代对象的每一个数据都分别放入函数中,然后将函数的返回值变成一个map(可迭代对象)返回</p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306155639537.png" alt="image-20230306155639537"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">map</span>(Iterator[_S], <span class="type">Generic</span>[_S]): <span class="comment"># 我们发现这个对象是可以迭代,也是生成器</span></span><br></pre></td></tr></table></figure>
<p>第一个参数是一个函数,第二个参数是可变长迭代对象,返回的是一个map对象,他也是可以迭代的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ll = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ll)) <span class="comment"># [1,4,9]</span></span><br><span class="line">ll = <span class="built_in">map</span>(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ll)) <span class="comment"># [5,7,9]</span></span><br></pre></td></tr></table></figure>
<h3 id="filter-过滤">filter(过滤)</h3>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160339383.png" alt="image-20230306160339383"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160405245.png" alt="image-20230306160405245"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ll)) <span class="comment"># [2]</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce-归约">reduce(归约)</h3>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160903441.png" alt="image-20230306160903441"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160818570.png" alt="image-20230306160818570"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">res = functools.reduce(<span class="keyword">lambda</span> x,y : x+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<h3 id="zip">zip</h3>
<p>将后面的每个可迭代对象迭代一次的值组成一个元组变成一个新的迭代器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">zip</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些函数的返回值都是一次性的,因为迭代器就是一次性的</p>
</blockquote>
<h3 id="compress">compress</h3>
<p>跟filter很像,但是呢它是根据后一个可迭代对象的真假决定第一个可迭代对象的值是否返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line"></span><br><span class="line">addresses = [</span><br><span class="line">    <span class="string">&#x27;5412 N CLARK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5148 N CLARK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5800 E 58TH&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2122 N CLARK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1060 W ADDISON&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;4801 N BROADWAY&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1039 W GRANVILLE&#x27;</span></span><br><span class="line">]</span><br><span class="line">counts = [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(compress(addresses,[n&gt;<span class="number">5</span> <span class="keyword">for</span> n <span class="keyword">in</span> counts])))</span><br></pre></td></tr></table></figure>
<h3 id="partial">partial</h3>
<p>如果我们需要某个函数的一些参数值固定,我们就可以使用这个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d</span><br><span class="line"></span><br><span class="line">three = partial(func,<span class="number">1</span>)</span><br><span class="line">two = partial(func,<span class="number">1</span>,d=<span class="number">4</span>)</span><br><span class="line">one = partial(func,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(three(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(two(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(one(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>其实这个也很简单,我们自己都能实现, 记录下给的函数与默认参数,然后返回一个可调用对象,那个可调用对象的call方法里面把默认参数给上去就可以了</p>
<h2 id="反射">反射</h2>
<p>这就是反射吧</p>
<ol>
<li>告诉别人，我是谁</li>
<li>告诉别人，我能做什么</li>
</ol>
<p>我们可以通过反射函数知道某个模块,某个类的一些信息</p>
<h3 id="dir">dir()</h3>
<p>返回传递给它的任何对象的属性名称,是一个排好序的列表</p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306162731170.png" alt="image-20230306162731170"></p>
<h3 id="type">type()</h3>
<p>返回类型</p>
<h3 id="hasattr">hasattr()</h3>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306162708633.png" alt="image-20230306162708633"></p>
<p>使用 dir() 函数会返回一个对象的属性列表。</p>
<p>但是，有时我们只想测试一个或多个属性是否存在。如果对象具有我们正在考虑的属性，那么通常希望只检索该属性。这个任务可以由 hasattr() 来完成.</p>
<h3 id="getattr">getattr()</h3>
<p>使用 hasattr 获知了对象拥有某个属性后，可以搭配 getattr() 函数来获取其属性值。</p>
<h3 id="id">id()</h3>
<p><strong>id()</strong> 函数返回对象的唯一标识符，标识符是一个整数。</p>
<h3 id="isinstance">isinstance()</h3>
<p>使用 isinstance() 函数可以确定一个对象是否是某个特定类型或定制类的实例。</p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306163223421.png" alt="image-20230306163223421"></p>
<h3 id="callable">callable()</h3>
<p>使用 callable 可以确定一个对象是否是可调用的，比如函数，类这些对象都是可以调用的对象。</p>
<h3 id="模块的魔法属性">模块的魔法属性</h3>
<ol>
<li><code>__name__</code>：模块的名称，可以使用<code>import</code>语句导入模块。如果当前模块时被运行的模块,那么他就是 __main__</li>
<li><code>__file__</code>：模块的文件名，可以用于获取模块所在的文件路径。</li>
<li><code>__doc__</code>：模块的文档字符串，可以使用<code>help()</code>函数查看模块的文档。</li>
<li><code>__all__</code>：模块的公开接口，用于限制模块中的变量、函数和类的访问范围。</li>
</ol>
<h3 id="类的魔法属性">类的魔法属性</h3>
<ol>
<li><code>__doc__</code>：类的文档字符串，可以使用<code>help()</code>函数查看类的文档。</li>
<li><code>__name__</code>：类的名称，可以用于获取类所在的模块名称。</li>
<li><code>__module__</code>：类所属的模块名称，可以用于获取类所在的模块路径。</li>
<li><code>__dict__</code>：类或实例的命名空间，包含类或实例的所有属性和方法。</li>
<li><code>__bases__</code>：类的基类元组，可以用于获取类的所有父类。</li>
<li><code>__subclasses__()</code>：类的所有直接子类的列表，可以用于获取类的所有子类。</li>
<li><code>__class__</code>：类的元类，用于控制类的创建和行为。</li>
</ol>
<h2 id="作用域-和-命名空间">作用域  和 命名空间</h2>
<p>分为 <strong>全局作用域 G</strong>,<strong>局部作用域 L</strong>,<strong>内建作用域B</strong>,<strong>闭包函数外的函数中E</strong></p>
<p>变量/函数 的查找顺序： L –&gt; E –&gt; G –&gt;B</p>
<p>每个作用域都包含一个<strong>命名空间</strong>,我们在使用变量的时候会先在当前命名空间里面找有没有这个变量,如果没有会向外层找,我们在给变量赋值的时候,如果没有使用<strong>global,nonlocal</strong> 这些关键字向外面引入变量,那么将会在自己的命名空间里面创建这么一个变量</p>
<h3 id="全局与局部">全局与局部</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = <span class="number">10</span>  <span class="comment"># 局部</span></span><br><span class="line">a = <span class="number">20</span>  <span class="comment"># 全局</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出20</span></span><br></pre></td></tr></table></figure>
<p>我们发现在func里面对a赋值其实是在局部作用域里面创建了一个a,而不是对全局的a做修改,那么如何在函数里面修改全局变量呢?</p>
<h3 id="global-关键字">global 关键字</h3>
<p>引入全局作用域里面的变量,如果不存在,当我们对这个变量赋值的时候,则会在全局作用于的命名空间里面定义这么一个变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">     b = <span class="number">10</span>  <span class="comment"># 不能再出现a的使用</span></span><br><span class="line">     <span class="keyword">global</span> a  <span class="comment"># 如果不使用这条语句,下面这条语句将变成 定义一个局部变量</span></span><br><span class="line">     a = <span class="number">10</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在函数里面,我们不能再<strong>global语句前面出现任何关于使用global指定变量的语句</strong></p>
</blockquote>
<p><strong>另外还需要注意的点,如果局部变量跟全局变量重名了,在局部变量声明前,是不能使用这个变量名字的,会被看做未定义</strong>,比如这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">   <span class="built_in">print</span>(a)  <span class="comment"># 这里会报错</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<h3 id="nonlocal关键字">nonlocal关键字</h3>
<p><strong>这个呢是用来引入外层命名空间里面的变量的,而不是全局</strong>,如果不存在,则会报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">nonlocal</span> a  </span><br><span class="line">        a = <span class="number">10</span></span><br><span class="line">     <span class="comment"># 这个其实也是E作用域相对于func2里面来说</span></span><br><span class="line">    a = <span class="number">20</span>   <span class="comment"># 如果不定义 那么在 func2 里面会报错</span></span><br><span class="line">    func2()</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 输出10</span></span><br><span class="line">    </span><br><span class="line">func1()</span><br></pre></td></tr></table></figure>
<h3 id="变量集合">变量集合</h3>
<p>在Python中，有两个内建函数，你可能用不到，但是需要掌握它们。</p>
<ul>
<li>globals() ：以dict的方式存储所有全局变量/函数</li>
<li>locals()：以dict的方式存储所有局部变量/函数</li>
</ul>
<h3 id="总结">总结</h3>
<p>如果我们仅仅使用变量而不赋值,那么会从当前作用域一层一层向外找,<strong>而且外层的声明语句必须在调用这个作用域的时候的前面</strong>,如果我们对变量进行赋值了, 如果没有特殊关键字修饰,那么就是当前作用域定义,如果有global修饰,那么就是修改全局作用域中的变量,或者是赋值(全局可以不存在这个变量),如果有nonlocal修饰,那么就是修改外面一层作用域的变量而且外层作用域必须先定义好这个变量</p>
<h2 id="闭包">闭包</h2>
<p>闭包（closure）在Python中是一个非常强大的功能，它涉及到函数和作用域的概念。</p>
<p>在Python中，一个函数可以定义在另一个函数内部，而内部函数可以访问外部函数中定义的变量。如果一个函数被定义在另一个函数的作用域内，并且引用了外部函数的变量，那么这个内部函数就被称为闭包。</p>
<p>以下是一个闭包的简单例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> inner_function</span><br><span class="line"></span><br><span class="line">closure = outer_function(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(closure(<span class="number">5</span>))  <span class="comment"># 输出 15</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>inner_function</code>就是一个闭包，因为它在<code>outer_function</code>的作用域内定义，并且引用了<code>outer_function</code>的参数<code>x</code>。当我们调用<code>outer_function(10)</code>时，它返回了<code>inner_function</code>函数对象，我们将这个对象赋值给了<code>closure</code>。这个对象记住了当时<code>outer_function</code>的参数<code>x</code>的值，所以即使<code>outer_function</code>已经结束，<code>closure</code>依然可以正确地计算<code>x + y</code>。</p>
<p>闭包有许多好处，以下是一些主要的优点：</p>
<ol>
<li>
<p><strong>数据隐藏</strong>：闭包可以用来提供数据隐藏和封装。由于闭包只能通过外部函数来访问其内部的状态，因此这些状态对于外部世界是隐藏的。</p>
</li>
<li>
<p><strong>函数工厂</strong>：你可以使用闭包来创建函数工厂，即根据参数生成特定功能的函数。在上面的例子中，<code>outer_function</code>就是一个函数工厂，根据传入的<code>x</code>参数生成了不同的<code>inner_function</code>。</p>
</li>
<li>
<p><strong>持久化状态</strong>：闭包可以记住并持久化包含它的作用域中的状态，即使包含它的函数已经结束。</p>
</li>
<li>
<p><strong>实现装饰器</strong>：在Python中，装饰器是一种高级功能，它允许你修改一个函数的行为，而不改变其源代码。装饰器的实现离不开闭包。</p>
</li>
</ol>
<p>总的来说，闭包是一种强大的工具，它可以让你编写出更加灵活和功能强大的代码。</p>
<h2 id="异常处理">异常处理</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	代码</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># 建议这样做,才能得到异常对象,如果不加 as 的话就是异常类</span></span><br><span class="line">	处理</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没发生异常执行</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    都会执行的代码</span><br><span class="line"><span class="keyword">raise</span>  <span class="comment"># 向上抛出异常</span></span><br></pre></td></tr></table></figure>
<h2 id="类和对象">类和对象</h2>
<p>感觉python的类和对象整的就很…,不知道咋说,感受一下吧,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:  <span class="comment"># 也可以class Car()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:   <span class="comment"># 初始化函数,也就是构造函数吧</span></span><br><span class="line">        self.price = <span class="number">10</span>  <span class="comment"># 这里必须用self.xxx 的格式,不然就不是这个对象的属性,还记的作用域跟命名空间么,但是这里不能用nonlocal</span></span><br><span class="line">        self.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    </span><br><span class="line">car1 = Car()</span><br><span class="line">car1.number = <span class="string">&#x27;10000&#x27;</span>   <span class="comment"># 这样的话 number 也属于 car1 的属性了</span></span><br><span class="line"><span class="built_in">print</span>(car1)</span><br></pre></td></tr></table></figure>
<p>当我们使用对象名.方法名的时候相当于 类名.方法名(对象名)  所以方法的第一个参数就是self,也可以取别的名字,当我们使用类名.方法名的时候,就相当于普通函数</p>
<h3 id="类属性">类属性</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    a = <span class="number">10</span>        </span><br><span class="line">user = User()</span><br><span class="line">user.a = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(user.a)</span><br><span class="line"><span class="built_in">print</span>(User.a)</span><br></pre></td></tr></table></figure>
<p>类属性存在与类的dict里面,  而不在实例的dict里面</p>
<h3 id="静态方法-类方法-实例方法">静态方法 类方法 实例方法</h3>
<p>静态方法和类方法必须使用@staticmethod   @classmethod  两个装饰器装饰才行,不然一律当做实例方法</p>
<p>这三个东西真的比较混乱,我们从调用上来理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">a</span>):</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">a</span>):</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    </span><br><span class="line">user = User()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例调用的时候,第一个参数传递的是自己</span></span><br><span class="line"><span class="comment"># 类名调用的时候就是普通函数调用</span></span><br><span class="line">user.test()  </span><br><span class="line">User.test(user)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种方式都是普通函数调用</span></span><br><span class="line">user.test1(<span class="number">1</span>)</span><br><span class="line">User.test1(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#两种方式都会将类当成第一个参数传进去</span></span><br><span class="line">user.test2()</span><br><span class="line">User.test2()</span><br></pre></td></tr></table></figure>
<p>三种方法声明要注意:  静态方法必须使用@staticmethod装饰,然后参数可以定义也可以不定义, 类方法必须使用@classmethod装饰,必须定义一个参数,这个参数就是类本身, 实例方法必须要定义一个参数(除非你不通过实例调用这个方法),这个参数就是实例本身</p>
<h3 id="私有变量和方法">私有变量和方法</h3>
<p>python中其实并没有提供这种功能,我们可以在类外调用任何变量和方法,这个只是一种规范罢了</p>
<h4 id="单前导下划线-var">单前导下划线 _var</h4>
<p>下划线前缀的含义是告知其他程序员：<strong>以单个下划线开头的变量或方法仅供内部使用</strong>。</p>
<h4 id="双前导下划线-var">双前导下划线 __var</h4>
<p>双下划线前缀会导致Python解释器<strong>重写属性名称</strong>，以避免子类中的命名冲突。</p>
<p>这也叫做<strong>名称修饰(name mangling)</strong> - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__name = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name  </span><br><span class="line"><span class="built_in">print</span>(User().__dict__)  <span class="comment">#&#123;&#x27;_User__name&#x27;: &#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(User.__dict__)  <span class="comment"># &#x27;_User__func&#x27;: &lt;function User.__func at 0x0000027AF68C2820&gt;</span></span><br><span class="line"><span class="built_in">print</span>(User().getage())  <span class="comment">#  这样是没有问题的</span></span><br><span class="line"><span class="built_in">print</span>(User().__name)  <span class="comment"># 这样会报错</span></span><br></pre></td></tr></table></figure>
<p>我们发现,名字被重写了,变成了 _类名变量名 的格式了,  我们在内部可以直接使用__name这样的形式,而在外部则不行,这样是不是也做到了一定上的私有化呢?</p>
<h3 id="继承">继承</h3>
<h4 id="单继承">单继承</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, weight</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 说: 我<span class="subst">&#123;self.age&#125;</span>岁。&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, weight, grade</span>):</span><br><span class="line">        <span class="comment"># 调用父类的实例化方法,这里必须带上self</span></span><br><span class="line">        People.__init__(self, name, age, weight)</span><br><span class="line">        self.grade = grade</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写父类的speak方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        People.speak(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我在读<span class="subst">&#123;self.grade&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>子类的属性和方法会重写父类的属性和方法</p>
<h3 id="多继承">多继承</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类(父类1, 父类2, 父类3...):</span><br></pre></td></tr></table></figure>
<p>如果多个父类中有相同的方法跟属性,访问的时候优先选择左边的</p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307171808747.png" alt="image-20230307171808747"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307171850020.png" alt="image-20230307171850020"></p>
<p>从左到右再深度选择</p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307171918818.png" alt="image-20230307171918818"></p>
<h3 id="super">super</h3>
<p>这个玩意也有很多坑,这个东西是用来调用父类的属性跟方法,但是如果父类中的方法也使用了super 调用方法的话,那就得注意了,<strong>它不是简简单单的调用父类的父类的方法,而是去_mro_中找下一个父类的顺序</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Base.__init__&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Base&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A,B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>)</span><br><span class="line">        self.hello()</span><br><span class="line">C()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Base.__init__</span></span><br><span class="line"><span class="comment"># B.__init__</span></span><br><span class="line"><span class="comment"># A.__init__</span></span><br><span class="line"><span class="comment"># C.__init__</span></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>按理来说是不是应该输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base.__init__</span><br><span class="line">A.__init__</span><br><span class="line">C.__init__</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>有没有发现多输出了B的,这就说明了如果父类方法也使用了super,那么下一个找的是mro链里面的方法</p>
<h3 id="property装饰器">property装饰器</h3>
<p>使用property去装饰类里面的一个方法的时候,会将其变成属性,当我们访问这个属性的时候就会调用里面的方法,(这个和vue的计算属性很像),如果直接对对象里面的其他属性赋值的话,那么就不能对其进行约束和检查,如果我们采用这个property修饰的属性去赋值,那么就能够实现检查和约束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,age</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将方法变成属性</span></span><br><span class="line"><span class="meta">    @property </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">    <span class="comment"># 检查值是否合法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self,age</span>):</span><br><span class="line">        <span class="keyword">if</span> age &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;age invalid&quot;</span>)</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">user = User(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 不合法,会抛出异常</span></span><br><span class="line">user = User(-<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>我们打印User.__dict__ 会输出 ‘age’: &lt;property object at 0x0000022BB2FEBF90&gt;  他变成了property的对象了</p>
<ul>
<li>当你读取属性值时，会进入被 <code>property</code> 装饰的函数。</li>
<li>当你对属性进行赋值时，会进入被 <code>@xx.setter</code> 装饰的函数。</li>
<li>两个装饰器，一定是 <code>@property</code> 在前面，而 <code>@xx.setter</code> 在后</li>
</ul>
<h3 id="类的魔法方法">类的魔法方法</h3>
<h4 id="构造方法">构造方法</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180058571.png" alt="image-20230307180058571"></p>
<h4 id="比较运算符">比较运算符</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180040473.png" alt="image-20230307180040473"></p>
<h4 id="一元操作符">一元操作符</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180154965.png" alt="image-20230307180154965"></p>
<h4 id="算数操作符">算数操作符</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180229621.png" alt="image-20230307180229621"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180258476.png" alt="image-20230307180258476"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180447324.png" alt="image-20230307180447324"></p>
<h4 id="增强赋值运算符">增强赋值运算符</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180538110.png" alt="image-20230307180538110"></p>
<h4 id="类型转换运算符">类型转换运算符</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180601912.png" alt="image-20230307180601912"></p>
<h4 id="类的表示">类的表示</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180721780.png" alt="image-20230307180721780"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180802074.png" alt="image-20230307180802074"></p>
<h4 id="访问控制">访问控制</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181404626.png" alt="image-20230307181404626"></p>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181131165.png" alt="image-20230307181131165"></p>
<h4 id="自定义序列">自定义序列</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181441101.png" alt="image-20230307181441101"></p>
<h4 id="反射">反射</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181630304.png" alt="image-20230307181630304"></p>
<h4 id="可调用对象">可调用对象</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181648695.png" alt="image-20230307181648695"></p>
<h4 id="上下文管理器">上下文管理器</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181712884.png" alt="image-20230307181712884"></p>
<h4 id="属性描述符">属性描述符</h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230308180510390.png" alt="image-20230308180510390"></p>
<blockquote>
<p>千万要注意,它一定要属于某个类的属性才能使用,是对象属性都不行,而且必须得是被对象或者类去用点.去访问或者修改才会触发set和get函数,使用dict 是没有用的</p>
</blockquote>
<p>这里很有必要讲一下这个东西,它能够限制和检查类里面的属性,跟__setattr__ 这样差不多,不过它相当于另外一种数据类型,而且如果使用__setattr__ 来做检查与限制会使得代码很冗余,而属性描述符就很简单了,看下面这个代码,基本上所有的分数都可以用这个描述符去限制,如果用__setattr__ 来的话,那岂不是每个分数都要判断一次,而且他可以做到每一次修改都能检查跟限制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,score</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__get__&quot;</span>,instance,owner,sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__set__&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;value invalid&quot;</span>)</span><br><span class="line">        self.score = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    math = Score(<span class="number">0</span>)</span><br><span class="line">    chinese = Score(<span class="number">0</span>)</span><br><span class="line">    english = Score(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, math, chinese, english</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.math = math</span><br><span class="line">        self.chinese = chinese</span><br><span class="line">        self.english = english</span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">&quot;dd&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">student.english</span><br></pre></td></tr></table></figure>
<p>这里要注意一下,我们在初始化函数里面明明是对实例属性赋值,但是由于属性描述符的原因,所以赋值变成对属性描述符修饰的属性赋值,而name则不受影响,所以我们打印student.__dict__的时候只能看到name</p>
<h4 id="数据描述符与非数据描述符">数据描述符与非数据描述符</h4>
<p>如果只有__get__  那么就是非数据描述符,如果有 __set__和__get__两个就是数据描述符,<strong>数据描述符和非数据描述符的区别在于：通过实例修改与类属性同名的描述符时,数据描述符是修改类属性,而非数据描述符则是修改或者创建这么一个实例属性</strong>。</p>
<h4 id="拷贝"><strong>拷贝</strong></h4>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181840529.png" alt="image-20230307181840529"></p>
<blockquote>
<p>这些魔法方法,其实都是为了方便或者提供一种好的办法给我们,我们可以通过这些魔法方法让我们的类能够支持更多的操作,比如加法,减法,支持内建函数这些,这些方法也不是必选的,你需要什么功能,你就去实现什么方法</p>
</blockquote>
<h3 id="元类">元类</h3>
<p><strong>类是用来创建对象的</strong>,<strong>元类是用来创建类的</strong>  因此类时元类的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User = <span class="built_in">type</span>(<span class="string">&quot;User&quot;</span>,(),&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;djm&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">user = User()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(user.name)</span><br><span class="line"><span class="built_in">print</span>(user.__class__) <span class="comment"># 打印出创建自己的类  User</span></span><br><span class="line"><span class="built_in">print</span>(User.__class__) <span class="comment"># 打印出创建自己的类  type</span></span><br></pre></td></tr></table></figure>
<p><strong>一个类要具有创建其他类的本领的话就必须继承type</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,*args,**kwd</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in test&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,*args,**kwd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(metaclass = test):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>上面我们说到,User类时test元类的一个实例,因此必然会走test的 new 方法,因此 会输出in test</p>
<p>既然这样我们是不是可以在创建类时候自定义一些属性,还有是在类在创建对象的时候往对象身上添加一些属性(利用 call函数)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,*args,**kwd</span>):</span><br><span class="line">        </span><br><span class="line">        obj =  <span class="built_in">super</span>().__new__(cls,*args,**kwd) </span><br><span class="line">        obj.age = <span class="number">10</span> <span class="comment"># 往User类上添加一些属性</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>) :</span><br><span class="line">        obj = <span class="built_in">super</span>().__call__(*args, **kwds)</span><br><span class="line">        obj.name = <span class="string">&#x27;hello world&#x27;</span>  <span class="comment"># 往User 实例对象上添加属性</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(metaclass = test):</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>所以这不就正符合框架的做法了么,毕竟通过元类我们能够动态的做很多事,而我们平常基本上是用不到元类的</p>
<h2 id="文件和io">文件和io</h2>
<p>python使用 open函数用来打开文件,默认情况下是 “rt” 模式,当然我们也能够自己指定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">iter</span>(f.read,<span class="string">&#x27;&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="迭代器">迭代器</h2>
<p>python的列表,元组,集合,字典这些容器都提供了迭代器,所以我们能够使用for in 来循环遍历,如果我们想让for in 来遍历我们自己的对象,我们需要在类中定义好 __iter__方法,并且它的返回值对象实现了 __next__方法 和   __iter__ 方法</p>
<blockquote>
<p>如果只是为了实现for in 的话  实现 __getitem__ 这个方法就行</p>
</blockquote>
<p>我们可以使用 iter 方法获得对象的迭代器,然后使用next遍历数据,当next 抛出StopIteration 异常就代表迭代结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">5</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">myclass = MyNumbers()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (myclass):</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">iter</span>(myclass)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>生成器的出现（Python 2.2 +），实现了延时计算，从而缓解了在大量数据下内存消耗过猛的问题。</p>
<h3 id="创建生成器">创建生成器</h3>
<p>第一种方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="comment"># [0,1,2,3,4]</span></span><br><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)) <span class="comment"># 注意和列表推导式的区别哦,这个返回的是一个生成器对象</span></span><br></pre></td></tr></table></figure>
<p>第二种方式</p>
<p>使用yield</p>
<p><code>yield</code> 是什么东西呢? 它相当于我们函数里的 return，但与 return 又有所不同。</p>
<ul>
<li>当一个函数运行到 yield 后，函数的运行会暂停，并且会把 yield 后的值返回出去。</li>
<li>若 yield 没有接任何值，则返回 None,是指这条语句返回None</li>
<li>yield 虽然返回了，但是函数并没有结束,等到下一次继续运行的时候会接着yield后面这里运行</li>
</ul>
<h3 id="生成器的使用">生成器的使用</h3>
<p>可以使用for in 循环跟 next函数,这个就跟迭代器的使用差不多了</p>
<p>还可以使用send方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;<span class="number">5</span>:</span><br><span class="line">        b = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        i += b</span><br><span class="line">    </span><br><span class="line">gen = func()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>send方法可以传递参数,作为 yield返回值,<strong>而且第一次传递参数必须是None</strong></p>
<p>当我们第一次执行send函数的时候,是直接停在了yield那里,那么这个返回值当然不是它设置,而是第二次继续send的时候将传递来的参数当做返回值, 就是这么设计的</p>
<h3 id="生成器异常">生成器异常</h3>
<p>当我们的函数执行完后,会自动抛出一个停止异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;前面&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;后面&quot;</span>)</span><br><span class="line">    </span><br><span class="line">gen = func(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">gen.send(<span class="literal">None</span>)</span><br><span class="line">gen.send(<span class="literal">None</span>) <span class="comment"># 这里会出一个异常,其实也是为了告诉别的使用者,生成器已经执行完了</span></span><br></pre></td></tr></table></figure>
<h3 id="生成器的函数返回值">生成器的函数返回值</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>,<span class="number">20</span></span><br><span class="line"></span><br><span class="line">gen = func()</span><br><span class="line"><span class="built_in">next</span>(gen)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">next</span>(gen)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> s:</span><br><span class="line">    <span class="built_in">print</span>(s.value)  <span class="comment"># (10,20)</span></span><br></pre></td></tr></table></figure>
<h3 id="生成器常用方法">生成器常用方法</h3>
<p>send(val) :  传递val作为 yield 语句的返回值</p>
<p>throw: 传递异常给生成器里面的yield语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;前面&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">lambda</span> x:<span class="number">1</span>/x</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;出现异常&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;后面&quot;</span>)</span><br><span class="line">    </span><br><span class="line">gen = func()</span><br><span class="line">div = gen.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(div(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(div(<span class="number">0</span>))  <span class="comment"># 这里会出现异常</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        gen.throw(Exception) <span class="comment"># 我们将异常交给生成器内部去处理</span></span><br><span class="line">    <span class="keyword">except</span> Exception:   <span class="comment"># 这里是为了处理stop那个异常</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="yield-from">yield from</h3>
<p>这个语句后面要跟一个可迭代对象(自然就包括生成器)  然后调用这个生成器就能一次遍历这个对象,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span>  a  <span class="comment">#等价于 for i in a: yield i</span></span><br><span class="line"></span><br><span class="line">f = func()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们来看一下yield from 的参考代码吧,看看它干了些什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">_i：子生成器，同时也是一个迭代器</span></span><br><span class="line"><span class="string">_y：子生成器生产的值</span></span><br><span class="line"><span class="string">_r：yield from 表达式最终的值</span></span><br><span class="line"><span class="string">_s：调用方通过send()发送的值</span></span><br><span class="line"><span class="string">_e：异常对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">_i = <span class="built_in">iter</span>(EXPR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = <span class="built_in">next</span>(_i)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.close</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()</span><br><span class="line">            <span class="keyword">raise</span> _e</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e:</span><br><span class="line">            _x = sys.exc_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.throw</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _y = _m(*_x)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    _y = <span class="built_in">next</span>(_i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                _r = _e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">RESULT = _r</span><br></pre></td></tr></table></figure>
<p>可以发现,它帮我们做了很多的异常处理</p>
<h2 id="上下文管理器">上下文管理器</h2>
<h3 id="什么是上下文管理器">什么是上下文管理器</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.file&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.readline()</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>上下文表达式：<code>with open('test.txt') as file:</code></p>
</li>
<li>
<p>上下文管理器：<code>open('test.txt')</code> 的返回值</p>
</li>
</ol>
<p>有没有发现,我们不需要自己去关闭文件</p>
<h3 id="有什么好处">有什么好处?</h3>
<ol>
<li>可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；</li>
<li>可以以一种更加优雅的方式，处理异常；</li>
</ol>
<h3 id="如何编写上下文管理器">如何编写上下文管理器</h3>
<p>需要定义__enter__,__exit__这两个方法,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;====enter=====&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===close resource connection===&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>   <span class="comment"># 这里如果不返回True的话,产生的异常就会接着往上面抛</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operator</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Resource() <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>运行之后,发现并没有报错</p>
<h3 id="使用contextlib">使用contextlib</h3>
<p>这个可以只使用一个函数就可以了,不需要重新多写一个类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_func</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="comment"># __enter__方法</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;open file:&#x27;</span>, file_name, <span class="string">&#x27;in __enter__&#x27;</span>)</span><br><span class="line">    file_handler = <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> file_handler</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="comment"># deal with exception</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the exception was thrown&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;close file:&#x27;</span>, file_name, <span class="string">&#x27;in __exit__&#x27;</span>)</span><br><span class="line">        file_handler.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open_func(<span class="string">&#x27;/Users/MING/mytest.txt&#x27;</span>) <span class="keyword">as</span> file_in:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_in:</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>
<h3 id="自己实现contextlib">自己实现contextlib</h3>
<p>我们要明白这个with 的用法, with 后面的表达式的返回值必须是上下文管理器,也就是必须有 exit 和 enter 两个方法的对象, 然后调用它的enter方法得到返回值,就是资源对象, 等到结束后就执行exit方法,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">context</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,func</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.func = func  <span class="comment"># 保存好函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwds = kwds</span><br><span class="line">        <span class="keyword">return</span>  self   <span class="comment"># 这里要返回自己,但是要保存好参数信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">       self.handler = self.func(*self.args,**self.kwds)  <span class="comment"># 执行函数得到生成器</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">next</span>(self.handler)  <span class="comment"># 返回资源对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> exc_type != <span class="literal">None</span>:</span><br><span class="line">                self.handler.throw(exc_type)  <span class="comment"># 如果有异常,就将异常交给用户去处理</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.handler.send() <span class="comment"># 没有异常就继续</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="meta">@context</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__enter__&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> func2</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;产生异常&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__exit__&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> func() <span class="keyword">as</span> f:</span><br><span class="line">    f(<span class="number">20</span>)</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="装饰器">装饰器</h2>
<p>装饰器就像代理一样,在不改变原先的代码的情况下,对其进行增强,这样我们就能够节省很多代码,减少耦合</p>
<h3 id="普通装饰器">普通装饰器</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testtime</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwd</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args,**kwd)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(func.__name__+<span class="string">&quot;用时&quot;</span>+<span class="built_in">str</span>((end-start)) +<span class="string">&quot;s&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用装饰器之后相当于这样一条语句   test = testtime(test)</span></span><br><span class="line"><span class="meta">@testtime  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;<span class="number">1000000000</span>:</span><br><span class="line">        j = j+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">test() <span class="comment"># 等价于 testtime(test)()</span></span><br></pre></td></tr></table></figure>
<h3 id="带参数的函数装饰器">带参数的函数装饰器</h3>
<p>上面这种普通的装饰器只能执行固定的逻辑,我们并不能对其传递参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delay</span>(<span class="params">ns</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper2</span>(<span class="params">*argv,**kwd</span>):</span><br><span class="line">            time.sleep(ns)</span><br><span class="line">            result = func(*argv,**kwd)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper2</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@delay(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayhello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">sayhello()   <span class="comment"># 等价于  delay(1)(sayhello)()</span></span><br><span class="line">delay(<span class="number">1</span>)(sayhello)()</span><br></pre></td></tr></table></figure>
<p>比如这个带参数的装饰器,我们可以给定延迟时间执行</p>
<h3 id="不带参数的类装饰器">不带参数的类装饰器</h3>
<p>上面这些都是函数装饰器,我们还可以用类来做装饰器,用类做装饰器必须实现两个方法,一个是__init__(用于传递被装饰函数)和 __call__(用来实现装饰逻辑)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testtime</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,func</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = self.func(*args,**kwds)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(self.func.__name__+<span class="string">&quot;用时&quot;</span>+<span class="built_in">str</span>((end-start)) +<span class="string">&quot;s&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@testtime</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;<span class="number">1000000</span>:</span><br><span class="line">        j = j+<span class="number">1</span></span><br><span class="line">test() <span class="comment"># testtime(test).__call__() == testtime(test)()</span></span><br></pre></td></tr></table></figure>
<h3 id="带参数的类装饰器">带参数的类装饰器</h3>
<p>这个与不带参数的类装饰器有很大的变化 __init__(用于传递参数)和 __call__(用来接收被装饰函数)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">delay</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ns</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ns = ns</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper2</span>(<span class="params">*argv,**kwd</span>):</span><br><span class="line">            time.sleep(self.ns)</span><br><span class="line">            result = func(*argv,**kwd)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper2</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">@delay(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayhello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">sayhello()   <span class="comment"># 等价于  delay(1).__call__(sayhello)() == delay(1)(sayhello)()</span></span><br><span class="line">delay(<span class="number">1</span>)(sayhello)()</span><br></pre></td></tr></table></figure>
<h3 id="其他装饰器">其他装饰器</h3>
<ul>
<li>类方法</li>
<li>实例方法</li>
<li>静态方法</li>
</ul>
<h3 id="总结">总结</h3>
<p>有没有发现其实就只有两种装饰器  一种带参数,一种不带参数   最终使用格式分别为 A§(B)() 和 A(B)()  A代表装饰器,P代表参数,B代表被装饰的东西(<strong>可以是类</strong>,也可以是函数)</p>
<p><strong>函数总是作为装饰器的返回值可调用对象的第一个参数</strong></p>
<p>我们需要明白一个东西,我们可以使用@装饰器 的方式  也可以直接使用 A = 装饰器(A) 这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(cls)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"><span class="meta">@test</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">A = test(A)</span><br></pre></td></tr></table></figure>
<p>我们来分析一下下面这个代码吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">func</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwds</span>):</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwds)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">info</span>):</span><br><span class="line">    <span class="built_in">print</span>(info)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> test1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test3</span>(<span class="params">info2</span>):</span><br><span class="line">    <span class="built_in">print</span>(info2)</span><br><span class="line">    <span class="keyword">return</span> test2(info2*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@test3(<span class="params"><span class="string">&quot;hello&quot;</span></span>) </span><span class="comment"># 首先执行 test3() 然后 执行 test2() 然后返回 test1函数,所以func一定是test1的参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="comment"># func = test3(&quot;hello&quot;)(func)</span></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>有了这个我们就可以写出可以带参数,也可以不带参数的装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger</span>(<span class="params">func = <span class="literal">None</span>, info=<span class="string">&quot;logger&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> func:logger(func,info)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwd</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;info&#125;</span>:<span class="subst">&#123;func.__name__&#125;</span>被执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwd)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@logger()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@logger(<span class="params">info=<span class="string">&quot;djm&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func1()  <span class="comment"># func1 和 func2 不同的区别在于  func1 直接执行wrapper函数  func2 还执行了 lambda函数</span></span><br><span class="line">func2()</span><br><span class="line">func3()</span><br></pre></td></tr></table></figure>
<h2 id="并发编程">并发编程</h2>
<h3 id="多线程的使用">多线程的使用</h3>
<p>创建多线程的两种方式</p>
<blockquote>
<p>两种方式各有千秋,第一个简单,第二个可以自定义很多内容</p>
</blockquote>
<ul>
<li>使用Thread 类 创建线程</li>
<li>继承Thead 类 重写run 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义线程函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>(<span class="params">name=<span class="string">&quot;Python&quot;</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, name)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程01，不指定参数</span></span><br><span class="line">thread_01 = Thread(target=target)</span><br><span class="line"><span class="comment"># 启动线程01</span></span><br><span class="line">thread_01.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程02，指定参数，注意逗号</span></span><br><span class="line">thread_02 = Thread(target=target, args=(<span class="string">&quot;MING&quot;</span>,))</span><br><span class="line"><span class="comment"># 启动线程02</span></span><br><span class="line">thread_02.start()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">type</span>=<span class="string">&quot;Python&quot;</span></span>):</span><br><span class="line">        <span class="comment"># 注意：super().__init__() 必须写</span></span><br><span class="line">        <span class="comment"># 且最好写在第一行</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.<span class="built_in">type</span>=<span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, self.<span class="built_in">type</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建线程01，不指定参数</span></span><br><span class="line">    thread_01 = MyThread()</span><br><span class="line">    <span class="comment"># 创建线程02，指定参数</span></span><br><span class="line">    thread_02 = MyThread(<span class="string">&quot;MING&quot;</span>)</span><br><span class="line"></span><br><span class="line">    thread_01.start()</span><br><span class="line">    thread_02.start()</span><br></pre></td></tr></table></figure>
<h3 id="锁机制">锁机制</h3>
<h4 id="互斥锁">互斥锁</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成锁对象，全局唯一</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取锁。未获取到会阻塞程序，直到获取到锁才会往下执行</span></span><br><span class="line">lock.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁，归还锁，其他人可以拿去用了</span></span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure>
<p>推荐使用 with lock</p>
<h4 id="可重入锁">可重入锁</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 生成可重入锁对象</span></span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=main)</span><br><span class="line">t1.start()</span><br></pre></td></tr></table></figure>
<h4 id="全局锁gil">全局锁GIL</h4>
<blockquote>
<p>在python中多个线程其实并不是并行,而是并发,交替运行</p>
</blockquote>
<p>什么是GIL呢？ &gt;任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<h3 id="线程通信">线程通信</h3>
<h4 id="event">Event</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置event，使得所有该event事件都处于待命状态</span></span><br><span class="line">event.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待接收event的指令，决定是否阻塞程序执行</span></span><br><span class="line">event.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送event指令，使所有设置该event事件的线程执行</span></span><br><span class="line">event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">event = Event()  </span><br><span class="line">rank = <span class="number">0</span></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">name</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> rank</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;name&#125;</span>,我已经准备好了&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待发出枪声</span></span><br><span class="line">    event.wait()</span><br><span class="line">    <span class="comment"># 开始竞争</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    rank += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;rank&#125;</span>名:<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    lock.release()</span><br><span class="line">    </span><br><span class="line">event.clear()</span><br><span class="line">runners = [Thread(target=run,args=[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[runner.start() <span class="keyword">for</span> runner <span class="keyword">in</span> runners]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;各就位&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始跑&quot;</span>)</span><br><span class="line">event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>
<p>上面这个代码是5名选手参加跑步比赛,用event来控制统一开始跑, lock来模拟速度,谁先抢到谁排名高</p>
<h4 id="condition">condition</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cond = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似lock.acquire() 抢占锁</span></span><br><span class="line">cond.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似lock.release() 释放锁</span></span><br><span class="line">cond.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待指定触发，同时会释放对锁的获取,直到被notify才重新竞争这个琐。必须得先拥有锁也就是acquire</span></span><br><span class="line">cond.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送指定，触发执行</span></span><br><span class="line">cond.notify()</span><br></pre></td></tr></table></figure>
<h4 id="queue">Queue</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="comment"># maxsize默认为0，不受限</span></span><br><span class="line"><span class="comment"># 一旦&gt;0，而消息数又达到限制，q.put()也将阻塞</span></span><br><span class="line">q = Queue(maxsize=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认阻塞程序，等待队列消息，可设置超时时间</span></span><br><span class="line">q.get(block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息：默认会阻塞程序至队列中有空闲位置放入数据</span></span><br><span class="line">q.put(item, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有的消息都被消费完</span></span><br><span class="line">q.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知队列任务处理已经完成，当所有任务都处理完成时，join() 阻塞将会解除</span></span><br><span class="line">q.task_done()</span><br></pre></td></tr></table></figure>
<h3 id="信息隔离">信息隔离</h3>
<p>就是每个线程来的时候,去找他们自己对应的字典信息,我简略的实现一下就知道了,每个线程都有一个自己的字典域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,currentThread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">local1</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, __name: <span class="built_in">str</span></span>) :</span><br><span class="line">      <span class="keyword">if</span> __name == <span class="string">&quot;__dict__&quot;</span>:</span><br><span class="line">         <span class="built_in">object</span>.__getattribute__(self,__name).setdefault(currentThread(),&#123;&#125;)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self,__name)[currentThread()]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> self.__dict__[__name]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, __name, __value</span>):</span><br><span class="line">      self.__dict__[__name] = __value</span><br><span class="line">      </span><br><span class="line">       </span><br><span class="line">n2 = local1()</span><br><span class="line">n2.name = <span class="string">&quot;main&quot;</span></span><br><span class="line">n2.t = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line">   n2.name = name</span><br><span class="line">   <span class="built_in">print</span>(n2.__dict__)</span><br><span class="line"></span><br><span class="line">[Thread(target=func,args=[<span class="string">&quot;thread&quot;</span>+<span class="built_in">str</span>(i)]).start() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n2.__dict__)</span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230312185501172.png" alt="image-20230312185501172"></p>
<h3 id="线程池">线程池</h3>
<p>在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，需要切换上下文环境，依然会造成cpu的大量开销。还有就是创建销毁线程也会消耗资源,为解决这个问题，线程池的概念被提出来了。预先创建好一个合理数量的线程池，让过来的任务立刻能够使用，就形成了线程池。</p>
<p>在Python3中，创建线程池是通过<code>concurrent.futures</code>函数库中的<code>ThreadPoolExecutor</code>类来实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">f&quot;<span class="subst">&#123;threading.get_ident()&#125;</span> : <span class="subst">&#123;i&#125;</span> &quot;</span> )</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    pool.submit(func)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用with 这样的方式更加优雅, submit 之后有一个返回值,  我们可以调用它的result 方法得到结果  但是这个方法是阻塞的,除非我们就是要现在得到结果,否则就将这个句柄保存起来,等到后面再得到结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">f&quot;<span class="subst">&#123;threading.get_ident()&#125;</span> : <span class="subst">&#123;i&#125;</span> &quot;</span> )</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> threading.get_ident()</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">5</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    handlers = [pool.submit(func) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    res = [handler.result() <span class="keyword">for</span> handler <span class="keyword">in</span> handlers]</span><br><span class="line">    dicts = &#123;&#125;</span><br><span class="line">    <span class="built_in">dict</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">        dicts[r] = dicts.get(r,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> dicts.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> 执行了 <span class="subst">&#123;v&#125;</span>的函数&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="异步io-asyncio框架">异步io asyncio框架</h3>
<h4 id="协程">协程</h4>
<p>怎么去理解协程呢, 拿线程去对比一下吧, 如果我们有一个网络请求,需要1s钟才能得到响应, 如果是线程的话,它会一直在那等着,如果是协程,我们可以让CPU去干别的事情</p>
<p>协程的实现就是依靠生成器</p>
<h4 id="创建一个协程">创建一个协程</h4>
<p>只要在函数声明的前面用async声明就行了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(request())  <span class="comment"># &lt;coroutine object request at 0x000001F8FAE163C0&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="概念">概念</h4>
<p>在了解<code>asyncio</code>的使用方法前，首先有必要先介绍一下，这几个贯穿始终的概念。</p>
<ul>
<li><code>event_loop 事件循环</code>：程序开启一个无限的循环，程序员会把一些函数（协程）注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。</li>
<li><code>coroutine 协程</code>：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</li>
<li><code>future 对象</code>： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别</li>
<li><code>task 任务</code>：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。Task 对象是 Future 的子类，它将 coroutine 和 Future 联系在一起，将 coroutine 封装成一个 Future 对象。</li>
<li><code>async/await 关键字</code>：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。其作用在一定程度上类似于yield。</li>
</ul>
<blockquote>
<p><strong>async里面不能使用 yield ,await 也必须在async里面使用</strong></p>
</blockquote>
<h4 id="协程的并发">协程的并发</h4>
<p>协程的并发其实是需要异步函数的支持,如果不是异步函数的话,协程是不能并发的,我们来对比一下</p>
<p>不支持异步的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 不支持异步</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = request()</span><br><span class="line">    task2 = request()</span><br><span class="line"></span><br><span class="line">    task1 = asyncio.create_task(task1)</span><br><span class="line">    task2 = asyncio.create_task(task2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">asyncio.run(main())</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;一共运行<span class="subst">&#123;end-start:<span class="number">.2</span>f&#125;</span>s&quot;</span>) <span class="comment"># 2s</span></span><br></pre></td></tr></table></figure>
<p>支持异步的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 这个是支持异步的</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = request()</span><br><span class="line">    task2 = request()</span><br><span class="line"></span><br><span class="line">    task1 = asyncio.create_task(task1)</span><br><span class="line">    task2 = asyncio.create_task(task2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">asyncio.run(main())</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;一共运行<span class="subst">&#123;end-start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)  <span class="comment"># 1s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="网络编程">网络编程</h2>
<h1>第二部分 自动化</h1>
<h2 id="正则表达式">正则表达式</h2>
<blockquote>
<p>关于什么是正则表达式,我已经在我的另外一篇博客里面介绍清楚了,这里只做关于python如何使用正则表达式的总结</p>
</blockquote>
<p>python的正则表达式的使用有两种:</p>
<p>第一种就是 直接使用 re 模块里面的函数 比如 re.search(pattern,string,flags) re.match() re.findall() …</p>
<p>第二种就是 使用re.compile(pattern,flags)  得到一个对象,然后调用这个对象的search(string),match findall 方法</p>
<p>第一种呢,方便我们一次性使用,第二种方便一个匹配模式多次使用</p>
<h3 id="search方法">search方法</h3>
<p>搜索第一个匹配的字符串,并且返回包含这个字符串的匹配对象</p>
<h3 id="match方法">match方法</h3>
<p>从开头开始匹配,如果没有匹配成功,则不会继续匹配</p>
<h3 id="findall方法">findall方法</h3>
<p><strong>返回全部匹配的字符串的所有分组(0分组除外,如果只有0分组的话就必须包含0分组)</strong>,并且都放在列表中返回</p>
<h3 id="finditer方法">finditer方法</h3>
<p>匹配所有字符串,而且<strong>我们可以迭代遍历所有的匹配对象</strong></p>
<p>四个方法总结一下吧:</p>
<p>如果我们只是想看某个字符串是否包含这个模式,我们可以使用search</p>
<p>如果我们要看从开头是否匹配,使用match</p>
<p>如果只需要得到所有匹配结果的分组,使用findall</p>
<p>如果要获得所有的匹配字符串,还要获得所有的匹配字符串的分组,使用finditer</p>
<h2 id="读写文件">读写文件</h2>
<h1>好用的功能</h1>
<h2 id="格式化字符串"><strong>格式化字符串</strong></h2>
<ol>
<li>
<p>通过字符串前加f/F  然后直接引用变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">s = <span class="string">f&#x27;i have <span class="subst">&#123;a:-<span class="number">3</span>&#125;</span> apples&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过字符串的format方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:-3&#125; apples&#x27;</span>.<span class="built_in">format</span>(<span class="number">10</span>)) <span class="comment"># 左对齐三位格式</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305204838893.png" alt="image-20230305204838893"></p>
</li>
</ol>
<h2 id="不一样的作用域">不一样的作用域</h2>
<p>在python中,貌似对这个代码块作用域不太敏感</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出10</span></span><br></pre></td></tr></table></figure>
<p>如果在c++和 java中,这个代码肯定会报错,我去,那这样也太爽了</p>
<h2 id="call-方法">__call__方法</h2>
<p>a.__call__ () == a()  这么一来,我感觉函数跟类其实也没有什么区别</p>
<h2 id="type返回值">type返回值</h2>
<p>type的返回值就是一个类,他也是一个对象,因此我们是不是可以根据某个数据直接造出跟它一样类型的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getobj</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(obj)()</span><br><span class="line"><span class="built_in">print</span>(getobj(<span class="number">111</span>))</span><br><span class="line"><span class="built_in">print</span>(getobj(<span class="string">&quot;111&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(getobj([]))</span><br><span class="line"><span class="built_in">print</span>(getobj(&#123;&#125;))</span><br></pre></td></tr></table></figure>
<h2 id="切片">切片</h2>
<p>对于列表,元组,字符串这种,我们都可以使用切片来获得他们的子序列,  而且切片是可以越界的, 只会返回包含的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">print(a[1:10:1]) # [2,3]</span><br></pre></td></tr></table></figure>
<h1>额外补充</h1>
<h2 id="可变对象与不可变对象">可变对象与不可变对象</h2>
<p>我们可以通过id()得到一个整数值,它代表唯一的一个对象,我们也可以把它理解成地址</p>
<p>可变对象就是我们可以修改对象里面的内容,不可变对象是不可以修改里面的内容的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变对象</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">l += [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变对象</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 2775197888320  </span></span><br><span class="line"><span class="comment"># 2775197888320</span></span><br><span class="line"><span class="comment"># 140721313420960</span></span><br><span class="line"><span class="comment"># 140721313420992</span></span><br></pre></td></tr></table></figure>
<p>l += [10] 其实调用的是 __add__ 方法,它里面只是将10添加进去然后返回自己,所以地址值肯定没有变,而 a += 1 是返回了一个新的对象,所以地址值肯定变了, 所以对于这个所谓的可变对象与不可变对象,只是我们取决于我们在这些方法里面返回什么罢了,还有就是不可变对象可以通过 __setattr__里面抛出异常禁止我们设置值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.score = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, __name: <span class="built_in">str</span>, __value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;不允许操作&quot;</span>)</span><br><span class="line">s = Score()</span><br><span class="line">s.score = <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="对象属性访问和创建的规则">对象属性访问和创建的规则</h2>
<ul>
<li>
<p>当我们对一个实例属性进行访问时，Python 会按 <code>obj.__dict__</code> → <code>type(obj).__dict__</code> → <code>type(obj)的父类.__dict__</code> 顺序进行查找</p>
</li>
<li>
<p>当我们对一个实例属性,<strong>跟类属性不重名,或者类属性不是一个数据描述符</strong>,进行赋值的时候,如果obj.__dict__ 里面不存在,那么就创建,如果存在则修改</p>
</li>
<li>
<p>当我们对一个实例属性,<strong>跟类属性重名,而且类属性是一个数据描述符</strong>,进行赋值的时候, 一定是按照这个顺序<code>type(obj).__dict__</code> → <code>type(obj)的父类.__dict__</code> 去修改数据</p>
</li>
</ul>
<h2 id="property实现原理">property实现原理</h2>
<p>装饰器  +  属性描述符</p>
<p>我们好好想想这三个东西的功能:  property是将方法当成属性访问或者赋值,而且只要一访问就会执行这个方法并且得到返回值, 装饰器,能够增强函数的功能,  <strong>把函数当做参数传递到装饰器里面</strong>,属性描述符  当通过类或者实例点.属性名字的时候就会执行里面的 get set 方法</p>
<p>如果我们设计一个装饰器类,在init方法中保存修饰函数,它又正好是属性描述符,在get 和 set 方法里面执行对应的函数,用这个装饰器去修饰方法,那是不是就做到了通过访问属性名就能代替方法了</p>
<p>先看一个简单的例子吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testfunc</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,func</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.func(instance)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @testfunc</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">                </span><br><span class="line">t = test()   </span><br><span class="line"><span class="built_in">print</span>(t.age)  <span class="comment"># 输出18</span></span><br></pre></td></tr></table></figure>
<p>通过类装饰器testfunc 保存好age 函数,而且这个属性age也变成了testfunc类型,所以age是属性(非数据)描述符,所以当我们访问age这个属性的时候,就会调用get方法,而且还会传递实例对象和类对象过去,我们正好利用实例对象执行这个方法得到数据返回</p>
<p>这里我们只实现了get方法,那要是要设置set方法呢? 那就必须在test里面重载一个age方法,而且必须使用原先的age修饰器对象重新建一个新的对象,把set 和 get 方法都保存好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testfunc</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,get = <span class="literal">None</span>,<span class="built_in">set</span> = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.get = get</span><br><span class="line">        self.<span class="built_in">set</span> = <span class="built_in">set</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get(instance)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">set</span>(instance,value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setter</span>(<span class="params">self,<span class="built_in">set</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in setter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> testfunc(self.get, <span class="built_in">set</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @testfunc</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">    <span class="built_in">print</span>(age) </span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self,_age</span>):</span><br><span class="line">        self._age = _age</span><br><span class="line">    <span class="built_in">print</span>(age)   </span><br><span class="line">t = test()  </span><br><span class="line">t.age = <span class="number">28</span> </span><br><span class="line"><span class="built_in">print</span>(t.age)  <span class="comment"># 输出28</span></span><br></pre></td></tr></table></figure>
<p>在 test 类中 我们 打印了两次 age修饰器对象,发现两个是不一样的,但是最终又只有一个age对象存在类中,所以我们必须用原先的装饰器对象创建一个新的装饰器对象,这样才能把所有的 get set 方法 保存下来</p>
<h2 id="所有实例共享数据描述符">所有实例共享数据描述符</h2>
<p>先看看下面这种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,score</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;value invalid&quot;</span>)</span><br><span class="line">        self.score = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    score = Score(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,score</span>):</span><br><span class="line">       self.score = score</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">60</span>)</span><br><span class="line">student2 = Student(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(student.score)  <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span>(student2.score) <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>
<p>我们惊奇的发现student 与 student2的 值居然一样了,这种数据描述符是有问题的,我们需要修改get 和 set方法,让他们返回和各个实例的属性值(但是这不意味着当我们通过实例访问与类同名的实例属性的时候就是直接访问它,其实还是访问的 类的dict,只不过我们根据不同实例返回不同值罢了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;value invalid&quot;</span>)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    math = Score(<span class="string">&quot;math&quot;</span>)</span><br><span class="line">    chinese = Score(<span class="string">&quot;chinese&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,math,chinese</span>):</span><br><span class="line">       self.math = math</span><br><span class="line">       self.chinese = chinese</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">60</span>,<span class="number">60</span>)</span><br><span class="line">student2 = Student(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(student.math,student.chinese) <span class="comment"># 60 60</span></span><br><span class="line"><span class="built_in">print</span>(student2.math,student2.chinese) <span class="comment"># 100 100</span></span><br></pre></td></tr></table></figure>
<p>这样就可以啦,当我们进入Score 的 get 和 set 方法的时候,我们返回他们自己对应的属性,记得一定要用 dict 不要直接 .  因为使用 dict 不会触发 get 和 set 方法</p>
<h2 id="类装饰器注意点">类装饰器注意点</h2>
<p>在使用<strong>类装饰器</strong>修饰<strong>类方法</strong>时候,我们还必须得实现__get__ 这个方法,这是因为类方法属于一个属性,当我们通过类或者对象通过点去调用它的时候,会走__get__ 这个函数得到返回值再执行,所以我们的通过对象调用方法不需要再传递self,是因为function的__get__帮我们传递了,因此我们也需要自己在类修饰器的__get__里面传递self,  而<strong>函数装饰器我们就不需要去管这件事</strong></p>
<h2 id="多个装饰器需要注意的点">多个装饰器需要注意的点</h2>
<p>多个装饰器最需要注意的点是 后一个装饰器返回的东西到底是什么,是一个函数还是一个对象还是一个属性描述符,函数和可调用对象调用起来需要几个参数, 如果是一个属性描述符而且我们需要他的get方法被调用的话则必须位于第一个装饰器,所以像@staticmethod 和 @ classmethod 这些就必须放在最前面</p>
<h2 id="getattribute-和-getattr的区别">getattribute 和 getattr的区别</h2>
<p><strong>getattribute 对任何属性的获取都会走这个方法</strong>,  如果我们没有重写这个方法,  默认会调用object.__getattribute__这个方法,如果找到了访问的属性就会返回,如果没有找到就会调用getattr方法, 如果都没有找到就会报错</p>
<h2 id="线程池的实现">线程池的实现</h2>
<h2 id="设置清华源">设置清华源</h2>
<h3 id="临时使用">临时使用</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure>
<h3 id="设为默认">设为默认</h3>
<p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip</span><br></pre></td></tr></table></figure>
<h1>答疑解惑</h1>
<h2 id="为什么类没有实现call方法却可以被调用-生成对象">为什么类没有实现call方法却可以被调用()生成对象</h2>
<p>哈哈哈,这里确实是一个迷惑点,  其实类也是一个对象,它是元类的对象, 一个对象能不能像方法那样被调用,是要看创建它的类是否具有call方法, 所以我们在类中有没有声明的call方法跟类能不能创建对象没有任何关系,而跟它创建的对象能不能被调用才有关系,  真正跟类能不能调用是跟元类中有没有call方法有关系**,type 是所有类的父类**,而它具有call 方法,所以所有的类一定能被调用</p>
<h2 id="实例对象属性的访问流程与赋值流程">实例对象属性的访问流程与赋值流程</h2>
<h3 id="默认访问流程-没有重写getattribute方法">默认访问流程(没有重写getattribute方法)</h3>
<ol>
<li>调用object.<code>__getattribute__</code>方法。</li>
<li>在类对象的<code>__dict__</code>中查找属性,如果是数据描述符,就调用它的get方法得到返回值返回,如果不是数据描述符就继续</li>
<li>在实例对象的<code>__dict__</code>中查找属性。<strong>如果找到了就返回这个值,没找到就继续往下走</strong></li>
<li>在类对象的<code>__dict__</code>中查找属性。<strong>处理方法、类变量和非数据描述符</strong></li>
<li>调用<code>__getattr__</code>方法 (<strong>这个方法一般需要我们重写,如果没有重写就不会调用,所以这个方法只有当属性找不到的时候才会被调用</strong>)</li>
<li>如果上述步骤都没有找到,抛出<code>AttributeError</code>异常。</li>
</ol>
<h3 id="默认赋值流程-没有重写setter方法">默认赋值流程(没有重写setter方法)</h3>
<ol>
<li>调用object.<code>__setattr__</code>方法。</li>
<li>在类对象的<code>__dict__</code>中查找属性。如果找到一个属性而且是数据描述符(具有get和set方法,其实只有set方法也可以,但是只要set方法没有意义),就会调用这个属性set方法并且将值传递给他, 如果没有找到属性,或者这个属性不具有set方法,那么就会往下走</li>
<li>将属性赋值到实例对象的<code>__dict__</code>。</li>
</ol>
<p><strong>这里我们就能解释数据描述符了, 为什么我们在init方法的时候对一个数据描述符赋值不会赋值到自己的dict里面,而是调用了类属性的set方法</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://djmnb.github.io">戴晶明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://djmnb.github.io/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/">https://djmnb.github.io/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://djmnb.github.io" target="_blank">戴晶明的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9C%80%E8%A6%81%E5%A4%8D%E4%B9%A0/">需要复习</a><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"><div class="social-share" data-image="/img/site/touxiang.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" title="python实用技巧"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python实用技巧</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/03/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/markdown%E8%AF%AD%E6%B3%95/" title="markdown语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">markdown语法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" title="python实用技巧"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">python实用技巧</div></div></a></div><div><a href="/2023/06/12/C%E5%92%8CC++/MFC/" title="MFC学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">MFC学习</div></div></a></div><div><a href="/2023/06/22/C%E5%92%8CC++/c++/" title="c++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-22</div><div class="title">c++</div></div></a></div><div><a href="/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/" title="c语言学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">c语言学习</div></div></a></div><div><a href="/2023/06/27/English/%E8%AF%AD%E6%B3%95/" title="考研英语语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-27</div><div class="title">考研英语语法</div></div></a></div><div><a href="/2022/11/25/git/git%E6%80%BB%E7%BB%93/" title="git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">git</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/site/touxiang.gif" onerror="this.onerror=null;this.src='/404.html'" alt="avatar"/></div><div class="author-info__name">戴晶明</div><div class="author-info__description">不积跬步,无以至千里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="/img/site/weixin.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="/img/site/qq.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">第一部分 python 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">基本运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">算数运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">特殊运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">常用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.5.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.6.</span> <span class="toc-text">控制流语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">2.6.1.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while"><span class="toc-number">2.6.2.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">2.6.3.</span> <span class="toc-text">for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">2.7.</span> <span class="toc-text">包和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">2.7.1.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">导入模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">2.7.2.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93"><span class="toc-number">2.7.3.</span> <span class="toc-text">库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.7.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">2.8.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">2.9.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.10.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">2.11.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#in-%E5%AD%97%E5%85%B8%E5%92%8C-in-keys-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.1.</span> <span class="toc-text">in 字典和 in keys()的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.12.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE"><span class="toc-number">2.13.</span> <span class="toc-text">可变数据与不可变数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#del%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.14.</span> <span class="toc-text">del语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC"><span class="toc-number">2.15.</span> <span class="toc-text">多重赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy%E6%A8%A1%E5%9D%97"><span class="toc-number">2.16.</span> <span class="toc-text">copy模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BC%A9%E8%BF%9B"><span class="toc-number">2.17.</span> <span class="toc-text">关于缩进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%82%E4%BA%AE%E6%89%93%E5%8D%B0pprint"><span class="toc-number">2.18.</span> <span class="toc-text">漂亮打印pprint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pass"><span class="toc-number">2.19.</span> <span class="toc-text">pass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.20.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.20.1.</span> <span class="toc-text">参数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">2.20.1.1.</span> <span class="toc-text">必选参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">2.20.1.2.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">2.20.1.3.</span> <span class="toc-text">不定长参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0"><span class="toc-number">2.20.1.4.</span> <span class="toc-text">特殊参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">2.20.2.</span> <span class="toc-text">参数解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.21.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">2.22.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E6%98%A0%E5%B0%84"><span class="toc-number">2.22.1.</span> <span class="toc-text">map(映射)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter-%E8%BF%87%E6%BB%A4"><span class="toc-number">2.22.2.</span> <span class="toc-text">filter(过滤)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce-%E5%BD%92%E7%BA%A6"><span class="toc-number">2.22.3.</span> <span class="toc-text">reduce(归约)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip"><span class="toc-number">2.22.4.</span> <span class="toc-text">zip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compress"><span class="toc-number">2.22.5.</span> <span class="toc-text">compress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial"><span class="toc-number">2.22.6.</span> <span class="toc-text">partial</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">2.23.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dir"><span class="toc-number">2.23.1.</span> <span class="toc-text">dir()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type"><span class="toc-number">2.23.2.</span> <span class="toc-text">type()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hasattr"><span class="toc-number">2.23.3.</span> <span class="toc-text">hasattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getattr"><span class="toc-number">2.23.4.</span> <span class="toc-text">getattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id"><span class="toc-number">2.23.5.</span> <span class="toc-text">id()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isinstance"><span class="toc-number">2.23.6.</span> <span class="toc-text">isinstance()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#callable"><span class="toc-number">2.23.7.</span> <span class="toc-text">callable()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E9%AD%94%E6%B3%95%E5%B1%9E%E6%80%A7"><span class="toc-number">2.23.8.</span> <span class="toc-text">模块的魔法属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%AD%94%E6%B3%95%E5%B1%9E%E6%80%A7"><span class="toc-number">2.23.9.</span> <span class="toc-text">类的魔法属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%92%8C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.24.</span> <span class="toc-text">作用域  和 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%B8%8E%E5%B1%80%E9%83%A8"><span class="toc-number">2.24.1.</span> <span class="toc-text">全局与局部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#global-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.24.2.</span> <span class="toc-text">global 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nonlocal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.24.3.</span> <span class="toc-text">nonlocal关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%9B%86%E5%90%88"><span class="toc-number">2.24.4.</span> <span class="toc-text">变量集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.24.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">2.25.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.26.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.27.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">2.27.1.</span> <span class="toc-text">类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E7%B1%BB%E6%96%B9%E6%B3%95-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.27.2.</span> <span class="toc-text">静态方法 类方法 实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.27.3.</span> <span class="toc-text">私有变量和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%89%8D%E5%AF%BC%E4%B8%8B%E5%88%92%E7%BA%BF-var"><span class="toc-number">2.27.3.1.</span> <span class="toc-text">单前导下划线 _var</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%89%8D%E5%AF%BC%E4%B8%8B%E5%88%92%E7%BA%BF-var"><span class="toc-number">2.27.3.2.</span> <span class="toc-text">双前导下划线 __var</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.27.4.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="toc-number">2.27.4.1.</span> <span class="toc-text">单继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.27.5.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">2.27.6.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.27.7.</span> <span class="toc-text">property装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.27.8.</span> <span class="toc-text">类的魔法方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.27.8.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.27.8.2.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.27.8.3.</span> <span class="toc-text">一元操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.27.8.4.</span> <span class="toc-text">算数操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.27.8.5.</span> <span class="toc-text">增强赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.27.8.6.</span> <span class="toc-text">类型转换运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.27.8.7.</span> <span class="toc-text">类的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">2.27.8.8.</span> <span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">2.27.8.9.</span> <span class="toc-text">自定义序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">2.27.8.10.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.27.8.11.</span> <span class="toc-text">可调用对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.27.8.12.</span> <span class="toc-text">上下文管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.27.8.13.</span> <span class="toc-text">属性描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%9D%9E%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.27.8.14.</span> <span class="toc-text">数据描述符与非数据描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.27.8.15.</span> <span class="toc-text">拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B1%BB"><span class="toc-number">2.27.9.</span> <span class="toc-text">元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8Cio"><span class="toc-number">2.28.</span> <span class="toc-text">文件和io</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.29.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">2.30.</span> <span class="toc-text">生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">2.30.1.</span> <span class="toc-text">创建生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.30.2.</span> <span class="toc-text">生成器的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%BC%82%E5%B8%B8"><span class="toc-number">2.30.3.</span> <span class="toc-text">生成器异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.30.4.</span> <span class="toc-text">生成器的函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.30.5.</span> <span class="toc-text">生成器常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield-from"><span class="toc-number">2.30.6.</span> <span class="toc-text">yield from</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.31.</span> <span class="toc-text">上下文管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.31.1.</span> <span class="toc-text">什么是上下文管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">2.31.2.</span> <span class="toc-text">有什么好处?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.31.3.</span> <span class="toc-text">如何编写上下文管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8contextlib"><span class="toc-number">2.31.4.</span> <span class="toc-text">使用contextlib</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0contextlib"><span class="toc-number">2.31.5.</span> <span class="toc-text">自己实现contextlib</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.32.</span> <span class="toc-text">装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.32.1.</span> <span class="toc-text">普通装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.32.2.</span> <span class="toc-text">带参数的函数装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.32.3.</span> <span class="toc-text">不带参数的类装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.32.4.</span> <span class="toc-text">带参数的类装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.32.5.</span> <span class="toc-text">其他装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.32.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">2.33.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.33.1.</span> <span class="toc-text">多线程的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">2.33.2.</span> <span class="toc-text">锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">2.33.2.1.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">2.33.2.2.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81gil"><span class="toc-number">2.33.2.3.</span> <span class="toc-text">全局锁GIL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.33.3.</span> <span class="toc-text">线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#event"><span class="toc-number">2.33.3.1.</span> <span class="toc-text">Event</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#condition"><span class="toc-number">2.33.3.2.</span> <span class="toc-text">condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue"><span class="toc-number">2.33.3.3.</span> <span class="toc-text">Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E9%9A%94%E7%A6%BB"><span class="toc-number">2.33.4.</span> <span class="toc-text">信息隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.33.5.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5io-asyncio%E6%A1%86%E6%9E%B6"><span class="toc-number">2.33.6.</span> <span class="toc-text">异步io asyncio框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.33.6.1.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.33.6.2.</span> <span class="toc-text">创建一个协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.33.6.3.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="toc-number">2.33.6.4.</span> <span class="toc-text">协程的并发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.34.</span> <span class="toc-text">网络编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">第二部分 自动化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#search%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">search方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#match%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">match方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findall%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">findall方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finditer%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.</span> <span class="toc-text">finditer方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">读写文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">好用的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.1.</span> <span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.2.</span> <span class="toc-text">不一样的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">__call__方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.4.</span> <span class="toc-text">type返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">4.5.</span> <span class="toc-text">切片</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">额外补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">可变对象与不可变对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E5%88%9B%E5%BB%BA%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">对象属性访问和创建的规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">property实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">所有实例共享数据描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">5.5.</span> <span class="toc-text">类装饰器注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">5.6.</span> <span class="toc-text">多个装饰器需要注意的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getattribute-%E5%92%8C-getattr%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.</span> <span class="toc-text">getattribute 和 getattr的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.8.</span> <span class="toc-text">线程池的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B8%85%E5%8D%8E%E6%BA%90"><span class="toc-number">5.9.</span> <span class="toc-text">设置清华源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">5.9.1.</span> <span class="toc-text">临时使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E4%B8%BA%E9%BB%98%E8%AE%A4"><span class="toc-number">5.9.2.</span> <span class="toc-text">设为默认</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">答疑解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0call%E6%96%B9%E6%B3%95%E5%8D%B4%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%B0%83%E7%94%A8-%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">为什么类没有实现call方法却可以被调用()生成对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%B5%81%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">实例对象属性的访问流程与赋值流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%86%99getattribute%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">默认访问流程(没有重写getattribute方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%B5%8B%E5%80%BC%E6%B5%81%E7%A8%8B-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%86%99setter%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">默认赋值流程(没有重写setter方法)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/" title="目标检测领域的经典模型">目标检测领域的经典模型</a><time datetime="2024-12-10T16:00:00.000Z" title="发表于 2024-12-11 00:00:00">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/29/python/yolo%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="yolo框架学习">yolo框架学习</a><time datetime="2024-11-28T16:00:00.000Z" title="发表于 2024-11-29 00:00:00">2024-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/12/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95%E8%AE%BA/" title="论文阅读方法论">论文阅读方法论</a><time datetime="2024-11-11T16:00:00.000Z" title="发表于 2024-11-12 00:00:00">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/01/python/pytorch/" title="pytorch学习">pytorch学习</a><time datetime="2024-10-31T16:00:00.000Z" title="发表于 2024-11-01 00:00:00">2024-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/30/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="深度学习">深度学习</a><time datetime="2024-09-29T16:00:00.000Z" title="发表于 2024-09-30 00:00:00">2024-09-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 戴晶明</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BkV10wtzbo9nuKwtsBG04Idw-gzGzoHsz',
      appKey: 'CLv4OkdYGyropWktyqSDf2af',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>