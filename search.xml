<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>目标检测领域的经典模型</title>
      <link href="/2024/12/11/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/12/11/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>此文是我对目标检测领域各个经典模型的一个总结</p><h1>Faster RCNN</h1><p>Fast RCNN 的ROI是通过 SS(选择性搜索)得到的, 他的速度比较慢, 而且是在CPU里面执行的, 基于此, 在Fast RCNN 基础上提出了 RPN(区域建议网络), 直接通过主干网络提取出来的特征生成ROI</p><h2 id="rpn">RPN</h2><p>首先对于主干网络使用3x3的卷积进一步的提取特征(特征图大小不变),  然后将特征图分别送入 分类分支(背景还是前景), 回归分支(预测目标框位置)</p><p>RPN 里面引入了锚框的概念, 锚框就是以某一个点为中心点, 生成不同大小或者不同比例的框, 为什么引入锚框, 以及有什么用?</p><ul><li>引入锚框是为了生成预选框, 这样生成是比SS快的, 我们的特征图中的每个点其实就是一个中心点, 然后将锚框对应特征图区域的特征值送入分类器和回归器得到预选框</li><li>锚框其实是使用了我们人的经验, 因为我们知道生活中物体大概都是多大的, 所以我们就可以基于此设计锚框</li></ul><p>对于特征图每个点都会根据k个锚框生成k个预测框, 包含4个参数(位置信息), 2个参数(分类信息)</p><h2 id="分类器">分类器</h2><p>根据RPN产生的预测框, 生成对应位置的特征图, 然后进行ROI pooling, 然后送进分类器训练</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yolo框架学习</title>
      <link href="/2024/11/29/python/yolo%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/29/python/yolo%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文看的是yolov5的源代码, 后续的yolo除了网络架构不同, 其他地方是差不多的</p></blockquote><h1>数据集构建规则</h1><ol><li>必须使用中心点加宽高模式, 而且必须都归一化, 所有值必须大于等于0</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> lb.shape[<span class="number">1</span>] == <span class="number">5</span>, <span class="string">f&quot;labels require 5 columns, <span class="subst">&#123;lb.shape[<span class="number">1</span>]&#125;</span> columns detected&quot;</span></span><br><span class="line">points = lb[:, <span class="number">1</span>:]</span><br><span class="line"><span class="keyword">assert</span> points.<span class="built_in">max</span>() &lt;= <span class="number">1</span>, <span class="string">f&quot;non-normalized or out of bounds coordinates <span class="subst">&#123;points[points &gt; <span class="number">1</span>]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">assert</span> lb.<span class="built_in">min</span>() &gt;= <span class="number">0</span>, <span class="string">f&quot;negative label values <span class="subst">&#123;lb[lb &lt; <span class="number">0</span>]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h1>数据集yaml编写规则</h1><p>yolo的数据集加载类是LoadImagesAndLabels, 他搜索数据的方式如下:</p><ol><li><p>从所给目录拿到这个目录及其子目录下的所有文件</p></li><li><p>然后进行筛选, 只保留图片文件</p></li><li><p>根据图片文件搜索图片对应的标签文件, 方式很简单 <strong>替换图片路径中最后一个 images 为 lables</strong></p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sa, sb = <span class="string">f&quot;<span class="subst">&#123;os.sep&#125;</span>images<span class="subst">&#123;os.sep&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;os.sep&#125;</span>labels<span class="subst">&#123;os.sep&#125;</span>&quot;</span>  <span class="comment"># /images/, /labels/ substrings</span></span><br><span class="line"><span class="keyword">return</span> [sb.join(x.rsplit(sa, <span class="number">1</span>)).rsplit(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>)[<span class="number">0</span>] + <span class="string">&quot;.txt&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> img_paths]</span><br></pre></td></tr></table></figure></li></ol><p>根据这个规则, 我们其实就很容易搞懂怎么存放标签和图片, 只要标签和图片路径最后一个images和labels不同就行</p><p>比如: /images/a/b/c 和 /labels/a/b/c 可以, /a/b/c/images 和 /a/b/c/images 也可以, 这样就满足了大家喜欢的两种布局, 真的很巧妙</p><h1>模型构建</h1><p>根据模型yaml文件动态搭建,  源码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_model</span>(<span class="params">d, ch</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parses a YOLOv5 model from a dict `d`, configuring layers based on input channels `ch` and model architecture.&quot;&quot;&quot;</span></span><br><span class="line">    LOGGER.info(<span class="string">f&quot;\n<span class="subst">&#123;<span class="string">&#x27;&#x27;</span>:&gt;<span class="number">3</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;from&#x27;</span>:&gt;<span class="number">18</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;n&#x27;</span>:&gt;<span class="number">3</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;params&#x27;</span>:&gt;<span class="number">10</span>&#125;</span>  <span class="subst">&#123;<span class="string">&#x27;module&#x27;</span>:&lt;<span class="number">40</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;arguments&#x27;</span>:&lt;<span class="number">30</span>&#125;</span>&quot;</span>)</span><br><span class="line">    anchors, nc, gd, gw, act, ch_mul = (</span><br><span class="line">        d[<span class="string">&quot;anchors&quot;</span>],</span><br><span class="line">        d[<span class="string">&quot;nc&quot;</span>],</span><br><span class="line">        d[<span class="string">&quot;depth_multiple&quot;</span>],</span><br><span class="line">        d[<span class="string">&quot;width_multiple&quot;</span>],</span><br><span class="line">        d.get(<span class="string">&quot;activation&quot;</span>),</span><br><span class="line">        d.get(<span class="string">&quot;channel_multiple&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> act:</span><br><span class="line">        Conv.default_act = <span class="built_in">eval</span>(act)  <span class="comment"># redefine default activation, i.e. Conv.default_act = nn.SiLU()</span></span><br><span class="line">        LOGGER.info(<span class="string">f&quot;<span class="subst">&#123;colorstr(<span class="string">&#x27;activation:&#x27;</span>)&#125;</span> <span class="subst">&#123;act&#125;</span>&quot;</span>)  <span class="comment"># print</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ch_mul:</span><br><span class="line">        ch_mul = <span class="number">8</span></span><br><span class="line">    na = (<span class="built_in">len</span>(anchors[<span class="number">0</span>]) // <span class="number">2</span>) <span class="keyword">if</span> <span class="built_in">isinstance</span>(anchors, <span class="built_in">list</span>) <span class="keyword">else</span> anchors  <span class="comment"># number of anchors</span></span><br><span class="line">    no = na * (nc + <span class="number">5</span>)  <span class="comment"># number of outputs = anchors * (classes + 5)</span></span><br><span class="line"></span><br><span class="line">    layers, save, c2 = [], [], ch[-<span class="number">1</span>]  <span class="comment"># layers, savelist, ch out</span></span><br><span class="line">    <span class="keyword">for</span> i, (f, n, m, args) <span class="keyword">in</span> <span class="built_in">enumerate</span>(d[<span class="string">&quot;backbone&quot;</span>] + d[<span class="string">&quot;head&quot;</span>]):  <span class="comment"># from, number, module, args</span></span><br><span class="line">        m = <span class="built_in">eval</span>(m) <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, <span class="built_in">str</span>) <span class="keyword">else</span> m  <span class="comment"># eval strings</span></span><br><span class="line">        <span class="keyword">for</span> j, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(args):</span><br><span class="line">            <span class="keyword">with</span> contextlib.suppress(NameError):</span><br><span class="line">                args[j] = <span class="built_in">eval</span>(a) <span class="keyword">if</span> <span class="built_in">isinstance</span>(a, <span class="built_in">str</span>) <span class="keyword">else</span> a  <span class="comment"># eval strings</span></span><br><span class="line"></span><br><span class="line">        n = n_ = <span class="built_in">max</span>(<span class="built_in">round</span>(n * gd), <span class="number">1</span>) <span class="keyword">if</span> n &gt; <span class="number">1</span> <span class="keyword">else</span> n  <span class="comment"># depth gain</span></span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">in</span> &#123;</span><br><span class="line">            Conv,</span><br><span class="line">            GhostConv,</span><br><span class="line">            Bottleneck,</span><br><span class="line">            GhostBottleneck,</span><br><span class="line">            SPP,</span><br><span class="line">            SPPF,</span><br><span class="line">            DWConv,</span><br><span class="line">            MixConv2d,</span><br><span class="line">            Focus,</span><br><span class="line">            CrossConv,</span><br><span class="line">            BottleneckCSP,</span><br><span class="line">            C3,</span><br><span class="line">            C3TR,</span><br><span class="line">            C3SPP,</span><br><span class="line">            C3Ghost,</span><br><span class="line">            nn.ConvTranspose2d,</span><br><span class="line">            DWConvTranspose2d,</span><br><span class="line">            C3x,</span><br><span class="line">        &#125;:</span><br><span class="line">            c1, c2 = ch[f], args[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> c2 != no:  <span class="comment"># if not output, 保证输出通道数是ch_mul的倍数</span></span><br><span class="line">                c2 = make_divisible(c2 * gw, ch_mul)</span><br><span class="line"></span><br><span class="line">            args = [c1, c2, *args[<span class="number">1</span>:]]</span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">in</span> &#123;BottleneckCSP, C3, C3TR, C3Ghost, C3x&#125;:</span><br><span class="line">                args.insert(<span class="number">2</span>, n)  <span class="comment"># number of repeats</span></span><br><span class="line">                n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> m <span class="keyword">is</span> nn.BatchNorm2d:</span><br><span class="line">            args = [ch[f]]</span><br><span class="line">        <span class="keyword">elif</span> m <span class="keyword">is</span> Concat:</span><br><span class="line">            c2 = <span class="built_in">sum</span>(ch[x] <span class="keyword">for</span> x <span class="keyword">in</span> f)</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> channel, gw, gd</span></span><br><span class="line">        <span class="keyword">elif</span> m <span class="keyword">in</span> &#123;Detect, Segment&#125;:</span><br><span class="line">            args.append([ch[x] <span class="keyword">for</span> x <span class="keyword">in</span> f])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(args[<span class="number">1</span>], <span class="built_in">int</span>):  <span class="comment"># number of anchors</span></span><br><span class="line">                args[<span class="number">1</span>] = [<span class="built_in">list</span>(<span class="built_in">range</span>(args[<span class="number">1</span>] * <span class="number">2</span>))] * <span class="built_in">len</span>(f)</span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">is</span> Segment:</span><br><span class="line">                args[<span class="number">3</span>] = make_divisible(args[<span class="number">3</span>] * gw, ch_mul)</span><br><span class="line">        <span class="keyword">elif</span> m <span class="keyword">is</span> Contract:</span><br><span class="line">            c2 = ch[f] * args[<span class="number">0</span>] ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> m <span class="keyword">is</span> Expand:</span><br><span class="line">            c2 = ch[f] // args[<span class="number">0</span>] ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c2 = ch[f]</span><br><span class="line"></span><br><span class="line">        m_ = nn.Sequential(*(m(*args) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n))) <span class="keyword">if</span> n &gt; <span class="number">1</span> <span class="keyword">else</span> m(*args)  <span class="comment"># module</span></span><br><span class="line">        t = <span class="built_in">str</span>(m)[<span class="number">8</span>:-<span class="number">2</span>].replace(<span class="string">&quot;__main__.&quot;</span>, <span class="string">&quot;&quot;</span>)  <span class="comment"># module type</span></span><br><span class="line">        np = <span class="built_in">sum</span>(x.numel() <span class="keyword">for</span> x <span class="keyword">in</span> m_.parameters())  <span class="comment"># number params</span></span><br><span class="line">        m_.i, m_.f, m_.<span class="built_in">type</span>, m_.np = i, f, t, np  <span class="comment"># attach index, &#x27;from&#x27; index, type, number params</span></span><br><span class="line">        LOGGER.info(<span class="string">f&quot;<span class="subst">&#123;i:&gt;<span class="number">3</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(f):&gt;<span class="number">18</span>&#125;</span><span class="subst">&#123;n_:&gt;<span class="number">3</span>&#125;</span><span class="subst">&#123;np:<span class="number">10.0</span>f&#125;</span>  <span class="subst">&#123;t:&lt;<span class="number">40</span>&#125;</span><span class="subst">&#123;<span class="built_in">str</span>(args):&lt;<span class="number">30</span>&#125;</span>&quot;</span>)  <span class="comment"># print</span></span><br><span class="line">        save.extend(x % i <span class="keyword">for</span> x <span class="keyword">in</span> ([f] <span class="keyword">if</span> <span class="built_in">isinstance</span>(f, <span class="built_in">int</span>) <span class="keyword">else</span> f) <span class="keyword">if</span> x != -<span class="number">1</span>)  <span class="comment"># append to savelist</span></span><br><span class="line">        layers.append(m_)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            ch = []</span><br><span class="line">        ch.append(c2)</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*layers), <span class="built_in">sorted</span>(save)</span><br></pre></td></tr></table></figure><p>这个东西确实好, 比起我们用代码构建模型方便太多了</p><p>在模型训练过程中, 会记录每一层输出的东西, 如果某一层的来源有多个个, 就需要在上一层的时候就使用concat进行连接, 前向传播源码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_forward_once</span>(<span class="params">self, x, profile=<span class="literal">False</span>, visualize=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Performs a forward pass on the YOLOv5 model, enabling profiling and feature visualization options.&quot;&quot;&quot;</span></span><br><span class="line">        y, dt = [], []  <span class="comment"># outputs</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.model:</span><br><span class="line">            <span class="keyword">if</span> m.f != -<span class="number">1</span>:  <span class="comment"># if not from previous layer</span></span><br><span class="line">                x = y[m.f] <span class="keyword">if</span> <span class="built_in">isinstance</span>(m.f, <span class="built_in">int</span>) <span class="keyword">else</span> [x <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">else</span> y[j] <span class="keyword">for</span> j <span class="keyword">in</span> m.f]  <span class="comment"># from earlier layers, 如果有多层就使用多层数据, 这样下面的时候就必须使用concat, m就必须是concat, 或者在这里就concat</span></span><br><span class="line">            <span class="keyword">if</span> profile:</span><br><span class="line">                self._profile_one_layer(m, x, dt)</span><br><span class="line">            x = m(x)  <span class="comment"># run</span></span><br><span class="line">            y.append(x <span class="keyword">if</span> m.i <span class="keyword">in</span> self.save <span class="keyword">else</span> <span class="literal">None</span>)  <span class="comment"># save output</span></span><br><span class="line">            <span class="keyword">if</span> visualize:</span><br><span class="line">                feature_visualization(x, m.<span class="built_in">type</span>, m.i, save_dir=visualize)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1>缓存</h1><p>yolo提供了 cache这个选项, 有三种:</p><ol><li>ram 在dataset里面一次将图片全部加载到内存中, 这种在使用的时候是最快的</li><li>disk 会在图片路径下创建同名的.npy文件, 需要的时候就是加载这个文件了, 这个文件是经过了处理图片后的numpy数组格式, 加载的时候更快</li><li>不使用–cache, 每次使用图片的时候都从磁盘加载图片</li></ol><p>有时候我们有疑惑, 为什么训练的时候三种速度一样?</p><p><strong>因为图片加载速度高于GPU训练速度</strong>, 这个就要归功于pytorch的DataLoader了, 他会启用多个工作进程, 在GPU训练的时候,每个进程加载2*batch_size(可以自己设置)个数据到缓存队列中, 如果数据不大, 加载速度就可能快于GPU训练速度, 所以需要用的时候数据已经在内存了, 这样的话, 三个就没有区别</p><h1>衡量标准计算</h1><p>模型的好坏一般有些评判标准, 精度, 召回率, f1分数, AP, mAP(50, 50-95)</p><p>AP 是指 一个类别的平均精度, 是通过在一个Iou阈值下, 不同置信度产生的精度和召回率曲线与坐标轴围成的面积</p><p>mAP 就是指所有类别的平均了, mAP50 指 Iou为0.5的情况下, mAP的值,  mAP50-95 是指Iou 从0.5-0.95的mAP的平均值</p><p>Iou越大, 说明对于检测越加严格, 同样置信度越大, 也越严格</p><p>yolo中mAP计算步骤:</p><ol><li>首先根据不同的iou阈值得到预测框是否正确, 得到一个tp数组维度通常是(N, 10), N代表预测框数量, 10代表不同iou(0.5:0.95)</li><li>然后根据预测框的置信度排序, 置信度大的在前面, 这里是为了快速得到不同置信度下tp和fp的框有多少, 如果在置信度大的时候,tp都为true, 那么置信度小的时候也会为true</li><li>根据置信度的从大到小的变化, 我们能得到不同的精确度和召回率, 然后通过插值函数就能得到AP了</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读方法论</title>
      <link href="/2024/11/12/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>/2024/11/12/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><h1>方法</h1><p>三遍法:</p><ul><li>第一遍(海选): 看标题, 摘要, 然后直接跳到结论, 看完这些大概知道文章在讲什么, 然后看看实验和方法部分的图和表,  经过这些步骤就可以判断文章怎么样, 有没有必要继续下去</li><li>第二遍:  从头读到尾, 但是没必要在意太多的细节,比如公式证明, 但是 要搞清楚图和表 以及 作者提出了什么方法, 以及他的方法和别人的区别,  对于不懂的地方先做标记,比如他参考的文献你不懂的地方</li><li>第三遍: 精读文章, 每一句话在干什么,  即使不看文章, 你也知道这篇文章到底是在干啥了</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch学习</title>
      <link href="/2024/11/01/python/pytorch/"/>
      <url>/2024/11/01/python/pytorch/</url>
      
        <content type="html"><![CDATA[<h1>nn模块</h1><h2 id="权重初始化">权重初始化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义线性层</span></span><br><span class="line">linear_layer = nn.Linear(in_features=<span class="number">10</span>, out_features=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 直接赋值给权重和偏置</span></span><br><span class="line">linear_layer.weight.data.fill_(<span class="number">0.01</span>)  <span class="comment"># 将权重全设置为 0.01</span></span><br><span class="line">linear_layer.bias.data.fill_(<span class="number">0</span>)       <span class="comment"># 将偏置设置为 0</span></span><br></pre></td></tr></table></figure><h1>广播机制</h1><p>广播机制的核心流程可以概括为：</p><ol><li><strong>从右往左逐个对比两个张量的维度</strong>。</li><li><strong>相等时继续</strong>：如果对应维度大小相等，直接匹配。</li><li><strong>不相等时判断是否有1</strong>：如果不相等，检查其中一个维度是否为1。如果是，则可以广播扩展成相等的维度。</li><li><strong>无法匹配时停止</strong>：如果对应维度大小不相等，且都不为1，则广播机制无法继续，运算会报错。</li><li><strong>缺少的维度补1</strong>：如果一个张量维度数量少，从右侧开始自动补充1，以便进行对比。</li></ol><p>例如，如果有两个张量：</p><ul><li><code>a</code> 的形状是 <code>(3, 1, 5)</code></li><li><code>b</code> 的形状是 <code>(4, 5)</code></li></ul><p>按照广播机制，从右往左依次匹配：</p><ul><li>最右边的维度 5 匹配。</li><li>中间的维度 <code>1</code>（<code>a</code> 的第二维）可以扩展到 4，以匹配 <code>b</code> 的第二维。</li><li><code>a</code> 的第一个维度 <code>3</code> 与 <code>b</code> 无需匹配，因为 <code>b</code> 没有对应的维度，所以直接保留。</li></ul><p>最终 <code>a</code> 会广播为 <code>(3, 4, 5)</code>，<code>b</code> 会广播为 <code>(1, 4, 5)</code>，最后结果为 <code>(3, 4, 5)</code>。</p><blockquote><p>pytorch并不会真正的扩展原始数据维度, 而是在计算的时候重复利用原始数据</p></blockquote><p><strong>注意</strong>: 矩阵乘法(点积) 有自己的运算规则, 并不满足这种广播机制</p><h1>技巧</h1><h2 id="损失函数数值图">损失函数数值图</h2><p>我们在训练模型的时候, 推荐把每一轮的损失值画出来, 因为深度学习是个黑盒子, 我们很难得知他到底学啥了, 学的咋样了, 我们只有通过我们自己的评判标准也就是损失去判断, 所以把图画出来是最直观的, 也方便调试bug</p><h1>问题</h1><h2 id="梯度爆炸">梯度爆炸</h2><p>在使用MSELoss的时候, 如果reduction改成sum,  那么损失值跟batch就线性相关了, 很容易导致梯度爆炸,  就需要对这个reduction做调整, 要么使用mean, 要么自己去定义</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习</title>
      <link href="/2024/09/30/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/09/30/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="zh.d2l.a">学习链接</a></p></blockquote><h1>前言</h1><p>神经网络就是用来学习一种我们无法通过公式和算法显式的写出来的规则, 比如 目标检测,  我们人脑能很快的从一副图像中检测某个物体, 并且分类, 但是我们是无法直接写出这个检测和分类的代码的, 所以我们需要神经网络这个黑盒子去帮我们隐式的表达出来</p><h1>前馈神经网络(FNN)</h1><p>即多层感知机(MLP),  输入层 与 隐藏层 之间, 以及隐藏层和输出层之间 采用全连接的方式</p><h2 id="激活函数">激活函数</h2><p>有了激活函数, 我们可以将多层感知机的表达能力变得更强,而不局限于线性表达, 如果没有激活函数, 多层感知机和线性模型那些没有啥区别, 这里可以以一个只有一个隐藏层的模型推导</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">O</mi><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="bold">X</mi><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi mathvariant="bold">X</mi><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi mathvariant="bold">X</mi><mi mathvariant="bold">W</mi><mo>+</mo><mi mathvariant="bold">b</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex"> \mathbf{O} = (\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)})\mathbf{W}^{(2)} + \mathbf{b}^{(2)} = \mathbf{X} \mathbf{W}^{(1)}\mathbf{W}^{(2)} + \mathbf{b}^{(1)} \mathbf{W}^{(2)} + \mathbf{b}^{(2)} = \mathbf{X} \mathbf{W} + \mathbf{b}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">O</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.938em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.938em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76944em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">b</span></span><span class="mord">.</span></span></span></span></span></p><h1>卷积神经网络(CNN)</h1><p>这个给我的感觉就是用来做特征提取,  使用一小块的卷积核 依次去以某种模式去匹配一个矩阵(图像, 以及其他能被矩阵表达的东西), 然后得出匹配的特征, 然后做池化, 如此往复, 最后再使用前馈神经网络输出东西</p><ul><li>卷积核: 用来做特征匹配的, 也是需要学习的参数, 卷积核的通道数与输入数据的通道数是一样的.  一个卷积核就是一种特征提取</li><li>池化: 降低计算复杂度, 减少过拟合,保留我们需要的信息, 只会改变宽高, 不会改变通道数</li><li>感受野: 能看到原始输入数据区域大小</li></ul><h2 id="现代卷积神经网络">现代卷积神经网络</h2><h3 id="alextnet">AlextNet</h3><p>改良LeNet, 使用了Relu作为激活函数,</p><h3 id="vgg">VGG</h3><p>引入块的概念, 将一系列操作(卷积, 激活,池化)封装成块</p><h3 id="nin">NiN</h3><p>引入1*1卷积改变通道数</p><p>引入1*1卷积 加上全局平均池化 代替一般卷积神经网络最后的全连接层, 1*1卷积不会保留了各通道之间的空间信息</p><h3 id="googlelet">GoogleLet</h3><p>定义了一个Inception块, 里面包含了各种卷积块大小操作, 最后连接这些操作产生的数据, 引入了四条并行路径</p><h3 id="resnet">ResNet</h3><p>用来克服深层次卷积神经网络失效的问题,  f(x) = x+g(x)</p><h3 id="densenet">DenseNet</h3><p>ResNet的变种, f(x) =[ x, g(x), g1(x+g(x)) …]</p><h1>循环神经网络(RNN)</h1><p>前馈神经网络是没有记忆能力的, 不能根据之前的输入做出不同的输出, 只要是相同的东西都是同样的输出, 而循环神经网络是有记忆能力的, 他能理解上下文</p><p>循环神经网络的记忆力体现在引入了隐状态,  他每一步都会根据当前的输入以及上一次的隐状态生成这一次的隐状态并且记录下来, 所以根据不同的生成隐状态的方式就能引出一些现在循环神经网络模型:</p><ul><li>LSTM</li><li>GRU</li><li>BRNN(双向循环网络)</li></ul><h1>注意力机制</h1><p>他是一种模仿人类注意力的机制，能够让模型在处理复杂任务时更关注某些关键的信息或部分</p><p>举个例子:  你手里有很多同事的笔记（键），你自己有一个具体的问题（查询），你要从这些笔记中找到和你问题最相关的信息（值）。你可能会在不同的同事那里找到不同程度的帮助，所以你会根据他们的经验来判断谁的笔记最有价值（注意力权重）。最后，你整合了最有帮助的内容，得到了答案。</p><ul><li><p><strong>查询</strong>是你当前想要解决的问题。</p></li><li><p><strong>键</strong>是整个上下文背景，告诉你每个部分的信息如何相互关联。</p></li><li><p><strong>值</strong>是你从键中提取的答案或信息。</p></li><li><p><strong>注意力权重</strong>决定了你应该关注哪些信息，并忽略哪些不相关的部分。</p></li></ul><p>我们的模型就是需要训练出如何根据输入得到查询, 键, 值,  根据输入得到关注的点(查询), 得到 不同部分(键), 不同部分中的关键信息(值),  然后计算查询与键的注意力权重, 然后将权重与值加权得到输出(整合)</p><h2 id="注意力评分函数">注意力评分函数</h2><p>这个是根据键和查询得到关于值的权重</p><h3 id="加性注意力评分函数">加性注意力评分函数</h3><p>将键和值通过两个不同线性变化映射到同一个长度, 然后相加经过一个激活函数, 然后再做一个线性变化(内积)变成长度为1得到这个值的权重</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>w</mi><mi>v</mi><mi>T</mi></msubsup><mi>tanh</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>W</mi><mi>q</mi></msub><mi>q</mi><mo>+</mo><msub><mi>W</mi><mi>k</mi></msub><mi>k</mi><mo stretchy="false">)</mo><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">a(q, k) = w_v^T \tanh(W_q q + W_k k) \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.177439em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">tanh</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span></span></p><h3 id="缩放点积注意力评分函数">缩放点积注意力评分函数</h3><p>这个需要键和值特征长度是相同的, 直接相乘然后除以长度的开方</p><h2 id="多头注意力">多头注意力</h2><p>将q,k,v映射到相同的维度, 然后分成指定头, 然后每个头上做注意力, 最后汇聚起来, 再映射出去</p><h1>额外笔记</h1><ul><li><p>权重衰退: 其实就是正则化, 让复杂的权重产生更大的损失, 这样可以避免过拟合</p></li><li><p>丢弃法: 也就是dropout,  通过丢弃一些节点(训练过程中), 相当于加入一些噪音, 提高模型的鲁棒性和泛化能力, <strong>也是相当于正则化</strong>,  p的概率丢弃这个节点输出, 1-p的概率将输出除以1-p 其实这样的话会发现这一层的输出均值不变</p></li><li><p>数值稳定性: 训练过程中可能出现梯度爆炸或者梯度消失, 这样都会对模型的训练产生问题, 我们希望模型的训练比较稳定, 一般通过控制反向传播和前馈传播的时候, 让输出的大小满足均值为0, 方差为一个固定值,  这可以通过权重初始化(一般是正态分布)来做到(但是也仅限于前期, 因为后期权重会发生变化, 可能就偏离了原始分布)</p></li><li><p>batchNorm:  用于固定小批量里面的均值和方差, 可以加速模型收敛速度, 但是一般不会改变模型精度, 相比权重初始化, 这个东西可以在全局爆炸数据满足某种分布, 而权重初始化只能在开始的时候保证满足某种分布</p></li></ul><h1>反思总结</h1><h2 id="梯度更新">梯度更新</h2><p>我以前总是以为上一层的参数更新所用的梯度 是瓜分上一层的梯度, 因为我以前看过一个课程, 他举例子正好是 t = 1/2*x + 1/2*y, 这样的话就会导致反向传播的时候, x和y的梯度正好是相同的并且是t的梯度一半,  但是其实不是, 实际在反向传播中，梯度是按链式法则计算的，每个变量的梯度是<strong>单独求导并独立传递</strong>的, 是用t的梯度乘以dt/dx</p><p>借此机会正好谈一下梯度消失和梯度爆炸, 正是因为这种链式求导法则, 会导致梯度消失和梯度爆炸</p><h3 id="梯度消失">梯度消失</h3><p>如果我们采用sigmoid这类激活函数, 就会出现这种问题, 还有就是如果数据初始就很小, 累乘的时候会导致梯度很小,</p><p>sigmoid的激活函数的导数最大也就只有0.25而且越往两边数值都接近0了, 这样很容易导致梯度变得很小</p><p><img src="/2024/09/30/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/../img/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0assets/image-20241103170237123.png" alt="image-20241103170237123"></p><p>还有就是链式法则累乘: da * db * dc * dd</p><h3 id="梯度爆炸">梯度爆炸</h3><p>正是因为链式法则, 如果初始化的时候, 其中的参数都很大的话, 就会导致梯度直接爆炸了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sci论文各个组成部分</title>
      <link href="/2024/09/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/sci%E8%AE%BA%E6%96%87%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E6%9E%84%E6%88%90/"/>
      <url>/2024/09/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/sci%E8%AE%BA%E6%96%87%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E6%9E%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>SCI（Science Citation Index）论文的结构通常是标准化的，遵循IMRaD格式，即：引言（Introduction）、方法（Methods）、结果（Results）和讨论（Discussion）。除此之外，还有其他一些关键部分。以下是SCI论文的常见模块及其功能说明：</p><ol><li><p><strong>题目（Title）</strong>：</p><ul><li>功能：简洁明确地概括论文的核心内容，让读者一目了然地知道研究主题。题目通常包括关键的研究方法、对象、研究变量或结论。</li></ul></li><li><p><strong>摘要（Abstract）</strong>：</p><ul><li>功能：摘要是整篇论文的简短总结，通常在200-300字之间。它包含了<strong>研究背景、目的、方法、结果和结论</strong>，<strong>目的是帮助读者快速了解论文的主要内容和结论。</strong></li></ul></li><li><p><strong>关键词（Keywords）</strong>：</p><ul><li>功能：关键词是论文内容的核心术语，帮助研究人员和数据库快速检索相关研究。通常是3到5个关键词。</li></ul></li><li><p><strong>引言（Introduction）</strong>：</p><ul><li>功能：介绍研究的背景、现有研究现状（文献综述）、<strong>研究的目的及意义</strong>。通过提出研究的科学问题或假设，激发读者兴趣，阐明研究的必要性。(没有研究方法和和结论)</li></ul></li><li><p><strong>材料与方法（Materials and Methods）</strong>：</p><ul><li>功能：详细描述实验设计、研究方法、工具、数据采集过程和分析手段，以便其他研究人员可以复现实验。这部分应清晰、详细，确保研究的可靠性和可重复性。</li></ul></li><li><p><strong>结果（Results）</strong>：</p><ul><li>功能：展示实验或研究得到的主要结果。可以通过表格、图表和文字形式总结数据，但通常不对结果进行解释或讨论。这部分应准确、简洁，重点突出研究的核心发现。</li></ul></li><li><p><strong>讨论（Discussion）</strong>：</p><ul><li>功能：解释结果的意义，与之前的研究进行对比，讨论结果的应用价值及其局限性，并提出未来研究的方向。讨论部分通常包括对研究假设是否成立的回答，并解释结果背后的机制。</li></ul></li><li><p><strong>结论（Conclusion）</strong>（可选）：</p><ul><li>功能：有些论文会在讨论之后有独立的结论部分，总结研究的核心发现和重要性。</li></ul></li><li><p><strong>致谢（Acknowledgements）</strong>：</p><ul><li>功能：向在研究中提供帮助但未直接参与写作的人或机构表示感谢，通常包括资助机构、技术支持等。</li></ul></li><li><p><strong>参考文献（References）</strong>：</p><ul><li>功能：列出论文中引用的所有文献，确保研究的科学性和来源的可靠性。引用文献的格式取决于期刊要求。</li></ul></li><li><p><strong>附录（Appendix）</strong>（可选）：</p><ul><li>功能：在附录中提供额外的资料，如冗长的公式、额外的图表、详尽的数据集或程序代码，帮助有深入兴趣的读者理解和重现研究。</li></ul></li></ol><p>这些模块共同组成了SCI论文的框架，各自承担着不同的任务，确保研究的科学性、透明性和可重复性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读指令集</title>
      <link href="/2024/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AF%BB%E6%96%87%E7%8C%AE%E6%8C%87%E4%BB%A4/"/>
      <url>/2024/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AF%BB%E6%96%87%E7%8C%AE%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1>指令集</h1><h2 id="指令1">指令1</h2><p>请你阅读井理解这篇文献，然后将该篇文章的标题作为一级标题，将摘要和各个大标题作为二级标题，将小标题作为三级标题，将小标题下每一部分内容作为四级标题，给我以markdown的语言输出中文的翻译。去掉致谢和参考文献的部分。</p><h2 id="指令2">指令2</h2><p>请你以“该篇文章的笔记“为一级标题别以&quot;该篇文章的研究目的”、“2.该篇文章的研究方法”、”3该篇文章的研究内容”、“4该篇文章的最大创新点”、“5该篇文章给我们的启发“为二级标题，总结的这五部分内容作为三级表题，给我总结后以markdown的语言输出。</p><h2 id="指令3">指令3</h2><p>请你对该文章中的所有的图例和表例按照顺序给我依次翻译成中文。</p><h2 id="指令4">指令4</h2><p>这是图X，请你结合该篇文章内容，首先给我介绍每个图中的横坐标和纵坐标各自表示的含义，然后针对每一个图给我详细的解释。</p><h2 id="指令5">指令5</h2><p>我对XX内容”不是很理解，请你用通俗的语言给我解释，并给我举出一个实例以让我更加深刻的理解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gcc环境配置</title>
      <link href="/2024/06/27/C%E5%92%8CC++/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/06/27/C%E5%92%8CC++/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1>Windows</h1><ol><li><p>来到<a href="https://www.mingw-w64.org/downloads/">mingw官网</a>, 根据自己的喜好选择,  我这里选择mingw64</p><img src="/2024/06/27/C%E5%92%8CC++/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/../img/环境配置assets/image-20240627005230160.png" alt="image-20240627005230160" style="zoom: 80%;"><ol start="2"><li><p>进去之后点击<a href="https://github.com/niXman/mingw-builds-binaries/releases">GitHub</a>链接来到下载页面</p><img src="/2024/06/27/C%E5%92%8CC++/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/../img/环境配置assets/image-20240627005338382.png" alt="image-20240627005338382" style="zoom:80%;"><ul><li><strong>i686</strong> 和 **x86_64 **分别代表32位和64位</li><li>posix 和 win32 代表默认使用线程库,  其实就是编译器默认参数选择, 如果是posix 链接的时候就回默认带上 -lpthread, 其实无论怎么选, pthread库都是包含的</li><li><strong>msvcrt</strong>  和 <strong>ucrt</strong> 代表不同的运行时库, 就是一些基础函数, 库函数</li></ul></li><li><p>配置环境变量</p></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令和工具</title>
      <link href="/2024/06/19/linux/linux%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/06/19/linux/linux%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 场景解决方案</title>
      <link href="/2024/06/18/linux/%E5%9C%BA%E6%99%AF%E6%96%B9%E6%A1%88/"/>
      <url>/2024/06/18/linux/%E5%9C%BA%E6%99%AF%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>用于记录Linux使用的时候遇到的一些特殊场景, 以及对应的解决方案</p><h1>多用户同时使用图形界面</h1><p>机房有一台很好配置的服务器, 但是同学们不太会直接使用命令行界面, 都需要图形化的使用, 这个时候我们就需要多个用户同时使用, 就不用等某个同学的使用了</p><p>解决方案: vnc+内网穿透  或者 vnc+向日葵 (这个可能有点问题, 我尝试没成功)</p><p>要在CentOS服务器上设置VNC以便远程多用户访问，您可以按照以下步骤进行：</p><h2 id="vnc安装">VNC安装</h2><h3 id="1-安装vnc-server和桌面环境">1. 安装VNC Server和桌面环境</h3><p>首先，您需要安装一个VNC服务器和一个桌面环境。这里以TigerVNC和GNOME桌面环境为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release -y</span><br><span class="line">sudo yum install tigervnc-server -y</span><br><span class="line">sudo yum groupinstall <span class="string">&quot;GNOME Desktop&quot;</span> -y</span><br></pre></td></tr></table></figure><h3 id="2-设置vnc-server">2. 设置VNC Server</h3><p>创建VNC Server的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</span><br></pre></td></tr></table></figure><p>编辑该文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/vncserver@:1.service</span><br></pre></td></tr></table></figure><p>找到以下行并修改<code>&lt;USER&gt;</code>为您的实际用户名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="line">ExecStartPre=/bin/sh -c &#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span><br><span class="line">ExecStart=/usr/bin/vncserver %i</span><br><span class="line">ExecStop=/usr/bin/vncserver -kill %i</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h3 id="3-设置vnc密码">3. 设置VNC密码</h3><p>切换到您的用户，然后设置VNC密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - &lt;USER&gt;</span><br><span class="line">vncpasswd</span><br></pre></td></tr></table></figure><h3 id="4-启动vnc服务">4. 启动VNC服务</h3><p>重新加载systemd服务，并启动VNC服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> vncserver@:1.service</span><br><span class="line">sudo systemctl start vncserver@:1.service</span><br></pre></td></tr></table></figure><h3 id="5-配置防火墙">5. 配置防火墙</h3><p>打开VNC服务所需的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-port=5901/tcp</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="6-连接到vnc服务器">6. 连接到VNC服务器</h3><p>在本地计算机上，使用VNC客户端连接到服务器的IP地址和端口。例如，如果服务器的IP地址是<code>192.168.1.100</code>，您可以使用<code>192.168.1.100:5901</code>进行连接。</p><h3 id="7-其他配置">7. 其他配置</h3><p>可以编辑每个用户的VNC启动脚本以自定义启动环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vnc/xstartup</span><br></pre></td></tr></table></figure><p>添加以下内容以启动GNOME桌面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">unset</span> SESSION_MANAGER</span><br><span class="line"><span class="built_in">unset</span> DBUS_SESSION_BUS_ADDRESS</span><br><span class="line"><span class="built_in">exec</span> /etc/X11/xinit/xinitrc</span><br></pre></td></tr></table></figure><p>保存并关闭文件，给脚本添加执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ~/.vnc/xstartup</span><br></pre></td></tr></table></figure><h3 id="8-多用户配置">8. 多用户配置</h3><p>如果需要多个用户访问，可以为每个用户配置一个不同的VNC实例。重复上述步骤2和3，修改配置文件和服务端口号。例如，为第二个用户创建一个新的服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:2.service</span><br></pre></td></tr></table></figure><p>编辑该文件并将<code>&lt;USER&gt;</code>替换为新用户的用户名，同时将所有端口号从<code>1</code>改为<code>2</code>。</p><p>启动新的VNC服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> vncserver@:2.service</span><br><span class="line">sudo systemctl start vncserver@:2.service</span><br></pre></td></tr></table></figure><p>为新用户设置VNC密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - &lt;NEW_USER&gt;</span><br><span class="line">vncpasswd</span><br></pre></td></tr></table></figure><h3 id="9-关闭服务">9. 关闭服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop vncserver@:1.service</span><br><span class="line">sudo systemctl disable vncserver@:1.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">多用户</span></span><br><span class="line">sudo systemctl stop vncserver@:2.service</span><br><span class="line">sudo systemctl disable vncserver@:2.service</span><br></pre></td></tr></table></figure><h3 id="10-同一用户不同桌面">10. 同一用户不同桌面</h3><p>首先按照第8步把服务再配置一份即可</p><h4 id="为每个实例设置不同密码">为每个实例设置不同密码</h4><p>如果需要为每个实例设置独立的密码，可以在不同实例的配置中指定单独的密码文件：</p><ol><li><p>生成密码文件：</p><p>切换到那个用户 su DJM</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.vnc</span><br><span class="line">vncpasswd ~/.vnc/passwd1</span><br><span class="line">vncpasswd ~/.vnc/passwd2</span><br></pre></td></tr></table></figure><ul><li><code>~/.vnc/passwd1</code> 将用于显示号 <code>:1</code>。</li><li><code>~/.vnc/passwd2</code> 将用于显示号 <code>:2</code>。</li></ul></li><li><p>修改服务文件： 在您的 <code>vncserver_wrapper</code> 或直接的 <code>ExecStart</code> 参数中，添加 <code>-rfbauth</code> 选项，指定不同的密码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/vncserver_wrapper DJM %i -rfbauth /home/DJM/.vnc/passwd%i</span><br></pre></td></tr></table></figure><p>这样，显示号为 <code>:1</code> 的实例会使用 <code>/home/DJM/.vnc/passwd1</code>，显示号为 <code>:2</code> 的实例会使用 <code>/home/DJM/.vnc/passwd2</code>。</p></li></ol><h2 id="内网穿透工具">内网穿透工具</h2><ul><li><a href="https://dashboard.cpolar.com/get-started">cpolar</a></li><li></li></ul><p>选择其中一个工具,按照使用方法做好端口映射就行</p><h2 id="vnc工具">VNC工具</h2><ul><li><a href="https://www.realvnc.com/en/connect/download/viewer/">realVNC</a></li></ul><h1>桌面卡死, 项目更换父进程</h1><p>我在跑我的项目, 但是桌面卡死了, 我又要需要查看当前项目的情况,  这个时候我就需要这个项目的父进程交给其他进程(一定要是这个用户的进程), 不然重启桌面会导致这个项目被杀死</p><p>使用ssh登陆进入(如果这个做不到, 就自求多福希望这个跑的项目不重要)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install screen</span><br><span class="line"></span><br><span class="line">screen -S my_session  #  </span><br><span class="line"></span><br><span class="line">ps -axu | grep 项目信息  # 找到pid</span><br><span class="line"></span><br><span class="line">reptyr pid # 使用上面找到的pid</span><br><span class="line"></span><br><span class="line">systemctl restart gdm # 这里对应自己的桌面管理程序</span><br></pre></td></tr></table></figure><p>这个是事后补救了,   如果是很重要的项目在跑或者很费时间的项目, 建议提前使用 screen这类工具, 这样就不怕什么终端关闭, 桌面卡死了,  但是如果断电还是怕的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>office办公软件</title>
      <link href="/2024/06/17/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/office%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/"/>
      <url>/2024/06/17/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/office%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1>word</h1><h1>Excel</h1><h1>PPT</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>office办公软件安装</title>
      <link href="/2024/06/16/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/office%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2024/06/16/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/office%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>方式一</h1><p><a href="https://zhenxingdongbei.com/1278.html">参考链接</a></p><p>如果直接在网上搜索office安装, 弹出的基本要么是官方的先购买才能安装, 要么就是office tool plus 安装,   后者有时候会下载失败, 就很傻逼, 我就干脆自己直接下载</p><ol><li><p>官网下载 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=49117">Office Deployment Tool</a>,  打开后会选择一个文件夹,东西会放在这里</p></li><li><p><a href="https://config.office.com/deploymentsettings">配置config文件</a>, 官网导出config.xml 到上一步选择的文件夹</p></li><li><p>进入到第一步选择的文件夹执行下面命令:</p><ul><li><pre><code>setup.exe /download config.xml<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  这里是在下载应用</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  setup.exe /configure config.xml</span><br></pre></td></tr></table></figure>进行安装</code></pre></li></ul></li></ol><p>这样就完成了下载, 后续就是破解了</p><h1>方式二</h1><p>直接使用office tool plus 安装,  这个其实就是软件帮我们集成了上面的操作, 我们只需要使用这个软件来安装即可,  但是这样有时候会下载不了东西导致超时从而下载失败</p><p><a href="https://otp.landian.vip/zh-cn/">地址</a></p><h1>破解</h1><h2 id="方式一">方式一</h2><p>通过这个<a href="https://github.com/zbezj/HEU_KMS_Activator/releases">地址</a>下载压缩包打开, 然后运行里面程序 选择激活office即可</p><h2 id="方式二">方式二</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谷歌使用</title>
      <link href="/2024/06/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/chrome/"/>
      <url>/2024/06/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/chrome/</url>
      
        <content type="html"><![CDATA[<h1>备份</h1><p>我们知道Google自带了云备份, 但是这里的云备份删除的时候是不需要密码的,  这就存在潜在隐患, Google里面保存了我很多的密码, 万一别人或者自己不小心删掉了, 这你找谁说理去, 而且貌似也没有看到如何恢复,  与其这样, 不如自己搞个备份来的稳妥</p><p>在Google页面输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://version</span><br></pre></td></tr></table></figure><p><img src="/2024/06/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/chrome/../img/chromeassets/image-20240606181412391.png" alt="image-20240606181412391"></p><p>上面显示了个人资料路径找到这个路径备份就行, 下次可以直接用这里面的东西覆盖, 这样就能直接使用了</p><p>里面其实很多东西不需要备份, 比如说 缓存啊, 索引数据啊, 我们都可以直接删除了 再备份, 这样就小很多</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows</title>
      <link href="/2024/06/02/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/windows%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/06/02/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/windows%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>问题记录</h1><h2 id="启动变得很慢">启动变得很慢</h2><ul><li>我的磁盘测试了, 没有问题</li><li>安全启动也很慢</li><li>启动日志总是循环加载一个驱动不成功</li></ul><p>我的解决方法就是更新系统,  然后就遇到了无法更新的问题, 可以参照下面, 更新成功后, 就没有任何问题了</p><h2 id="无法更新">无法更新</h2><p>报错信息   针对 Windows 10 的功能更新，版本 22H2 - 错误 0xc1900204</p><p>这个大概率是我们的默认安装路径换到其他盘去了, 然后导致更新失败, 我们只需要换回来就行</p><p>win + r  然后输入 regedit</p><p>然后输入框输入  这个:    计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion</p><p><img src="/2024/06/02/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/windows%E4%BD%BF%E7%94%A8/../img/windows%E4%BD%BF%E7%94%A8assets/image-20240602160449584.png" alt="image-20240602160449584"></p><p>将其他盘的改成C盘即可, 然后就可以安装成功了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux问题记录</title>
      <link href="/2024/05/30/linux/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/05/30/linux/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>服务器用户家目录空间不足</h1><p>服务器出现问题的时候磁盘情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p>输出如下:(具体数值我记不上了, 情况是这么个情况)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs                  63G     0   63G    0% /dev</span><br><span class="line">tmpfs                     63G     0   63G    0% /dev/shm</span><br><span class="line">tmpfs                     63G   12M   63G    1% /run</span><br><span class="line">tmpfs                     63G     0   63G    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   50G   23G   27G   17% /</span><br><span class="line">/dev/sda2               1014M  414M  601M   41% /boot</span><br><span class="line">/dev/sda1                200M   12M  189M    6% /boot/efi</span><br><span class="line">/dev/sdb1                  6T   81M  5.9T    1% /data</span><br><span class="line">/dev/mapper/centos-home  379G  378.9G  12k   99% /home</span><br><span class="line">tmpfs                     13G     0   13G    0% /run/user/1001</span><br><span class="line">tmpfs                     13G   56K   13G    1% /run/user/1000</span><br><span class="line">tmpfs                     13G     0   13G    0% /run/user/0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的/home目录空间是已经不够了的, 我们需要对他进行扩充</p><p>这里是/dev/mapper/centos-home  挂载到了/home目录,  经过查找得知,  这是一种逻辑卷,  具体可以参考额外知识点</p><p>现在我们的目的就是扩展这个逻辑卷,  可以查看当前逻辑卷所在卷组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/05/30/linux/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/../img/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95assets/image-20240530213150642.png" alt="image-20240530213150642"></p><h1>额外知识点</h1><p>逻辑卷（Logical Volume）和物理卷（Physical Volume）是逻辑卷管理器（LVM）中的两个重要概念，它们在功能和用途上有显著区别。以下是它们的主要区别：</p><p><strong>物理卷（Physical Volume，PV）</strong></p><ul><li><strong>定义</strong>：物理卷是硬盘上的实际存储设备或存储设备的分区，是 LVM 的最底层组成部分。它们可以是整个磁盘、磁盘分区或 RAID 设备。</li><li><strong>作用</strong>：物理卷提供了实际存储空间，供卷组（Volume Group，VG）使用。</li><li><strong>创建</strong>：通过 <code>pvcreate</code> 命令可以将一个物理存储设备初始化为物理卷。</li><li><strong>标识</strong>：物理卷在系统中通过设备文件标识，例如 <code>/dev/sda1</code>、<code>/dev/sdb1</code>。</li></ul><p><strong>逻辑卷（Logical Volume，LV）</strong></p><ul><li><strong>定义</strong>：逻辑卷是 LVM 提供的一个虚拟存储设备，用户和应用程序可以将其视为一个普通分区。逻辑卷建立在卷组之上，卷组则由物理卷组成。</li><li><strong>作用</strong>：逻辑卷用于存储数据，并提供了灵活的存储管理功能，如动态调整大小、创建快照等。</li><li><strong>创建</strong>：通过 <code>lvcreate</code> 命令可以在卷组中创建逻辑卷。</li><li><strong>标识</strong>：逻辑卷在系统中也通过设备文件标识，例如 <code>/dev/mapper/centos-home</code> 或 <code>/dev/centos/home</code>。</li></ul><p><strong>卷组（Volume Group，VG）</strong></p><ul><li><strong>定义</strong>：卷组是 LVM 中的中间层，它将多个物理卷聚合成一个统一的存储池。</li><li><strong>作用</strong>：卷组将物理卷的存储空间进行管理和分配，并为逻辑卷提供存储空间。</li><li><strong>创建</strong>：通过 <code>vgcreate</code> 命令可以创建卷组，并将物理卷加入到卷组中。</li></ul><p><strong>总结</strong></p><ul><li><strong>物理卷（PV）</strong>：实际存储设备或其分区，是 LVM 的最基础组成部分。</li><li><strong>卷组（VG）</strong>：由多个物理卷组成的存储池，用于管理和分配存储空间。</li><li><strong>逻辑卷（LV）</strong>：虚拟存储设备，建立在卷组之上，提供灵活的数据存储和管理功能。</li></ul><p>这种层次结构使得 LVM 可以提供高度灵活的存储管理，允许在不影响数据的情况下调整存储空间的分配和使用。</p><p><strong>图示关系</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[物理卷 PV1]   [物理卷 PV2]   [物理卷 PV3]</span><br><span class="line">      |             |             |</span><br><span class="line">      +-------------+-------------+</span><br><span class="line">                    |</span><br><span class="line">                [卷组 VG]</span><br><span class="line">                    |</span><br><span class="line">         +----------+----------+</span><br><span class="line">         |                     |</span><br><span class="line">  [逻辑卷 LV1]           [逻辑卷 LV2]</span><br></pre></td></tr></table></figure><p>现在我们可以查看 /dev/mapper/centos-home 这个逻辑卷的情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvdisplay /dev/mapper/centos-home</span><br><span class="line">lvdisplay /dev/centos/home  <span class="comment">#这样也是可以的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能学习</title>
      <link href="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>学习路线图</h1><p>用一张黑马的图来看看具体有些什么东西吧</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240523114703098.png" alt="image-20240523114703098"></p><h1>术语</h1><h2 id="参数-parameters">参数 (Parameters)</h2><p>参数是模型在训练过程中通过数据学习得到的值。这些值直接影响模型的预测能力。不同类型的模型有不同的参数。例如：</p><ul><li><strong>线性回归</strong>中的参数是回归系数（权重）和偏置项。</li><li><strong>神经网络</strong>中的参数是权重和偏置项。</li></ul><p>在模型训练过程中，这些参数通过优化算法（如梯度下降）进行调整，以最小化损失函数，从而提高模型的预测精度。</p><h2 id="超参数-hyperparameters">超参数 (Hyperparameters)</h2><p>超参数是在模型训练之前设置的值，它们不会在训练过程中通过数据学习到，而是需要通过实验或交叉验证等方法来选择。超参数控制模型的训练过程和模型的复杂度。常见的超参数包括：</p><ul><li><strong>学习率</strong>（learning rate）：控制梯度下降算法中步长的大小。</li><li><strong>正则化参数</strong>（regularization parameters）：控制正则化项的强度，以防止过拟合。</li><li><strong>决策树中的深度</strong>（depth of decision tree）：控制树的最大深度。</li><li><strong>神经网络中的隐藏层数</strong>（number of hidden layers）和每层的神经元数目（number of neurons per layer）。</li></ul><h3 id="参数和超参数的区别">参数和超参数的区别</h3><ol><li><p><strong>学习方式</strong>：</p><ul><li><strong>参数</strong>：通过训练数据学习得到。</li><li><strong>超参数</strong>：通过先验知识、实验或交叉验证设置。</li></ul></li><li><p><strong>调节方式</strong>：</p><ul><li><strong>参数</strong>：通过优化算法（如梯度下降）自动调整。</li><li><strong>超参数</strong>：通常需要人工设定，使用网格搜索、随机搜索或贝叶斯优化等方法进行调节。</li></ul></li></ol><p>在实际操作中，超参数的选择往往需要大量的实验和调优，以找到最佳的模型配置，从而获得最佳的性能。</p><h2 id="损失函数">损失函数</h2><p>损失函数（Loss Function）是用于衡量机器学习模型的预测结果与实际结果之间差异的一种函数。它是模型训练过程中的核心要素，因为它提供了一个衡量标准来评估模型的表现，并指导模型的优化和更新。通过最小化损失函数的值，模型可以提高其预测的准确性和性能。</p><h1>机器学习</h1><p>机器学习（Machine Learning，简称ML）是一种人工智能（Artificial Intelligence，简称AI）技术，<strong>它使计算机能够从数据中自动学习和改进，而无需明确编程</strong>。机器学习涉及算法和统计模型的开发，这些算法和模型可以分析和识别数据中的模式，并根据这些模式进行预测或决策。机器学习的主要类型包括：</p><ol><li><strong>监督学习</strong>：在这种方法中，模型在包含输入和输出的已标记数据集上进行训练，学习从输入映射到输出的关系。</li><li><strong>无监督学习</strong>：在这种方法中，模型在未标记的数据集上进行训练，目标是发现数据中的隐藏模式或结构。</li><li><strong>半监督学习</strong>：结合监督和无监督学习的方法，使用少量已标记数据和大量未标记数据进行训练。</li><li><strong>强化学习</strong>：通过试错法进行学习，模型通过与环境交互并获得反馈（奖励或惩罚）来优化其行为。</li></ol><blockquote><p>我对机器学习的理解在于,  给计算机数据, 让它找到里面的隐藏规律,  我们不需要知道这个规律, 但是我们可以使用这个规律做很多事情, 比如预测, 决策</p></blockquote><p>人工智能的难点在于 黑盒型, 以及难以掌握性, 它不像传统的数据结构算法, 传统的算法是很明确的, 我们是能一步步验证的, 但是人工智能的算法通常很难自己一步步验证, 一步步看效果,  虽然我们可以评估它, 但我们对他训练出来的规律是那种看不透抓不着的感觉</p><h2 id="主要难点">主要难点</h2><ol><li><strong>黑盒性</strong>：许多机器学习算法，尤其是深度学习模型，内部机制复杂且难以解释。这使得我们难以理解模型是如何做出决策的。</li><li><strong>可解释性</strong>：传统算法的每一步都是明确的，可以追踪和调试，而<strong>机器学习模型，特别是复杂的神经网络，很难逐步验证每一步的效果。</strong></li><li><strong>训练过程的不可预测性</strong>：机器学习模型的训练过程涉及大量的参数调整和数据处理，结果可能具有高度的不确定性和不可预测性。</li><li><strong>数据依赖性</strong>：模型的性能严重依赖于训练数据的质量和数量，不同的数据集可能导致完全不同的模型行为。</li></ol><h2 id="线性回归">线性回归</h2><h3 id="定义">定义</h3><p>用于预测一个目标变量（通常称为因变量）与一个或多个特征变量（自变量）之间的关系。<strong>线性回归模型假设目标变量与特征变量之间存在线性关系，即目标变量可以表示为特征变量的线性组合。</strong></p><h3 id="模型求解">模型求解</h3><p>线性回归模型的目标是通过最小化误差平方和来求解模型参数，使得模型的预测值尽可能接近实际观测值**。直观上，我们希望误差平方和越小越好，这样模型的拟合效果就越好。**</p><p>在统计学领域，为了形式化这种思想，我们引入了条件概率的概念。我们假设在给定模型参数和自变量的情况下，<strong>预测值与真实值之间的关系可以表示为一个条件概率。具体来说，给定模型参数和自变量，预测值等于真实值的概率应该最大化</strong>。</p><blockquote><p>这里一般是选择正态分布概率模型, 我们其实也可以根据需要使用其他概率模型, 比如后续的逻辑分布就是另外的一个模型</p></blockquote><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240526123421526.png" alt="image-20240526123421526"></p><p>为了实现这一目标，我们使用似然函数，即所有数据点的条件概率乘积。我们希望最大化似然函数，从而找到最优的模型参数。由于直接最大化似然函数通常比较复杂，我们常常取对数来简化计算过程，这样目标变为最大化对数似然函数。</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240526123439154.png" alt="image-20240526123439154"></p><h4 id="最小二乘法">最小二乘法</h4><p>最小二乘法是直接通过公式推导, 然后直接用自变量和因变量推导出来参数的过程,  这就没有体现出来学习的过程, 而且如果公式中的矩阵不可逆,最小二乘法也不能使用了, 下面是他的推导过程</p><p>对对数似然函数中的参数求偏导:</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240526123546030.png" alt="image-20240526123546030"></p><h4 id="梯度下降">梯度下降</h4><p>梯度下降是一种迭代优化算法，通过计算损失函数的梯度，并沿着梯度的反方向逐步更新参数，以找到最小值</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240526152737556.png" alt="image-20240526152737556"></p><ol><li>批量梯度下降: 在每次迭代中使用整个训练数据集来计算梯度并更新参数。</li><li>随机梯度下降</li><li>小批量梯度下降</li></ol><h4 id="最小二乘法和梯度下降对比">最小二乘法和梯度下降对比</h4><p>最小二乘法是一种解析方法，通过最小化预测值与实际值之间误差的平方和来拟合模型参数。</p><p>梯度下降是一种迭代优化算法，通过计算损失函数的梯度，并沿着梯度的反方向逐步更新参数，以找到最小值。</p><ol><li><strong>计算方式</strong>：<ul><li>最小二乘法：通过解析方法一次性求解。</li><li>梯度下降：通过迭代方法逐步逼近最优解。</li></ul></li><li><strong>适用范围</strong>：<ul><li>最小二乘法：适用于线性、小规模数据集问题。</li><li>梯度下降：适用于线性、非线性、大规模数据集和复杂模型。</li></ul></li><li><strong>计算复杂度</strong>：<ul><li>最小二乘法：高（需要矩阵求逆）。</li><li>梯度下降：相对低（每次迭代计算量小）。</li></ul></li><li><strong>灵活性</strong>：<ul><li>最小二乘法：低，局限于特定条件下使用。</li><li>梯度下降：高，广泛适用于各种优化问题。</li></ul></li></ol><h3 id="多项式回归">多项式回归</h3><p>多项式回归是一种用于处<strong>理变量间非线性关系的回归分析方法</strong>。它通过为模型引入自变量的高次项，比如平方或立方项，使模型能够拟合更复杂的数据形态。这种方法的关键在于它实质上仍然是线性回归的一个扩展，因为这些高次项被视作新的独立变量。这样，多项式回归就能使用标准的线性回归技术来解决。</p><p>在实际应用中，多项式回归模型的选择很重要，模型的复杂度（即多项式的最高次数）需要仔细选择以避免过拟合，即模型在训练集上表现出色但在新的数据集上表现不佳的情况。过拟合是多项式回归中常见的问题，特别是在模型阶数较高时。</p><p>为了解决过拟合问题，可以采用正则化技术，如岭回归和Lasso回归。岭回归通过添加一个与系数平方成正比的惩罚项（L2正则化）来控制系数的大小，而Lasso回归通过添加一个与系数绝对值成正比的惩罚项（L1正则化），不仅减少系数大小，还能实现系数的稀疏化，即某些系数可能变为零，从而简化模型。</p><p>总的来说，多项式回归是一种强大的工具，适用于揭示变量之间复杂的非线性关系。然而，选择合适的模型复杂度和采用适当的正则化方法是保证模型泛化能力和避免过拟合的关键。</p><h2 id="逻辑回归">逻辑回归</h2><p>逻辑回归是一种统计学中的回归分析方法，用于处理因变量是分类变量的情况。<strong>它主要用于二分类问题</strong>，即因变量只有两个可能的结果（例如，是或否、成功或失败）。逻辑回归通过使用一个或多个自变量来预测一个事件发生的概率。</p><blockquote><p>逻辑回归可以实现多分类,  但是思想还是二分类,  就是将多分类问题看成多个二分类就行</p></blockquote><p>逻辑回归的核心思想是，<strong>它不直接预测分类结果，而是预测结果发生的概率</strong>。这是通过使用逻辑函数（或称为sigmoid函数）实现的，该函数输出一个介于0到1之间的值，表示概率。</p><blockquote><p>标签中谁是1, 这个模型得到概率就代表 分类结果是他的概率是多少</p></blockquote><h3 id="求解">求解</h3><p>选择sigmoid函数作为模型,  应为他的函数值就0-1之间, 而且也覆盖了全部的自变量值</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240603193844435.png" alt="image-20240603193844435"></p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240603193927448.png" alt="image-20240603193927448"></p><p>这里h(x)还是代表在当前x,参数下,  y预测值与真实值相同的概率是多少,  还是利用最大似然函数,  我们希望得到的参数尽可能的让所有点概率比较大</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240603194142698.png" alt="image-20240603194142698"></p><p>接着就是求导这些</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240603194236896.png" alt="image-20240603194236896"></p><p>然后我们就可以使用梯度下降算法来解这个题目了, 是不是就很熟悉</p><p><img src="/2024/05/23/python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0/../img/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0assets/image-20240603194311527.png" alt="image-20240603194311527"></p><p>在多分类中,    标签的一个维度代表数据量,  一个维度代表分类个数,    参数中 一个维度代表分类个数, 一个维度代表分类个数</p><h2 id="聚类">聚类</h2><p>聚类（Clustering）是一种无监督学习技术，它的目的是将数据集中的对象分成若干个簇（Clusters），使得同一簇内的对象彼此之间的相似性尽可能大，而不同簇之间的对象的相似性尽可能小。聚类广泛应用于数据挖掘、图像处理、模式识别、市场分析等领域。</p><h3 id="聚类的基本概念">聚类的基本概念</h3><ol><li><strong>簇（Cluster）</strong>：簇是指在某种相似度或距离度量标准下，相互接近或相似的一组数据点。</li><li><strong>相似度度量</strong>：用于衡量数据点之间的相似性或距离。常见的度量方法有欧氏距离、曼哈顿距离、余弦相似度等。</li><li><strong>簇中心（Centroid）</strong>：在一些聚类算法中，每个簇都有一个中心点，代表该簇的中心位置。</li></ol><h3 id="常见的聚类算法">常见的聚类算法</h3><h4 id="1-k均值聚类-k-means-clustering">1. K均值聚类（K-Means Clustering）</h4><p>K均值聚类是一种迭代算法，其目标是将数据集划分为K个簇，每个簇由其簇中心代表。基本步骤如下：</p><ul><li>初始化K个簇中心。</li><li>将每个数据点分配到最近的簇中心，形成K个簇。</li><li>重新计算每个簇的簇中心，即所有簇内数据点的平均值。</li><li>重复上述步骤，直到簇中心不再变化或达到最大迭代次数。</li></ul><h4 id="2-层次聚类-hierarchical-clustering">2. 层次聚类（Hierarchical Clustering）</h4><p>层次聚类通过构建树状的聚类结构（树状图或树状结构）来实现数据点的分层聚类。它有两种主要方法：</p><ul><li><strong>自底向上（凝聚）</strong>：从每个数据点开始，将最相似的簇合并，直到所有数据点聚合成一个簇。</li><li><strong>自顶向下（分裂）</strong>：从一个包含所有数据点的大簇开始，逐步将其分裂为更小的簇，直到每个数据点单独成为一个簇。</li></ul><h4 id="3-dbscan-density-based-spatial-clustering-of-applications-with-noise">3. DBSCAN（Density-Based Spatial Clustering of Applications with Noise）</h4><p>DBSCAN是一种基于密度的聚类算法，能够发现任意形状的簇，并识别噪声点。它定义了以下概念：</p><ul><li><strong>核心点（Core Point）</strong>：在给定半径内包含至少指定数量数据点的点。</li><li><strong>边界点（Border Point）</strong>：不满足核心点条件，但在某个核心点的半径内。</li><li><strong>噪声点（Noise Point）</strong>：既不是核心点也不是边界点的点。</li></ul><h4 id="4-均值漂移聚类-mean-shift-clustering">4. 均值漂移聚类（Mean Shift Clustering）</h4><p>均值漂移是一种基于密度的非参数聚类算法，通过平滑的密度估计来识别簇中心。它通过在特征空间中迭代移动数据点，直到所有点收敛到密度峰值位置，从而形成簇。</p><h3 id="聚类的应用">聚类的应用</h3><ul><li><strong>图像分割</strong>：将图像中的像素点聚类为不同的区域，进行图像分割和对象识别。</li><li><strong>市场细分</strong>：将客户分为不同的群体，以便进行个性化营销策略。</li><li><strong>文档聚类</strong>：将文档按主题进行分类，以便于信息检索和组织。</li><li><strong>异常检测</strong>：识别数据集中与其他数据点显著不同的异常点。</li></ul><h3 id="结论">结论</h3><p>聚类是一种强大的无监督学习方法，通过将数据分组为若干簇，揭示数据内在结构和相似性。不同的聚类算法适用于不同类型的数据和应用场景，选择合适的聚类方法是实现有效数据分析的关键。</p><h2 id="决策树">决策树</h2><p>算法思路: 依照某个特征值将当前节点数据划分开来,  删除这个特征, 继续递归划分开来的数据,  如果只有一个数据, 或者数据中的标签全部相同划分结束, 且值为众数</p><p>如何选择某个特征值,  需要先了解一下熵</p><p>熵:  代表当前混乱程度,   我们用熵值来衡量他, 越大越混乱 ,   计算方法是  (-样本概率*log样本概率)累加和</p><p>如果某个特征划分之后,  熵值是最低的(也可以使用其他评估标准), 那么就选择这个特征来划分</p><h1>数据预处理</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yolo8环境搭建</title>
      <link href="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/"/>
      <url>/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>安装miniconda</h1><p>找到<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">地址</a>, 下载对应版本, 我这里选择Windows 以及 python3.8</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240517162538114.png" alt="image-20240517162538114"></p><p>下载后安装, 记得勾选添加到环境变量, 这样就能在控制台使用conda</p><h1>创建yolov8虚拟环境</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov8 python=3.9</span><br></pre></td></tr></table></figure><p>激活和退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate yolov8  </span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240517162805770.png" alt="image-20240517162805770"></p><h1>安装pytorch</h1><p>首先先激活使用虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate yolov8  </span><br></pre></td></tr></table></figure><p>找到显卡版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240518114237604.png" alt="image-20240518114237604"></p><p>安装pytorch</p><p>去<a href="https://pytorch.org/get-started/previous-versions/">官网</a>搜索找到自己对应的版 我这里是11.0</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240521205920583.png" alt="image-20240521205920583"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==1.12.0 torchvision==0.13.0 torchaudio==0.12.0 cudatoolkit=10.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br></pre></td></tr></table></figure><h1>安装yolov8</h1><h2 id="pip直接安装">pip直接安装</h2><p>这种安装方式无法修改源码, 不推荐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ultralytics</span><br></pre></td></tr></table></figure><p>然后可以命令行使用它, 也能在代码中import它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolo predict model=yolov8n.pt source=&#x27;https://ultralytics.com/images/bus.jpg&#x27;</span><br></pre></td></tr></table></figure><p>这里就不使用这种方式安装, 就卸载掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall ultralytics</span><br></pre></td></tr></table></figure><h2 id="pip源码安装">pip源码安装</h2><p>使用git将源码克隆下来, 也可以下载压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/ultralytics.git</span><br></pre></td></tr></table></figure><p>然后进入目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ultralytics</span><br></pre></td></tr></table></figure><p>执行下面命令安装, 这样做的目的是更改库源码目录到这里, 然后我们修改了这里的源码, 就会对其他引用yolo库目录的项目起作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><blockquote><p>这样既可以使用源码也可以使用命令行</p></blockquote><p>使用pip list 就能查看了</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240521212543909.png" alt="image-20240521212543909"></p><p>这里显示ultralytics库在我们自己的目录下</p><h1>安装cuda</h1><p>如果我们想要显卡来跑项目, 就需要安装cude,  去到这个<a href="https://developer.nvidia.com/cuda-toolkit-archive">地址</a>, 根据前面自己的显卡版本选择cuda版本</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240524150734937.png" alt="image-20240524150734937"></p><p>找到里面的本地安装吧, 感觉好一点</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240524150917023.png" alt="image-20240524150917023"></p><p>然后进入界面安装即可, 但是网上说这里有个问题, 可以去看看, <a href="https://blog.csdn.net/weixin_43062964/article/details/127888350">地址</a>, 是跟vs一些相关的,  如果安装过了vs系列桌面开发环境的应该就没什么,  取消勾选这两个</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240524161154988.png" alt="image-20240524161154988"></p><p>安装完成后建议重启电脑, windows这个傻逼控制台有时候不能及时更新环境变量</p><p>检测是否安装成功(这个检测并不准确)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>我们只需要去到安装目录查看是否有这些东西</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240524162607381.png" alt="image-20240524162607381"></p><p>进入extra/demo_suite , 然后再控制台运行这个程序</p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240524162648845.png" alt="image-20240524162648845"></p><p><img src="/2024/05/17/python/yolo8%E5%AE%89%E8%A3%85/../img/yolo8%E5%AE%89%E8%A3%85assets/image-20240524162726139.png" alt="image-20240524162726139"></p><p>这样就安装成功了</p><h1>安装CUDNN</h1><h1>yolo使用GPU</h1><p>通过下面代码可以看是否能够检测到GPU</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 CUDA 是否可用</span></span><br><span class="line">cuda_available = torch.cuda.is_available()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;CUDA available: <span class="subst">&#123;cuda_available&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 GPU 的数量</span></span><br><span class="line">cuda_device_count = torch.cuda.device_count()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;CUDA device count: <span class="subst">&#123;cuda_device_count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有可用的 GPU，打印每个 GPU 的名称</span></span><br><span class="line"><span class="keyword">if</span> cuda_device_count &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cuda_device_count):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;CUDA device <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;torch.cuda.get_device_name(i)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No CUDA device detected.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果检测不到,  可能是torch的一些问题, 需要使用对的版本, 我也是更新后才能检测到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu110</span><br></pre></td></tr></table></figure><p>使用GPU来跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from ultralytics import YOLO</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># 检查是否有可用的 GPU</span><br><span class="line">device = torch.device(&#x27;cuda&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)</span><br><span class="line">print(f&quot;Using device: &#123;device&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 加载模型并将其移动到 GPU（如果有的话）</span><br><span class="line">model = YOLO(&#x27;yolov8n.pt&#x27;).to(device)</span><br><span class="line"></span><br><span class="line"># 训练模型，指定数据配置文件，并设置使用 GPU</span><br><span class="line">model.train(data=&#x27;data.yaml&#x27;, workers=0, epochs=20, batch=8, device=device)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>额外安装包</h1><p>requirements文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy</span><br><span class="line">tqdm</span><br><span class="line">pandas</span><br><span class="line">opencv-python</span><br></pre></td></tr></table></figure><h1>参考文档</h1><ol><li><a href="https://blog.csdn.net/weixin_43062964/article/details/127888350">https://blog.csdn.net/weixin_43062964/article/details/127888350</a></li><li><a href="https://blog.csdn.net/qq_53817374/article/details/135854702">https://blog.csdn.net/qq_53817374/article/details/135854702</a></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows程序设计</title>
      <link href="/2024/05/08/C%E5%92%8CC++/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/05/08/C%E5%92%8CC++/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>基础知识</h1><h2 id="字符集">字符集</h2><p>我觉得字符集这里要分为两个部分:</p><ol><li>字符集编码: 一个字符对应一个数字值, 不同的字符集对应的编码是不一样的 比如 ascll 编码 和 Unicode 和 ansi</li><li>编码方案:  如何转换计算机里面的字节数据到编码 比如 Unicode的转换就有 UTF-8 UTF-16 UTF-32</li></ol><p>asni编码 根据不同国家对应的编码方案是不同的, 字符集也不同</p><h2 id="字符和宽字符">字符和宽字符</h2><p>宽字符使用Unicode编码 统一两个字节 字符的话一般使用多字节编码ansi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wchar* &quot;c语言&quot;  // 在Unicode下面这个是8字节</span><br><span class="line">char* &quot;c语言&quot; // 在ansi  里面是6字节 c一个 \0 一个 其他都是双字节</span><br></pre></td></tr></table></figure><p>注意区分代码编码  和 变量本身编码  这是两个不同的东西,  代码的编码取决于你的选择, 但是变量的编码一般不是你决定的,  但是你的代码编码会影响到变量里面的值</p><p>比如 你的代码文件采用的是asni  但是对于 wchar* “c语言”  文件里面它是6字节  但是内存里面它是8字节 (可以这样理解),  如果代码文件编码与变量编码不一致 就会出现很大的问题了没准 “c语言” 就变成其他东西饿了</p><h3 id="tchar">TCHAR</h3><p>windows为了可以使用这个东西 实现程序的两套编码版本,  一个是ansi 一个是 Unicode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef  UNICODE</span><br><span class="line">    typedef WCHAR  TCHAR, *PTCHAR;</span><br><span class="line">#else</span><br><span class="line">    typedef CHAR   TCHAR, *PTCHAR;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>搭配TEXT宏就很完美</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef  UNICODE</span><br><span class="line">    #define __TEXT(quote) L##quote</span><br><span class="line">#else</span><br><span class="line">    #define __TEXT(quote) quote</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define  TEXT(quote)  __TEXT(quote)</span><br></pre></td></tr></table></figure><p>这样就演化出不同的字符串指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef char CHAR;</span><br><span class="line"></span><br><span class="line">typedef _Null_terminated_ CHAR          *NPSTR, *LPSTR, *PSTR;</span><br><span class="line">typedef _Null_terminated_ CONST  CHAR   *LPCSTR, *PCSTR;</span><br><span class="line"></span><br><span class="line">typedef _Null_terminated_ WCHAR         *NWPSTR, *LPWSTR, *PWSTR;</span><br><span class="line">typedef _Null_terminated_ CONST  WCHAR  *LPCWSTR, *PCWSTR;</span><br><span class="line"></span><br><span class="line">#ifdef  UNICODE</span><br><span class="line">    typedef LPWSTR   PTSTR,  LPTSTR;</span><br><span class="line">    typedef LPCWSTR  PCTSTR, LPCTSTR;</span><br><span class="line">#else</span><br><span class="line">    typedef LPSTR    PTSTR, LPTSTR, PUTSTR, LPUTSTR;</span><br><span class="line">    typedef LPCSTR   PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>所以我们尽量使用 TCHAR 变量类型   TEXT 转换字符串字面值  LPTSTR LPCTSTR(常量) 字符串指针</p><blockquote><p>对于 PTSTR  和 LPTSTR  是为了兼容以前的版本  以前有长指针 和 指针的区别  现在都一样了</p></blockquote><h3 id="字符串函数">字符串函数</h3><p>为了让wchar和char使用字符串函数使用起来统一 Windows提供了很多  _t 开头的函数 比如 _tprintf  _tcscat_s  等等</p>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式">设计模式</h2><h3 id="一-创建型模式">一 创建型模式</h3><p>创建对象时隐藏创建逻辑,而不是直接使用new的方式创建对象,可以根据程序判定创建什么样的对象,这样会很灵活</p><h4 id="1-工厂模式">1.工厂模式</h4><p>在工厂模式中,不对外暴露对象创建的过程,用户需要什么跟工厂要就行.</p><p>优点:</p><ul><li>不需要知道产品内部实现细节,只需要知道产品对应的接口能干嘛就行</li><li>扩展性高,增加一类产品只需要多写一个工厂类就行</li></ul><p>缺点:</p><ul><li>每次创建一类产品,都需要增加一个工厂类,而多增加一个产品,需要更改工厂类的代码</li></ul><p>举例说明:</p><p>​我们买车只需要直接告诉造车工厂我们需要什么车就行,不需要知道车怎么造出来的,如果我们需要买飞机,我们就需要告诉造飞机的工厂,</p><p>​车:接口</p><p>​奥迪:具体实现类</p><p>​造车工厂:工厂类</p><p>​我们知道车可以干嘛,然后我们可以根据喜欢向工厂要什么样的车.</p><p>​每多一个接口,就需要多 一个工厂类,每多一个具体实现类,工厂类里面就需要多些一段代码.</p><p>何时使用:  明确知道不同条件下需要创建什么对象,如果创建对象本来就很简单,我们还是直接new比较好</p><h4 id="2-抽象工厂模式">2.抽象工厂模式(---------)</h4><p>抽象工厂是工厂的工厂,它可以创建工厂类对象,创建的工厂又可以提供创建用户需要对象的功能</p><p>优点:</p><ul><li>保证用户使用的都是一类产品</li></ul><p>缺点:</p><ul><li>扩展新的工厂比较麻烦,需要为抽象工厂添加新方法,每个具体工厂也得实现这个方法(虽然不干嘛)</li></ul><p>抽象工厂模式其实也是工厂模式,只不过抽象工厂创建的是工厂,工厂创建的是产品</p><h4 id="3-单例模式">3.单例模式</h4><p>私有化构造器,保证全局只有一个对象</p><p>创建单例的几种方法:</p><ol><li>懒汉式</li><li>饿汉式</li><li>双重校验锁(其实也是懒汉式)</li><li>枚举</li><li>静态内部类(里面编写一个静态内部类,添加一个属性赋值为单例对象)</li></ol><h4 id="4-建造者模式">4.建造者模式</h4><p>通过一步一步构建,创造出对象,与工厂模式的区别:更加关注装配的顺序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统镜像还原</title>
      <link href="/2024/01/07/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E8%BF%98%E5%8E%9F/"/>
      <url>/2024/01/07/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<ol><li>实模式下的中断向量 占4个字节   段基址+段偏移地址(中断处理程序地址)   中断向量表最多1024 字节,  因此最多256中断处理程序</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于电脑的一些基本硬件</title>
      <link href="/2023/12/19/%E7%A1%AC%E4%BB%B6/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/12/19/%E7%A1%AC%E4%BB%B6/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>最近本人心血来潮想自己diy主机玩玩,  然后呢我只知道电脑需要些什么,  但是他们的型号啊, 搭配关系啊, 我是完全不知道的, 因此就记录一下</p><h1>主板</h1><p>主板型号通常由几个部分组成，每个部分代表不同的信息，帮助用户了解主板的规格和功能。以下是主板型号中常见的组成部分及其含义：</p><h3 id="1-品牌名称">1. <strong>品牌名称</strong></h3><ul><li>代表主板的制造商或品牌，例如华硕（ASUS）、技嘉（Gigabyte）、微星（MSI）等。品牌名称通常是型号的第一个部分，用来识别主板的生产厂商。</li></ul><h3 id="2-芯片组代号">2. <strong>芯片组代号</strong></h3><ul><li>芯片组是主板的核心部分之一，<strong>影响主板的性能和功能支持</strong>。常见的芯片组代号是字母和数字的组合，表示主板采用的芯片组类型。</li><li><strong>例子：</strong><ul><li>Intel平台：Z790、B660、H510 等（Z代表高端，B和H则代表中低端）。</li><li>AMD平台：X670、B550、A320 等（X代表高端，B和A表示中低端）。</li></ul></li></ul><h3 id="3-平台和处理器代号">3. <strong>平台和处理器代号</strong></h3><ul><li>有时型号中会包含与支持的处理器类型或平台相关的信息。特别是在不同代数的CPU出现时，主板厂商会区分主板型号。例如，Intel的 LGA 1700 或 AMD 的 AM5 插槽。</li><li><strong>例子：</strong><ul><li>Intel：LGA1151、LGA1200、LGA1700</li><li>AMD：AM4、AM5</li></ul></li></ul><h3 id="4-规格和扩展功能">4. <strong>规格和扩展功能</strong></h3><ul><li>该部分通常是字母与数字的组合，用来表示主板的规格，扩展能力，或者是特定的功能。例如是否支持 Wi-Fi、主板尺寸（ATX、Micro ATX、Mini ITX）等。</li><li><strong>例子：</strong><ul><li><strong>-F、-A、-P</strong>：表示不同的功能，比如“F”可能代表带有更强的风扇支持或网络功能，“A”表示具有基本功能的型号。</li><li><strong>WiFi</strong>：表示该主板支持内置Wi-Fi功能。</li><li><strong>ATX、mATX、Mini-ITX</strong>：表示主板的尺寸标准，ATX是标准尺寸，mATX是微型，Mini-ITX是迷你版。</li></ul></li></ul><h3 id="5-代数和版本号">5. <strong>代数和版本号</strong></h3><ul><li>有时候型号会有一个数字或字母用来表示主板的代数或版本。这个部分通常位于主板名称的后面，用来区分不同代际产品。</li><li><strong>例子：</strong><ul><li>PRIME Z790-A 和 PRIME Z790-A II，其中“II”表示该型号的第二版或更新版本。</li></ul></li></ul><h3 id="举个例子：">举个例子：</h3><ul><li><strong>ASUS ROG STRIX Z790-E GAMING WIFI</strong><ul><li><strong>ASUS</strong>：品牌名称，表示这是华硕的主板。</li><li><strong>ROG STRIX</strong>：系列名称，表示该主板是华硕ROG（玩家国度）系列中的STRIX系列，专为游戏玩家设计。</li><li><strong>Z790</strong>：表示主板使用的是Intel Z790芯片组，支持Intel第12代或第13代处理器。</li><li><strong>E</strong>：常用于表示主板的功能级别，“E”通常意味着比“A”更高端。</li><li><strong>GAMING</strong>：表示这是为游戏设计的主板。</li><li><strong>WIFI</strong>：表示主板带有内置Wi-Fi功能。</li></ul></li></ul><p>总结来说，主板型号由品牌、芯片组、平台、规格功能以及版本等组成，每个部分都有特定的含义，帮助用户快速识别主板的功能定位和适配性。</p><h1>CPU</h1><p>CPU主要是AMD 和 Intel,  我这里能就只讨论AMD 和 Intel的 后面那一串数字和字母是什么意思</p><h2 id="intel">Intel</h2><p>Intel CPU的型号通常包含一系列的数字和字母，每个部分都有特定的含义。下面是一些主要部分的解析：</p><ol><li><p><strong>品牌前缀</strong>：大多数Intel CPU以品牌前缀开头，例如：</p><ul><li>Core：高性能，面向普通消费者和专业人士（如Core i3, Core i5, Core i7, Core i9）。</li><li>Pentium和Celeron：预算友好型号，适用于基本任务。</li><li>Xeon：专为服务器和高级工作站设计。</li></ul></li><li><p><strong>品牌修饰符</strong>：这是Core系列的一部分，表示处理器的性能等级。i3是入门级，适合基本任务；i5是中级，适合大多数用户；i7和i9是高级选项，提供更高的性能，适合要求高的应用程序和游戏。<strong>如果其他数字和字母相同，那么品牌修饰符（如i3、i5、i7、i9）中的数字越大，通常意味着更高的性能</strong></p></li><li><p><strong>代数指示符</strong>：这是一个四位数字序列的第一个数字，它表示CPU所属的代数。例如，Core i7-10700K中的&quot;10&quot;表示第10代Intel Core。<strong>如果其他数字和字母相同,代数越高,性能可能会越好</strong></p></li><li><p><strong>SKU数字</strong>：在代数指示符之后的三位数字通常是SKU数字，它们进一步区分同一代内的不同处理器。</p></li><li><p><strong>产品线后缀</strong>：这些字母提供了有关处理器特性的额外信息：</p><ul><li><strong>K</strong>：代表可超频。</li><li><strong>U</strong>：代表超低功耗，常见于轻薄笔记本。</li><li><strong>Y</strong>：代表极低功耗，用于超轻薄设备。</li><li><strong>H</strong>：代表高性能移动版，常用于游戏笔记本和移动工作站。</li><li><strong>G</strong>：带有较强的集成图形处理器(<strong>核显</strong>)。</li><li><strong>T</strong>：代表低功耗版，适用于节能台式机。</li><li><strong>S</strong>：性能优化版。</li><li><strong>X</strong>：代表极端性能，用于高端台式机。</li></ul></li><li><p><strong>其他特殊后缀</strong>：</p><ul><li>F：没有集成图形处理器。</li><li>P：较低的集成图形性能。</li></ul></li></ol><p>例如，Intel Core i7-10700K：</p><ul><li>“i7” 表示这是Core i7系列，意味着高性能。</li><li>“10” 代表这是第10代Intel Core。</li><li>“700” 是SKU编号，区分同代其他型号。</li><li>“K” 表明这款处理器可以超频。</li></ul><p>不同代的Intel处理器可能会在这个命名模式上有所变化，但以上是最常见的命名规则。</p><h1>显卡</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自制操作系统</title>
      <link href="/2023/10/17/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/17/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>启动</h1><h2 id="bios">BIOS</h2><p>basic input output system  基本输入输出系统</p><p>BIOS启动流程:  加电自检,  然后读出启动盘的第一个扇区 到 0x7c00 位置  然后调整到 0x7c00位置执行代码,   这个时候把执行权限交给我们,  我们需要将代码写入到第一个扇区, 然后将操作系统加载到内存中</p><p>此时CPU处于的模式是在实模式下 ,  在这个模式下我们能够直接操作内存, 想怎么操作怎么操作,  但是只有1M的寻址空间</p><h1>中断</h1><h2 id="中断处理流程">中断处理流程</h2><ol><li><strong>中断产生和检测</strong>：<ul><li>当外部设备或其他源产生中断信号时，外部中断控制器（如PIC或APIC）负责接收这些信号。</li><li>当CPU完成当前执行的指令后，它会检查中断控制器是否标记了任何待处理的中断。</li></ul></li><li><strong>中断向量和中断服务例程（ISR）的查找</strong>：<ul><li>如果中断被允许（即处理器的中断标志IF位为1），CPU会从中断控制器获取一个中断向量号。</li><li>使用这个中断向量号，CPU会查找IDT（中断描述符表），以确定相应的中断服务例程的地址。</li></ul></li><li><strong>状态保存和中断响应</strong>：<ul><li>在跳转到中断服务例程之前，CPU自动保存当前的代码段寄存器（CS）和指令指针（IP）到堆栈中。这确保了中断处理完成后能够返回到正确的位置继续执行。</li><li>CPU同时保存状态寄存器（如EFLAGS），其中包括中断标志位。</li><li>接着，CPU会清除IF位以关闭进一步的中断，防止在处理当前中断时受到干扰。</li></ul></li><li><strong>执行中断服务例程</strong>：<ul><li>执行的中断处理函数由操作系统提供。这个函数可以根据需要保存和恢复更多的执行上下文，如寄存器等。</li><li>在某些情况下，中断服务程序可以根据设计选择重新开启中断（即在ISR中重新设置IF位），这允许嵌套中断或二级中断。</li></ul></li><li><strong>中断处理完成后的恢复与返回</strong>：<ul><li>中断服务例程完成后，执行特定的返回指令（如x86的<code>IRET</code>），这将从堆栈中恢复之前保存的IP、CS和EFLAGS等状态寄存器。</li><li>恢复这些寄存器后，CPU返回到被中断的代码继续执行。</li></ul></li></ol><p>前三步硬件自动完成</p><h2 id="实模式">实模式</h2><p>实模式下,  系统通过中断号, 在中断向量表中找到对应的中断向量, 中断向量 是由cs:ip 组成, 记录了中断处理函数的位置</p><h2 id="保护模式">保护模式</h2><p>保护模式下, 系统通过中断号, 在中断描述符表中找到中断描述符,   中断描述符中记录了很多信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">gate_t</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 offset0;    <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    u16 selector;   <span class="comment">// 代码段选择子</span></span><br><span class="line">    u8 reserved;    <span class="comment">// 保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;    <span class="comment">// 任务门/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>; <span class="comment">// segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;     <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>; <span class="comment">// 是否有效</span></span><br><span class="line">    u16 offset1;    <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br></pre></td></tr></table></figure><p>通过中断描述符就能找到中断处理函数了</p><h3 id="加载中断描述符表">加载中断描述符表</h3><p>定义中断描述符表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ENTRY_SIZE 0x30   // 这里可以根据需要更改, 这里只定义一些常用的</span><br><span class="line">gate_t idt[IDT_SIZE];</span><br></pre></td></tr></table></figure><p>中断描述符指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct pointer_t</span><br><span class="line">&#123;</span><br><span class="line">    u16 limit; </span><br><span class="line">    u32 base;</span><br><span class="line">&#125; _packed pointer_t;</span><br><span class="line">pointer_t idt_ptr;  // 中断描述符指针</span><br><span class="line">idt_ptr.base = (u32)idt;</span><br><span class="line">idt_ptr.limit = sizeof(idt)-1;</span><br></pre></td></tr></table></figure><p>加载中断描述符表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asm volatile(&quot;lidt idt_ptr\n&quot;); </span><br></pre></td></tr></table></figure><h3 id="中断函数编写思路">中断函数编写思路</h3><p>首先定义一个做验证, 和 保存上下文 和 恢复上下文的函数 handle_entry 作为中断描述符入口地址,   里面调用 handle 函数 来处理真正的中断,</p><h1>物理内存分配</h1><p>0x1000 页目录</p><p>0x2000-0x3000 内核页表  (前八兆的虚拟地址就是物理地址)</p><p>0x4000-0x40DF 内核虚拟内存位图 (一位代表一页, 第一位代表0x100000开始的那一页, 值为1代表分配了, 值为0代表未分配,  总共0x700页)</p><p>0x10000-0x101000  内核物理内存分配图(一个字节代表一页)</p><h1>疑问解答</h1><h2 id="一个物理地址是怎么到硬件的">一个物理地址是怎么到硬件的?</h2><ol><li><strong>硬件映射BIOS地址</strong>：<ul><li>系统的主板设计（尤其是芯片组的设计）固定了BIOS ROM在物理地址空间的位置。这通常是在系统的物理地址空间的高地址端。这个映射是固定的，确保在计算机启动时，CPU能够找到并执行BIOS的启动代码。CPU在复位时自动将指令指针设置到这个预定的高地址处，通常是<code>0xFFFFFFF0</code>（实模式下的<code>0xFFFF0</code>），这里的代码负责跳转到BIOS的主体部分。</li></ul></li><li><strong>BIOS映射其他硬件地址(通过芯片组)</strong>：<ul><li>在系统启动和BIOS初始化阶段，BIOS负责探测系统中的硬件（如内存、显卡、存储设备等），并进行相应的配置和初始化。在这个过程中，BIOS根据探测到的硬件配置情况来设置和调整系统资源（如IRQs, DMA, I/O端口等）的分配和物理地址空间的映射。</li><li>对于系统内存，BIOS会检测安装的内存条和配置，并设置内存控制器将物理内存映射到物理地址空间的适当位置，这通常从低地址开始。</li></ul></li></ol><h2 id="cpu如何限制用户态功能">cpu如何限制用户态功能</h2><h3 id="特权级别-rings">特权级别（Rings）</h3><p>在 x86 架构中，有四个特权级别，从 Ring 0 到 Ring 3：</p><ul><li><strong>Ring 0（内核态）</strong>：具有最高权限的执行级别，操作系统的核心部分（内核）在这个级别运行。可以访问所有的 CPU 指令和直接管理硬件资源。</li><li><strong>Ring 1 和 Ring 2</strong>：这两个级别在大多数现代操作系统中很少使用，它们为设备驱动程序和其他特定的系统代码提供了中间层的权限级别。</li><li><strong>Ring 3（用户态）</strong>：具有最低权限的执行级别，绝大多数应用程序在这个级别运行。用户态程序被限制只能执行非特权指令，且不能直接访问硬件资源。</li></ul><p>在用户程序中, 段选择子中是用户级别, 可以限制很多执行无法使用</p><h2 id="为什么中断-系统调用-可以从用户态到内核态">为什么中断(系统调用)可以从用户态到内核态</h2><h3 id="中断描述符">中断描述符</h3><p>中断描述符有下面两个属性, 一个是可以执行当前中断的特权级,  一个是执行中断的时候拥有的特权级</p><h4 id="1-dpl-descriptor-privilege-level">1. DPL（Descriptor Privilege Level）</h4><p>DPL是中断门描述符中的一个字段，它指定触发该中断所需的最低CPL（当前特权级）。这意味着：</p><ul><li>对于系统调用，中断门的DPL通常设置为3，这允许用户态程序（CPL为3）触发这些中断。这是因为系统调用是由用户程序意图执行的操作，需要从用户态切换到内核态以执行更高权限的操作。</li><li>对于其他大多数硬件中断和异常处理，DPL通常设置为0。这意味着只有在内核态（CPL为0）代码执行时才能处理这些中断，或者由硬件自动触发，无需用户态程序直接触发。</li></ul><h4 id="2-段选择子-segment-selector">2. 段选择子（Segment Selector）</h4><p>段选择子指向全局描述符表（GDT）中的一个段，该段包含中断处理程序（ISR）的代码。这个段的特权级（即代码段的DPL）通常是0，表示ISR运行在内核态。</p><ul><li>当中断发生时，CPU会检查触发中断的CPL是否满足访问IDT条目中指定的段选择子的DPL要求。对于系统调用，由于DPL为3，用户态程序可以访问；对于其他中断，只有内核代码或由硬件触发的事件才能访问。</li></ul><h3 id="系统调用与常规中断">系统调用与常规中断</h3><ul><li><strong>系统调用</strong>（如<code>int 0x80</code>，<code>syscall</code>）是用户程序请求操作系统服务的方式。操作系统提供的系统调用接口在IDT中配置，以允许用户态程序触发这些中断进而执行内核代码。系统调用中断门的DPL设置为3，使得用户态程序可以触发它们。</li><li><strong>常规中断和异常</strong>：如硬件中断（来自外设）和异常（如页错误），它们的中断门DPL通常设置为0，这意味着它们只能在内核态被处理或由硬件直接触发。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode的使用</title>
      <link href="/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vscode/"/>
      <url>/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vscode/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>这里主要介绍一些配置项和好用插件</p><h1>外观</h1><h2 id="主题选择">主题选择</h2><h3 id="文件主题">文件主题</h3><ul><li>vscode-icons</li><li>Material Icon Theme</li></ul><h1>插件</h1><h1>运行和调试</h1><p>vscode  是通过 配置launch.json  和  task.json 来  进行调试和 运行程序</p><h2 id="python配置">python配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 使用 IntelliSense 了解相关属性。</span><br><span class="line">  // 悬停以查看现有属性的描述。</span><br><span class="line">  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Python 调试程序: 当前文件&quot;, // 当前配置名字</span><br><span class="line">      &quot;type&quot;: &quot;debugpy&quot;, // 类型</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">      &quot;program&quot;: &quot;$&#123;file&#125;&quot;,</span><br><span class="line">      &quot;console&quot;: &quot;integratedTerminal&quot;,</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span><br><span class="line">      &quot;python&quot;: &quot;C:\\Users\\asus\\miniconda3\\envs\\ML\\python.exe&quot;, // 默认使用vscode底部选用的python</span><br><span class="line">      &quot;env&quot;: &#123;</span><br><span class="line">        &quot;PYTHONPATH&quot;: &quot;$&#123;fileDirname&#125;&quot; // 我们需要将当前工作目录加到python包寻找路径里面,可以寻找到我们的包</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile学习</title>
      <link href="/2023/10/02/makefile/makefile/"/>
      <url>/2023/10/02/makefile/makefile/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><h2 id="什么是-makefile？">什么是 Makefile？</h2><p><code>Makefile</code> 是一个用来自动化构建项目的简单工具，通常用在编译和链接程序的过程中，但它也可以用来执行任何你想自动化的任务。<code>Makefile</code> 包含一系列规则和指令，它们定义了如何构建项目和执行其他相关任务。</p><h2 id="为什么使用-makefile？">为什么使用 Makefile？</h2><ol><li><strong>自动化：</strong><code>Makefile</code> 可以自动化许多编程任务，比如编译源代码、生成文档、或执行测试等。</li><li><strong>依赖跟踪：</strong><code>make</code> 工具可以自动检测文件之间的依赖关系，只重新构建实际需要更新的部分，而不是整个项目。</li><li>**跨平台：**虽然 <code>make</code> 最初是为 Unix 和类 Unix 系统开发的，但现在也可用于许多其他操作系统。</li></ol><h2 id="makefile-的基本组成">Makefile 的基本组成</h2><ol><li><strong>目标（Target）:</strong> 是你想完成的任务名称。比如：编译源代码可以是一个目标。</li><li><strong>依赖（Dependencies）:</strong> 是完成任务所需的前置条件，通常是源文件或其他目标。</li><li><strong>命令（Commands）:</strong> 是 <code>make</code> 执行的实际命令，它们指定了如何从源文件创建目标输出。</li><li><strong>伪目标(Phony target)</strong>: 伪目标并不代表实际的文件名，<strong>而是一个执行特定任务的标签名称</strong>。伪目标没有对应的文件名，并且它的命令总是被执行的, <strong>主要是为了避免和文件同名然后不执行的情况</strong>。 可以通过**.PHONY: clean** 这样 指定</li></ol><p>我们需要将目标的名字设置成有用的,真实的目标的名字  以及 依赖也需要写上,  这样的话,Makefile会帮我们做检查,  看是否需要生成, 这样的话, 对于大型项目,  编译 构建的效率就非常高</p><h1>Makefile 变量</h1><p>Makefile 中的变量是其强大功能之一，它们使得 Makefile 更具有模块化和可维护性。以下是 Makefile 中常见的变量及其简短总结：</p><ol><li><p><strong>简单变量赋值 (<code>=</code>)</strong>:</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br></pre></td></tr></table></figure><p><strong>这种赋值是递归的</strong>，右边的 <code>value</code> 在每次引用 <code>$(VARIABLE)</code> 时都会重新被评估。(<strong>这里指的是,如果在后面修改了VARIABLE 这里的的值,  这样的话,  前面使用了这个变量的话也会变成这个值</strong>)  <strong>相当于引用赋值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value = djm</span><br><span class="line">value2 = $(value)</span><br><span class="line">showValue:</span><br><span class="line"># 这里的value2变成了 djm666</span><br><span class="line">echo $(value2)  </span><br><span class="line">value = djm666</span><br></pre></td></tr></table></figure></li><li><p><strong>立即变量赋值 (<code>:=</code>)</strong>:</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE := value</span><br></pre></td></tr></table></figure><p>右边的 <code>value</code> 仅在赋值时评估一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value = djm</span><br><span class="line">value2 := $(value)</span><br><span class="line">showValue:</span><br><span class="line"># 这里的value2 不会变成了 djm666   还是 djm</span><br><span class="line">echo $(value2)  </span><br><span class="line">value = djm666</span><br></pre></td></tr></table></figure></li><li><p><strong>追加赋值 (<code>+=</code>)</strong>:</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE += value</span><br></pre></td></tr></table></figure><p>这种方式会将 <code>value</code> 追加到现有的 <code>VARIABLE</code> 值后面。</p></li><li><p><strong>条件变量赋值 (<code>?=</code>)</strong>:</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE ?= value</span><br></pre></td></tr></table></figure><p>只有当 <code>VARIABLE</code> 未定义或为空时，才会赋值。</p></li><li><p><strong>自动化变量</strong>:</p><ul><li><code>$@</code>: 代表规则的目标文件名。</li><li><code>$&lt;</code>: 代表规则的第一个依赖文件名。</li><li><code>$^</code>: 列出所有的依赖文件，避免列出重复的依赖。</li><li><code>$+</code>: 类似 <code>$^</code>，但包括所有依赖，包括重复的。</li><li><code>$*</code>: 代表目标文件名中的基本部分（没有扩展名或路径）。</li></ul></li><li><p><strong>预定义变量</strong>:<br>例如:</p><ul><li><code>CC</code>: C编译器，默认为 <code>cc</code>。</li><li><code>CXX</code>: C++编译器，默认为 <code>g++</code>。</li><li><code>AR</code>: 创建库的程序，默认为 <code>ar</code>。</li><li><code>RM</code>: 删除文件的程序，默认为 <code>rm -f</code>。<br>以上仅仅是其中的一部分预定义变量。</li></ul></li><li><p><strong>环境变量</strong>:<br>所有的环境变量都被导入到 Makefile 中，并可以被直接引用。例如，<code>PATH</code> 环境变量在 Makefile 中可以使用 <code>$(PATH)</code> 来引用。</p></li><li><p><strong>函数</strong>:<br>Makefile 支持各种字符串、文件名和其他函数来操作和转换变量的值。例如:</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJECTS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SOURCES)</span>)</span></span><br></pre></td></tr></table></figure></li></ol><p>在使用 Makefile 的过程中，正确地使用和理解这些变量对于编写强大、可维护的构建规则至关重要。</p><p>使用变量的格式:</p><ul><li>$(变量名字)</li><li>${变量名字}</li></ul><h1>Makefile 函数</h1><p><code>Makefile</code> 中包含了一系列的函数，它们提供了字符串操作、文件名操作、条件判断等功能。以下是一些常用的 <code>Makefile</code> 函数及其简短描述：</p><ol><li><p><strong>字符串函数</strong>:</p><ul><li><code>$(subst from,to,text)</code>: 在文本 <code>text</code> 中替换字符串 <code>from</code> 为 <code>to</code>。</li><li><code>$(patsubst pattern,replacement,text)</code>: 模式字符串替换。</li><li><code>$(strip string)</code>: 去除 <code>string</code> 开头和结尾的空白。</li><li><code>$(findstring find,text)</code>: 在 <code>text</code> 中查找 <code>find</code>，如果找到，则返回 <code>find</code>，否则返回空。</li><li><code>$(filter pattern...,text)</code>: 返回与模式匹配的词。</li><li><code>$(filter-out pattern...,text)</code>: 返回与模式不匹配的词。</li><li><code>$(word n,text)</code>: 返回 <code>text</code> 中的第 <code>n</code> 个词。</li></ul></li><li><p><strong>文件名函数</strong>:</p><ul><li><code>$(dir names...)</code>: 返回文件名的目录部分。</li><li><code>$(notdir names...)</code>: 返回非目录部分的文件名。</li><li><code>$(suffix names...)</code>: 返回文件名的后缀。</li><li><code>$(basename names...)</code>: 返回不带后缀的文件名。</li><li><code>$(addsuffix suffix,names...)</code>: 添加后缀到文件名。</li><li><code>$(addprefix prefix,names...)</code>: 添加前缀到文件名。</li></ul></li><li><p><strong>控制函数</strong>:</p><ul><li><code>$(foreach var,list,text)</code>: 为 <code>list</code> 中的每个单词求值一次 <code>text</code>。</li><li><code>$(if condition,then-part[,else-part])</code>: 如果 <code>condition</code> 为真，则求值 <code>then-part</code>，否则求值 <code>else-part</code>。</li><li><code>$(or condition...)</code>: 如果至少有一个 <code>condition</code> 为真，返回第一个为真的 <code>condition</code>。</li><li><code>$(and condition...)</code>: 如果所有 <code>condition</code> 都为真，返回最后一个 <code>condition</code>。</li></ul></li><li><p><strong>其他函数</strong>:</p><ul><li><code>$(wildcard pattern)</code>: 返回与模式匹配的所有文件名。</li><li><code>$(realpath names...)</code>: 返回文件的绝对路径。</li><li><code>$(abspath names...)</code>: 返回文件的绝对路径，但不解析符号链接。</li><li><code>$(shell command)</code>: 执行 shell 命令并返回其输出。</li><li><code>$(call var,param,param,...)</code>: 使用参数扩展变量。</li></ul></li><li><p><strong>计算函数</strong>:</p><ul><li><code>$(value var)</code>: 获取变量的值而不是扩展它。</li><li><code>$(eval text)</code>: 评估 <code>text</code> 作为 <code>make</code> 代码。</li><li><code>$(origin variable)</code>: 返回变量的定义来源。</li></ul></li></ol><p>以上仅列出了 <code>Makefile</code> 中的常用函数，实际上还有更多功能和更详细的参数选项。使用这些函数可以帮助你编写更加复杂和灵活的构建规则。</p><h1>补充</h1><h2 id="注意点">注意点</h2><ol><li><p><strong><code>@</code> 符号</strong>：它告诉 <code>make</code> 在执行命令时不显示命令。</p> <figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">@echo This will be printed without showing the command.</span><br></pre></td></tr></table></figure></li><li><p><strong><code>-</code> 符号</strong>：放在命令前面，它告诉 <code>make</code> 即使命令失败也要继续执行。默认情况下，<code>make</code> 会在命令失败时停止。</p> <figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">-false</span><br><span class="line">@echo This will still be printed even though the command above failed.</span><br></pre></td></tr></table></figure></li><li><p><strong><code>+</code> 符号</strong>：如果你使用了 <code>.ONESHELL</code> 特性或使用了 <code>make -e</code> 选项，这会导致 <code>make</code> 用单个 shell 执行整个脚本。<code>+</code> 符号可以强制某个命令在它自己的 shell 中执行。</p></li><li><p><strong>自动变量</strong>：例如 <code>$@</code>, <code>$&lt;</code>, <code>$^</code> 等。这些变量在规则的命令中都有特定的值，用于引用目标和依赖项。</p></li><li><p><strong>变量引用</strong>：在 <code>Makefile</code> 中，你使用 <code>$(VARIABLE_NAME)</code> 或 <code>$&#123;VARIABLE_NAME&#125;</code> 来引用变量。</p></li><li><p><strong>多行命令</strong>：如果你需要一个目标执行多个命令，每个命令都必须独立且前面有一个制表符（tab），不是空格。</p> <figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">@echo First command.</span><br><span class="line">@echo Second command.</span><br></pre></td></tr></table></figure></li><li><p><strong>制表符 vs 空格</strong>：这可能是新手最常遇到的问题。在目标的命令前，你必须使用制表符（tab），而不是空格。否则，<code>make</code> 会报错。</p></li><li><p><strong>命令组合</strong>：如果你想在单行上执行多个命令，你可以使用分号 <code>;</code> 或逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code>。</p> <figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">@echo First command. ; echo Second command.</span><br></pre></td></tr></table></figure></li></ol><p>这些只是使用 <code>Makefile</code> 时需要注意的一些细节和特性。为了编写高效且没有错误的 <code>Makefile</code>，通常需要对 <code>make</code> 的更多特性和细节有深入的了解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2023/09/20/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2023/09/20/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="十万个为什么">十万个为什么</h2><p>目前CPU分为两种架构,精简指令集和复杂指令集,不同的CPU的指令集是不一样的</p><p>精简指令集(RISC):动作简单,执行时间短,效率高,执行复杂操作的时候,需要多条指令集完成  主要的CPU有:ARM ,SPARC</p><p>复杂指令集(CISC):</p><p>硬盘是分扇区的,以前每个扇区512B,为了减少存储一个文件的拆解 现在一般是 4KB(所以现在文件所占大小一定是4KB的整数倍,所以文件的实际大小一般比文件所占大小小),</p><p>传统硬盘是分为很多盘片,每个盘片上又分为很多磁道(就是一圈一圈的),每个磁道又分了很多扇区,每个扇区就是存放一个文件的一部分的地方,每个盘片相同的磁道被称为柱面,当我们需要数据时,告诉磁头在哪个盘面哪个扇区哪个柱面就行,这样是比较慢的,因为盘面转一圈才能找到一个或者多个文件块.</p><p>固态硬盘像内存那样,可以直接定位到数据在哪,所有就非常快</p><p><strong>Linus是很聪明,但是,我觉得他的成功可不只有聪明,他早些年的经历(学过组合语言,经常跟硬件打交道,明白硬件的特性,CPU不够用,需要紧凑,这样写代码的话需要充分考虑资源,这些不是正好符合操作系统的功能吗?),让他写出了如此优秀的操作系统</strong></p><p><strong>为什么1TB的固态硬盘只有930多GB呢?</strong></p><p>因为1TB中的T对应的是10^12,而930多中的G单位是2^30</p><p><strong>为什么CPU型号一样,可执行程序不可以同时在windows和linux上跑呢?</strong></p><p>因为可执行程序里面不只有机器指令,它还包括了数据,运行资源等等,这些需要操作系统的管理的,不同的操作系统有不同的管理方式,还有就是api的不同,不同的操作系统提供的api是不同的,所以可执行程序需要同CPU,同操作系统才能跑起来</p><p><strong>是不是频率越高,CPU就越好呢?</strong></p><p>答案是否定的,频率越高只能说明,CPU运行次数快,但是不同的CPU对应的指令集不同,架构不同,所以每款CPU每次频率做的执行的指令也不一样多,如果一款CPU频率高,而且每次频率做执行指令也多,那么说明这个CPU好</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bochs安装</title>
      <link href="/2023/09/19/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/09/19/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用centos7   (遇到坑不少)</p></blockquote><h1>bochs-gdb安装(2.7)</h1><p>由于bochs的GDB要么本地要么远程, 所以我们得整两个bochs, 这个就当bochs-gdb</p><blockquote><p>参考地址   <a href="https://zhuanlan.zhihu.com/p/492780020">https://zhuanlan.zhihu.com/p/492780020</a></p></blockquote><h2 id="依赖库安装">依赖库安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gtk2 gtk2-devel libXt libXt-devel libXpm libXpm-devel SDL SDL-devel libXrandr-devel.x86_64 xorg-x11-server-devel glibc-headers gcc-c++ SDL SDL-devel</span><br></pre></td></tr></table></figure><h2 id="安装nasm">安装nasm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.gz</span><br><span class="line">tar xvzf nasm-2.15.05.tar.gz</span><br><span class="line">cd nasm-2.15.05</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="下载bochs">下载bochs</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceforge.net/projects/bochs/files/bochs/2.7/bochs-2.7.tar.gz --no-check-certificate</span><br><span class="line">tar xvfz bochs-2.7.tar.gz</span><br><span class="line">mv bochs-2.7 bochs-gdb</span><br><span class="line">cd bochs-gdb</span><br></pre></td></tr></table></figure><h2 id="配置文件">配置文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-x11 --with-x --enable-all-optimizations --enable-readline --enable-a20-pin --enable-fast-function-calls --enable-gdb-stub</span><br></pre></td></tr></table></figure><blockquote><p>./configure --with-x11 --with-wx  --enable-disasm --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls  --enable-handlers-chaining  --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check  --enable-monitor-mwait --enable-avx  --enable-evex --enable-x86-debugger --enable-pci --enable-usb --enable-voodoo --enable-gdb-stub</p></blockquote><h2 id="复制文件-保留-不需要执行-这个是2-6-8遗留">复制文件(保留,不需要执行, 这个是2.6.8遗留)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp misc/bximage.cpp  misc/bximage.cc</span><br><span class="line">cp iodev/hdimage/hdimage.cpp iodev/hdimage/hdimage.cc</span><br><span class="line">cp iodev/hdimage/vmware3.cpp  iodev/hdimage/vmware3.cc</span><br><span class="line">cp iodev/hdimage/vmware4.cpp iodev/hdimage/vmware4.cc</span><br><span class="line">cp iodev/hdimage/vpc-img.cpp iodev/hdimage/vpc-img.cc</span><br><span class="line">cp iodev/hdimage/vbox.cpp iodev/hdimage/vbox.cc</span><br></pre></td></tr></table></figure><h2 id="修改makefile">修改makefile</h2><p>vim Makefile</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prefix          = /usr/local</span></span><br><span class="line">prefix          = /usr/local/bochs-gdb <span class="comment"># 修改为你要存放的目录位置</span></span><br><span class="line">exec_prefix     = <span class="variable">$&#123;prefix&#125;</span></span><br><span class="line">srcdir          = .</span><br><span class="line"></span><br><span class="line">bindir          = <span class="variable">$&#123;exec_prefix&#125;</span>/bin</span><br><span class="line">libdir          = <span class="variable">$&#123;exec_prefix&#125;</span>/lib</span><br><span class="line">plugdir         = <span class="variable">$&#123;exec_prefix&#125;</span>/lib/bochs/plugins</span><br><span class="line">datarootdir     = <span class="variable">$&#123;prefix&#125;</span>/share</span><br><span class="line">mandir          = <span class="variable">$&#123;datarootdir&#125;</span>/man</span><br><span class="line">man1dir         = $(mandir)/man1</span><br><span class="line">man5dir         = $(mandir)/man5</span><br><span class="line">docdir          = $(datarootdir)/doc/bochs</span><br><span class="line">sharedir        = $(datarootdir)/bochs</span><br><span class="line">top_builddir    = .</span><br><span class="line">top_srcdir      = $(srcdir)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建">构建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/../img/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAassets/image-20230930223054400.png" alt="image-20230930223054400"></p><p>显示是这样就代表安装成功了</p><p>然后可以查看/usr/local/share  /usr/local/bin 下面就有了 对应的东西</p><h2 id="复制到bin目录下">复制到bin目录下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/bochs-gdb/bin/bochs /usr/local/bin/bochs-gdb  </span><br><span class="line">cp /usr/local/bochs-gdb/bin/bximage /usr/local/bin/</span><br></pre></td></tr></table></figure><h2 id="创建硬盘">创建硬盘</h2><blockquote><p>不同的bochs对应的bximage参数可能不同</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes | bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat maste</span><br></pre></td></tr></table></figure><blockquote><p>记录下来配置项  ata0-master: type=disk, path=“master.img”, mode=flat</p></blockquote><h2 id="创建bochsrc-gdb">创建bochsrc-gdb</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configuration file generated by Bochs</span></span><br><span class="line">plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1</span><br><span class="line">config_interface: textconfig</span><br><span class="line">display_library: x</span><br><span class="line">memory: host=32, guest=32</span><br><span class="line">romimage: file=<span class="string">&quot;/usr/local/bochs-gdb/share/bochs/BIOS-bochs-latest&quot;</span>   <span class="comment"># 修改为我们上面修改的目录</span></span><br><span class="line">vgaromimage: file=<span class="string">&quot;/usr/local/bochs-gdb/share/bochs/VGABIOS-lgpl-latest&quot;</span> <span class="comment"># 修改为我们上面修改的目录</span></span><br><span class="line">boot: disk  <span class="comment"># 硬盘启动</span></span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"><span class="comment"># no floppya</span></span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;./build/master.img&quot;</span>, mode=flat  <span class="comment"># 这里的相对地址要写对,  我这里是已经创建好了硬盘在/build/master.img下面了</span></span><br><span class="line">ata0-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: <span class="built_in">type</span>=none</span><br><span class="line">ata1-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata2: enabled=0</span><br><span class="line">ata3: enabled=0</span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line">vga: extension=vbe, update_freq=5, realtime=1</span><br><span class="line">cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0</span><br><span class="line">cpuid: level=6, stepping=3, model=3, family=6, vendor_string=<span class="string">&quot;AuthenticAMD&quot;</span>, brand_string=<span class="string">&quot;AMD Athlon(tm) processor&quot;</span></span><br><span class="line">cpuid: mmx=1, apic=xapic, simd=sse2, sse4a=0, misaligned_sse=0, sep=1, movbe=0, adx=0</span><br><span class="line">cpuid: aes=0, sha=0, xsave=0, xsaveopt=0, avx_f16c=0, avx_fma=0, bmi=0, xop=0, fma4=0</span><br><span class="line">cpuid: tbm=0, x86_64=1, 1g_pages=0, pcid=0, fsgsbase=0, smep=0, smap=0, mwait=1, vmx=1</span><br><span class="line">cpuid: svm=0</span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line"><span class="comment"># no gdb stub</span></span><br><span class="line">gdbstub: enabled=1, port=1234   <span class="comment"># 这里配置gdb启动端口</span></span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">private_colormap: enabled=0</span><br><span class="line">clock: <span class="built_in">sync</span>=none, time0=<span class="built_in">local</span>, rtc_sync=0</span><br><span class="line"><span class="comment"># no cmosimage</span></span><br><span class="line"><span class="comment"># no loader</span></span><br><span class="line"><span class="built_in">log</span>: -</span><br><span class="line">logprefix: %t%e%d</span><br><span class="line">debug: action=ignore</span><br><span class="line">info: action=report</span><br><span class="line">error: action=report</span><br><span class="line">panic: action=ask</span><br><span class="line">keyboard: <span class="built_in">type</span>=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: <span class="built_in">type</span>=ps2, enabled=0, toggle=ctrl+mbutton</span><br><span class="line">speaker: enabled=1, mode=system</span><br><span class="line">parport1: enabled=1, file=none</span><br><span class="line">parport2: enabled=0</span><br><span class="line">com1: enabled=1, mode=null</span><br><span class="line">com2: enabled=0</span><br><span class="line">com3: enabled=0</span><br><span class="line">com4: enabled=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建启动脚本">创建启动脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LTDL_LIBRARY_PATH=/usr/local/bochs-gdb/lib/bochs/plugins </span><br><span class="line">export BXSHARE=/usr/local/bochs-gdb/share/bochs </span><br><span class="line">bochs-gdb -q -f bochsrc-gdb</span><br></pre></td></tr></table></figure><h2 id="创建启动makefile">创建启动makefile</h2><p>和上面二选一即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug: $(BUILD)/master.img</span><br><span class="line"></span><br><span class="line">LTDL_LIBRARY_PATH=/usr/local/bochs-gdb/lib/bochs/plugins \</span><br><span class="line">BXSHARE=/usr/local/bochs-gdb/share/bochs \</span><br><span class="line">bochs-gdb -q -f $(WORKDIR)/bochs/bochsrc-gdb</span><br></pre></td></tr></table></figure><h1>bochs安装</h1><h2 id="再解压一份bochs">再解压一份bochs</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xvfz bochs-2.7.tar.gz</span><br><span class="line"><span class="built_in">mv</span> bochs-2.7 bochs</span><br><span class="line"><span class="built_in">cd</span> bochs</span><br></pre></td></tr></table></figure><h2 id="配置文件">配置文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-x11 --with-x --enable-all-optimizations --enable-readline --enable-a20-pin --enable-fast-function-calls  --enable-x86-debugger   --enable-debugger</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>./configure --with-x11 --with-wx --enable-debugger --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-smp --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls  --enable-handlers-chaining  --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check  --enable-monitor-mwait --enable-avx  --enable-evex --enable-x86-debugger --enable-pci --enable-usb --enable-voodoo</p><p>–enable-gdb-stub  和 --enable-debugger 是互斥的,  --enable-debugger 是本地调试  --enable-gdb-stub 是远程调试</p></blockquote><h2 id="复制文件-不需要执行">复制文件(不需要执行)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp misc/bximage.cpp  misc/bximage.cc</span><br><span class="line">cp iodev/hdimage/hdimage.cpp iodev/hdimage/hdimage.cc</span><br><span class="line">cp iodev/hdimage/vmware3.cpp  iodev/hdimage/vmware3.cc</span><br><span class="line">cp iodev/hdimage/vmware4.cpp iodev/hdimage/vmware4.cc</span><br><span class="line">cp iodev/hdimage/vpc-img.cpp iodev/hdimage/vpc-img.cc</span><br><span class="line">cp iodev/hdimage/vbox.cpp iodev/hdimage/vbox.cc</span><br></pre></td></tr></table></figure><h2 id="修改makefile">修改makefile</h2><p>vim Makefile</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prefix          = /usr/local</span></span><br><span class="line">prefix          = /usr/local/bochs <span class="comment"># 修改为你要存放的目录位置, 注意区别,上面是bochs-gdb</span></span><br><span class="line">exec_prefix     = <span class="variable">$&#123;prefix&#125;</span></span><br><span class="line">srcdir          = .</span><br><span class="line"></span><br><span class="line">bindir          = <span class="variable">$&#123;exec_prefix&#125;</span>/bin</span><br><span class="line">libdir          = <span class="variable">$&#123;exec_prefix&#125;</span>/lib</span><br><span class="line">plugdir         = <span class="variable">$&#123;exec_prefix&#125;</span>/lib/bochs/plugins</span><br><span class="line">datarootdir     = <span class="variable">$&#123;prefix&#125;</span>/share</span><br><span class="line">mandir          = <span class="variable">$&#123;datarootdir&#125;</span>/man</span><br><span class="line">man1dir         = $(mandir)/man1</span><br><span class="line">man5dir         = $(mandir)/man5</span><br><span class="line">docdir          = $(datarootdir)/doc/bochs</span><br><span class="line">sharedir        = $(datarootdir)/bochs</span><br><span class="line">top_builddir    = .</span><br><span class="line">top_srcdir      = $(srcdir)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建">构建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h2 id="复制到bin目录下">复制到bin目录下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/bochs/bin/bochs /usr/local/bin/bochs </span><br><span class="line">cp /usr/local/bochs/bin/bximage /usr/local/bin/bximage</span><br></pre></td></tr></table></figure><h2 id="编写boot-asm">编写boot.asm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line"></span><br><span class="line">; 设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax, 3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">; 初始化段寄存器</span><br><span class="line">mov ax, 0</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0x7c00</span><br><span class="line"></span><br><span class="line">mov si, 0</span><br><span class="line"></span><br><span class="line">; 屏幕显示区域</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov ds,ax</span><br><span class="line">; 显示字符H</span><br><span class="line">mov byte [0],&#x27;H&#x27;   </span><br><span class="line"></span><br><span class="line">; 阻塞</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 填充 0</span><br><span class="line">times 510 - ($ - $$) db 0</span><br><span class="line"></span><br><span class="line">; 主引导扇区的最后两个字节必须是 0x55 0xaa</span><br><span class="line">; dw 0xaa55</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure><p>编译boot.asm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin boot.asm -o boot.bin</span><br></pre></td></tr></table></figure><p>将boot.bin写入主引导扇区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=boot.bin of=master.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure><h2 id="修改bochs启动配置项">修改bochs启动配置项</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configuration file generated by Bochs</span></span><br><span class="line">plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1</span><br><span class="line">config_interface: textconfig</span><br><span class="line">display_library: x,options=<span class="string">&quot;gui_debug&quot;</span>  <span class="comment"># 可视化调试</span></span><br><span class="line">memory: host=32, guest=32</span><br><span class="line">romimage: file=<span class="string">&quot;/usr/local/bochs/share/bochs/BIOS-bochs-latest&quot;</span>  <span class="comment"># 修改为我们上面修改的目录</span></span><br><span class="line">vgaromimage: file=<span class="string">&quot;/usr/local/bochs/share/bochs/VGABIOS-lgpl-latest&quot;</span>  <span class="comment"># 修改为我们上面修改的目录</span></span><br><span class="line">boot: disk  <span class="comment">#硬盘启动</span></span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"><span class="comment"># no floppya</span></span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;master.img&quot;</span>, mode=flat</span><br><span class="line">ata0-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: <span class="built_in">type</span>=none</span><br><span class="line">ata1-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata2: enabled=0</span><br><span class="line">ata3: enabled=0</span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line">vga: extension=vbe, update_freq=5, realtime=1</span><br><span class="line">cpu: count=1:1:1, ips=4000000, quantum=16, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0</span><br><span class="line">cpuid: level=6, stepping=3, model=3, family=6, vendor_string=<span class="string">&quot;AuthenticAMD&quot;</span>, brand_string=<span class="string">&quot;AMD Athlon(tm) processor&quot;</span></span><br><span class="line">cpuid: mmx=1, apic=xapic, simd=sse2, sse4a=0, misaligned_sse=0, sep=1, movbe=0, adx=0</span><br><span class="line">cpuid: aes=0, sha=0, xsave=0, xsaveopt=0, avx_f16c=0, avx_fma=0, bmi=0, xop=0, fma4=0</span><br><span class="line">cpuid: tbm=0, x86_64=1, 1g_pages=0, pcid=0, fsgsbase=0, smep=0, smap=0, mwait=1, vmx=1</span><br><span class="line">cpuid: svm=0</span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line">debugger_log: -</span><br><span class="line">magic_break: enabled=1</span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">private_colormap: enabled=0</span><br><span class="line">clock: <span class="built_in">sync</span>=none, time0=<span class="built_in">local</span>, rtc_sync=0</span><br><span class="line"><span class="comment"># no cmosimage</span></span><br><span class="line"><span class="comment"># no loader</span></span><br><span class="line"><span class="built_in">log</span>: -</span><br><span class="line">logprefix: %t%e%d</span><br><span class="line">debug: action=ignore</span><br><span class="line">info: action=report</span><br><span class="line">error: action=report</span><br><span class="line">panic: action=ask</span><br><span class="line">keyboard: <span class="built_in">type</span>=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: <span class="built_in">type</span>=ps2, enabled=0, toggle=ctrl+mbutton</span><br><span class="line">speaker: enabled=1, mode=system</span><br><span class="line">parport1: enabled=1, file=none</span><br><span class="line">parport2: enabled=0</span><br><span class="line">com1: enabled=1, mode=null</span><br><span class="line">com2: enabled=0</span><br><span class="line">com3: enabled=0</span><br><span class="line">com4: enabled=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建启动脚本">创建启动脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LTDL_LIBRARY_PATH=/usr/local/bochs/lib/bochs/plugins </span><br><span class="line">export BXSHARE=/usr/local/bochs/share/bochs </span><br><span class="line">bochs -q -f bochsrc-gdb</span><br></pre></td></tr></table></figure><h2 id="创建启动makefile">创建启动makefile</h2><p>和上面二选一即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run: $(BUILD)/master.img</span><br><span class="line">LTDL_LIBRARY_PATH=/usr/local/bochs/lib/bochs/plugins \</span><br><span class="line">BXSHARE=/usr/local/bochs/share/bochs \</span><br><span class="line">bochs -q -f $(WORKDIR)/bochs/bochsrc</span><br></pre></td></tr></table></figure><h1>删除bochs</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入到bochs的解压目录</span><br><span class="line"># 可以选择直接删除整个目录, 也可以删除一部分</span><br><span class="line">rm -rf ./*</span><br><span class="line">make uninstall</span><br></pre></td></tr></table></figure><h1>升级gcc</h1><p>centos7 默认自带的gcc版本为4.8.5, 需要升级为11版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install centos-release-scl</span><br><span class="line">sudo yum install devtoolset-11-gcc*</span><br><span class="line">source /opt/rh/devtoolset-11/enable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mv /usr/bin/gcc /usr/bin/gcc-4.8.5</span><br><span class="line"></span><br><span class="line">ln -s /opt/rh/devtoolset-11/root/bin/gcc /usr/bin/gcc</span><br><span class="line"></span><br><span class="line">mv /usr/bin/g++ /usr/bin/g++-4.8.5</span><br><span class="line"></span><br><span class="line">ln -s /opt/rh/devtoolset-11/root/bin/g++ /usr/bin/g++</span><br><span class="line"></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line">g++ --version</span><br></pre></td></tr></table></figure><h1>升级gdb</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/gdb  /usr/bin/gdb-7</span><br><span class="line">sudo yum install texinfo  # 新版本的gdb需要这个东西</span><br><span class="line">wget http://ftp.gnu.org/gnu/gdb/gdb-10.2.tar.gz</span><br><span class="line">tar -xzvf gdb-10.2.tar.gz</span><br><span class="line">cd gdb-10.2</span><br><span class="line">./configure --prefix=/usr/     ## --prefix=/usr/参数实现自动配置环境变量</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h1>qemu安装</h1><p>进入到root用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install qemu-kvm</span><br></pre></td></tr></table></figure><h2 id="转换磁盘镜像文件">转换磁盘镜像文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img convert -f raw -O vmdk boot.img boot.vmdk</span><br></pre></td></tr></table></figure><h1>参考</h1><p>文章链接:</p><ul><li><a href="https://www.jianshu.com/p/00969a32dfae">bochs配置</a></li><li><a href="https://zhuanlan.zhihu.com/p/452578845">bochs配置</a></li></ul><p>书籍参考:</p><ul><li>一个64位操作系统的设计与实现</li></ul><h1>test</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceforge.net/projects/bochs/files/bochs/2.6.11/bochs-2.6.11.tar.gz --no-check-certificate</span><br><span class="line"></span><br><span class="line">tar xvfz bochs-2.6.11.tar.gz</span><br><span class="line">cd bochs-2.6.11</span><br><span class="line"></span><br><span class="line">wget https://sourceforge.net/projects/bochs/files/bochs/2.7/bochs-2.7.tar.gz --no-check-certificate</span><br><span class="line">tar xvfz bochs-2.7.tar.gz</span><br><span class="line">cd bochs-2.7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>电源</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>英语短语积累</title>
      <link href="/2023/09/16/English/%E8%AF%8D%E7%BB%84%E7%A7%AF%E7%B4%AF/"/>
      <url>/2023/09/16/English/%E8%AF%8D%E7%BB%84%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h1></h1><ol><li>stay out of  置身事外</li><li>above all   尤其,  重要的是</li><li>at all 根本,完全不, 一点也不</li><li>for sure 肯定地</li><li>out to 表示意图目的  比如 out to get  me  想要对付我   也可以以表示 方向 比如  go out to somewhere</li><li>just as 正如</li><li>make sense 有意义 讲得通</li><li>work through 解决 完成 修复</li><li>be left to  由… 决定    被留下</li><li>responsible for  对…负责,有责任</li><li>an array of 一批</li><li>viewed against 与什么…相比  ,审视</li><li>owe  to   将…归因于…</li><li>call for   呼吁;提倡;需要</li><li>think of 想象;设想  考虑到;</li><li>think of … as  把…看做</li><li>so far as  就…而言; 只要;就</li><li>in so far as  在…范围内</li><li>in favor of  有利于;支持;赞同</li><li>such as  例如;比如;像      such a good boy as you  比如你这样的男孩</li><li>right away 立刻,马上</li><li>known as  称为;熟知</li><li>as well as  也;和;以及   as well 也有这些意思   但是  as well as 是连接词,  但是 as well 是副词</li><li>make out of  制造;    make .A. out of .B.   通过B 获得A;</li><li>make the most of   充分利用</li><li>show up  出现;露面</li><li>in advance 预先;提前</li><li>on good terms 关系良好</li><li>live off 靠什么为生</li><li>take in  吸收;欣赏;收留</li><li>all over 到处;遍及</li><li>so forth 等等;表示列举</li><li>hand over 移交</li><li>take account of 考虑,顾及</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编学习</title>
      <link href="/2023/09/15/%E6%B1%87%E7%BC%96/8086%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/15/%E6%B1%87%E7%BC%96/8086%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>在考研过程中好好学了一下计算机组成原理,  让我对底层这些东西产生了浓厚的兴趣,  因此就先学学基础汇编</p><blockquote><p>本文章 是掺杂8086 和  x86一起总结的,  可能有些地方在8086里面不具备</p></blockquote><h1>基本信息</h1><ul><li>机器字长为 16位    存储字长为16位    地址线20根   数据线16根</li><li>由于机器字长只有16位,  地址线有20根,  计算物理地址需要特别处理  物理地址 =  段地址*16 + 段内地址    (物理地址表示不唯一)</li><li>AX,BX,CX,DX  都是通用寄存器, 用来存放数据  段地址寄存器有: CS  DS ES SS  偏移地址寄存器有:  SP,BP,SI,DI,IP,BX</li><li>CS:IP  指定下一条执行指令的位置,   SS:SP 指定栈顶位置 (进栈操作 SP-字节数  放入数据, 出栈操作 拿出数据 SP+数据字节数)  DS , ES是数据段位置</li><li>数据在内存中都是小端存放</li></ul><h1>寄存器</h1><p>下面是8086 CPU的主要寄存器及其英文全称和功能：</p><ol><li><p><strong>AX (Accumulator Register)</strong>：累加寄存器。</p><ul><li>主要用于算数运算和数据传输。</li></ul></li><li><p><strong>BX (Base Register)</strong>：基址寄存器。</p><ul><li>除了可以用于算术运算外，它还经常用于地址运算。 <strong>默认使用ds作为段地址</strong></li></ul></li><li><p><strong>CX (Count Register)</strong>：计数寄存器。</p><ul><li>通常用于循环计数。</li></ul></li><li><p><strong>DX (Data Register)</strong>：数据寄存器。</p><ul><li>用于算数运算和某些特殊指令，如某些I/O操作。</li></ul></li><li><p><strong>SI (Source Index)</strong>：源索引寄存器。 <strong>默认使用ds作为段地址</strong></p><ul><li>主要用于字符串操作，表示源字符串的地址。</li></ul></li><li><p><strong>DI (Destination Index)</strong>：目标索引寄存器。<strong>默认使用es作为段地址</strong></p><ul><li>主要用于字符串操作，表示目标字符串的地址。</li></ul></li><li><p><strong>BP (Base Pointer)</strong>：基指针寄存器。</p><ul><li>通常用于基于堆栈的参数和局部变量的地址引用。 <strong>默认使用 ss作为段地址</strong></li></ul></li><li><p><strong>SP (Stack Pointer)</strong>：堆栈指针寄存器。</p><ul><li>始终指向堆栈的顶部，随着数据的压入和弹出而变化。</li></ul></li></ol><p>此外，8086还有段寄存器，用于段地址运算：</p><ol><li><p><strong>CS (Code Segment)</strong>：代码段寄存器。</p><ul><li>指向当前执行代码的段。</li></ul></li><li><p><strong>DS (Data Segment)</strong>：数据段寄存器。</p><ul><li>用于大多数数据操作指令的默认段。</li></ul></li><li><p><strong>SS (Stack Segment)</strong>：堆栈段寄存器。</p><ul><li>指向堆栈的段。</li></ul></li><li><p><strong>ES (Extra Segment)</strong>：附加段寄存器。</p><ul><li>为某些字符串操作提供一个附加的段选择。</li></ul></li></ol><p>8086还有一个特殊的寄存器：</p><ol><li><strong>IP (Instruction Pointer)</strong>：指令指针。<ul><li>与CS寄存器一起，CS:IP总是指向下一条要执行的指令。</li></ul></li></ol><p>以上列举的是8086微处理器的主要寄存器。这些寄存器为低级编程提供了大量的灵活性和功能。</p><h2 id="标志位寄存器">标志位寄存器</h2><p>下面是8086微处理器中标志位寄存器的总结，以及在DEBUG工具中显示的符号及其意义：</p><ol><li><p><strong>CF (Carry Flag)</strong> - 表示进位或借位</p><ul><li>值: 0 或 1<ul><li><code>0</code> (NC: No Carry) 表示没有进位</li><li><code>1</code> (CY: Carry) 表示有进位</li></ul></li></ul></li><li><p><strong>PF (Parity Flag)</strong> - 反映了结果字节中1的数量。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (PO: Parity Odd) 表示1的数量为奇数</li><li><code>1</code> (PE: Parity Even) 表示1的数量为偶数</li></ul></li></ul></li><li><p><strong>AF (Auxiliary Carry Flag)</strong> - 在BCD（二进制编码十进制）运算中使用，当低4位产生进位或借位时设置。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (NA: No Auxiliary Carry) 表示低4位没有进位</li><li><code>1</code> (AC: Auxiliary Carry) 表示低4位产生了进位</li></ul></li></ul></li><li><p><strong>ZF (Zero Flag)</strong> - 如果最后一个操作的结果为零，则设置ZF。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (NZ: Not Zero) 表示结果不为零</li><li><code>1</code> (ZR: Zero) 表示结果为零</li></ul></li></ul></li><li><p><strong>SF (Sign Flag)</strong> - 反映了最后操作的结果的符号。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (PL: Positive) 表示结果为正数或零</li><li><code>1</code> (NG: Negative) 表示结果为负数</li></ul></li></ul></li><li><p><strong>TF (Trap Flag)</strong> - 允许单步执行。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (NT: No Trap) 表示TF未被设置</li><li><code>1</code> (TR: Trap) 表示TF被设置</li></ul></li></ul></li><li><p><strong>IF (Interrupt Flag)</strong> - 控制外部中断的响应。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (DI: Disable Interrupts) 禁止中断</li><li><code>1</code> (EI: Enable Interrupts) 允许中断</li></ul></li></ul></li><li><p><strong>DF (Direction Flag)</strong> - 控制字符串操作的方向。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (UP: Increment) 字符串操作地址自增</li><li><code>1</code> (DN: Decrement) 字符串操作地址自减</li></ul></li></ul></li><li><p><strong>OF (Overflow Flag)</strong> - 在有符号运算中，如果结果超出了有符号数值范围，则设置OF。</p><ul><li>值: 0 或 1<ul><li><code>0</code> (NV: No Overflow) 表示没有溢出</li><li><code>1</code> (OV: Overflow) 表示有溢出</li></ul></li></ul></li></ol><p>总的来说，ALU不是基于有符号和无符号数的概念来执行操作的。而是执行二进制运算，然后设置或清除相关标志以提供有关操作结果的信息。然后，程序员或编译器可以根据这些标志来解释和处理结果。</p><h1>Debug的使用</h1><p>通过debug 能够查看寄存器的内容, 以及内存的内容, 并且指令执行跟踪</p><ol><li><strong>A [address]</strong>: Assemble<ul><li>用于在指定地址开始手动汇编代码。</li><li>当你输入<code>A</code>然后按Enter，你可以开始输入汇编指令。</li><li>使用空行结束汇编。</li></ul></li><li><strong>D [range]</strong>: Dump<ul><li>用于显示内存中的内容。</li><li><code>D</code>后面可以跟一个地址范围，如<code>D 100 150</code>，表示显示从100到150的内存内容。</li></ul></li><li><strong>E address [list]</strong>: Enter<ul><li>用于修改指定地址的内存内容。</li><li>例如，<code>E 100 90 91 92</code>会将地址100、101、102的内存值分别设为90、91、92。</li><li>询问式更改 :  E 地址 空格继续,回车结束</li></ul></li><li><strong>G [=address] [breakpoints]</strong>: Go<ul><li>执行程序直到遇到指定的断点。</li><li><code>G=100</code>表示从地址100开始执行。</li></ul></li><li><strong>I port</strong>: Input<ul><li>从指定的I/O端口读取值。</li><li>例如，<code>I 60</code>会读取端口60的值。</li></ul></li><li><strong>L range address</strong>: Load<ul><li>从磁盘上的文件加载数据到指定地址的内存。</li></ul></li><li><strong>N [filename]</strong>: Name<ul><li>指定一个文件名，用于后续的读/写操作。</li></ul></li><li><strong>R [register]</strong>: Register<ul><li>查看或修改CPU寄存器的值。</li><li>输入<code>R</code>会显示所有寄存器的值。<code>R AX</code>会显示AX寄存器的值，并允许你修改它。</li></ul></li><li><strong>T [=address] [count]</strong>: Trace<ul><li>单步执行指令。</li><li><code>T=100 5</code>表示从地址100开始执行，并执行5条指令。</li></ul></li><li><strong>U [range]</strong>: Unassemble<ul><li>将指定内存地址的机器代码反汇编为汇编语言。</li><li><code>U 100 150</code>表示将从100到150的地址反汇编。</li></ul></li><li><strong>Q</strong>: Quit<ul><li>退出DEBUG。</li></ul></li></ol><h1>指令</h1><h2 id="数据传送指令">数据传送指令</h2><ol><li><p><strong><code>MOV dest, src</code></strong>:</p><ul><li><strong>功能</strong>：传送源操作数（src）的值到目标操作数（dest）。</li><li><strong>用法</strong>：<ul><li><code>MOV AX, BX</code>：将BX寄存器的值复制到AX寄存器。</li><li><code>MOV AL, [BX]</code>：将地址BX处的字节值复制到AL寄存器。</li><li><code>MOV [BX], AL</code>：将AL的值存到地址BX处。</li></ul></li><li><strong>注意点</strong>：不能直接在两个内存操作数之间进行数据传送。例如，<code>MOV [1000h], [2000h]</code> 是非法的。</li></ul></li><li><p><strong><code>PUSH src</code></strong>:</p><ul><li><strong>功能</strong>：将源操作数的值推送到堆栈顶部。</li><li><strong>用法</strong>：<ul><li><code>PUSH AX</code>：将AX寄存器的内容推送到堆栈。</li><li><code>PUSH DS</code>：将段寄存器DS的内容推送到堆栈。</li></ul></li><li><strong>注意点</strong>：可以推送所有的16位寄存器和段寄存器，但不能直接推送8位寄存器和内存字节。</li></ul></li><li><p><strong><code>POP dest</code></strong>:</p><ul><li><strong>功能</strong>：从堆栈顶部取一个值并放入目标操作数。</li><li><strong>用法</strong>：<ul><li><code>POP BX</code>：从堆栈中弹出顶部值并放入BX寄存器。</li><li><code>POP ES</code>：从堆栈中弹出顶部值并放入段寄存器ES。</li></ul></li><li><strong>注意点</strong>：可以弹出到所有的16位寄存器和段寄存器，但不能直接弹出到8位寄存器和内存字节。</li></ul></li><li><p><strong><code>LEA reg, mem</code></strong>:</p><ul><li><strong>功能</strong>：加载有效地址到指定的寄存器，不是传送内存处的数据，而是传送数据的地址。</li><li><strong>用法</strong>：<ul><li><code>LEA AX, [BX+SI]</code>：将BX和SI的和（即它们表示的内存地址）加载到AX。</li></ul></li><li><strong>注意点</strong>：通常用于地址计算，不改变内存内容。</li></ul></li><li><p><strong><code>LDS reg, mem</code></strong>:</p><ul><li><strong>功能</strong>：加载指针到数据段（DS）和寄存器。</li><li><strong>用法</strong>：<ul><li><code>LDS AX, [BX]</code>：将地址BX处的两个字作为AX的内容，接下来的两个字作为DS的内容。</li></ul></li><li><strong>注意点</strong>：经常在准备进行内存访问之前使用。</li></ul></li><li><p><strong><code>LES reg, mem</code></strong>:</p><ul><li><strong>功能</strong>：加载指针到额外段（ES）和寄存器。</li><li><strong>用法</strong>：<ul><li><code>LES BX, [SI]</code>：将地址SI处的两个字作为BX的内容，接下来的两个字作为ES的内容。</li></ul></li><li><strong>注意点</strong>：与LDS类似，但影响ES而不是DS。</li></ul></li><li><p><strong><code>XCHG op1, op2</code></strong>:</p><ul><li><strong>功能</strong>：交换两个操作数的值。</li><li><strong>用法</strong>：<ul><li><code>XCHG AX, BX</code>：交换AX和BX寄存器的内容。</li><li><code>XCHG AL, [BX]</code>：交换AL和地址BX处的字节值。</li></ul></li><li><strong>注意点</strong>：该指令可以用于任意寄存器对，也可以用于一个寄存器和一个内存位置。</li></ul></li><li><p><strong><code>MOVSB</code></strong>:</p><ul><li><strong>功能</strong>：从源字符串位置（由DS:SI指定）传送一个字节到目标字符串位置（由ES:DI指定），并根据DF标志更新SI和DI。</li><li>用法<ul><li><code>MOVSB</code>：从DS:SI处复制一个字节到ES:DI处。</li></ul></li><li><strong>注意点</strong>：如果DF=0，SI和DI都会递增；如果DF=1，SI和DI都会递减。</li></ul></li><li><p><strong><code>MOVSW</code></strong>:</p><ul><li><strong>功能</strong>：从源字符串位置（由DS:SI指定）传送一个字（两个字节）到目标字符串位置（由ES:DI指定），并根据DF标志更新SI和DI。</li><li>用法<ul><li><code>MOVSW</code>：从DS:SI处复制一个字到ES:DI处。</li></ul></li><li><strong>注意点</strong>：与<code>MOVSB</code>类似，但操作的单位是一个字而不是一个字节。</li></ul></li></ol><h2 id="算术指令">算术指令</h2><p>当然可以，以下是8086中关于算术指令的详细总结：</p><ol><li><p><strong><code>ADD dest, src</code></strong>:</p><ul><li><strong>功能</strong>：将两个操作数相加并将结果存储在目标操作数中。</li><li><strong>用法</strong>：<ul><li><code>ADD AX, BX</code>：将AX和BX的值相加，并将结果存放在AX中。</li></ul></li><li><strong>注意点</strong>：可能会设置或清除AF、CF、OF、PF、SF和ZF标志。</li></ul></li><li><p><strong><code>ADC dest, src</code></strong>:</p><ul><li><strong>功能</strong>：将两个操作数与进位标志（CF）相加并将结果存储在目标操作数中。</li><li><strong>用法</strong>：<ul><li><code>ADC AX, BX</code>：将AX、BX和CF的值相加，并将结果存放在AX中。</li></ul></li><li><strong>注意点</strong>：这个指令在多字节或多字的加法操作中非常有用，其中一个字节或一个字的加法可能会影响到下一个字节或字的加法。</li></ul></li><li><p><strong><code>SUB dest, src</code></strong>:</p><ul><li><strong>功能</strong>：从目标操作数中减去源操作数，并将结果存放在目标操作数中。</li><li><strong>用法</strong>：<ul><li><code>SUB AX, BX</code>：从AX的值中减去BX的值，并将结果存放在AX中。</li></ul></li><li><strong>注意点</strong>：可能会设置或清除AF、CF、OF、PF、SF和ZF标志。</li></ul></li><li><p><strong><code>SBB dest, src</code></strong>:</p><ul><li><strong>功能</strong>：从目标操作数中减去源操作数和进位标志（CF）。</li><li><strong>用法</strong>：<ul><li><code>SBB AX, BX</code>：从AX的值中减去BX和CF，并将结果存放在AX中。</li></ul></li><li><strong>注意点</strong>：与ADC类似，SBB在多字节或多字的减法操作中很有用。</li></ul></li><li><p><strong><code>MUL src</code></strong>:</p><ul><li><strong>功能</strong>：无符号乘法。将AX与源操作数相乘。</li><li><strong>用法</strong>：<ul><li><code>MUL BX</code>：如果源操作数是8位，结果将是16位，存放在AX中；如果源操作数是16位，结果将是32位，高16位存放在DX中，低16位存放在AX中。</li></ul></li><li><strong>注意点</strong>：如果结果是16位数，则DX将被清零；如果结果是32位数，DX将包含高16位。</li></ul></li><li><p><strong><code>IMUL src</code></strong>:</p><ul><li><strong>功能</strong>：有符号乘法。将AX与源操作数相乘。</li><li><strong>用法</strong>：<ul><li><code>IMUL BX</code>：与MUL类似，但考虑操作数的符号。</li></ul></li><li><strong>注意点</strong>：与MUL不同，IMUL是用于有符号数的乘法。</li></ul></li><li><p><strong><code>DIV src</code></strong>:</p><ul><li><strong>功能</strong>：无符号除法。将DX:AX与源操作数相除。</li><li><strong>用法</strong>：<ul><li><code>DIV BX</code>：如果源操作数是8位，那么AX将被视为被除数，结果的商将存放在AL中，余数将存放在AH中。如果源操作数是16位，则DX:AX将被视为被除数，结果的商将存放在AX中，余数将存放在DX中。</li></ul></li><li><strong>注意点</strong>：除数不应为零。如果是，会触发一个除以零的中断。</li></ul></li><li><p><strong><code>IDIV src</code></strong>:</p><ul><li><strong>功能</strong>：有符号除法。将DX:AX与源操作数相除。</li><li><strong>用法</strong>：<ul><li><code>IDIV BX</code>：与DIV类似，但考虑操作数的符号。</li></ul></li><li><strong>注意点</strong>：与DIV不同，IDIV用于有符号数的除法。</li></ul></li><li><p><strong><code>INC dest</code></strong>:</p><ul><li><strong>功能</strong>：将目标操作数增加1。</li><li><strong>用法</strong>：<ul><li><code>INC AX</code>：将AX增加1。</li></ul></li><li><strong>注意点</strong>：可能会设置或清除AF、OF、PF、SF和ZF标志，但不会影响CF标志。</li></ul></li><li><p><strong><code>DEC dest</code></strong>:</p><ul><li><p><strong>功能</strong>：将目标操作数减少1。</p><ul><li><strong>用法</strong>：<ul><li><code>DEC AX</code>：将AX减少1。</li></ul></li></ul></li><li><p><strong>注意点</strong>：可能会设置或清除AF、OF、PF、SF和ZF标志，但不会影响CF标志。</p></li></ul></li><li><p><strong><code>NEG dest</code></strong>:</p><ul><li><p><strong>功能</strong>：求目标操作数的二进制补码。</p><ul><li><strong>用法</strong>：<ul><li><code>NEG AX</code>：将AX的值替换为其二进制补码。</li></ul></li></ul></li><li><p><strong>注意点</strong>：如果操作数为0，则CF被清除；如果操作数不为0，则CF被设置。</p></li></ul></li><li><p><strong><code>CMP dest, src</code></strong>:</p><ul><li><p><strong>功能</strong>：比较两个操作数，实际上执行一个SUB操作但不保存结果，只设置标志。</p><ul><li><strong>用法</strong>：<ul><li><code>CMP AX, BX</code>：比较AX和BX的值。</li></ul></li></ul></li><li><p><strong>注意点</strong>：可能会设置或清除AF、CF、OF、PF、SF和ZF标志。</p></li></ul></li></ol><p>这些是8086的主要算术指令。每当执行算术指令时，都应该注意相关的标志，因为它们提供了关于操作结果的信息，如是否产生进位、溢出等。</p><h2 id="逻辑指令">逻辑指令</h2><ol><li><p><strong><code>AND dest, src</code></strong>:</p><ul><li><strong>功能</strong>：执行位与操作。</li><li><strong>用法</strong>：<ul><li><code>AND AX, BX</code>：将AX与BX执行按位与，并将结果存放在AX中。</li></ul></li><li><strong>注意点</strong>：会设置或清除OF、CF、PF、SF、ZF标志。OF和CF始终被清零。</li></ul></li><li><p><strong><code>OR dest, src</code></strong>:</p><ul><li><strong>功能</strong>：执行位或操作。</li><li><strong>用法</strong>：<ul><li><code>OR AX, BX</code>：将AX与BX执行按位或，并将结果存放在AX中。</li></ul></li><li><strong>注意点</strong>：OF和CF标志始终被清零。</li></ul></li><li><p><strong><code>XOR dest, src</code></strong>:</p><ul><li><strong>功能</strong>：执行位异或操作。</li><li><strong>用法</strong>：<ul><li><code>XOR AX, BX</code>：将AX与BX执行按位异或，并将结果存放在AX中。</li></ul></li><li><strong>注意点</strong>：当两个操作数相同时，结果为0。OF和CF标志始终被清零。</li></ul></li><li><p><strong><code>NOT dest</code></strong>:</p><ul><li><strong>功能</strong>：求操作数的一元反码（按位取反）。</li><li><strong>用法</strong>：<ul><li><code>NOT AX</code>：求AX的一元反码。</li></ul></li><li><strong>注意点</strong>：此指令不影响标志。</li></ul></li></ol><h2 id="移位指令">移位指令</h2><ol start="5"><li><p><strong><code>SHL dest, count</code> 或 <code>SAL dest, count</code></strong>:</p><ul><li><strong>功能</strong>：将目标操作数向左移动指定的位数。</li><li><strong>用法</strong>：<ul><li><code>SHL AX, 1</code>：将AX左移1位。</li></ul></li><li><strong>注意点</strong>：移出的最后一位存储在CF中，最高位的空位被清零。</li></ul></li><li><p><strong><code>SHR dest, count</code></strong>:</p><ul><li><strong>功能</strong>：将目标操作数向右移动指定的位数。</li><li><strong>用法</strong>：<ul><li><code>SHR AX, 1</code>：将AX右移1位。</li></ul></li><li><strong>注意点</strong>：移出的最后一位存储在CF中，最低位的空位被清零。</li></ul></li><li><p><strong><code>SAR dest, count</code></strong>:</p><ul><li><strong>功能</strong>：算术右移，保持最高位不变。</li><li><strong>用法</strong>：<ul><li><code>SAR AX, 1</code>：将AX算术右移1位。</li></ul></li><li><strong>注意点</strong>：移出的最后一位存储在CF中。</li></ul></li><li><p><strong><code>ROL dest, count</code></strong>:</p><ul><li><strong>功能</strong>：循环左移操作数。</li><li><strong>用法</strong>：<ul><li><code>ROL AX, 1</code>：将AX循环左移1位。</li></ul></li><li><strong>注意点</strong>：移出的最后一位存储在CF中，并从右边重新输入。</li></ul></li><li><p><strong><code>ROR dest, count</code></strong>:</p><ul><li><strong>功能</strong>：循环右移操作数。</li><li><strong>用法</strong>：<ul><li><code>ROR AX, 1</code>：将AX循环右移1位。</li></ul></li><li><strong>注意点</strong>：移出的最后一位存储在CF中，并从左边重新输入。</li></ul></li><li><p><strong><code>RCL dest, count</code></strong>:</p><ul><li><p><strong>功能</strong>：带进位的循环左移。</p><ul><li><strong>用法</strong>：<ul><li><code>RCL AX, 1</code>：将AX和CF一起循环左移1位。</li></ul></li></ul></li><li><p><strong>注意点</strong>：移出的最后一位存储在CF中。</p></li></ul></li><li><p><strong><code>RCR dest, count</code></strong>:</p><ul><li><p><strong>功能</strong>：带进位的循环右移。</p><ul><li><strong>用法</strong>：<ul><li><code>RCR AX, 1</code>：将AX和CF一起循环右移1位。</li></ul></li></ul></li><li><p><strong>注意点</strong>：移出的最后一位存储在CF中。</p></li></ul></li></ol><h2 id="比较指令">比较指令</h2><ol start="12"><li><p><strong><code>TEST dest, src</code></strong>:</p><ul><li><p><strong>功能</strong>：执行逻辑与操作，但结果不存储，仅用于设置标志。</p><ul><li><strong>用法</strong>：<ul><li><code>TEST AX, BX</code>：将AX和BX进行逻辑与操作。</li></ul></li></ul></li><li><p><strong>注意点</strong>：此指令与AND类似，但不会存储结果。</p></li></ul></li></ol><h2 id="控制转移指令">控制转移指令</h2><p>8086的控制转移指令可以分为三类：无条件跳转、条件跳转和循环控制。以下是它们的详细总结：</p><h3 id="1-无条件跳转指令">1. 无条件跳转指令</h3><ol><li><strong><code>JMP destination</code></strong>:<ul><li><strong>功能</strong>：跳转到指定的地址。</li><li><strong>用法</strong>：<ul><li><code>JMP LABEL</code>：跳转到LABEL标签指定的地址。</li></ul></li><li><strong>注意点</strong>：该跳转是无条件的，执行此指令后，总会跳转到指定的地址。</li></ul></li></ol><h3 id="2-条件跳转指令">2. 条件跳转指令</h3><p>这些指令基于标志寄存器中的某个或某些标志的状态来决定是否进行跳转。</p><ol><li><p><strong><code>JE/JZ destination</code></strong> (Jump if Equal/Zero):</p><ul><li><strong>功能</strong>：如果ZF标志为1，则跳转。</li><li><strong>用法</strong>：<ul><li><code>JE LABEL</code>：如果上一指令的结果为零（ZF=1），则跳转到LABEL。</li></ul></li></ul></li><li><p><strong><code>JNE/JNZ destination</code></strong> (Jump if Not Equal/Not Zero):</p><ul><li><strong>功能</strong>：如果ZF标志为0，则跳转。</li><li><strong>用法</strong>：<ul><li><code>JNE LABEL</code>：如果上一指令的结果非零（ZF=0），则跳转到LABEL。</li></ul></li></ul></li><li><p><strong><code>JB/JNAE/JC destination</code></strong> (Jump if Below/Not Above or Equal/Carry):</p><ul><li><strong>功能</strong>：如果CF标志为1，则跳转。</li><li><strong>用法</strong>：<ul><li><code>JB LABEL</code>：如果上一指令产生了进位（CF=1），则跳转。</li></ul></li></ul></li><li><p><strong><code>JAE/JNB/JNC destination</code></strong> (Jump if Above or Equal/Not Below/No Carry):</p><ul><li><strong>功能</strong>：如果CF标志为0，则跳转。</li><li><strong>用法</strong>：<ul><li><code>JAE LABEL</code>：如果上一指令没有产生进位（CF=0），则跳转。</li></ul></li></ul></li></ol><p>… 以此类推。8086有一系列的条件跳转指令，如：<code>JL</code>, <code>JGE</code>, <code>JO</code>, <code>JNO</code>, <code>JP</code>, <code>JNP</code>, <code>JS</code>, <code>JNS</code> 等，它们基于OF、SF、ZF、PF和CF的组合来决定是否跳转。</p><h3 id="3-循环控制指令">3. 循环控制指令</h3><ol><li><p><strong><code>LOOP destination</code></strong>:</p><ul><li><strong>功能</strong>：递减CX，并且如果CX不为0，则跳转。</li><li><strong>用法</strong>：<ul><li><code>LOOP LABEL</code>：减少CX的值。如果CX不为0，则跳转到LABEL。</li></ul></li><li><strong>注意点</strong>：无论是否跳转，CX都会递减。</li></ul></li><li><p><strong><code>LOOPE/LOOPZ destination</code></strong> (Loop while Equal/Zero):</p><ul><li><strong>功能</strong>：递减CX，如果CX不为0且ZF为1，则跳转。</li><li><strong>用法</strong>：<ul><li><code>LOOPE LABEL</code>：如果上一指令的结果为零且CX不为0，则跳转。</li></ul></li></ul></li><li><p><strong><code>LOOPNE/LOOPNZ destination</code></strong> (Loop while Not Equal/Not Zero):</p><ul><li><strong>功能</strong>：递减CX，如果CX不为0且ZF为0，则跳转。</li><li><strong>用法</strong>：<ul><li><code>LOOPNE LABEL</code>：如果上一指令的结果非零且CX不为0，则跳转。</li></ul></li></ul></li></ol><p>这些指令都依赖于特定的条件。在使用这些指令时，程序员需要确保在跳转之前设置了相应的条件（通常是上一个算术或逻辑指令的结果）。而循环控制指令则常常与算术指令结合使用，以创建计数器控制的循环。</p><h2 id="标志操作指令">标志操作指令</h2><p>8086的标志操作指令主要用于操作或测试标志寄存器（Flags Register）中的特定标志。以下是相关的标志操作指令的详细总结：</p><h3 id="1-clc">1. <strong>CLC</strong></h3><ul><li><strong>功能</strong>：清除进位标志（Carry Flag, CF）。</li><li><strong>用法</strong>：<ul><li><code>CLC</code></li></ul></li><li><strong>注意点</strong>：此指令将CF置为0，不影响其他标志。</li></ul><h3 id="2-cmc">2. <strong>CMC</strong></h3><ul><li><strong>功能</strong>：反转进位标志（Complement Carry Flag）。</li><li><strong>用法</strong>：<ul><li><code>CMC</code></li></ul></li><li><strong>注意点</strong>：如果CF原来是1，则将其变为0；如果原来是0，则将其变为1。</li></ul><h3 id="3-stc">3. <strong>STC</strong></h3><ul><li><strong>功能</strong>：设置进位标志。</li><li><strong>用法</strong>：<ul><li><code>STC</code></li></ul></li><li><strong>注意点</strong>：此指令将CF置为1，不影响其他标志。</li></ul><h3 id="4-cld">4. <strong>CLD</strong></h3><ul><li><strong>功能</strong>：清除方向标志（Direction Flag, DF）。</li><li><strong>用法</strong>：<ul><li><code>CLD</code></li></ul></li><li><strong>注意点</strong>：此指令将DF置为0，这意味着在使用字符串指令时，SI和DI寄存器会递增。</li></ul><h3 id="5-std">5. <strong>STD</strong></h3><ul><li><strong>功能</strong>：设置方向标志。</li><li><strong>用法</strong>：<ul><li><code>STD</code></li></ul></li><li><strong>注意点</strong>：此指令将DF置为1，这意味着在使用字符串指令时，SI和DI寄存器会递减。</li></ul><h3 id="6-cli">6. <strong>CLI</strong></h3><ul><li><strong>功能</strong>：清除中断标志（Interrupt Flag, IF）。</li><li><strong>用法</strong>：<ul><li><code>CLI</code></li></ul></li><li><strong>注意点</strong>：此指令将IF置为0，禁止外部中断。必须谨慎使用以避免禁止长时间的中断。</li></ul><h3 id="7-sti">7. <strong>STI</strong></h3><ul><li><strong>功能</strong>：设置中断标志。</li><li><strong>用法</strong>：<ul><li><code>STI</code></li></ul></li><li><strong>注意点</strong>：此指令将IF置为1，允许外部中断。</li></ul><h3 id="8-lahf">8. <strong>LAHF</strong></h3><ul><li><strong>功能</strong>：加载标志到AH寄存器。</li><li><strong>用法</strong>：<ul><li><code>LAHF</code></li></ul></li><li><strong>注意点</strong>：此指令将当前的标志（SF, ZF, AF, PF, CF）的值加载到AH寄存器中。</li></ul><h3 id="9-sahf">9. <strong>SAHF</strong></h3><ul><li><strong>功能</strong>：将AH寄存器的内容存储到标志寄存器。</li><li><strong>用法</strong>：<ul><li><code>SAHF</code></li></ul></li><li><strong>注意点</strong>：此指令将AH寄存器中的值加载到标志寄存器中的标志（SF, ZF, AF, PF, CF）。</li></ul><h3 id="10-pushf">10. <strong>PUSHF</strong></h3><ul><li><strong>功能</strong>：将标志寄存器的内容压入堆栈。</li><li><strong>用法</strong>：<ul><li><code>PUSHF</code></li></ul></li><li><strong>注意点</strong>：标志寄存器的当前值被压入堆栈中。</li></ul><h3 id="11-popf">11. <strong>POPF</strong></h3><ul><li><strong>功能</strong>：从堆栈中弹出值到标志寄存器。</li><li><strong>用法</strong>：<ul><li><code>POPF</code></li></ul></li><li><strong>注意点</strong>：堆栈的顶部值被加载到标志寄存器中。</li></ul><p>这些标志操作指令允许程序员直接控制或测试标志寄存器中的标志。当使用这些指令时，需要特别注意确保不会不小心改变无意中改变的标志，因为这可能会影响程序的其他部分。</p><h1>中断</h1><p>8086 微处理器中的中断系统是该处理器响应外部和内部事件的一种机制。在8086中，中断可以分为两类：硬件中断和软件中断。</p><ol><li><p><strong>硬件中断</strong>：</p><ul><li><strong>外部中断</strong>：由外部事件触发，例如外部设备发出的请求。这些中断通常用于设备驱动程序中，使得微处理器能够响应外部设备的需求。</li><li><strong>NMI（非屏蔽中断）</strong>：是一个特殊的外部中断，它不能被程序禁用。在8086中，NMI由特定的硬件条件触发，如电源故障。</li><li><strong>INTR（可屏蔽中断）</strong>：不同于NMI，INTR是可以被程序通过CLI指令禁用或通过STI指令启用的。</li></ul></li><li><p><strong>软件中断</strong>：</p><ul><li>通过指令（如<code>INT</code>指令）明确生成。在8086中，软件中断常常用于系统调用或其他高级功能，例如BIOS中的服务调用。</li></ul></li></ol><p><strong>中断过程</strong>：<br>当中断发生时，8086会完成当前的指令，然后执行以下动作：</p><ul><li>当前的标志寄存器、CS和IP被推送到堆栈中。</li><li>根据中断类型和<strong>中断号</strong>，从中断向量表（IVT）中查找中断处理程序的地址。<strong>IVT位于物理地址0000:0000到0000:03FF的内存区域，其中每个中断使用一个4字节的条目（2字节的偏移量和2字节的段地址）</strong>。</li><li>微处理器从IVT中取得中断处理程序的段地址和偏移量，然后跳转到该地址以执行中断处理程序。</li><li>中断处理程序执行结束后，通常使用<code>IRET</code>指令返回到被中断的程序。</li></ul><p><strong>总之</strong>，8086的中断系统为微处理器提供了与外部设备交互和执行系统级服务的机制。</p><h1>补充</h1><h2 id="cmos-ram">CMOS RAM</h2><p>访问的时候直接使用这个数就行,   比如 0,2,4,6,8,  拿出来的数据都是一个字节</p><ul><li>00h: 存储秒信息</li><li>02h: 存储分钟信息</li><li>04h: 存储小时信息</li><li>06h: 存储一周中的某一天的信息</li><li>07h: 存储月中的某一天的信息</li><li>08h: 存储月份信息</li><li>09h: 存储年份信息</li></ul><h2 id="偏移地址寄存器与段地址寄存器的默认对应">偏移地址寄存器与段地址寄存器的默认对应</h2><p>在x86架构中，段寄存器和偏移寄存器一起为我们提供了物理地址。在实模式下（比如早期的DOS系统），通过段地址和偏移地址的组合，我们得到物理地址：[ \text{物理地址} = (\text{段地址} \times 16) + \text{偏移地址} ]</p><p>在实模式下，不同的指令或操作经常有一个默认的段寄存器。以下是x86架构中各偏移寄存器默认对应的段寄存器：</p><ol><li><strong>BX、SI、DI</strong>：默认与<strong>DS</strong>（数据段寄存器）相关联。</li><li><strong>SP、BP</strong>：默认与<strong>SS</strong>（堆栈段寄存器）相关联。</li><li><strong>IP</strong>：默认与<strong>CS</strong>（代码段寄存器）相关联。IP是指令指针寄存器，用于指向当前执行的指令。</li></ol><p>但是，这些默认的段：偏移关系可以通过使用段重写前缀来更改。例如，你可以使用<code>ES:</code>前缀来明确地指定使用<code>ES</code>段寄存器与<code>DI</code>或其他寄存器组合。</p><p>在受保护模式和长模式中（例如，现代32位和64位操作系统中），段寄存器的行为和意义与实模式中有所不同。在这些模式下，段寄存器主要是用于访问描述符表，而不是简单地提供物理地址的基地址。但了解实模式下的默认段：偏移组合对于理解x86架构的历史和基本概念很有帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研计划表</title>
      <link href="/2023/09/08/%E8%80%83%E7%A0%94/%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92%E8%A1%A8/"/>
      <url>/2023/09/08/%E8%80%83%E7%A0%94/%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>计划表</h1><p>数学:  跟着张宇尽快过一遍,  学的过程中 多刷一下题目 不要偷懒  (每天至少两个小时)</p><p>英语:  每天读几遍kk音标,  单词一直记着 一天三十个 ,  语法过一遍 然后开始刷题,  然后再过一遍语法  (每天至少两个小时)</p><p>政治: 9月份再开始吧</p><p>408:  数据结构-&gt;操作系统-&gt;计算机组成原理-&gt;计算机网络   学完一章就用微信小程序刷题,  全部学完后, 就开始刷试卷查漏补缺 (每天至少两个小时)</p><p>学习的时候要写好笔记, 尽量用电脑写成博客, 然后推送到GitHub上去, 这样就能随时随机复习了</p><p><strong>晚上花一个小时以内的时间总结全天学习内容</strong>,</p><p><strong>贵在坚持,不在量</strong></p><p>每天早上待背内容:</p><ul><li><p>kk音标</p></li><li><p>介词</p></li><li><p>泰勒公式</p></li><li><p>基本求导公式</p></li><li><p>预备知识公式</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高等数学</title>
      <link href="/2023/06/28/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
      <url>/2023/06/28/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><h1>预备知识</h1><h2 id="函数">函数</h2><h2 id="反函数">反函数</h2><h2 id="复合函数">复合函数</h2><h2 id="函数的四种特性">函数的四种特性</h2><h3 id="有界性">有界性</h3><h3 id="单调性">单调性</h3><h3 id="奇偶性">奇偶性</h3><h3 id="周期性">周期性</h3><h2 id="画图">画图</h2><h3 id="直角坐标系画图">直角坐标系画图</h3><h3 id="画极坐标系图">画极坐标系图</h3><ul><li>描点法 比较麻烦, 得计算多个角度对应的长度 然后连接起来</li><li>画出长度与角度的直角坐标系关系图, 长度是y轴, 角度是x轴,  然后就可以画极坐标图了  ,  这样可以很直观的看到角度变化会带来长度的变化</li></ul><p>举例:</p><p>画出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r=a(1-\cos \theta)(a&gt;0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p><p>描点法:</p><p><img src="/2023/06/28/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/../img/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6assets/image-20230629170459682.png" alt="image-20230629170459682"></p><p><img src="/2023/06/28/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/../img/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6assets/image-20230629171750792.png" alt="image-20230629171750792"></p><p>画关系图法:</p><p><img src="/2023/06/28/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/../img/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6assets/image-20230629171758114.png" alt="image-20230629171758114"></p><h3 id="根据参数方程画图">根据参数方程画图</h3><h1>数列极限</h1><h2 id="定义">定义</h2><p>四句话:   对于任给正数 x, 存在正整数N, 当 n&gt;N 时,  恒有 | an - a | &lt; x  =&gt; a是an的极限</p><h2 id="性质">性质</h2><h2 id="数列极限的运算">数列极限的运算</h2><h2 id="夹逼准则">夹逼准则</h2><h2 id="单调有界准则">单调有界准则</h2><h2 id="题目">题目</h2><h1>函数极限与连续性</h1><h2 id="函数极限">函数极限</h2><h3 id="函数极限定义">函数极限定义</h3><h3 id="函数极限的性质">函数极限的性质</h3><h3 id="极限的四则运算">极限的四则运算</h3><h3 id="夹逼准则">夹逼准则</h3><h3 id="洛必达法则">洛必达法则</h3><h3 id="泰勒公式">泰勒公式</h3><h3 id="海涅定义-归结原则">海涅定义(归结原则)</h3><h3 id="无穷小">无穷小</h3><h4 id="定义">定义</h4><h4 id="无穷小比阶">无穷小比阶</h4><h4 id="运算规则">运算规则</h4><h4 id="等价无穷小替换">等价无穷小替换</h4><h2 id="函数的连续与间断">函数的连续与间断</h2><h3 id="连续的定义">连续的定义</h3><h3 id="间断的定义和分类">间断的定义和分类</h3><h2 id="七种未定式">七种未定式</h2><p><strong>这7种结果就是 极限可能存在也可能不存在</strong>,  其他的是要么存在,要么不存在 比如 无穷大 + 无穷大 就是 无穷大, 已经不存在了,不需要判断</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>0</mn><mn>0</mn></mfrac><mfrac><mi mathvariant="normal">∞</mi><mi mathvariant="normal">∞</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{0}{0}   \frac{\infty}{\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>⋅</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">0 \cdot \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></p><p>对于这种题型   要考虑使用  运算规则, 洛必达法则,泰勒公式, <strong>归结原则</strong>,<strong>夹逼准则</strong>,  对于前三个, 我们通常会想到的,  但是对于后两个, 特别是夹逼准则, 一定要记得,  归结原则的话需要先求出函数的极限, 然后拿出一个特殊的x数列带入进去得到待求数列极限, 比如下面这个题</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">∞</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></p><p>对于这种, 一定要转变为   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>0</mn><mn>0</mn></mfrac><mfrac><mi mathvariant="normal">∞</mi><mi mathvariant="normal">∞</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{0}{0}   \frac{\infty}{\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>⋅</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">0 \cdot \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> ,  有分母就是通分, 没有就创建分母再通分, 创建分母的方式有: 提取公因式  换元倒代换,</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">∞</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">\infty^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">∞</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">0^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mi mathvariant="normal">∞</mi></msup></mrow><annotation encoding="application/x-tex">1^{\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span></span></span></span></span></span></span></span> .</p><p>这种就是转变成 e^ln 这种形式</p><h2 id="做题">做题</h2><h3 id="求函数某一点的极限">求函数某一点的极限</h3><p>如果函数在某一点连续, 就没有必要分左右讨论, 就是函数值, <strong>如果不连续或者我们不知道连续不连续,  我们需要分两侧来讨论</strong>, 两侧极限相等, 那么极限存在, 否则就不存在</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> 当 </mtext><mi>x</mi><mo>→</mo><mn>1</mn><mtext> 时, 函数 </mtext><mfrac><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></mfrac><msup><mi mathvariant="normal">e</mi><mfrac><mn>1</mn><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></mfrac></msup><mtext> 的极限 </mtext></mrow><annotation encoding="application/x-tex">\text { 当 } x \rightarrow 1 \text { 时, 函数 } \frac{x^2-1}{x-1} \mathrm{e}^{\frac{1}{x-1}} \text { 的极限 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">当</span><span class="mord"> </span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.260438em;vertical-align:-0.7693300000000001em;"></span><span class="mord">1</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">时</span><span class="mord">, </span><span class="mord cjk_fallback">函数</span><span class="mord"> </span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord"><span class="mord mathrm">e</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.00402em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.40352142857142853em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的极限</span><span class="mord"> </span></span></span></span></span></span></p><p>这个题, 我们就需要分 x在1左右两侧的极限</p><h3 id="函数在区间有界">函数在区间有界</h3><p><strong>(1) 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在闭区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span> 上为连续函数, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span> 上必定有界.</strong><br><strong>(2) 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 内为连续函数, 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><msub><mi>a</mi><mo>+</mo></msub></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><msub><mi>b</mi><mo>−</mo></msub></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow a_+} f(x) \lim _{x \rightarrow b_-} f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.041765em;vertical-align:-0.291765em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2736642857142857em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.291765em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2736642857142857em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.291765em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>都存在, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 内必定有界.</strong></p><h3 id="讨论间断点问题">讨论间断点问题</h3><ol><li>首先看无定义点 处 两边极限值</li><li>如果是分段函数,  就看 分段处两边极限  和 函数值</li></ol><h3 id="求未定式的极限值">求未定式的极限值</h3><ul><li>要定要把公式灵活运用, 比如泰勒和洛必达, 他们是可以共同使用的,  有时候就需要组合他们一起使用</li><li>既要看局部, 又要有大局观,  比如在做等价无穷小替换的时候,  趋于0的是一个很复杂的关于自变量的表达式,  但是我们可以把它看成一个整体然后做等价替换</li></ul><h1>一元函数微分学的概念与计算</h1><h2 id="概念">概念</h2><h3 id="导数">导数</h3><h4 id="单侧导数">单侧导数</h4><p><em style="color:red">导数说到底还是极限问题</em></p><h4 id="导数的几何意义">导数的几何意义.</h4><h4 id="高阶导数的概念">高阶导数的概念.</h4><h4 id="定理">定理</h4><h3 id="微分">微分</h3><h4 id="定义">定义</h4><h2 id="计算">计算</h2><h3 id="四则运算">四则运算</h3><h3 id="分段函数求导">分段函数求导</h3><h3 id="变限积分求导">变限积分求导</h3><h3 id="复合求导">复合求导</h3><h3 id="反函数的导数">反函数的导数</h3><h3 id="参数方程所确定的函数的导数">参数方程所确定的函数的导数</h3><h3 id="隐函数求导">隐函数求导</h3><h3 id="对数求导法">对数求导法</h3><h3 id="幂指函数求导">幂指函数求导</h3><h3 id="高阶求导">高阶求导</h3><h2 id="基本的求导公式">基本的求导公式</h2><h2 id="总结">总结</h2><p>本讲主要是 讲了导数和微分的定义,  以及如何关于导数求导的计算,  <strong>一定要打好基础,  记牢固基本求导公式,  因为后续找原函数的时候,需要用到, 如果导数记得不牢固, 那么找原函数就会很麻烦</strong></p><h1>一元微分学的几何应用</h1><h2 id="极值和最值的概念">极值和最值的概念</h2><h3 id="极值">极值</h3><h3 id="最值">最值</h3><h2 id="单调性和极值的判别">单调性和极值的判别</h2><h3 id="单调性的判别">单调性的判别</h3><h3 id="一阶可导点是极值点的必要条件">一阶可导点是极值点的必要条件</h3><h3 id="判别极值的第一充分条件">判别极值的第一充分条件</h3><blockquote></blockquote><h3 id="判别极值的第二充分条件">判别极值的第二充分条件</h3><h3 id="判别极值的第三充分条件">判别极值的第三充分条件</h3><p>小技巧, 对于 极值判别的第二第三充分条件,   我们可以将公式记成这样 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{(n)}\left(x_0\right)&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x) - f\left(x_0\right)&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{(n)}\left(x_0\right)&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x) - f\left(x_0\right)&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 这样就很快的记住了</p><h2 id="凹凸性与拐点的概念">凹凸性与拐点的概念</h2><h3 id="凹凸性的定义">凹凸性的定义</h3><p>设函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上连续. 如果对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上任意不同两点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 恒有</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mfrac><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><mo>&lt;</mo><mfrac><mrow><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow><mo>+</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow></mrow><mn>2</mn></mfrac><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">f\left(\frac{x_1+x_2}{2}\right)&lt;\frac{f\left(x_1\right)+f\left(x_2\right)}{2},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span></span></span></span></span></p><p>则称 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上的图形是凹的 (或凹弧)</p><p><img src="/2023/06/28/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/../img/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6assets/image-20230707150543901.png" alt="image-20230707150543901"></p><p>如果恒有</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mfrac><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><mo>&gt;</mo><mfrac><mrow><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow><mo>+</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow></mrow><mn>2</mn></mfrac><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">f\left(\frac{x_1+x_2}{2}\right)&gt;\frac{f\left(x_1\right)+f\left(x_2\right)}{2},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span></span></span></span></span></p><p>则称 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上的图形是凸的 (或凸弧).</p><p><img src="/2023/06/28/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/../img/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6assets/image-20230707150604895.png" alt="image-20230707150604895"></p><h3 id="拐点的定义">拐点的定义</h3><p><strong>连续曲线</strong>的凹弧与凸弧的分界点称为该曲线的拐点.(不用区分先凹还是先凸)  这是一个函数点(x,f(x))</p><h2 id="凹凸性与拐点的判别">凹凸性与拐点的判别</h2><h3 id="判别凹凸性">判别凹凸性</h3><p>设函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上二阶可导.<br>(1)若在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{\prime \prime}(x)&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上的图形是凹的;<br>(2) 若在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{\prime \prime}(x)&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 上的图形是凸的.</p><h3 id="二阶可导点是拐点的必要条件">二阶可导点是拐点的必要条件</h3><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f^{\prime \prime}\left(x_0\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 存在, 且点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(x_0, f\left(x_0\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 为曲线上的拐点, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{\prime \prime}\left(x_0\right)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.</p><h3 id="判别拐点的第一充分条件">判别拐点的第一充分条件</h3><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x=x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处连续, 在点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x=x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的某去心邻域 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>U</mi><mo>˙</mo></mover><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>δ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\dot{U}\left(x_0, \delta\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.17019em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9201900000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.11111000000000001em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 内二阶导数存在, 且在该点的左、右邻域 内 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{\prime \prime}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 变号 (无论是由正变负, 还是由负变正), 则点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(x_0, f\left(x_0\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 为曲线上的拐点.</p><h3 id="判别拐点的第二充分条件">判别拐点的第二充分条件</h3><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x=x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的某邻域内三阶可导, 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo>=</mo><mn>0</mn><mo separator="true">,</mo><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{\prime \prime}\left(x_0\right)=0, f^{\prime \prime \prime}\left(x_0\right) \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(x_0, f\left(x_0\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 为拐点.</p><h3 id="判别拐点的第三充分条件">判别拐点的第三充分条件</h3><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 阶可导, 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo>=</mo><mn>0</mn><mo stretchy="false">(</mo><mi>m</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo mathvariant="normal">≠</mo><mn>0</mn><mo stretchy="false">(</mo><mi>n</mi><mo>⩾</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{(m)}\left(x_0\right)=0(m=2, \cdots, n-1), f^{(n)}\left(x_0\right) \neq 0(n \geqslant 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>, 则当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为奇数时, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(x_0, f\left(x_0\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 为拐点.</p><h2 id="渐近线">渐近线</h2><h3 id="铅垂渐近线">铅垂渐近线</h3><p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><msup><mi>x</mi><mo lspace="0em" rspace="0em">+</mo></msup></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow x^{+}} f(x)=\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.341865em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7026642857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> (或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><msub><mi>x</mi><mn>0</mn></msub></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow x_0} f(x)=\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> ), 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x=x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为一条铅垂渐近线.</p><h3 id="水平渐近线">水平渐近线</h3><p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow+\infty} f(x)=y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y=y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为一条水平渐近线; 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow-\infty} f(x)=y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y=y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为一条水平渐近线; 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow+\infty} f(x)=\lim _{x \rightarrow-\infty} f(x)=y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y=y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为一条水平渐近线.</p><h3 id="斜渐近线">斜渐近线</h3><p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>x</mi></mfrac><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><mrow><mo fence="true">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo fence="true">]</mo></mrow><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow+\infty} \frac{f(x)}{x}=a_1, \lim _{x \rightarrow+\infty}\left[f(x)-a_1 x\right]=b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y=a_1 x+b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是曲线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的一条斜渐近线;<br>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow></msub><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>x</mi></mfrac><mo>=</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow></msub><mrow><mo fence="true">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>a</mi><mn>2</mn></msub><mi>x</mi><mo fence="true">]</mo></mrow><mo>=</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow-\infty} \frac{f(x)}{x}=a_2, \lim _{x \rightarrow-\infty}\left[f(x)-a_2 x\right]=b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>a</mi><mn>2</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y=a_2 x+b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是曲线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的一条斜渐近线;<br>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>x</mi></mfrac><mo>=</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow></msub><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>x</mi></mfrac><mo>=</mo><mi>a</mi><mo separator="true">,</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>a</mi><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow></msub><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>a</mi><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow+\infty} \frac{f(x)}{x}=\lim _{x \rightarrow-\infty} \frac{f(x)}{x}=a, \lim _{x \rightarrow+\infty}[f(x)-a x]=\lim _{x \rightarrow-\infty}[f(x)-a x]=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y=a x+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 是曲线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的 一条斜渐近线.</p><h3 id="解答步骤">解答步骤</h3><ol><li>找无定义点 或者 定义域端点, 如果函数值趋于无穷大,就是铅锤渐近线,</li><li>当x趋于无穷大时, 如果函数值趋于常数,就是水平渐近线</li><li>f(x)/x  趋于无穷大的时候,如果极限存在不等于0 记做a, 然后再求 f(x)-ax 趋于无穷大的时候是否存在, 如果两个都满足了 那么就存在斜渐进线,</li></ol><h2 id="最值或取值范围">最值或取值范围</h2><p>求闭区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span> 上<strong>连续函数</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的最大值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 和最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span><br>(1)求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 内的可疑点—驻点与不可导点, 并求出这些可疑点处的函数值;<br>(2) 求出端点的函数值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>;<br>(3) 比较以上所求得的所有函数值, 其中最大者为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span> 上的最大值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, 最小者为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span> 上的最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>.</p><p>求开区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 内连续函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的最值或者取值范围  (不一定存在最值)<br>(1)求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 内的可疑点一驻点与不可导点, 并求出这些可疑点处的函数值.<br>(2) 求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 两端的单侧极限: 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span> 为有限常数, 则求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lim</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lim f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lim</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lim</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lim f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lim</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>; 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 为- - , 则求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lim</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lim f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lim</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>; 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span>, 则求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lim _{x \rightarrow+\infty} f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>. 记以上所求左端极限为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, 右端极限为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>.<br>(3) 比较(1), (2) 所得结果, 确定最值或取值范围.</p><h2 id="做函数图形">做函数图形</h2><p>给出函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, 作图的一般步骤:<br>(1) 确定函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的定义域, 并考查它是否有奇偶对称性;<br>(2) 求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{\prime}(x), f^{\prime \prime}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, 用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的无定义点, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{\prime}(x)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的点, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{\prime}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 不存在的点, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f^{\prime \prime}(x)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的点, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{\prime \prime}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 不 存在的点, 将定义域划分为若干子区间, 确定函数图形在各个子区间上的单调性与凹凸性, 进而确定函数 的极值点和拐点;<br>(3) 确定渐近线 (如果有的话);<br>(4)作出函数图形.<br>这是基本功, 一定要重视.</p><h2 id="总结">总结</h2><ul><li>导数只是研究单调性,极值 凹凸性和拐点的工具,   我们千万要记住他们的定义, 有时候不需要使用导数 使用定义就能够把题目做出来了</li></ul><h1>中值定理</h1><h2 id="涉及到函数的中值定理">涉及到函数的中值定理</h2><h3 id="有界与最值定理">有界与最值定理</h3><h3 id="介值定理">介值定理</h3><h3 id="平均值定理">平均值定理</h3><h3 id="零点定理">零点定理</h3><h2 id="涉及到导数的中值定理">涉及到导数的中值定理</h2><h3 id="费马定理">费马定理</h3><h3 id="罗尔定理">罗尔定理</h3><h3 id="拉格朗日中值定理">拉格朗日中值定理</h3><p><em style="color:red"> 我们不一定要在固定作用区间上用拉格朗日, 我们也可以将一个区间变成动态的 , 比如将b变成x</em></p><h3 id="泰勒公式">泰勒公式</h3><h2 id="涉及到积分的中值定理">涉及到积分的中值定理</h2><h3 id="积分中值定理">积分中值定理</h3><h2 id="做题">做题</h2><h1>零点问题与微分不等式</h1><h2 id="零点问题">零点问题</h2><h3 id="零点定理">零点定理</h3><h3 id="单调性">单调性</h3><h3 id="罗尔原话">罗尔原话</h3><h3 id="实系数奇次方程至少有一个实根">实系数奇次方程至少有一个实根</h3><h2 id="微分不等式">微分不等式</h2><h1><strong>补充</strong></h1><h2 id="转换坐标系">转换坐标系</h2><p><em style="color:red"><strong>转换坐标系不会改变图形的实际形状</strong>，<strong>但是会改变描述这个图形的方程式</strong></em>。有些图形在极坐标系中表示起来更简单，有些则在直角坐标系中更简单。对于有些复杂的图形,比如椭圆这些二元二次方程,或者二元多次方程  我们可以将直角坐标系方程变成极坐标, 然后 <strong>建立 直角坐标系 角度和长度的关系</strong>,  然后观察这个关系图 画出 图形对象的极坐标系,  然后直接在极坐标系的中心建立直角坐标系,  这样就把图形画好了</p><h2 id="极限">极限</h2><p>在数学中，极限是对函数在某点趋近的行为进行描述的一种工具。我们常常会讨论一个函数在某一点的极限，或者当自变量趋近无穷时函数的极限。极限的概念是微积分学基础之一，而微积分又是现代科学和工程中的基本工具。</p><ol><li><p><strong>序列的极限</strong>：假设我们有一个数列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{a_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>。如果存在一个实数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，对于任何给定的正实数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>，都存在一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，使得当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n &gt; N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>n</mi></msub><mo>−</mo><mi>L</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">|a_n - L| &lt; \varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>，那么我们说序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{a_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 的极限为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\lim_{n\to\infty} a_n = L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>。</p></li><li><p><strong>函数的极限</strong>：假设我们有一个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 和一个实数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。如果存在一个实数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，对于任何给定的正实数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>，都存在一个正实数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>，使得当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><mi>c</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">0&lt;|x-c|&lt;\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span> 时，都有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>L</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">|f(x)-L|&lt;\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>，那么我们说函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 趋近于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 时的极限为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mi>c</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\lim_{x\to c} f(x) = L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>。</p></li></ol><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>（epsilon）和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>（delta）是用于描述&quot;接近程度&quot;的阈值。</p><p>请注意，有时候函数在某一点的极限可能不存在。例如，当函数在接近某一点时呈现出“震荡”的行为，或者当函数在某一点的左极限和右极限不相等时，<strong>我们就说该函数在这一点的极限不存在</strong>。</p><blockquote><p>对于序列的极限,  我们指的是当n趋于无穷大</p></blockquote><h3 id="极限和有界">极限和有界</h3><p>极限和有界这两个概念在数学中都是非常重要的，尽管它们是两个不同的概念，但有时它们之间可以有一些有趣的交集。让我们来分别讨论一下这两个概念：</p><p><strong>极限</strong>：如我在前面的回答中所述，极限是对函数或序列在某点趋近的行为进行描述的一种工具。极限可能存在，也可能不存在。例如，考虑函数 f(x) = x，当x趋向无穷大时，f(x)的极限就不存在，因为随着x的增大，f(x)的值也在无限增大。</p><p><strong>有界</strong>：在数学中，如果一个集合的元素在某种意义上&quot;不会无限大或无限小&quot;，那么我们就说这个集合是有界的。对于一组实数来说，如果存在一个实数M，使得这组数中的任何数的绝对值都不超过M，那么我们就说这组数是有界的。</p><p>那么，这两个概念之间的关系是什么呢？</p><p>一个有趣的点是：<strong>如果一个序列有极限，那么这个序列一定是有界的</strong>。这是因为，根据极限的定义，当n足够大的时候，序列的项都可以被&quot;限制&quot;在离极限值一个非常小的区间内。然而，反过来并不总是成立，也就是说，一个序列即使是有界的，也不一定存在极限。<strong>一个简单的例子就是序列 {(-1)^n}，这个序列是有界的，但是它不收敛，也就是说，它没有极限。</strong></p><h2 id="概念">概念</h2><h3 id="无穷大无穷小">无穷大无穷小</h3><p>在微积分中，无穷大量和无穷小量是两个基本的概念，用来描述一些量的特性或行为。以下是对这两个概念的简单介绍：</p><ol><li><strong>无穷大量</strong>：如果一个序列的元素的绝对值趋向于无穷大（即没有上界），那么我们就称这个序列是无穷大量。例如，序列 {n}（n是所有正整数）就是无穷大量，因为随着n的增大，**序列的元素值也趋向于无穷大。**如果是跳跃来的趋于无穷大, 比如 奇数项趋于无穷大, 偶数项随机值, <strong>那么这个只能说是无界量, 而不是无穷大</strong></li><li><strong>无穷小量</strong>：如果一个序列的元素的绝对值趋向于0，那么我们就称这个序列是无穷小量。例如，序列 {1/n}（n是所有正整数）就是无穷小量，因为随着n的增大，<strong>序列的元素值越来越接近0</strong>。如果是跳跃来的趋于无穷小, 比如 奇数项趋于无穷小, 偶数项随机值, <strong>那就不能说是无穷小</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语语法</title>
      <link href="/2023/06/27/English/%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/06/27/English/%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>贵在坚持</p></blockquote><h1>前言</h1><p>趁这次考研,  总结一下大体的英语语法吧.</p><h1>基本句子知识</h1><h2 id="词性">词性</h2><p>英语句子中主要包含以下几种词性：</p><ol><li><p><strong>名词(Nouns)</strong>：指人、地点、事物、抽象概念。如：“book”（书），“Tom”（汤姆），“city”（城市）等。</p></li><li><p><strong>动词(Verbs)</strong>：表示行动、状态或存在。如：“run”（跑），“is”（是），“seem”（似乎）等。</p></li><li><p>形容词(Adjectives)：<strong>描述或修饰名词</strong>。如：“happy”（快乐的），“blue”（蓝色的）等。</p></li><li><p>副词(Adverbs)：<strong>修饰动词、形容词或其他副词</strong>，表达方式、时间、地点、原因等。如：“slowly”（慢慢地），“very”（非常）等。</p></li><li><p>代词(Pronouns)：<strong>代替名词或短语</strong>。如：“he”（他），“it”（它），“they”（他们）等。</p></li><li><p>介词(Prepositions)：<em style="color:pink"><strong>表达物体之间的关系</strong></em>。如：“in”（在…里），“on”（在…上），“with”（和…一起）等。</p></li><li><p>连词(Conjunctions)：<strong>连接词、短语或句子</strong>。如：“and”（和），“but”（但是），“if”（如果）等。</p></li><li><p>感叹词(Interjections)：<strong>表达感情或反应</strong>。如：“Oh!”（哦！），“Wow!”（哇！）等。</p></li><li><p>冠词(Articles)：<strong>在名词前面确定或限定名词的使用</strong>。如：“a”（一个），“an”（一个，前面的单词以元音音标开头时使用），“the”（特定的）。</p></li></ol><p>每种词性都有其特定的规则和使用情况，掌握它们是理解和使用英语的关键。</p><h2 id="句子成分">句子成分</h2><p>在英语句子中，有以下几种主要的句子成分：</p><ol><li><p>主语（Subject）：主语是句子的中心，表示动作、行为或状态的发起者。主语通常由<strong>名词、代词、名词短语、从句、动名词或不定式短语、甚至有时由形容词或数词</strong>充当。</p></li><li><p>谓语（Predicate）：谓语表明主语的动作、行为或状态。谓语由<strong>动词、动词短语</strong>构成。在复合句中，谓语可以包括多个动词或动词短语。</p></li><li><p>宾语（Object）：<strong>宾语是动词或介词的目标</strong>。宾语可以由<strong>名词、代词、名词短语、从句、动名词或不定式短语</strong>充当。</p></li><li><p>补语（Complement）：补语是用来补充说明主语或宾语，使句意完整的成分。补语可以由<strong>名词、形容词、副词、介词短语、不定式、动名词或从句</strong>充当。</p></li><li><p>定语（Attribute）：定语是用来修饰名词的成分，它描述或限定名词。定语可以由<strong>形容词、名词、代词、数词、介词短语、从句、或者分词</strong>充当。</p></li><li><p>状语（Adverbial）：状语是用来修饰动词、形容词、副词或整个句子的成分，表示动作或状态的时间、地点、原因、方式、程度等。状语可以由<strong>副词、介词短语、从句、分词短语或不定式短语</strong>充当。</p></li></ol><p>以上是英语句子的基本成分及其常用词性。需要注意的是，一种词性的词可以在不同的句子结构中充当不同的成分，反之，一种成分也可以由不同词性的词来充当。具体取决于句子的语境和结构。</p><h2 id="限定词">限定词</h2><p>限定词（determiners）是英语语法中的一种词类，主要用来引入名词，<strong>限定其范围或数量</strong>。限定词通常出现在名词（或名词短语）的开头，可以和形容词一起修饰名词。</p><p>以下是一些常见的限定词种类：</p><ol><li><p><strong>冠词</strong>：包括定冠词（the）和不定冠词（a，an）。例如：“the book”，“a cat”。</p></li><li><p><strong>物主代词</strong>：如 my, your, his, her, its, our, their。例如：“my car”，“their house”。</p></li><li><p><strong>指示代词</strong>：这，那（this, that）以及它们的复数形式（these, those）。例如：“this pen”，“those books”。</p></li><li><p><strong>数量词</strong>：如一些、所有、无、多、少等。例如：“some apples”，“all people”。</p></li><li><p><strong>疑问词</strong>：用于提问的限定词，例如 which, what。例如：“Which book do you like?”。</p></li><li><p><strong>序数词</strong>：如第一、第二等。例如：“the first day”，“the second time”。</p></li><li><p><strong>基数词</strong>：如一、两、三等。例如：“two dogs”，“three cats”。</p></li></ol><p>这些<strong>限定词可以帮助我们更具体地定义或限定我们正在讨论的名词或名词短语</strong>。例如，在句子 “I want a book” 中，“a” 是一个限定词，它说明我们要的是“一本”书，而不是特定的某本书。</p><p>注意:</p><ul><li>基数词 + 序数词  = 分数   one second = 1/2  two thrids = 2/3   当分子超过1的时候 分母要加s</li></ul><h2 id="形容词">形容词</h2><p>形容词（Adjective）是英语中的一类词，主要用来<strong>修饰或描述名词或代词，为名词或代词添加一些特性或属性</strong>。</p><p>以下是形容词的一些主要特性和用途：</p><ol><li><p><strong>描述特性</strong>：形容词可以描述颜色、大小、形状、质地、味道等特性。例如，“red”, “big”, “round”, “rough”, “sour”。</p></li><li><p><strong>描述感觉或情绪</strong>：形容词可以用来表达感情或情绪，如 “happy”, “sad”, “angry”, “excited”。</p></li><li><p><strong>表达数量或顺序</strong>：虽然数量词和序数词通常被视为一种特殊的形容词，但它们也可以用作形容词，如 “two”, “second”。</p></li></ol><p>形容词通常位于它所修饰的名词之前，但也可以在某些动词（如 “be”, “seem”, “look” 等）之后作表语。</p><p>形容词还有比较级（“bigger”）和最高级（“biggest”）形式，用来比较两个或多个事物。</p><h2 id="副词">副词</h2><p>副词（Adverb）是英语中的一类词，主要用来修饰或限定<strong>动词、形容词、其他副词，或整个句子</strong>。</p><p>以下是副词的一些主要功能和使用方式：</p><ol><li><p><strong>修饰动词</strong>：副词可以用来描述动作的方式、时间、地点或频率等。例如，在句子 “She runs quickly” 中，“quickly” 是一个副词，修饰动词 “runs”。</p></li><li><p><strong>修饰形容词</strong>：副词可以用来强调或限定形容词。例如，在句子 “She is extremely beautiful” 中，“extremely” 是一个副词，修饰形容词 “beautiful”。</p></li><li><p><strong>修饰其他副词</strong>：副词也可以修饰其他副词。例如，在句子 “She runs quite quickly” 中，“quite” 是一个副词，修饰另一个副词 “quickly”。</p></li><li><p><strong>修饰整个句子</strong>：有些副词可以修饰整个句子，表示说话人对句子内容的态度或看法。例如，在句子 “Surprisingly, she runs very fast” 中，“Surprisingly” 是一个副词，修饰整个句子。</p></li></ol><p>副词有许多种类，包括方式副词（如 “quickly”）、地点副词（如 “here”）、时间副词（如 “yesterday”）、频率副词（如 “often”）、程度副词（如 “very”）等。</p><p>许多副词是由形容词加上后缀 “-ly” 构成的，如 “quick”（形容词）和 “quickly”（副词）。但也有一些副词，如 “well”、“fast”、“hard”，其形式和对应的形容词相同，只能通过语境来判断。</p><h3 id="副词位置">副词位置</h3><p>副词的位置在句子中可以变化，取决于它们修饰的对象以及它们的种类。下面是一些一般的规则：</p><ol><li><p><strong>修饰动词</strong>：<strong>当副词修饰动词时，它们通常放在动词之后</strong>。例如：“She speaks clearly.”（她说话说得清楚。）</p></li><li><p><strong>修饰形容词或其他副词</strong>：<strong>当副词修饰形容词或其他副词时，它们通常放在被修饰词之前</strong>。例如：“She is incredibly smart.”（她非常聪明。）“She runs extremely fast.”（她跑得非常快。）</p></li><li><p><strong>修饰整个句子</strong>：当副词修饰整个句子时，它们可以放在句首、句中或句末。例如：“Fortunately, we arrived on time.”（幸运的是，我们准时到达了。）“We have, unfortunately, missed the bus.”（不幸的是，我们错过了公共汽车。）</p></li><li><p><strong>频率副词</strong>：像 “always”, “usually”, “often”, “sometimes”, “rarely”, “never” 这样的频率副词，<strong>通常放在被修饰的动词之前，或者在 “be” 动词之后</strong>。例如：“She always arrives early.”（她总是早到。）“He is usually at home.”（他通常在家。）</p></li><li><p><strong>否定副词</strong>：像 “not”, “never”, “no” 这样的否定副词，<strong>通常放在动词之前，形成否定句</strong>。例如：“She does not like coffee.”（她不喜欢咖啡。）</p></li></ol><p><strong>需要注意的是，这些规则并不是绝对的，有时候，为了强调或者文学效果，副词的位置可能会改变</strong>。此外，副词的位置也可以受语境、口语习惯等因素影响。</p><h2 id="em-style-color-red-介词短语-em"><em style="color:red">介词短语</em></h2><h3 id="定义">定义</h3><p>介词短语是由介词和其后的宾语（通常是名词或代词）组成的。它通常用来说明<strong>动作的时间、地点、方式、原因等信息</strong>。<strong>所以介词短语在句子中通常都是非核心内容</strong>. 它可以作为句子的各种成分，如宾语、定语、状语等。  <strong>介词主要是用于表达前面的词和后面的名词之间的关系</strong></p><p><em style="color:red">介词短语的基本结构是：介词 + 宾语。这里的宾语可以是<strong>名词、代词、动名词、或者是另一个介词短语。</strong></em></p><h3 id="充当成分">充当成分</h3><p>介词短语在句子中的功能多样，它可以充当以下几种主要的句子成分：</p><ol><li><p><strong>定语</strong>：介词短语可以用作名词或代词的定语，即用来修饰名词或代词。例如，在句子 “The man with the hat is my uncle” 中，“with the hat” 就是一个介词短语作定语，修饰 “The man”。</p></li><li><p><strong>状语</strong>：介词短语也可以作为状语，修饰动词、形容词、副词或整个句子。例如，在句子 “She arrived in the morning” 中，“in the morning” 是一个介词短语作状语，修饰动词 “arrived”。</p></li><li><p><strong>宾语</strong>：在某些情况下，介词短语可以作为动词或形容词的宾语。例如，在句子 “She is thinking about the problem” 中，“about the problem” 是一个介词短语作宾语，是动词 “thinking” 的宾语。</p></li><li><p><strong>补语</strong>：在某些句型中，介词短语可以作为主语或宾语的补语。例如，在句子 “He is in the garden” 中，“in the garden” 是一个介词短语作表语，补充说明主语 “He” 的状态。</p></li></ol><p>总的来说，介词短语是英语句子结构中的重要部分，它可以在句子中担任多种不同的角色，起到连接和修饰的作用。</p><h3 id="修饰对象分类">修饰对象分类</h3><p>介词短语在英语中的作用非常广泛，可以修饰多种词性的词，包括名词、动词、形容词、副词等。</p><ol><li><p><strong>修饰名词</strong>：<strong>介词短语可以作为名词的后置定语</strong>，修饰名词。例如：“The man with the hat”（戴帽子的男人），这里的 “with the hat” 是介词短语，作为后置定语修饰 “man”。</p></li><li><p><strong>修饰动词</strong>：介词短语可以作为状语，修饰动词，描述动作发生的时间、地点、方式等。例如：“She arrived after dinner”（她在晚饭后到达），这里的 “after dinner” 是介词短语，修饰动词 “arrived”。</p></li><li><p><strong>修饰形容词</strong>：介词短语有时也可以修饰形容词。例如：“She is fond of music”（她喜欢音乐），这里的 “of music” 是介词短语，修饰形容词 “fond”。</p></li><li><p><strong>修饰副词</strong>：介词短语可以修饰副词。例如：“She came back right after dinner”（她在晚饭后立刻回来），这里的 “after dinner” 是介词短语，修饰副词 “right”。</p></li></ol><p>总的来说，介词短语在英语中起到了非常重要的修饰作用，它可以丰富句子的信息，使句子更具描述性。</p><h3 id="修饰对象位置">修饰对象位置</h3><p>在有多个连续介词短语的句子中，通常要根据语境和句子的结构来判断各个介词短语修饰的对象。这里有几个一般性的建议：</p><ol><li><p><strong>顺序原则</strong>：一般情况下，介词短语离其修饰的词越近，关系越密切。例如在句子 “He found a ring in the drawer of the desk” 中，“in the drawer” 的位置更接近 “ring”，所以首先修饰 “ring”；然后 “of the desk” 修饰的是 “the drawer”。</p></li><li><p><strong>逻辑关系</strong>：结合上下文，理解句子中各个部分之间的逻辑关系，可以帮助确定介词短语修饰的对象。例如在句子 “She’s good at playing piano in the morning” 中，理解 “in the morning” 更有可能是修饰 “playing piano” 而非 “good at”，因为在上下午钢琴的时间对 “playing piano” 更具相关性。</p></li><li><p><strong>固定搭配</strong>：一些介词和特定的动词、形容词、名词经常一起使用，形成固定的短语。了解这些固定搭配也可以帮助判断介词短语的修饰对象。例如 “interested in”、“good at”、“on the phone” 等都是固定搭配。</p></li></ol><p>但请注意，由于英语的灵活性，以上规则并不总是适用，存在一些例外情况。当遇到模棱两可的情况时，要结合上下文和语境进行判断。此外，大量的阅读和实践也有助于理解和掌握这些规则。</p><p>举例:</p><p>“He found a ring in the drawer of the desk” 有两种可能的理解方式，具体取决于我们如何解读 “in the drawer of the desk” 这个介词短语。</p><ol><li><p>如果我们认为 “in the drawer of the desk” 是修饰 “a ring”，那么这句话的意思就是 “他发现了一个在桌子的抽屉里的戒指”。这种解读下，<strong>强调的是戒指在桌子的抽屉里这个特定的位置</strong>。</p></li><li><p>另一方面，如果我们认为 “in the drawer of the desk” 是修饰整个动作 “He found a ring”，那么这句话的意思就变为 “他在桌子的抽屉里发现了一个戒指”。这种解读下，<strong>强调的是他在哪里发现的戒指</strong>。</p></li></ol><p>这个例子展示了英语中的某种模糊性，这种模糊性在很多语言中都存在。解决这种模糊性的最好方式就是通过上下文来理解。在有些情况下，可能需要额外的信息才能确定更准确的意思。</p><p><strong>不过,我们都不用纠结,  这两种意思都不会影响我们阅读</strong></p><h3 id="介词分类">介词分类</h3><p><strong>介词的分类是根据后面接的东西所表示的信息来分类的</strong>,  主要, 不要纠结</p><h4 id="表示时间类的介词">表示时间类的介词</h4><table><thead><tr><th style="text-align:center">介词</th><th style="text-align:center">表达含义</th></tr></thead><tbody><tr><td style="text-align:center">at / on / in</td><td style="text-align:center">在……时间点 / 时间上 / 时间内</td></tr><tr><td style="text-align:center">before / after</td><td style="text-align:center">在……时间之前 / 之后</td></tr><tr><td style="text-align:center">from, since</td><td style="text-align:center">自从……时间</td></tr><tr><td style="text-align:center">by, until</td><td style="text-align:center">截止到 (直到) ……时间</td></tr><tr><td style="text-align:center">for</td><td style="text-align:center">持续……时间</td></tr><tr><td style="text-align:center">during</td><td style="text-align:center">在……期间</td></tr></tbody></table><p>在英语中，表示时间的介词 “at”, “on”, “in” 的使用各有规定，具体区别如下：</p><ol><li><p><strong>at</strong>：<strong>用于表示具体的时间点，如几点几分、午夜、中午等</strong>。例如：</p><ul><li>at 7:30 (在7点半)</li><li>at noon (在中午)</li><li>at midnight (在午夜)</li></ul></li><li><p><strong>on</strong>：用于表示<strong>具体的一天或者日期</strong>。例如：</p><ul><li>on Monday (在星期一)</li><li>on New Year’s Day (在新年这一天)</li><li>on my birthday (在我生日那天)</li></ul></li><li><p><strong>in</strong>：用于<strong>表示时间段</strong>，如年份、季节、月份、世纪、上午/下午等。例如：</p><ul><li>in the morning / afternoon / evening (在早上/下午/晚上)</li><li>in May (在五月)</li><li>in 2023 (在2023年)</li><li>in the 21st century (在21世纪)</li><li>in the summer (在夏季)</li></ul></li></ol><p>这是一种通用的规则，但请注意有些特殊表达。比如我们通常说 “at night” 而不是 “in the night”，说 “on Christmas Day” 但 “at Christmas”（表示圣诞节期间）。语言使用中的这些特殊情况，通常需要通过大量的阅读和实践来学习和掌握。</p><h4 id="表示地点和范围的介词">表示地点和范围的介词</h4><table><thead><tr><th style="text-align:center">介词</th><th style="text-align:center">表达含义</th></tr></thead><tbody><tr><td style="text-align:center">at / in</td><td style="text-align:center">在……地点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span></span></span></span> 在……里面</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> on, above, over / under, below, </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> beneath </mtext></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}\text { on, above, over / under, below, } \\\text { beneath }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> on, above, over / under, below, </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> beneath </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> 在</mtext><mo>…</mo><mo>…</mo><mtext>上面/下面 </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (考研中不需要要区别这几个词的细微差别) </mtext></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}\text { 在……上面/下面 } \\\text { (考研中不需要要区别这几个词的细微差别) }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">在</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">上面</span><span class="mord">/</span><span class="mord cjk_fallback">下面</span><span class="mord"> </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">考研中不需要要区别这几个词的细微差别</span><span class="mord">) </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">in front of / behind</td><td style="text-align:center">在……之前 / 之后</td></tr><tr><td style="text-align:center">near / by, beside, next to</td><td style="text-align:center">在……附近 / 在……旁边 (挨着)</td></tr><tr><td style="text-align:center">between, among</td><td style="text-align:center">在 … 之间(between表示两者之间； among表示三者或以上的之间</td></tr><tr><td style="text-align:center">around</td><td style="text-align:center">在……周围</td></tr><tr><td style="text-align:center">into  / out of  (动态的)</td><td style="text-align:center">进入……里面 / 从……里面出</td></tr><tr><td style="text-align:center">onto / off</td><td style="text-align:center">到……上面 / 脱离……</td></tr><tr><td style="text-align:center">across, through / past</td><td style="text-align:center">穿过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo><mo>⋯</mo><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdots \cdots \cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">⋅</span></span></span></span> / 经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo><mo>⋯</mo><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdots \cdots \cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">⋅</span></span></span></span></td></tr><tr><td style="text-align:center">along</td><td style="text-align:center">沿着……</td></tr><tr><td style="text-align:center">from / to, towards</td><td style="text-align:center">来自…… /朝着……去</td></tr><tr><td style="text-align:center">beyond</td><td style="text-align:center">超过，超出（指在范用外）</td></tr></tbody></table><p>在表示空间位置时，“at”，“on”和“in”也各有用法规定：</p><ol><li><p><strong>at</strong>：指明了具体的位置或点。例如：</p><ul><li>at the door (在门口)</li><li>at the bus stop (在公交站)</li><li>at the corner of the street (在街道的拐角处)</li></ul></li><li><p><strong>on</strong>：表示在一个平面或者表面上。例如：</p><ul><li>on the table (在桌子上)</li><li>on the wall (在墙上)</li><li>on the floor (在地板上)</li></ul></li><li><p><strong>in</strong>：表示在三维空间中，或者某种范围、区域、地点内。例如：</p><ul><li>in the box (在箱子里)</li><li>in a car (在汽车里)</li><li>in China (在中国)</li><li>in a picture (在图片中)</li></ul></li></ol><p>然而，<strong>这些规则并不是绝对的，有些表达可能不符合这些规则,所以我们要具体问题具体分析</strong>。例如，我们会说 “on the bus” 或 “on the plane” 而不是 “in the bus” 或 “in the plane”，因为在这种情况下，“on”表示的是一种乘坐交通工具的状态。同样，当我们说 “at home” 或 “at school” 时，“at”表示的是一种处于某个环境或状态的含义。这些特殊的用法需要通过实际语境来学习和理解。</p><h4 id="其他用法">其他用法</h4><table><thead><tr><th style="text-align:center">介词</th><th style="text-align:center">表达含义</th></tr></thead><tbody><tr><td style="text-align:center">of</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>⋯</mo><mo>⋯</mo><mrow><mtext> 的</mtext><mo>…</mo><mo>…</mo><mtext> (表示属性) </mtext></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> (“A of </mtext><mi>B</mi><mtext> ”通常翻译为“B的A”) </mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\cdots \cdots \text { 的…… (表示属性) } \\\text { (“A of } B \text { ”通常翻译为“B的A”) }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"> (</span><span class="mord cjk_fallback">表示属性</span><span class="mord">) </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (“A of </span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord"> ”</span><span class="mord cjk_fallback">通常翻译为</span><span class="mord">“B</span><span class="mord cjk_fallback">的</span><span class="mord">A”) </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">about</td><td style="text-align:center">关于……</td></tr><tr><td style="text-align:center">with / without</td><td style="text-align:center">伴随着有…‥/ 没有……</td></tr><tr><td style="text-align:center">for</td><td style="text-align:center">为了…… (表示目的)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">因为…… (表示原因)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">对于…… (表示对象)</td></tr><tr><td style="text-align:center">by</td><td style="text-align:center">通过……方式或方法</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">被……做 (被动语态 + by + 动作的发出者</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">相差了…… (表示变化的差额)</td></tr><tr><td style="text-align:center">as</td><td style="text-align:center">作为……</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">像……样, 如同……</td></tr><tr><td style="text-align:center">like</td><td style="text-align:center">像……样</td></tr><tr><td style="text-align:center">despite, in spite of</td><td style="text-align:center">尽管…</td></tr></tbody></table><p>of … 的 … (表示属性)  two of the strings   和 two strings 这个是有区别的,   前者表示是 那群弦中的两根,  而且后置是任意两根,  而且前者中的两根是那群弦的属性</p><h2 id="连接词">连接词</h2><p>在英语中，连接词主要可以分为以下几类：</p><ol><li><p><strong>并列连接词（Coordinating Conjunctions）</strong>：这类连接词用于连接两个平等的句子成分，可以是主句与主句，或者从句与从句。常见的并列连接词包括 “and”（并且），“but”（但是），“or”（或者），“so”（所以），“for”（因为），“nor”（也不），“yet”（然而）等。</p></li><li><p><strong>关联连接词（Correlative Conjunctions）</strong>：这类连接词也属于并列连接词的一种特殊形式，用于连接在语法和逻辑上等同的句子成分，通常成对出现。常见的关联连接词包括 “either…or”（不是…就是…），“neither…nor”（既不…也不…），“both…and”（既…又…），“not only…but also”（不仅…而且…）等。</p></li><li><p><strong>从属连接词（Subordinating Conjunctions）</strong>：这类连接词用于引导从句，并将其与主句连接。常见的从属连接词包括 “because”（因为），“since”（自从/因为），“as”（因为/当…的时候），“although”（尽管），“if”（如果），“unless”（除非），“while”（虽然/当…的时候）等。</p></li><li><p><strong>关系词（Relative Pronouns）</strong>：这类词通常用来引导定语从句，常见的关系词有 “who”，“whom”，“whose”，“which”，“that” 等。</p></li></ol><p>以上就是英语中常见的四类连接词。请注意，每种连接词都有其特定的用法和上下文，理解它们的含义并知道如何在不同的语境中使用它们是提高英语水平的一个重要部分。</p><h2 id="连接符号">连接符号</h2><h3 id="破折号">破折号</h3><p>用于连接句子或者同位语, 或者用来强调前面的句子 以补充意思,  此时翻译为&quot;也就是说&quot;</p><h3 id="冒号">冒号</h3><p>用来强调前面句子中的名词</p><h3 id="分号">分号</h3><ul><li>等于 &quot; 逗号 + 连词&quot;</li><li>在原本对等的语句中, 有连词出现, 如果有插入语的话, 就会让句意不够清楚, 此时用;加原先句子, 来说明是和前面的语句做连接</li></ul><ol><li><p>句号（.）: 句号用于结束一个声明或陈述句。</p><p>例：I like apples.</p></li><li><p>问号（?）: 问号用于结束一个疑问句。</p><p>例：Do you like apples?</p></li><li><p>感叹号（!）: 感叹号用于结束一个感叹句，或表示强烈的情感。</p><p>例：Wow, that’s amazing!</p></li><li><p>逗号（,）: 逗号用于分隔句子中的元素，包括列表中的项，句子中的非限制性修饰语，以及复合句中的子句。</p><p>例：I bought apples, oranges, and bananas.</p></li><li><p>分号（;）: 分号用于连接两个相关的独立句子，或在复杂列表中分隔项。</p><p>例：Some people like apples; others prefer oranges.</p></li><li><p>冒号（:）: 冒号用于引出列表、解释或引述。</p><p>例：Here are three types of fruit: apples, oranges, and bananas.</p></li><li><p>引号（&quot; &quot;）: 引号用于引述直接引语，或者表示特殊词汇、短语或标题的使用。</p><p>例：“I love apples,” she said.</p></li><li><p>括号（( )）: 括号用于插入句子中的附加信息或澄清信息。</p><p>例：She loves apples (and other fruits).</p></li><li><p>破折号（—）: 破折号用于添加强调的额外信息，或用于句子的断句。</p><p>例：She loves apples—really loves them—not just likes them.</p></li><li><p>省略号（…）: 省略号用于表示语句的中断或省略。</p><p>例：I think I’m going to…</p></li></ol><p>详细解释一下 “;”（分号）和 “,”（逗号）的用法。</p><ol><li><p>分号（;）:</p><ul><li><p>分号用于将两个紧密相关但是可以独立成句的句子连接在一起。例如，“It’s raining; I’m staying in.” 在这个例子中，“It’s raining” 和 “I’m staying in” 都是完整的句子，但它们之间存在逻辑关系，所以使用分号将它们连接在一起。</p></li><li><p>分号也可以用于列举，特别是当列表的项中包含逗号时。例如，“The meeting will be attended by John Doe, CEO; Jane Smith, CFO; and Bob Johnson, CTO.” 在这个例子中，分号用于分隔列表中的项，因为每个项中都包含一个逗号。</p></li></ul></li><li><p>逗号（,）:</p><ul><li><p>逗号用于在句子中分隔元素。它可以用于分隔列表中的项：“I bought apples, oranges, and bananas.”</p></li><li><p>在复合句中，逗号用于连接两个由连词（如and, but, or, so等）连接的独立句子：“I like apples, but my sister prefers oranges.”</p></li><li><p>逗号还用于分隔非限制性修饰语，这种修饰语是可以从句子中删除而不影响句子的主要意思的部分。例如，在 “My sister, who is two years older than me, likes oranges.” 中，“who is two years older than me” 是一个非限制性修饰语。</p></li><li><p>在直接引语之前，通常使用逗号，例如：“She said, ‘I love apples.’”</p></li><li><p>当引入或结束引述、插入语、转折等时，也常用逗号，例如：“In fact, she loves all kinds of fruits.”</p></li></ul></li></ol><p>以上只是 “;” 和 “,” 的一些基本用法。这两种标点符号的使用规则非常复杂，而且有时根据具体的写作风格和语境，也可能有所不同。希望这些信息对你有所帮助！</p><h1>简单句</h1><p>在英语中，简单句(simple sentence)是<strong>由一个主语和一个谓语构成的句子</strong>。它只包含一个独立的子句，没有从属子句或并列子句。简单句<strong>通常用于表达一个完整的想法或信息</strong>。</p><p><strong>简单句的基本结构是：主语 + 谓语</strong>。</p><p>例如：</p><ol><li>“The cat is sleeping.” （猫正在睡觉。）</li><li>“She reads a book.” （她在读一本书。）</li></ol><p>尽管简单句通常被认为是简短的，但它们也可以包含补充信息，如修饰词、宾语、间接宾语等。例如：“The smart cat with black fur is quietly sleeping on the soft couch.” (黑毛聪明的猫正在软沙发上安静地睡觉。)</p><p>然而，重要的是要注意，无论它们多么长或复杂，<strong>只要句子中只有一个独立的子句，它就仍然是一个简单句</strong>。</p><h2 id="基本句型">基本句型</h2><p>英语中有几种基本的句型，这些句型是根据句子中的成分（例如主语、谓语、宾语等）来分类的。以下是英语中最常见的五种基本句型：</p><ol><li><p><strong>S-V 句型（主谓句型）</strong>：这种句型包含一个主语（Subject）和一个谓语（Verb）。<strong>谓语是一个不及物动词</strong>。例如：“Birds fly.”（鸟飞翔。）</p></li><li><p><strong>S-V-O 句型（主谓宾句型）</strong>：这种句型包含一个主语（Subject）、一个谓语（Verb）和一个宾语（Object）。<strong>谓语是一个及物动词</strong>。例如：“I love apples.”（我喜欢苹果。）</p></li><li><p><strong>S-V-C 句型（主谓补语句型 或者说是主系表）</strong>：这种句型包含一个主语（Subject）、一个联系动词（Linking Verb）和一个补语（Complement）。补语可以是名词、形容词等，<strong>用来对主语进行说明或者描述</strong>。例如：“He is a doctor.”（他是医生。）或 “The sky is blue.”（天空是蓝色的。）</p></li><li><p><strong>S-V-O-O 句型（主谓双宾句型）</strong>：这种句型包含一个主语（Subject）、一个谓语（Verb）、一个间接宾语（Indirect Object）和一个直接宾语（Direct Object）。例如：“She gave me a gift.”（她给了我一份礼物。）, <strong>物永远是直接宾语, 人永远是间接宾语</strong></p></li><li><p><strong>S-V-O-C 句型（主谓宾补句型）</strong>：这种句型包含一个主语（Subject）、一个谓语（Verb）、一个宾语（Object）和一个宾语补足语（Object Complement）。<strong>宾语补足语用来描述或说明宾语</strong>。例如：“They elected him president.”（他们选他为总统。）</p></li></ol><blockquote><p>在第五种句型中,  要注意的是,  当谓语是感官动词 ,  补语可以使用 动词原形  或者 现在分词   谓语是使役动词的时候,   有些只能只用动词原形,  有些还可以根据宾语跟宾语补足语的关系 可以使用  现在分词 或者 过去分词,  分别表示主动和被动</p></blockquote><p>这五种基本句型构成了英语句子的基础。理解并熟练使用这些句型可以帮助我们更好地理解和构造英语句子。</p><h3 id="祈使句">祈使句</h3><p>祈使句是英语中的一种语句类型，它主要用于发出命令、提出要求、提供指示或建议。以下是关于祈使句的一些主要点：</p><ol><li><p><strong>省略主语</strong>：在祈使句中，主语（通常是&quot;you&quot;）通常被省略。例如，“Be quiet.” 省略了主语 “you”，实际上的完整语句是 “You be quiet.”。</p></li><li><p><strong>动词形式</strong>：祈使句的动词通常是动词的原形，也就是不带任何词尾变化的形式。例如，“Go to the store.”。</p></li><li><p><strong>否定形式</strong>：要否定一个祈使句，你通常在动词前面加上 “don’t”。例如，“Don’t be late.”。</p></li><li><p><strong>礼貌形式</strong>：在请求或给予建议时，我们常常使用 “please” 来使祈使句更礼貌。例如，“Please close the door.”。</p></li><li><p><strong>祈使句的用途</strong>：祈使句可以用于各种情境，包括给出指令（“Turn left at the traffic light.”）、提供建议（“Take a coat. It might be cold outside.”）、发出请求（“Please pass the salt.”）或表达愿望（“Have a nice day.”）。</p></li></ol><p>祈使句是英语中一个重要的句型，掌握它的基本结构和用法能帮助你更好地理解和使用英语。</p><h3 id="感叹句">感叹句</h3><p>英语的感叹句（exclamatory sentences）用于表达强烈的情绪或感情，如惊讶、愤怒、快乐、悲伤等。感叹句通常以感叹号（!）结尾。</p><p>一般来说，英语的感叹句有两种基本结构：</p><ol><li><p><strong>What + （a/an）+ 形容词 +（名词）+ 主语 + 谓语！</strong></p><p>这种结构用来强调某人或某物的特性或状态。例如：</p><ul><li>What a beautiful painting it is!</li><li>What an intelligent girl she is!</li></ul></li><li><p><strong>How + 形容词/副词 + 主语 + 谓语！</strong></p><p>这种结构用来强调程度。例如：</p><ul><li>How beautiful the painting is!</li><li>How intelligently she answered the question!</li></ul></li></ol><p>此外，对于一些简单的感叹句，我们也可以直接使用形容词或副词，如 “Amazing!”，“Wonderful!”，“Fantastic!” 等。</p><p>最后，值得注意的是，在口语或非正式的书面语言中，我们也经常使用&quot;so&quot;或&quot;such&quot;来构造感叹句，如&quot;So beautiful!“或&quot;Such a beautiful painting!”。</p><h3 id="疑问句">疑问句</h3><h4 id="一般疑问句">一般疑问句</h4><p>一般疑问句是英语语法的一种基本句型，主要用于获取对方的肯定或否定回答。它的基本构造是以助动词或情态动词开始，紧接主语和谓语。以下是一些详细的构造规则和注意点：</p><ol><li><strong>助动词/情态动词 + 主语 + 其他</strong>: 这是一般疑问句最基本的结构。例如：“Do you like cats?”，“Can she sing?”。这样的句子通常期待&quot;yes&quot;或&quot;no&quot;的回答。</li><li><strong>“Be”动词</strong>: 对于使用&quot;be&quot;动词的句子，“be”动词直接移到句首，形成疑问句。例如，“Is he a teacher?”（他是老师吗？）或&quot;Are you happy?&quot;（你快乐吗？）。</li><li><strong>一般现在时和一般过去时</strong>: 对于一般现在时和一般过去时的句子，我们用&quot;do/does/did&quot;作为助动词，并将其置于句首。例如，“Do you work here?”（你在这里工作吗？）或&quot;Did you see that movie?&quot;（你看过那部电影吗？）。</li><li><strong>其他时态和情态动词</strong>: 对于其他时态（如完成时，进行时）和情态动词（如can, could, will, would等），把助动词或情态动词移至句首形成疑问句。例如，“Have you done your homework?”（你做完作业了吗？）或&quot;Will you go to the party?&quot;（你会去参加派对吗？）。</li><li><strong>否定疑问句</strong>: 在一般疑问句中加入否定词&quot;not&quot;，可以形成否定疑问句，用以表达惊讶、责备、建议等语气。例如，“Don’t you love me?”，“Isn’t it a beautiful day?”。   只要表达肯定就用yes  但是翻译过来得否定, 比如  Don’t you love me? 和 Do you love me?  肯定回答都是 yes,  i love  但是 翻译的时候有细微差别,  第一个是  不, 我爱你 , 第二个是  是的, 我爱你</li></ol><h4 id="特殊疑问句">特殊疑问句</h4><p>特殊疑问句是英语中用来获取特定信息的疑问句。它们通常以疑问词或疑问短语开始，比如 “what”, “where”, “when”, “why”, “how”, “which”, “who” 等。下面是一些特殊疑问句的基本规则和例子：</p><ol><li><p><strong>What</strong> 用来询问事物或人。例如：“What is your name?” 或 “What do you want?”</p></li><li><p><strong>Where</strong> 用来询问地点。例如：“Where do you live?” 或 “Where is the bank?”</p></li><li><p><strong>When</strong> 用来询问时间。例如：“When is your birthday?” 或 “When do we leave?”</p></li><li><p><strong>Why</strong> 用来询问原因。例如：“Why are you late?” 或 “Why is he crying?”</p></li><li><p><strong>How</strong> 用来询问方法、状态或程度。例如：“How do you make coffee?” 或 “How are you?”</p></li><li><p><strong>Which</strong> 用来从有限的选择中询问。例如：“Which color do you prefer, red or blue?” 或 “Which is your book?”</p></li><li><p><strong>Who</strong> 用来询问人。例如：“Who is that man?” 或 “Who wrote this book?”</p></li></ol><p>特殊疑问句的语序一般是疑问词 + 助动词(情态动词,be动词,do/does/did) + 主语 + 其他  (<strong>疑问词 + 一般疑问句的结构</strong>)，如 “What do you like?” 这种语序和陈述句（主语 + 动词 + 其他，如 “You like ice-cream”）是不同的。然而，有时特殊疑问句也可以不使用助动词</p><p>注意，特殊疑问句的回答通常不是简单的 “yes” 或 “no”，而是需要提供具体的信息。例如，对于 “Where do you live?” 的回答可能是 “I live in New York.”。</p><p>what who which 这三个疑问词 具有名词性质, 因此可以直接做主语, 而不需要倒装,</p><h2 id="简单句的核心构成">简单句的核心构成</h2><h3 id="主语">主语</h3><h3 id="谓语">谓语</h3><p>谓语动词可分为  实义动词（lexical verbs）和非实义动词（non-lexical verbs，也称助动词）：</p><p>**实义动词（lexical verbs）**是具有具体意义的动词，通常可以指代具体的动作、状态或存在。例如，“run”、“eat”、“think”、“exist” 等都是实意动词。实意动词可以进一步被分类为：</p><ol><li><strong>及物动词（transitive verbs）</strong>：这类动词需要一个或多个宾语来完成其意义。例如，在句子 “She loves her dog” 中，“loves” 是一个及物动词，因为它需要一个宾语 “her dog” 来完成其意义。 <strong>对应主谓宾  主谓宾补</strong></li><li><strong>不及物动词（intransitive verbs）</strong>：这类动词不需要宾语。例如，在句子 “She sleeps” 中，“sleeps” 是一个不及物动词，因为它不需要宾语就能完成其意义。<strong>对应主谓</strong></li><li><strong>双及物动词（ditransitive verbs）</strong>：这类动词可以有两个宾语。例如，在句子 “He gave Mary a book” 中，“gave” 是一个双及物动词，因为它有两个宾语 “Mary” 和 “a book”。<strong>对应主谓双宾</strong></li></ol><p>**非实义动词（non-lexical verbs，也称助动词）**不具有具体的意义，<strong>它们存在于动词短语中，用来帮助构建各种语法结构</strong>，例如时态、语态、语气等。非实义动词可以被分类为： <strong>对应主系表 也是主谓补</strong></p><ol><li><strong>情态助动词（modal auxiliary verbs）</strong>：这类动词用来表示可能性、能力、许可、义务等。例如，“can”, “could”, “may”, “might”, “shall”, “should”, “will”, “would”, “must” 等都是情态助动词。</li><li><strong>主要助动词（primary auxiliary verbs）</strong>：这类动词包括 “be”, “have”, “do”，它们可以用作助动词也可以用作实意动词。例如，在句子 “She is running” 中，“is” 是一个主要助动词，它用来构建进行时。而在句子 “She is a teacher” 中，“is” 是一个实意动词，表示存在关系。</li></ol><h2 id="谓语动词的变化">谓语动词的变化</h2><p>在英语中，谓语动词的变化主要包括以下几个方面：</p><ol><li><strong>时态</strong>：动词的时态表示动作或状态发生的时间。包括：<ul><li>现在时：表示现在进行的或经常发生的动作。例如：She works at a bank.</li><li>过去时：表示过去发生的动作。例如：They went to the concert yesterday.</li><li>将来时：表示将来要发生的动作。例如：He will arrive tomorrow.</li><li>现在进行时：表示现在正在进行的动作。例如：We are reading books.</li><li>过去进行时：表示在过去某一时刻正在进行的动作。例如：She was cooking when I arrived.</li><li>将来进行时：表示在将来某一时刻将会正在进行的动作。例如：He will be working when you arrive.</li><li>现在完成时：表示过去发生但对现在有影响的动作。例如：I have finished my work.</li><li>过去完成时：表示在过去某一时刻之前已经完成的动作。例如：She had left before I arrived.</li><li>将来完成时：表示在将来某一时刻之前将完成的动作。例如：I will have arrived by the time you get home.</li></ul></li><li><strong>语态</strong>：语态包括主动语态和被动语态。<ul><li>主动语态：主语是动作的执行者。例如：John ate an apple.</li><li>被动语态：主语是动作的承受者。例如：The apple was eaten by John.</li></ul></li><li><strong>情态动词</strong>：情态动词用来表示可能性、能力、必要性、猜测等。包括 can, could, may, might, shall, should, will, would, must 等。例如：She must be at home now.</li><li><strong>人称和数的变化</strong>：在现在时，动词与其主语的人称和数量有关。例如：“I/You/We/They run” 与 “He/She/It runs”.</li><li><strong>否定</strong>：在动词前加 not，形成否定句。例如：She does not (doesn’t) work at a bank.</li><li><strong>非谓语动词</strong>：包括不定式（to do）、分词（doing/done）和动名词（doing）。</li><li><strong>动词的语气</strong>：包括陈述语气、疑问语气、祈使语气、虚拟语气等。例如：I hope he could come. (陈述语气); Can you help me? (疑问语气); Please open the door. (祈使语气); If I were you, I would say no. (虚拟语气)</li></ol><p>这些都是谓语动词的主要变化，但各种具体情况可能需要根据上下文和具体语法规则来确定。</p><blockquote><p>我们可以把动词的变化 当成一个整体当成谓语动词</p></blockquote><h3 id="谓语动词的时态">谓语动词的时态</h3><p>对于谓语动词的时态,  我们在读文章的时候, 完全可以自己代入到这篇文章中去,  当成他在跟你对话,  而不是说 我们理解成他多久写的文章, 我们站在现在去看他的文章是现在还是过去</p><p><img src="/2023/06/27/English/%E8%AF%AD%E6%B3%95/../img/%E8%AF%AD%E6%B3%95assets/image-20230628083207910.png" alt="image-20230628083207910"></p><h4 id="一般时态">一般时态</h4><p>这是英语中一般时态陈述句的构造：</p><ol><li><strong>一般现在时</strong>：主语 + 动词原形 / 第三人称单数形式的动词 + 宾语。<strong>表示习惯性的动作、现实的状态或普遍的真理</strong><ul><li>例如：She reads books.</li></ul></li><li><strong>一般过去时</strong>：主语 + 动词的过去式 + 宾语。<strong>表示在过去某个时间发生的动作或存在的状态，没有明确的与现在相连的意思, 但是一般表示过去是这样, 现在不是这样了</strong>  (这里更多的是指 动作已经结束了)<ul><li>例如：She read books.</li></ul></li><li><strong>一般将来时</strong>：主语 + will/shall + 动词原形 + 宾语。<strong>表示未来将要发生的动作或状态，有时也用来表示将要发生的动作或打算、计划</strong>, shall 一般只能用在第一人称后面  比如 我,我们<ul><li>例如：She will read books.</li></ul></li><li><strong>一般过去将来时</strong>：主语 + would/should + 动词原形 + 宾语。<strong>主要用于表示在过去的某个时间点看，预计将要发生的事情。这种时态在英语中比较罕见，常常出现在间接引语或叙述性语言中。</strong><ul><li>例如：I knew she would come to the party.</li></ul></li></ol><p>这些是一般时态的基本构造。特别要注意的是，某些动词可能是不规则动词，其过去式和过去分词可能不遵循普通规则。<strong>另外，“shall” 主要用于较为正式的英语或者某些特定情况</strong>，如法律文档，或者与第一人称连用来表达强烈的意愿或决定。在现代口语英语中，“will” 的使用更为常见。</p><h4 id="进行时态">进行时态</h4><ol><li><p><strong>现在进行时</strong>：主语 + am/is/are（be动词的现在式） + 动词的-ing形式 + 宾语。<strong>表示此刻正在进行或发生的动作，也可以表示一段时间内（不一定就在说话的那一刻）在进行的动作或存在的情况</strong>。</p><ul><li>例如：She is reading a book.</li></ul></li><li><p><strong>过去进行时</strong>：主语 + was/were（be动词的过去式） + 动词的-ing形式 + 宾语。<strong>表示在过去某个特定时间点正在进行的动作，或者在过去某段时间内一直在进行的动作</strong>。</p><ul><li>例如：She was reading a book when I arrived.</li></ul></li><li><p><strong>将来进行时</strong>：主语 + will be / shall be + 动词的-ing形式 + 宾语。<strong>表示将要发生的动作，或者在未来某个特定时间点会正在进行的动作</strong>。请注意，&quot;shall&quot;更常用于第一人称（I 和 we），并且较为正式。</p><ul><li>例如：She will be reading a book when you arrive.</li></ul></li><li><p>过去将来进行时：主语 + would be / should be + 动词的-ing形式 + 宾语。<strong>表示在过去的某个时间点看，预计将要进行的事情。这种时态比较少见，通常出现在间接引语或叙述性语言中</strong>。</p><ul><li>例如：He said that she would be reading a book when I arrived.</li></ul></li></ol><p>这些是进行时态的基本构造和含义。记住，实际的语境和上下文可能会影响到你选择使用哪种时态。</p><h4 id="完成时态">完成时态</h4><p><strong>完成时态是表达一件事的&quot;完成结果&quot;</strong>, 做完了是一个结果,  没做完也是一个结果</p><p><strong>强调的是 某某时间之前</strong></p><p><strong>阶段性总结</strong>就可以使用完成时态</p><p>下面是完成时态的构造和含义：</p><ol><li><p><strong>现在完成时</strong>：主语 + have/has + 动词的过去分词 + 宾语。<strong>表示从过去某一时间开始延续到现在（可能持续到将来）的动作或状态，或者在最近或过去某一时间（不明确指出）完成的动作</strong>。</p><ul><li>例如：She has read the book.</li></ul></li><li><p><strong>过去完成时</strong>：主语 + had + 动词的过去分词 + 宾语。<strong>表示在过去某一时间点或某一动作之前已经完成的动作或存在的状态</strong>。</p><ul><li>例如：She had read the book before I saw her.</li></ul></li><li><p><strong>将来完成时</strong>：主语 + will have / shall have + 动词的过去分词 + 宾语。<strong>表示在将来某一时间点之前会已经完成的动作或存在的状态</strong>。</p><ul><li>例如：She will have read the book by the time you see her.</li></ul></li><li><p>过去将来完成时：主语 + would have / should have + 动词的过去分词 + 宾语。<strong>表示在过去的某个时间点看，预计在将来的某一时间点之前会已经完成的动作。这种时态比较少见，通常出现在间接引语或叙述性语言中</strong>。</p><ul><li>例如：He said that she would have read the book by the time I saw her.</li></ul></li></ol><p>请注意，完成时态强调的是动作的完成，或者状态的存在，而不仅仅是动作或状态本身。此外，完成时态经常与表示时间的短语（例如 “by the time”, “before”, “since”, “already”, “yet”, “just” 等）一起使用。</p><h4 id="完成进行时态">完成进行时态</h4><p>完成进行时 = 完成 + 进行</p><p><strong>强调过程</strong></p><p>完成进行时态是用来表示在某个时间之前持续发生的动作或者状态。下面是这种时态的基本构造：</p><ol><li><p><strong>现在完成进行时</strong>：主语 + has/have been + 动词的现在分词（-ing 形式）+ 宾语。这种时态表示从过去某个时间点开始，一直持续到现在的动作或状态，动作可能已经结束，也可能仍在继续。</p><ul><li>例如：She has been reading books.（她一直在读书，可能正在读，也可能刚刚停止）</li></ul></li><li><p><strong>过去完成进行时</strong>：主语 + had been + 动词的现在分词（-ing 形式）+ 宾语。这种时态表示在过去某个时间点或动作之前一直持续的动作或状态。</p><ul><li>例如：She had been reading books before I arrived.（我到达之前，她一直在读书）</li></ul></li><li><p><strong>将来完成进行时</strong>：主语 + will have been + 动词的现在分词（-ing 形式）+ 宾语。这种时态表示在未来某个时间点之前一直持续的动作或状态。</p><ul><li>例如：She will have been reading books for two hours by the time I arrive.（到我到达的时候，她将已经读了两个小时的书了）</li></ul></li></ol><p>这些是完成进行时态的基本构造。这种时态复杂的地方在于，它们同时包含了完成时态和进行时态的含义，即表示动作或状态的持续，并与某个特定的时间点有关。需要注意的是，某些动词可能没有进行时态，因为它们不表示动作，而是表示状态。例如，动词 “know” 就不常用于进行时态。</p><h3 id="谓语动词的情态">谓语动词的情态</h3><p>谓语动词的情态，通常指的是通过情态动词来表示说话人对动作或状态的看法和态度，比如可能性、需要性、肯定性等。情态动词在英语中很常见，包括&quot;can&quot;, “could”, “may”, “might”, “must”, “shall”, “should”, “will”, &quot;would&quot;等。</p><p>比如：</p><ol><li>“She can swim.” (她会游泳。) 这里的 “can” 表示能力。</li><li>“You must go.” (你必须去。) 这里的 “must” 表示义务或必要性。</li><li>“I might visit my grandmother.” (我可能会去看望我奶奶。) 这里的 “might” 表示可能性。</li></ol><p>这些情态动词<strong>没有人称变化</strong>，不能单独作为谓语，<strong>必须和动词原形一起使用</strong>。此外，它们也不使用 “to” 连接，例如，我们不说 “I must to go”，而应该说 “I must go”。</p><p>情态动词只有两种时态  一个是 <strong>一般现在时和一般过去时</strong>, must 还没有过去时(这里指的是情态动词没有其他时态, 但是后面的动词还是可以有的)</p><table><thead><tr><th style="text-align:center">一般现在时</th><th style="text-align:center">一般过去时</th></tr></thead><tbody><tr><td style="text-align:center">must</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">can</td><td style="text-align:center"><strong>could</strong></td></tr><tr><td style="text-align:center">will</td><td style="text-align:center"><strong>would</strong></td></tr><tr><td style="text-align:center">shall</td><td style="text-align:center"><strong>should</strong></td></tr><tr><td style="text-align:center">may</td><td style="text-align:center"><strong>might</strong></td></tr></tbody></table><p>对于&quot;could&quot;，“would”，“should” 和 “might” 这些一般过去时态的情态动词，他们不仅可以用于<strong>表达过去的情况</strong>，<strong>也常常用于表示对现在情况的一种更为委婉、礼貌或疑虑的态度</strong>。</p><p>情态动词的否定形式通常通过在<strong>情态动词后面加 “not” 来形成</strong>。例如，“can not”、“must not”。</p><p><strong>情态动词也可以表达推测</strong></p><p>情态动词在表达推测或猜测时具有不同的意义。以下是用于表达推测时的一般含义：</p><ul><li><p>Must：通常用于<strong>表达对现在或未来的强烈推测</strong>，表示说话人对其猜测的确定性很高。例如：“They must be at home by now.”（他们现在一定在家。）</p></li><li><p>Can/Could：在推测语境中，<strong>这两个词通常表示对某种可能性的猜测或推测</strong>。例如：“It can be true.”（这可能是真的。）或 “It could be true.”（这可能是真的。）</p></li><li><p>Will/Would：通常用于对未来的推测。例如：“It will probably rain tomorrow.”（明天可能会下雨。）</p></li><li><p>Shall/Should：‘Should’ <strong>通常用于表示对现在或未来的推测</strong>，其推测的确定性比 ‘must’ 弱一些。例如：“She should be at school by now.”（她现在应该在学校。）</p></li><li><p>May/Might：这两个词通常用于<strong>表达不确定的推测或猜测</strong>。例如：“It may rain later.”（等一会可能会下雨。）或 “It might rain later.”（等一会可能会下雨。）</p></li></ul><p>值得注意的是，情态动词在表达推测时，其确定性程度也会有所不同。例如，“must” 表达的推测相对更为确定，而 “may” 或 “might” 表达的推测则相对不那么确定。</p><ul><li><p>在情态动词后面，动词通常有以下三种形式来表示推测：</p><ol><li><p>情态动词 + do： 这种形式表示对<strong>现在或将来的一种基本推测</strong>。例如：“He must know the truth.” (他一定知道真相。）</p></li><li><p>情态动词 + be doing：这种形式表示对<strong>正在进行的行动的推测</strong>。例如：“He might be working now.” (他现在可能正在工作。)</p></li><li><p>情态动词 + have done：这种形式通常用来<strong>表示对过去事件的推测</strong>。例如：“They must have arrived at the station.” (他们一定已经到达车站了。）</p></li></ol><p>这些形式都可以用于表达推测，但是选择哪一种主要取决于你想表达的是现在、过去还是正在进行的行动的推测。</p></li></ul><h4 id="动词词组">动词词组</h4><ul><li>have to  不得不</li><li>ought to 应该</li></ul><h3 id="谓语动词的语态">谓语动词的语态</h3><p>谓语动词的语态主要有两种：主动语态和被动语态。</p><ol><li><p>主动语态：在主动语态中，主语是动作的执行者。大部分句子都采用主动语态，因为它们通常比被动语态更直接和简洁。例如：“I read a book.”（我读了一本书。）在这个句子中，“read”是主动语态的谓语动词，&quot;I&quot;是动作的执行者。</p></li><li><p>被动语态：<strong>在被动语态中，主语是动作的接受者</strong>，<strong>而动作的执行者通常在句子中以&quot;by…&quot;的形式出现，或者被完全省略</strong>。例如：“The book was read by me.”（这本书被我读了。）在这个句子中，&quot;was read&quot;是被动语态的谓语动词，&quot;The book&quot;是动作的接受者。</p></li></ol><p>被动语态的构成是：be动词（am, is, are, was, were, be, being, been）+过去分词(done)。使用被动语态的情况包括：<strong>强调动作的承受者</strong>，或者动作的执行者未知、不重要或者不需要提及。  <strong>be 确定时态   过去分词代表动作</strong>,  <strong>这是一个整体, 和时态(非一般时态)结合的时候要放整体上去</strong></p><p>需要注意的是，不是所有的动词都可以用在被动语态中。<strong>只有及物动词（即需要接宾语的动词）才能用在被动语态中</strong>，不及物动词（不需要接宾语的动词）则不能。例如，动词&quot;sleep&quot;就不能用在被动语态中，我们不能说&quot;People are slept&quot;。</p><p>例子:</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">这些评论家 (过去) 被遗忘了。</td><td style="text-align:left">These critics <strong>were forgotten</strong>.</td></tr><tr><td style="text-align:left">这些评论家 (现在) 被遗忘。</td><td style="text-align:left">These critics are forgotten.</td></tr><tr><td style="text-align:left">这些评论家将会 (现在的将来) 被遗忘。</td><td style="text-align:left">These critics <strong>will be forgotten</strong></td></tr><tr><td style="text-align:left">这些评论家过去将会 (过去的将来) 被遗忘。</td><td style="text-align:left">These critics would be forgotten</td></tr><tr><td style="text-align:left">这些评论家过去正在被遗忘。</td><td style="text-align:left">These critics <strong>were being forgotten</strong></td></tr><tr><td style="text-align:left">这些评论家现在正在被遗忘。</td><td style="text-align:left">These critics are being forgotten</td></tr><tr><td style="text-align:left">这些评论家过去已经 (过去的之前) 被遗忘了。</td><td style="text-align:left">These critics <strong>had been forgotten</strong></td></tr><tr><td style="text-align:left">这些评论家现在已经 (现在的之前) 被遗忘了。</td><td style="text-align:left">These critics have been forgotten</td></tr></tbody></table><p><strong>注意点:</strong></p><ul><li>英语的被动语态是非常严谨的,  比如作业写完了   这个在中文中是看不出被动语态的, 但是在英语中必须使用被动语态比如  Housework has been compeleted</li></ul><h3 id="谓语动词的否定和强调">谓语动词的否定和强调</h3><p>英语中的谓语动词可以通过添加否定词和强调形式来表示否定和强调。以下是一些基本的规则：</p><p><strong>否定形式：</strong></p><ol><li><p>对于实义动词:   do/does/did + not + <strong>动词原形</strong>   助动词 do决定时态</p></li><li><p>非实义动词   助动词和情态动词 + not<br>(be动词、情态动词、完成时态中的have等)</p></li></ol><blockquote><p>如果有多个非实义动词  比如 will have done  否定形式的not就加在 第一个非实义动词后面 will not have done</p></blockquote><p><strong>强调形式：</strong></p><p>do/does/did + <strong>动词原形</strong></p><ol><li><p>在口语中，我们通常通过重读动词来表示强调。例如，“I DO like pizza.”（我真的喜欢比萨。）</p></li><li><p>在书面英语中，我们可以使用&quot;do&quot;或&quot;did&quot;来强调谓语动词。例如：“I do understand your point.”（我确实理解你的观点。）</p></li></ol><p>注意，在否定和强调谓语动词时，<strong>必须考虑动词的时态和主语的人称和数</strong>。例如，第三人称单数主语在现在时的否定形式需要使用&quot;doesn’t&quot;，而过去时的否定形式需要使用&quot;didn’t&quot;。</p><h2 id="主语宾语表语的变化">主语宾语表语的变化</h2><h3 id="主语">主语</h3><p>在一个句子中，主语通常是执行动作或者处于某种状态的人、事物或者概念。主语可以是以下几种类型：</p><ol><li><p><strong>名词或名词短语</strong>：例如：“John is running.”（约翰在跑步。）在这个句子中，“John”是一个名词，它是这个句子的主语。</p></li><li><p><strong>代词</strong>：例如：“He is running.”（他在跑步。）在这个句子中，“He”是一个代词，它是这个句子的主语。</p></li><li><p><strong>名词从句</strong>：例如：“What you said is not true.”（你说的不是真的。）在这个句子中，“What you said”是一个名词从句，它是这个句子的主语。</p></li><li><p><strong>动名词或不定式</strong>：例如：“Running is good for health.”（跑步对健康有益。）在这个句子中，“Running”是一个动名词，它是这个句子的主语。</p></li><li><p><strong>形容词或数词</strong>：在某些情况下，形容词或数词也可以作为主语。例如：“The rich should help the poor.”（富人应该帮助穷人。）在这个句子中，“The rich”是形容词作为主语的例子。</p></li></ol><p><strong>在动名词和不定式做主语时,  主语通常会很长,  因为动名词和不定式经常用来表示复杂的概念或行动, 他们就相当于一个单独的语句, 也会涉及到宾语,状语,定语这些, 所以单词就会很多了,  但是他们是一个整体</strong></p><p><strong>对于动名词和不定式同时做 主语和表语的时候,   两个格式必须一样,要么是动名词,要么是不定式</strong>,比如  To see is to believe.<br>Seeing is believing.</p><h3 id="宾语">宾语</h3><p>宾语和主语是差不多的, <strong>只要注意有些词的主格和宾格</strong></p><h3 id="表语">表语</h3><p>表语处理主语那些类型以外,  还有  <strong>形容词,副词,介词短语</strong></p><h2 id="简单句的扩展">简单句的扩展</h2><p><strong>简单句的扩展可以通过添加各种补充信息来实现，这些信息可以帮助进一步描述或者修饰主语或谓语</strong></p><h3 id="词性扩展">词性扩展</h3><p>词性扩展的更多内容可以看前面的 基本句子知识 中的 限定词, 形容词, 副词, 介词短语</p><h3 id="成分扩展">成分扩展</h3><h4 id="非谓语">非谓语</h4><p><strong>当一主搭配好一谓之后, 如果还想表达其他的动作, 我们就需要使用非谓语了</strong></p><p>非谓语动词包括不定式（infinitive）、现在分词（present participle）和过去分词（past participle），他们各自有不同的功能和用途：</p><ol><li><p><strong>不定式</strong>：它的基本形式是&quot;to + 动词原形&quot;。不定式常用来<strong>表示目的，原因,意愿或者未来的动作</strong>。例如：“She hopes to visit Paris next year.”（她希望明年访问巴黎。）</p></li><li><p><strong>现在分词</strong>：它的形式是在动词原形后加-ing。<strong>现在分词常用来表示正在进行或者主动的动作或描述性质、特征</strong>。例如：“I saw a dog running in the park.”（我看到一只狗在公园里跑。）</p></li><li><p><strong>过去分词</strong>：它的形式通常是在动词原形后加-ed（不规则动词的过去分词形式各异）。<strong>过去分词通常用来表示已经完成的动作，或者用作形容词表示被动或结果状态</strong>。例如：“The door was locked.”（门被锁了。）</p></li></ol><p>以上，不定式、现在分词和过去分词都可以用作状语、补语、定语等句子成分，这取决于具体的语境和他们所在的句子结构。</p><p><strong>非谓语必须得单独出现,  千万别跟时态搞混了</strong></p><h5 id="成分">成分</h5><p>非谓语动词包括分词（现在分词和过去分词）、动名词和不定式，它们在句子中可以充当多种成分，具体包括：</p><ol><li><p><strong>主语</strong>：例如，“Running is good for your health.” （跑步对你的健康有好处。）中的 “Running” 是动名词作为主语。</p></li><li><p><strong>宾语</strong>：例如，“I love to read.” （我喜欢阅读。）中的 “to read” 是不定式作为宾语。</p></li><li><p><strong>定语</strong>：例如，“A man wearing a hat” （一个戴帽子的人）中的 “wearing a hat” 是现在分词短语作为定语；“A letter to be sent” （一封待寄的信）中的 “to be sent” 是不定式短语作为定语。</p></li><li><p><strong>状语</strong>：例如，“Seen from the sky, the city is more beautiful.” （从天空看，这个城市更美。）中的 “Seen from the sky” 是过去分词短语作为状语。</p></li><li><p><strong>主语补语(表语)</strong>：例如，“She seems to be happy.” （她看起来很快乐。）中的 “to be happy” 是不定式短语作为补语。</p></li><li><p><strong>宾语补足语</strong>：例如，“I found him sitting on the bench.” （我发现他坐在长凳上。）中的 “sitting on the bench” 是现在分词短语作为宾语补足语。</p></li></ol><p>非谓语动词在句子中的角色非常灵活，可以根据上下文和句子的需要进行调整。这也是英语的一种重要特性，使得表达更加丰富和灵活。</p><p><strong>如果是做状语, 就看主语与非谓语动词的关系,  如果做定语的话, 就看修饰对象和非谓语动词的关系</strong></p><h4 id="同位语-插入语">同位语 插入语</h4><ol><li><p><strong>同位语 (Appositive)</strong>：同位语是一个名词、名词短语、或者名词从句，用来解释或重新定义前面的名词或代词。<strong>它位于被解释的名词或代词之后，并通常通过逗号与其隔开</strong>。例如：“John Smith, my friend, is coming for dinner.” 在这句话中，“my friend”就是“John Smith”的同位语，用来解释“John Smith”是谁。 <strong>标志性符号 冒号,逗号,扩折号</strong></p></li><li><p><strong>插入语 (Parenthetical)</strong>：插入语是<strong>插入在句子中的词、短语或从句</strong>，它可以提供额外的信息，但是不影响主句的结构和完整性。插入语通常由逗号、破折号或括号包围。例如：“She is, as far as I know, the best candidate for the job.” 在这句话中，“as far as I know”就是插入语，提供了说话人对主句的额外评价。</p></li></ol><p>这两种语法现象都是用来增加语句的信息内容，但是他们的功能和使用方式有所不同。同位语更多地是用来解释和定义，而插入语更多地是提供额外的评论和背景信息。</p><h4 id="攻略">攻略</h4><ul><li><em style="color:red">要注意非谓语动词词组的完整性,它通常后面会接很多其他词组</em></li><li>注意非谓语修饰的对象</li><li>对于 to do 这个非谓语, 它一般出现在最后面,  我们可以使用代入法, 看他修饰的是 前面这个单词, 还是整个句子</li></ul><h2 id="总结">总结</h2><ul><li>攻略1：抓住谓语动词, 就抓住了句子最核心的表述动作或内容</li><li>攻略 2 : 通过定位谓语动词, 找到复杂多变的主语  <strong>主语一般在谓语动词前面</strong> , 找谓语比找主语好找多了</li><li>攻略3 : 通过谓语动词的数量, 判断长难句中包含了几件事</li></ul><p>我们利用所学语法来一步步扩充句子</p><p>Girls play games.  主谓宾<br>Girls are playing games. 谓语动词的现在进行时<br>Cute girls are playing games happily.  形容词修饰主语, 副词修饰谓语动词<br>Thousands of cute girls are playing games very happily. 进一添加修饰词<br>After class thousands of cute girls are playing games very happily on the playground.  加入介词短语补充更多信息</p><p><strong>所以在做题的过程中,  我们是不是可以去掉一些非核心的东西, 一遍遍的缩短句子, 然后就可以很好的知道句子表达的意思</strong></p><h1>长难句</h1><h2 id="并列句">并列句</h2><p>英语中的并列句（Compound Sentence）<strong>是由两个或更多个独立的简单句（主谓结构）通过并列连词连接而成的</strong>。每个简单句在并列句中都是一个完整的思想，它们相互之间是<strong>并列或者对等的关系</strong>。</p><h3 id="构成">构成</h3><p><strong>多个简单句+并列连词</strong></p><h3 id="并列连词">并列连词</h3><p><strong>并列连词</strong>：并列句中的各个部分通常由并列连词连接，常见的并列连词包括&quot;and&quot;（和）, “or”（或）, “but”（但是）, “so”（所以）, “yet”（然而）, “for”（因为）等等。</p><p>例如：</p><ul><li>“I like apples, and my sister likes oranges.”（我喜欢苹果，而我的姐姐喜欢橙子。）</li><li>“It’s raining outside, so you should take an umbrella.”（外面正在下雨，所以你应该带把伞。）</li><li>“He was tired, but he continued to work.”（他很累，但他继续工作。）</li></ul><p>请注意，各个部分之间的逗号并非必须，但在有些情况下，为了句子的清晰和阅读的流畅，逗号的使用是非常必要的。</p><p><em style="color:red">并列连词不一定要连接句子,也可以连接词和词组</em></p><h4 id="表示顺接">表示顺接</h4><table><thead><tr><th style="text-align:center">并列连词</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span> and…</td><td style="text-align:center">“…和…”</td></tr><tr><td style="text-align:center">both…and…</td><td style="text-align:center">(两者都 )</td></tr><tr><td style="text-align:center">not only… but… as well</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">not only… but also…</td><td style="text-align:center">“不但…而且…”(意思同 “…和…&quot;)</td></tr><tr><td style="text-align:center">not only… but…</td><td style="text-align:center"></td></tr></tbody></table><h4 id="表示转折">表示转折</h4><table><thead><tr><th style="text-align:center">并列连词</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">…but…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">…yet…</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span>. 但是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">\cdots \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></td></tr></tbody></table><p><em style="color:red"><strong>however这些可不是并列连词, 它是副词</strong> </em></p><p><strong>要着重看 转折后的句子</strong></p><h4 id="表示选择">表示选择</h4><table><thead><tr><th style="text-align:center">并列连词</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>…</mo><mtext>or</mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> either... or... </mtext></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\ldots \text {or} . . . \\\text { either... or... }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">or</span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> either... or... </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> &quot;......或者......&quot; </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> (二选一 </mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\text { &quot;......或者......&quot; } \\\text { (二选一 })\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> &quot;......</span><span class="mord cjk_fallback">或者</span><span class="mord">......&quot; </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">二选一</span><span class="mord"> </span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">neither… nor…</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> &quot;既不.......也不.......&quot; </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (两个都不选 ) </mtext></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\text { &quot;既不.......也不.......&quot; } \\\text { (两个都不选 ) }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> &quot;</span><span class="mord cjk_fallback">既不</span><span class="mord">.......</span><span class="mord cjk_fallback">也不</span><span class="mord">.......&quot; </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">两个都不选</span><span class="mord"> ) </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td></tr></tbody></table><h4 id="表示因果">表示因果</h4><table><thead><tr><th style="text-align:center">并列连词</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">… for…</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> 因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>.</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span>. so…</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>. 所以/因此……</td></tr></tbody></table><h3 id="并列句的省略">并列句的省略</h3><p>并列句中的省略是英语中常见的现象，<strong>特别是在两个或者更多并列句中的某些成分相同时</strong>，<strong>为了避免重复和提高语言的流畅性，我们通常会省略第二个及之后并列句中与前面部分重复的成分，特别是主语和助动词。</strong></p><p>例如：</p><ul><li>“I like apples and (I like) oranges.” 可简化为 “I like apples and oranges.”</li><li>“He can play the piano and (he can play) the guitar.” 可简化为 “He can play the piano and the guitar.”</li></ul><p>这样的省略不会影响句子的完整性和理解，而且使得表达更加简洁。但请注意，只有在清楚不会引起误解的情况下才可以进行这样的省略。如果省略后的句子含义模糊或者引起误解，那么最好不要省略。</p><p><strong>可以省略时态部分, 情态部分,等等,  所以在做题的时候一定要注意</strong></p><h3 id="总结">总结</h3><ol><li>并列句的构成 : 多个简单句+并列连词 (四类并列连词是重点)</li><li>并列句的省略 : 相同的成分可以省略, 余下的成分保持不变。</li></ol><h2 id="复合句">复合句</h2><p>在英语中，复合句（complex sentence）是一种包含一个主句（也称为独立子句）和一个或多个从句（也称为依赖子句）的句子。从句通常以连接词（例如“that”，“which”，“because”，“although”，“if”等）引导，并为主句提供补充信息。</p><p>复合句的基本类型主要有三种：名词性从句，状语从句和定语从句。</p><ol><li><p><strong>名词性从句</strong>：名词性从句可以在句子中充当主语，宾语，或者表语。例如，“What you said (主语）made me happy”，“I know that she is kind (宾语)”，“The truth is that he has left (表语)”。</p></li><li><p><strong>定语从句</strong>：定语从句修饰句子中的名词或代词，为它们提供更多的信息。例如，“The man who is wearing a blue shirt is my teacher”，“This is the place where I was born”。</p></li><li><p><strong>状语从句</strong>：状语从句修饰主句中的动词，形容词，副词或整个句子，通常表示原因，条件，目的，结果，时间，地点等。例如，“She arrived when the party had just started (时间)”，“If you study hard, you will pass the exam (条件)”。</p></li></ol><p><strong>在复合句中，主句和从句通过从属连词，关系代词或者关系副词连接。主句可以独立成句，而从句不能独立成句，它需要依赖主句来完成它的意思。</strong></p><h2 id="名词性从句">名词性从句</h2><p>在英语中，<strong>名词性从句(Noun Clauses)就是在句子中起名词作用的从句</strong>，可以做主语、宾语和表语。名词性从句通常由连词that，if，whether，或者连接代词what，who，which，连接副词when，where，how，why等引导。 <em style="color:red">但是要注意 从句必须是陈述句语序 </em></p><ol><li><p><strong>主语从句</strong>(Subject Clauses)：名词性从句充当整个句子的主语。例如，“What you said” in “What you said really surprised me.” 主语从句通常被动词，如is，are，seem，或者感叹词如it’s a pity，it’s strange等，引导。</p></li><li><p><strong>宾语从句</strong>(Object Clauses)：名词性从句可以作为动词或介词的宾语。例如，“that he failed the exam” in “I didn’t know that he failed the exam.”</p></li><li><p><strong>表语从句</strong>(Predicate Clauses)：名词性从句可以在系动词后面作为表语。例如，“where we should go” in “The question is where we should go.”</p></li><li><p><strong>同位语从句</strong>(Appositive Clauses)：<strong>名词性从句也可以作为同位语，解释或者进一步说明前面的名词或者代词</strong>。通常由that引导，也可以由if，whether，who，what，which，when，where，how等引导。例如：“The news that he passed the exam made us happy.” 在这个例子中，“that he passed the exam” 是同位语从句，用来解释前面的名词 “the news”。</p></li></ol><p>常用的连接词包括：that，if，whether，who，whom，whose，which，what，how，when，where，why等。名词性从句中，名词性从句中，<strong>&quot;that&quot;没有实际意义，也不作句子成分，它只是起连接作用，在某些情况下（如宾语从句，主语从句，表语从句等）可以省略</strong>。而其他连接词不仅起连接作用，还作为句子的一部分，表达一定的词义，因此不能省略。</p><p>例如：</p><ul><li>宾语从句：I think (that) you are right.</li><li>主语从句：(That) you are right is obvious.</li><li>表语从句：The fact is (that) you are right.</li></ul><p>但是，有些情况下，“that&quot;不能省略，例如当&quot;that&quot;被用作同位语从句的引导词时，或者为了避免歧义时，通常不会省略&quot;that”。例如：</p><ul><li>同位语从句：He told me the news that he got a job. （在这里，&quot;that&quot;不能省略）</li><li>避免歧义：I said that I like apples. （如果省略&quot;that&quot;，句子可能会被误解为&quot;I said I, like apples&quot;）</li></ul><h3 id="创造名词性从句">创造名词性从句</h3><ol><li>写一个陈述句A,表达一件事</li><li>然后根据这个陈述句 选择连接词 加在A句子之前, 形成句子B</li><li>然后这个句子B就能被拿来使用了</li></ol><p>比如  you bought yesterday  -&gt;    what  you bought yesterday   -&gt;   I kown what  you bought yesterday</p><p>比如  you bought gift yesterday -&gt;  where you bought the gift yesterday -&gt; I kown where you bought the gift yesterday</p><p>如果是一般疑问句, 就是变成称述语句,然后选择加上(whether 或者 if (不能放在句首),保留了是否) Did you buy gift yesterday?  就变成 if / whether you bought gift yesterday</p><p>如果是特殊疑问句,那就更好办了,只需要将疑问语序变成称述语序,即主语提前 <strong>如果疑问词就是充当主语部分,那就不需要变</strong>, 比如  what did you buy yesterday? -&gt; what  you bought yesterday   -&gt;   I kown what  you bought yesterday     再如  who is coming -&gt; who is coming -&gt; i   don’t know who is coming</p><p>要注意时态变化, 还有语序变化 比如疑问句是 do/did/does + 动词原形   转变成从句的时候, 要变成动词的时态</p><h3 id="宾语从句">宾语从句</h3><ul><li><p>宾语从句在英语中常见于以下三种位置：</p><ol><li><strong>动词后的宾语从句</strong>：这是最常见的类型，这类宾语从句通常位于<strong>某些及物动词后</strong>, 千万不要忘记还有动双宾，比如说、认为、感觉、希望等。例如：<ul><li>“He says that he will be late.”（他说他会迟到。）</li></ul></li><li><strong>介词后的宾语从句</strong>：这类宾语从句通常位于某些介词后，比如 about, before, after, in, on等。例如：<ul><li>“I am thinking about whether I should go to the party.”（我在考虑我是否应该去参加派对。）</li></ul></li><li><strong>形容器 + 宾语从句</strong></li></ol><p>在以上三种情况下，宾语从句都是句子的一部分，为主要动词或结构提供了所需要的信息。</p><p>请注意，这些都是一般规则，并不是每一个动词或介词后都可以直接接宾语从句，具体情况需要参照具体的语境和语法规则。</p></li></ul><h4 id="后置-it做形式宾语">后置,it做形式宾语</h4><p>这种情况适用于  主谓宾宾补的句型,   宾语从句太长了,it做形式宾语,然后从句往后放, 从而让句子看起来更自然</p><h3 id="表语从句">表语从句</h3><p>表语从句是名词性从句的一种，它在句中作表语，<strong>通常放在系动词后面, 不管这个系动词是不是谓语</strong>。</p><p>在使用表语从句时，应注意以下几点：</p><ul><li>当主语是a fact, the truth, the question, the problem等抽象名词时，通常需要用表语从句来说明具体内容。</li><li>当表语从句用于否定句型时，是否定词not通常放在系动词后面，即放在表语从句之前。</li><li>在一些特殊句型中，如It is/was…that…, 表语从句常常用在强调句型中。</li><li>表语从句的语序通常是陈述句语序，即使引导词是疑问词。</li></ul><h3 id="主语从句">主语从句</h3><p>主语从句是名词性从句的一种，它在句中充当主语的角色。主语从句通常由连词that，whether，if，或者疑问词(如：who, what, where, when, why, how等)来引导。</p><p>以下是一些主语从句的例子：</p><ol><li><p>“Whether he will come or not is not clear.”<br>在这个例子中，“Whether he will come or not” 是主语从句，谓语动词是&quot;is&quot;。</p></li><li><p>“What you need is more practice.”<br>在这个例子中，“What you need” 是主语从句，谓语动词是&quot;is&quot;。</p></li><li><p>“That he didn’t show up for the meeting is surprising.”<br>在这个例子中，“That he didn’t show up for the meeting” 是主语从句，谓语动词是&quot;is&quot;。</p></li></ol><p>在使用主语从句时，应注意以下几点：</p><ul><li><p>由于主语从句往往比较长，为避免句子头重脚轻，<strong>通常会用it作形式主语，而将真正的主语从句放到句尾</strong>。例如：“It is surprising that he didn’t show up for the meeting.”</p></li><li><p>当从句是由whether 或if 引导的，表示是否的意思时，它们可以和动词不定式互换。例如：&quot;Whether to go or not is a difficult decision.“和&quot;To go or not is a difficult decision.” 的意思是相同的。<strong>(if不能用在开头)</strong></p></li><li><p>在主语从句中，无论引导词是否为疑问词，句子的语序都应为陈述句语序。</p></li></ul><h3 id="同位语从句">同位语从句</h3><p>同位语从句是名词性从句的一种，它在句中起名词同位语的作用。同位语从句用于解释或者阐明其前面的名词或代词，通常由连接词（that、if、whether）或连接代词（who, what, which）以及连接副词（when, where, why, how）等引导。下面是一些例子：</p><ol><li><p>“The news that he passed the exam made us happy.” 在这句话中，“that he passed the exam” 是一个同位语从句，用于解释名词 “the news”。</p></li><li><p>“The question whether we should go or not remains.” 在这句话中，“whether we should go or not” 是一个同位语从句，用于解释名词 “the question”。</p></li><li><p>“The idea that everyone should be treated equally is fundamental.” 在这句话中，“that everyone should be treated equally” 是一个同位语从句，用于解释名词 “the idea”。</p></li></ol><p>请注意，同位语从句通常紧随其解释的名词之后，且二者之间通常不使用逗号分隔。有时，为了避免句子过于复杂或冗长，可能会使用冒号或者分号来引导同位语从句。</p><h2 id="定语从句">定语从句</h2><p>**定语从句 (Attributive Clauses)**是在句子中作定语的从句。定语是用来修饰或限定名词（或代词）的词、短语或句子，定语从句就是这样的一个从句。定语从句一般紧跟在它所修饰的先行词后面，由关系词（关系代词或关系副词）引导。</p><ol><li><p><strong>关系代词</strong>：在定语从句中，关系代词有&quot;who&quot;, “whom”, “whose”, “that”, “which”。“Who” 和 “whom” 用于指人，“that” 和 “which” 用于指物，“whose” 用于指人或物。例如：The man who spoke yesterday is my professor (昨天讲话的那个人是我的教授)。 <strong>后面一般不是完整的句子</strong></p></li><li><p><strong>关系副词</strong>：“when”, “where” 和 “why” 也可以引导定语从句。&quot;When&quot;用于时间，“where” 用于地点，“why” 用于原因。例如：I’ll never forget the day when I first met you (我永远不会忘记我第一次遇见你的那一天)。<strong>后面一般是完整的句子</strong></p></li></ol><p><strong>注意，关系词在从句中通常都有句法功能，作主语、宾语、定语等。</strong></p><p>同时，我们需要注意的是非限制性定语从句和限制性定语从句的区别。非限制性定语从句和它所修饰的先行词并无紧密联系，如果去掉，对主句的影响不大。而限制性定语从句则与先行词有紧密的语义联系，如果去掉，主句的意思就不完整或产生变化。</p><p>先行词是前面修饰的对象, 关系词是从句中做成分的关系代词或者副词</p><h3 id="关系词">关系词</h3><table><thead><tr><th style="text-align:center">先行词</th><th style="text-align:center">关系词</th></tr></thead><tbody><tr><td style="text-align:center">事/物</td><td style="text-align:center">which/that</td></tr><tr><td style="text-align:center">人</td><td style="text-align:center">who/whom/that</td></tr><tr><td style="text-align:center">人/物(表示人或物的所有关系, 即 “某人的/某物的” )</td><td style="text-align:center">whose</td></tr><tr><td style="text-align:center">时间</td><td style="text-align:center">when</td></tr><tr><td style="text-align:center">地点</td><td style="text-align:center">where</td></tr><tr><td style="text-align:center">原因</td><td style="text-align:center">why</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">whereby = by which</td></tr></tbody></table><h3 id="创造定语从句">创造定语从句</h3><ol><li>写一个陈述句(<strong>定语从句不存在什么疑问句变定语从句一说</strong>)</li><li>将要修饰的对象提取出来,  放到句首, 然后添加对应的关系词</li><li>这样就能被其他句子使用了</li></ol><blockquote><p>看到这里与名词从句创造的不同了吗?, 这里的关系词是确定的,  而名词性从句里面的关系词是不确定的</p></blockquote><p>比如:  I bought  a gift yesterday  -&gt;  a gift that i bought yesterday -&gt;  I know  a gift that i bought yesterday</p><h3 id="定语从句分类">定语从句分类</h3><p><strong>限定性定语从句（Restrictive Relative Clauses）</strong>，也称为必要性定语从句，是一种对先行词进行具体化或限定化的定语从句。换句话说，它的存在是为了确切地标识或限定先行词的身份或性质，<strong>如果去掉这个从句，那么主句的意思就可能发生很大的改变。</strong></p><p>例如，在句子 “The book that is on the table is mine” 中，“that is on the table” 就是一个限定性定语从句，它在限定&quot;the book&quot;的具体性，即在桌子上的那本书，而不是别的书。如果我们去掉这个定语从句，句子就变成了 “The book is mine”，这时就不清楚我们在谈论哪一本书了。</p><p><strong>非限定性定语从句（Nonrestrictive Relative Clauses）</strong>，也被称为非必要性定语从句，是一种对先行词提供附加信息的定语从句。这种从句并不对先行词做出必要的限定或识别，因此，如果去掉这个从句，主句的基本含义仍然清晰。 <strong>非限定性定语从句有时是修饰前面整句话, 这个时候关系词只能用which(只能放在主句之后)和as</strong></p><p>例如，在句子 “My brother, who lives in New York, is a doctor.” 中，“who lives in New York” 就是一个非限定性定语从句。它为&quot;my brother&quot;提供额外的信息，说明他住在纽约，但这并不是识别&quot;my brother&quot;的必要条件。如果我们去掉这个定语从句，句子就变成了 “My brother is a doctor.”，基本含义不变</p><p>限定性定语从句和非限定性定语从句（Non-restrictive Relative Clauses）的主要区别在于，<strong>非限定性定语从句只是为先行词提供额外的信息</strong>，如果去掉它，主句的基本意思仍然不会改变。</p><p><em style="color:red">其实也就是看先行词的范围明确不明确,  如果已经明确了, 就可以加逗号, 当做补充说明, 如果不明确,就不加逗号,用作限定</em></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">限定性定语从句</th><th style="text-align:center">非限定性定语从句</th></tr></thead><tbody><tr><td style="text-align:center">逗号</td><td style="text-align:center">无逗号</td><td style="text-align:center">有逗号</td></tr><tr><td style="text-align:center">先行词</td><td style="text-align:center">范围不明确</td><td style="text-align:center">范围明确</td></tr><tr><td style="text-align:center">作用</td><td style="text-align:center">修饰限定先行词, 不能省略, 影响表意</td><td style="text-align:center">补充说明先行词, 可以省略, 不影响表意</td></tr><tr><td style="text-align:center">翻译</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> 往前翻译 </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> (译到先行词前, “</mtext><mo>…</mo><mo>…</mo><mtext>的名词”) </mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}\text { 往前翻译 } \\\text { (译到先行词前, “……的名词”) }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">往前翻译</span><span class="mord"> </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">译到先行词前</span><span class="mord">, “</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">的名词</span><span class="mord">”) </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td><td style="text-align:center">不用往前翻译</td></tr><tr><td style="text-align:center">关系词</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (1) 关系词可以用that </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (2) 作宾语可以省略 </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (3) 指人作宾语, 用whom/who/that 都行 </mtext></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\text { (1) 关系词可以用that } \\\text { (2) 作宾语可以省略 } \\\text { (3) 指人作宾语, 用whom/who/that 都行 }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (1) </span><span class="mord cjk_fallback">关系词可以用</span><span class="mord">that </span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (2) </span><span class="mord cjk_fallback">作宾语可以省略</span><span class="mord"> </span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (3) </span><span class="mord cjk_fallback">指人作宾语</span><span class="mord">, </span><span class="mord cjk_fallback">用</span><span class="mord">whom/who/that </span><span class="mord cjk_fallback">都行</span><span class="mord"> </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (1) 关系词不能用that </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (2) 不可以省略 </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> (3) 指人作宾语, 只能用whom </mtext></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\text { (1) 关系词不能用that } \\\text { (2) 不可以省略 } \\\text { (3) 指人作宾语, 只能用whom }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (1) </span><span class="mord cjk_fallback">关系词不能用</span><span class="mord">that </span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (2) </span><span class="mord cjk_fallback">不可以省略</span><span class="mord"> </span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> (3) </span><span class="mord cjk_fallback">指人作宾语</span><span class="mord">, </span><span class="mord cjk_fallback">只能用</span><span class="mord">whom </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td></tr></tbody></table><h3 id="介词提前的短语从句">介词提前的短语从句</h3><p>介词提前的定语从句是指在定语从句中，<strong>介词与其宾语一起提前放置在关系词之前的结构</strong>。这种结构在英语中相对较常见，有以下几种形式：(注意, 如果是介词提前,千万不能使用that)</p><ol><li><p>介词提前的定语从句放在名词之后：</p><ul><li>The book on which I’m writing a report is very interesting.（关系词：“which”，介词提前：“on”）</li><li>The person with whom I went to the concert is my best friend.（关系词：“whom”，介词提前：“with”）</li></ul></li><li><p>介词提前的定语从句放在关系词之后：</p><ul><li>The house (that) I used to live in is now for sale.（关系词：“that”，介词提前：“in”）</li><li>The park (which) we played in yesterday is beautiful.（关系词：“which”，介词提前：“in”）</li></ul></li></ol><p>在这些例子中，介词通常与其宾语形成一个介词短语，该介词短语作为定语修饰关系词所指代的名词。通过将介词短语提前放置，可以使句子结构更加清晰，避免过长的句子或层层嵌套的从句结构。</p><p>需要注意的是，有时候可以省略关系词 “that” 或 “which”，但是不能省略介词。此外，在非正式口语中，有时可以使用介词提前的结构，而不使用定语从句，例如 “The book I’m writing a report on is very interesting.”（“on” 提前）。这种用法在口语和日常交流中较为常见。</p><h2 id="状语从句">状语从句</h2><p>状语从句是复合句的一种类型，是在主句中作状语的从句，<strong>它修饰主句中的动词、形容词、副词或整个句子</strong>。通常，状语从句通过<strong>表示时间、地点、方式、原因、目的、结果、条件、让步等，来修饰或者限定主句中的动词或者整个句子</strong>。</p><p>这里有一些例子和引导词:</p><ol><li><strong>时间状语从句</strong>：通常由when, while, as, before, after, since, until等引导。例如：“I’ll call you when I get home.”</li><li><strong>地点状语从句</strong>：通常由where, wherever等引导。例如：“He can work wherever he lives.”</li><li><strong>原因状语从句</strong>：通常由because, since, as等引导。例如：“She was late because she missed the bus.”</li><li><strong>结果状语从句</strong>：通常由so… + adj adv .that, such.+ n …that等引导。例如：“The rain was so heavy that we had to stay home.”<strong>(后面的事情一般都发生了)</strong></li><li><strong>目的状语从句</strong>：通常由so that, in order that等引导。例如：“He got up early so that he could catch the train.” (<strong>一般是后面的事情没有发生</strong>)  目的状语从句里面有情态动词</li><li><strong>条件状语从句</strong>：通常由if, unless, as long as等引导。例如：“If it rains, we will stay at home.”</li><li><strong>让步状语从句</strong>：通常由although, though等引导。例如：“Although he’s very young, he knows a lot.”</li><li><strong>比较状语从句</strong></li><li><strong>方式状语从句</strong>：通常由as if, as though等引导。例如：“She talks as if she knows everything.”</li></ol><p>状语从句可以根据语境和需要移动到句子的不同位置。例如，可以把 “If it rains, we will stay at home.” 改写为 “We will stay at home if it rains.”</p><p><strong>连接词是不做句子成分的, 但是它可以表示逻辑关系</strong></p><h3 id="创建状语从句">创建状语从句</h3><ol><li><strong>写一个陈述句</strong><ul><li>“I studied hard.”</li></ul></li><li><strong>选择连接词</strong> 你可以选择不同类型的连接词，以创建不同类型的状语从句，如时间、原因、条件、目的等。</li><li><strong>在主句中使用</strong><ul><li>“Before I went to the university, I studied hard.”</li><li>“If went to the university, I would study hard.”</li></ul></li></ol><h3 id="状语从句的位置">状语从句的位置</h3><p>状语从句在英语句子中可以出现在不同的位置，它可以放在主句前，也可以放在主句后，这取决于想要强调的信息和句子的流畅度。下面是一些关于状语从句位置的总结：</p><ol><li><p><strong>状语从句在主句之前</strong>：在英语中，状语从句通常放在主句之前，这种情况下，主句和状语从句之间通常会有一个逗号。例如：</p><ul><li>“Because it was raining, we decided to stay at home.”</li><li>“If you work hard, you will succeed.”</li></ul><p>这种结构的主要优点是可以清晰地表示出条件或原因，使句子更易理解。</p></li><li><p><strong>状语从句在主句之后</strong>：状语从句也可以放在主句之后，这时候通常不需要逗号。例如：</p><ul><li>“We decided to stay at home because it was raining.”</li><li>“You will succeed if you work hard.”</li></ul><p>这种结构的主要优点是可以更加强调主句中的信息。</p></li><li><p><strong>分隔主句的状语从句</strong>：在一些情况下，状语从句也可以分隔开主句的两个部分，这样可以更强地强调状语从句的信息。例如：</p><ul><li>“The man, while he was walking down the street, found a wallet.”</li></ul></li></ol><p>总的来说，状语从句的位置应根据你想强调的信息和句子的整体流畅度来确定。你可以通过在不同的位置试验状语从句，看看哪种位置更能表达你的意思。</p><p>大多数状语从句都可以在主句前或主句后。但是，某些状语从句（特别是某些比较短的状语从句）的位置可能更固定。这主要是由于习惯用法和流畅性考虑。</p><ol><li><p><strong>放在句首的状语从句</strong>：某些状语从句习惯上放在句首，尤其是那些以否定词或半否定词开头的状语从句，如&quot;never&quot;, “seldom”, “hardly”, “scarcely”, “rarely”, “little”, “no sooner”, &quot;not only&quot;等。这些状语从句放在句首时，主句要用倒装句，如：</p><ul><li>“Hardly had I arrived when the phone rang.”（我刚刚到，电话就响了。）</li><li>“No sooner had we reached the top than the fog began to lift.”（我们刚到山顶，雾就开始散了。）</li></ul></li><li><p><strong>放在句尾的状语从句</strong>：当状语从句以&quot;as&quot;（当…时）或&quot;than&quot;（比…）引导时，习惯上放在句尾。如：</p><ul><li>“Do as I do.”（跟我一样做。）</li><li>“He is taller than I am.”（他比我高。）</li></ul></li></ol><p>此外，一些短的时间或条件状语从句（如 “if possible”, “when necessary”）习惯上也放在句尾。如：</p><ul><li>“Call me if possible.”（如果可能的话，给我打电话。）</li></ul><p>以上说的是习惯用法，但并不是硬性规定。在考虑状语从句的位置时，主要要注意句子的通顺性和清晰度。</p><h2 id="特殊句式">特殊句式</h2><h3 id="倒装">倒装</h3><p>英语中的倒装语序（Inversion）是指将动词放在主语之前的语序，通常包括全倒装和半倒装两种类型</p><p><strong>全倒装</strong>：全倒装指的是谓语动词全部置于主语之前。这种倒装在英语中较为少见，主要出现在一些固定的句型中，如： “Here comes the bus!” 或 “There goes the bell!”。</p><p>比如  there be 句型: There be + n.    这里其实就是倒装, 因此是后面的名词作主语</p><p>there be +n. + 介词短语    There is a book on the table</p><p><strong>这里的be是可以结合时态和情态的, 还有要考虑他的单复数</strong></p><p><strong>半倒装</strong>：半倒装指的是谓语动词的一部分（<strong>通常是助动词或情态动词</strong>）置于主语之前。这种倒装在英语中较为常见，主要出现在以下几种情况：<strong>(一般疑问句就是半倒装, 因此我们可以像变一般疑问句一样变成倒装)</strong></p><ul><li><p><strong>否定转移</strong>：当句首状语（包括副词，短语或从句）为否定词或半否定词时，主句要使用倒装语序，例如：“Never have I seen such a beautiful sunset.” 或 “Hardly had he arrived when the train left.”。</p></li><li><p><strong>为了强调某一部分</strong>：例如：“Only then did I understand the problem.” 或 “So excited was she that she could not sleep.”。</p></li><li><p><strong>一些短语或从句</strong>：例如：“Not only does he speak English, but he also speaks French.” 或 “No sooner had I arrived than the phone rang.”。</p></li><li><p><strong>虚拟条件句省略if</strong>:  例如  If I were rich, I would travel around the world. -&gt; Were I rich, I would travel around the world.</p></li></ul><p>需要注意的是，倒装语序主要用在书面语或正式语境中，在日常口语中使用较少。另外，某些主语（如代词）不常使用倒装语序。</p><p>英语的倒装结构主要有以下几个作用：</p><ol><li><p><strong>强调</strong>：倒装结构能强调句子的某个部分，特别是当这个部分放在句首时。例如，“Never have I seen such a beautiful sight.” 在这句话中，“never” 放在句首，并通过倒装强调了我从未见过如此美丽的景象。</p></li><li><p><strong>修辞</strong>：倒装结构也是一种修辞手段，用来增强语言的表现力和生动性。例如，“On the tree sat a little bird.” 这样的句子在散文、诗歌等文体中常见。</p></li><li><p><strong>语法要求</strong>：在某些结构中，语法规则要求使用倒装，例如含有否定或半否定词的句子，&quot;Only&quot;引导的句子等。</p></li><li><p><strong>流畅和清晰</strong>：在一些情况下，倒装可以使句子读起来更流畅，理解起来更清晰。例如，“On the floor is a pair of glasses.” 比 “A pair of glasses is on the floor.” 读起来更自然，更清楚地表达了地点。</p></li></ol><p>这些都是倒装结构在英语中的重要作用，但值得注意的是，不是所有的句子都适合使用倒装，过度使用可能会让语言显得过于正式或者生硬。</p><h3 id="强调">强调</h3><p>在英语中，我们可以通过强调句型来特别强调句子中的某一部分信息。一般来说，强调句型的基本结构是：“It is/was + 被强调部分 + that/who + 其他部分”。</p><ol><li><p><strong>使用&quot;It is/was&quot;</strong>：这是强调句型的标志之一。我们使用&quot;It is/was&quot;来开头，并紧跟着我们想要强调的部分。</p></li><li><p><strong>使用&quot;that/who&quot;</strong>：在被强调部分后，我们使用&quot;that&quot;或&quot;who&quot;来引导其他部分。如果被强调部分是人，我们通常使用&quot;who&quot;，否则使用&quot;that&quot;(that也能够强调人)。</p></li><li><p><strong>其他部分</strong>：在&quot;that/who&quot;之后，我们添加句子剩下的部分。这部分信息通常是我们不特别强调的部分。</p></li></ol><p>例如，对于这句话：“I found the book in the library.”，如果我们想强调的是“我”这个主语，就可以说：“It was I who found the book in the library.”。如果我们想强调的是地点“图书馆”，就可以说：“It was in the library that I found the book.”</p><p>需要注意的是，强调句型通常在正式或书面英语中使用，而在日常口语交流中则不太常用。</p><p>在实践中，要判断一句话是否是强调句型，<strong>你可以尝试去掉&quot;It is/was…that/who…&quot;的结构</strong>，看看句子是否仍然有意义且没有改变原本的意思。<strong>如果句子仍然合乎语法且意思没变，那么原句很可能是使用了强调句型</strong>。否则，如果去掉&quot;It is/was…that/who…&quot;的结构后，句子就变得不完整或者意思改变了，那么原句可能并不是强调句型。</p><p>例如，对于强调句&quot;It is you who I trust.&quot;，如果我们去掉&quot;It is…who…“的结构，就变成了&quot;I trust you.”，这是一个完整的句子，且意思没有改变。因此，我们可以判断原句是一个强调句型。</p><p>相比之下，考虑句子&quot;It’s important that you should go.&quot;，如果我们去掉&quot;It’s…that…“的结构，就变成了&quot;You should go.”，这个句子虽然仍然有意义，但是失去了原句中强调事情的重要性的意思，因此原句并不是强调句型，而是&quot;It&quot;作为形式主语的句型。</p><p><strong>强调句不仅可以强调词或词组，还可以强调从句。 但是不能强调形容词或动词。</strong></p><h4 id="创建一个强调句">创建一个强调句</h4><ul><li>书写一个称述句</li><li>将强调部分放到  is/was 后面</li><li>其余部分放到  that/who 后面</li></ul><h3 id="虚拟句">虚拟句</h3><p>虚拟语气在英语中<strong>用来表示一种假设的、非现实的、未发生的、不可能发生的、或者希望发生的情况</strong>。虚拟语气的构成通常包括一个&quot;if&quot;条件从句和一个主句。<strong>这种结构通常用于表达对过去、现在和未来的假设</strong>。</p><p>这里就是和条件状语从句有点不一样的地方,  条件状语从句是如果这个事情成立, 就干嘛,  而虚拟句是  假设成立, 就干嘛, 一般都是和现实相反的条件</p><ol><li><p><strong>虚拟语气在条件句中的使用</strong>：(一般是与现在事实想法的假设)</p><p><strong>对现在和将来的虚拟</strong>：如果说话者提出一种对现在或将来的虚构情况，那么&quot;if&quot;条件从句通常会<strong>用一般过去时</strong>，而<strong>主句则会用&quot;would&quot;、&quot;could&quot;或&quot;might&quot;加上动词原形</strong>。例如：“If I had time, I would help you.”</p><p><strong>对过去的虚拟</strong>：如果说话者提出一种对过去的虚构情况，那么&quot;if&quot;条件从句通常会<strong>用过去完成时</strong>，而主句则会用&quot;would have&quot;、&quot;could have&quot;或&quot;might have&quot;加上过去分词。例如：“If I had known that, I would have helped you.”</p></li><li><p><strong>虚拟语气在祈使句、宾语从句、表语从句、同位语从句中的使用</strong>：</p><p>当我们希望表达一种建议、要求、命令、劝告等情绪时，通常会用&quot;should&quot;加上动词原形，或者直接使用动词原形。例如：“I suggest that you (should) go there as soon as possible.”</p></li><li><p><strong>虚拟语气在名词性从句中的使用</strong>：</p><p>在某些动词后面的宾语从句、表语从句以及同位语从句中，<strong>如果从句所表示的意思是一种建议、请求、命令、劝告</strong>等情绪，也<strong>需要使用虚拟语气。通常采用&quot;(should) + 动词原形&quot;的形式</strong>，例如：“He proposed that we (should) hold a meeting immediately.”</p></li></ol><p>虚拟语气是英语中一种非常重要的语气形式，其使用的情况也相当复杂多变，需要通过大量实践和使用才能逐渐熟悉。</p><p><strong>虚拟语气就是谓语动词时态的变化</strong>, 往前挪一个时态, 因为一般要假设与真实不同的状态, 我们一般是在过去改变,所以往前推一个时态</p><table><thead><tr><th style="text-align:center">时间范围</th><th style="text-align:center">if 从句</th><th style="text-align:center">主句</th></tr></thead><tbody><tr><td style="text-align:center">假设过去</td><td style="text-align:center">had done</td><td style="text-align:center">would</td></tr><tr><td style="text-align:center">假设现在</td><td style="text-align:center">did (were)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> could </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> should </mtext></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\text { could } \\\text { should }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> could </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> should </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">假设将来</td><td style="text-align:center">did (were)</td><td style="text-align:center">might</td></tr></tbody></table><p>口诀:<br>1 从句往前推<br>2 主句4+1   四个情态动词选一个  +  动词原形<br>3 将来同现在</p><h1>长难句分析</h1><h2 id="基本结构长难句分析">基本结构长难句分析</h2><h3 id="断开长难句">断开长难句</h3><h4 id="标点">标点</h4><ul><li>逗号</li><li>冒号</li><li>分号</li></ul><p>逗号后面的一句话一般带有连接词, 用来断开一句话</p><p>冒号 是用来进一步引入一句话说明, 单独用,不需要加连接词</p><p>分号  可以加连接词,也可以不加</p><p><strong>标点前后必须是句子才能断开</strong></p><h4 id="连接词">连接词</h4><ul><li>并列连词 but so and or</li><li>从属连词 if</li><li>关系词 who</li></ul><p>从句开始于连接词, 结束于 三种位置:</p><ul><li>标点</li><li>下一个连接词前</li><li>第二个谓语动词</li></ul><p>但是这个也不绝对, 因为 <strong>从句亦可以有从句</strong></p><h4 id="分析主谓">分析主谓</h4><p>当 连接词被省略的时候, 我们就需要使用分析主谓了</p><ul><li>主谓主谓  从句在后面</li><li>主主谓谓  从句在中间</li></ul><h3 id="简化长难句">简化长难句</h3><ol><li>定位谓语动词</li><li>去扩展找核心</li></ol><h2 id="特殊结构的长难句分析">特殊结构的长难句分析</h2><h3 id="分裂结构">分裂结构</h3><ol><li>插入式分裂结构:  <strong>句子中间加入了同位语, 插入语</strong></li><li>从句后移式:  从句太长了, 被后移</li></ol><h3 id="嵌套结构">嵌套结构</h3><p>从句中也有从句</p><h3 id="平行结构">平行结构</h3><p>多个词,词组或句子并列在一起</p><p>特点</p><ul><li>多个成分词性相同, 形式一致</li><li>中间有并列连词连接</li></ul><p>形式:</p><ul><li>名词或者词组并列</li><li>动词(谓语,非谓语)并列</li><li>介词短语并列</li><li>句子并列</li></ul><h1>补充</h1><h2 id="第三人称单数">第三人称单数</h2><p>在一般现在时中,  谓语动词要变成第三人称单数, 是为了对应第三人称单数的主语, 第三人称除了 he she it 外还有  不可数名词和可数名词单数</p><h2 id="完成时态和一般时态的区别">完成时态和一般时态的区别</h2><p>完成时态和一般时态是英语中的两种基本时态，它们在用法和含义上有一些重要的区别：</p><ol><li><p><strong>一般时态</strong>：一般时态主要用于描述事实、习惯、一般真理或者在某个特定的时间点（过去、现在或将来）发生的动作或状态。</p></li><li><p><strong>完成时态</strong>：<strong>完成时态主要用于描述某个时间点前已经完成的动作或影响</strong>。这些动作可能对现在或将来的情况有影响。</p></li></ol><p>所以说 完成时态的时间在一般时态的前面, 这就有了先后关系</p><p><strong>一般时态一般是某个时间点,  而完成时态 是一个时间段</strong></p><ul><li>I was  a teacher  我过去是一个老师   强调我当过老师</li><li>I had been a teacher  我过去是一个老师   强调持续了一个时间段</li></ul><p><strong>完成时态一般是跨时间段的</strong></p><h2 id="形容词和副词的比较级别">形容词和副词的比较级别</h2><p><strong>比较级别构成的短语通常作为副词短语或形容词短语使用</strong>，其功能和单独的副词或形容词非常相似</p><h3 id="原级比较">原级比较</h3><p><strong>as + adj./adv.原形 (比较的内容) + as + 比较的对象</strong>     “和……相比一样的……</p><p>否定形式  not as … as  “和…相比不如…”</p><h3 id="比较级">比较级</h3><p><strong>adj./adv.的比较级 + (than 比较的对象)</strong></p><p>单词的比较级有些是改成 er  还有就是前面加 more 和 less,  这里的比较对象是可以不加的,  可以是上下文中的对象</p><h3 id="最高级">最高级</h3><p><strong>adj./adv.的最高级 + (介词短语表示比较的范围)</strong></p><p>单词的最高级有些是改成 est  还有就是前面加 the most</p><h2 id="非谓语的位置">非谓语的位置</h2><p>非谓语动词（如分词和不定式）可以在句子中作定语，修饰名词。它们可以放在名词的前面或后面，但具体放置的位置通常取决于非谓语动词的类型和它们的含义。</p><ol><li><p><strong>现在分词（-ing 形式）</strong>：这类非谓语动词描述的是正在进行的行为，或者名词的特性。当它们作为前置定语时，往往强调的是名词的特性。例如：“A running man”（一个正在跑步的人）。当现在分词作为后置定语时，一般用来描述名词的某种状态。例如：“The man running is my brother”（正在跑步的那个人是我哥哥）。</p></li><li><p><strong>过去分词（-ed 形式）</strong>：这类非谓语动词描述的是被动或完成的行为。无论它们是作为前置定语还是后置定语，意义基本相同。例如：“The shattered window”（被打碎的窗户）和 “The window shattered by the ball”（被球打碎的窗户）。</p></li><li><p><strong>不定式</strong>：不定式通常作为后置定语，用来表示目的、原因或未来可能发生的行为。例如：“I have a lot of work to do”（我有很多工作要做）。</p></li></ol><p>总的来说，现在分词和过去分词都可以作为前置或后置定语，但不定式通常作为后置定语。在实际使用中，应考虑句子的整体结构和非谓语动词的具体含义。</p><h2 id="主句和从句时态问题">主句和从句时态问题</h2><p>英语中的主从句时态关系可以根据句子的具体内容和含义有所变化，但有一些常见的规则可以遵循：</p><ol><li><p>主句和从句的时态通常要一致。这被称为时态一致性。例如，如果主句使用了过去时，从句通常也会使用相应的过去时。比如：“He said (主句过去时) that he was tired (从句过去时)。”</p></li><li><p>当主句是一般现在时，从句可以使用任何需要的时态，例如：“I think (主句一般现在时) that he is at home (从句一般现在时) / he was at home yesterday (从句过去时) / he will be home tomorrow (从句将来时)。”</p></li><li><p>对于某些宾语从句和状语从句来说，如果主句的谓语动词是过去时，从句的谓语动词通常也需要用过去的某种形式，这个规则通常被称为&quot;时态的回溯&quot;或者&quot;序列的时态&quot;。例如， “She said (主句过去时) that she had finished (从句过去完成时) her work.”</p></li><li><p>在条件从句中，一般来说，如果主句使用将来时，从句则通常使用一般现在时来表示将来的动作或状态。例如：“If it rains (从句一般现在时)，we will stay at home (主句将来时)。”</p></li><li><p>但是，有些从句（如时间、条件、让步从句等）中，即使主句使用了过去时态，从句还是可以使用一般现在时，这主要用于表达一种客观真理、事实或习惯。例如：“He knew (主句过去时) that the earth revolves (从句一般现在时) around the sun.”</p></li><li><p>此外，有些从句的时态不受主句时态的影响，比如宾语从句中的某些动词，如 believe, think, suppose 等。例如：“I thought (主句过去时) that he is (从句一般现在时) a nice person.”</p></li></ol><p>这些只是一般的规则，实际应用中可能根据具体情况有所调整。</p><h2 id="同位语和定语从句的区别">同位语和定语从句的区别</h2><p>大体的区别就是同位语和定语的区别,   同位语从句用于解释前面的对象, 而且前面的对象在同位语从句中不做成分,  定语从句用于限定前面的对象,  但是定语从句中, 前面的对象是做成分的</p><h2 id="that的省略">that的省略</h2><p>在名词性从句的宾语从句中,  一般that只做连接词,可以省略,但是建议不要省略,  <em style="color:red"> <strong>在定语从句中,  只有当that充当的成分是宾语的时候才能省略</strong></em></p><h2 id="缩写">缩写</h2><p>英语中的 <code>'s</code> 缩写有三种常见的用途：</p><ol><li><p><strong>所有格</strong>： <code>'s</code> 可以用来表示所有格，用于显示某物或某人属于某人或某事。比如 “John’s car”（约翰的车），“the cat’s tail”（猫的尾巴）。</p></li><li><p><strong>缩写形式</strong>： <code>'s</code> 还可以表示 “is” 或 “has” 的缩写形式。例如，“it’s” 可以表示 “it is” 或者 “it has”，取决于上下文环境。另一种情况是，<code>'s</code> 可以用于表示形容词性物主代词和 be 动词的缩写形式，例如 “She’s” 可以表示 “She is”。</p></li><li><p><strong>缩略形式</strong>：在口语中，<code>'s</code> 还常常用于动词的缩略形式，例如 “let’s”（= let us）表示建议，“what’s”（= what is）表示疑问等。</p></li></ol><p>注意： <code>s</code> 或者 <code>es</code> 的添加还可以表示复数形式或者第三人称单数形式，但这种情况下并无撇号(<code>'</code>)。</p><p>尽管 <code>'s</code> 有多种用途，但其准确的意思通常可以从上下文中推断出来。一般来说，所有格 <code>'s</code> 通常出现在名词后，表明所有权；动词缩写的 <code>'s</code> 通常出现在代词或名词后，表示 “is” 或 “has”；而在表示建议或疑问的缩略形式中，<code>'s</code> 则通常出现在动词后。</p><h2 id="从句语序">从句语序</h2><p><strong>由于在从句中,  句子的语序必须是陈述语句,   如果从句就是一个疑问句(这里的疑问句是指,这个从句表达的意思是一个疑问句), 那是不行的, 因此我们需要将原先的疑问语序换成称述语句, 一般就是把倒装变回来</strong></p><p>但是也有特殊的情况,  就是 原先的句子不是倒装句, 那就不需要变化,可以直接使用,  比如 who come here,  what happen  这些,  连接词本身就是主语,  句子本身也没有倒装,  因此可以直接当成从句使用</p><p>但是 从句的语序亦有区别  就比如这句话,   who is the most important person  在宾语从句中, 它肯定是疑问语序, 定语从句中 它肯定是称述语序,  所以在写句子的时候, 一定要分析清楚它是疑问语序还是称述语序</p><h2 id="从句总结">从句总结</h2><ul><li>从句必须有 主谓,   主语可能是连接词, 也可能不是连接词,  但是如果是连接词, 他必须是能够做名词的连接词,而且还必须做主语, 比如 who what which ,但是 how where 这种就不行, 他们是具有副词性质的连接词.   如果一个连接词不是做主语, 这个句子又本身又没有很明确的主语, 我们可以使用连接词+不定式构成 名词短语(也就是缩写的从句)  比如  i don’t know where to go 就是 i don’t know where we should go 的缩写 where to go is not decided 是 where we should go is not decided</li><li>从句中必须是称述语序</li><li>除了上面的一些规则,  从句本身也是句子, 他也要遵守普通句子的规则</li></ul><h2 id="else">else</h2><p>“Else&quot;这个词在英语中是个非常有用的修饰词，它用于表达“其他的”或“另外的”。通常，我们将&quot;else&quot;与疑问词（如&quot;who”, “what”, “where&quot;等）或者不定代词（如&quot;something”, &quot;anything&quot;等）一起使用，以增加句子的含义。</p><p>在句子结构中，&quot;else&quot;通常作为一个副词，用来修改前面的词，增加“其他”或“另外”的含义。</p><p>以下是一些例子：</p><ol><li><p>“What else do you want?” （你还想要什么？）</p><p>在这个例子中，“else&quot;增加了句子的含义，不仅询问对方想要什么，而且还强调了&quot;除了已知的东西之外，你还想要什么”。</p></li><li><p>“Is there anything else I can do for you?” （还有我可以为您做的其他事情吗？）</p><p>这个例子中的&quot;else&quot;也是用来询问&quot;除了已经做的事情之外，还有什么我可以做的吗？&quot;</p></li><li><p>“If you don’t like this one, we can try somewhere else.” （如果你不喜欢这个地方，我们可以去其他地方试试。）</p><p>这里的&quot;else&quot;用于指出除了当前的地方之外的其他地方。</p></li></ol><p>这就是&quot;else&quot;在句子中的用法和作用。希望这个解释对你有所帮助。如果你还有其他问题，或者对&quot;else&quot;的用法有任何疑问，随时告诉我。</p><p>额</p><h1>错误总结</h1><h2 id="介词短语充当非谓语">介词短语充当非谓语</h2><p>我们来看这样一句话:  我喜欢去湖南  ,  错误翻译:   I like to HuNan</p><p>为什么会造成这样的错误呢?  主要是介词短语的to有 朝着…去 的意思,  我们就会想当然的以为 直接用to代替去这个动作,  其实不然, 这里的to的意思 <strong>不是一个动作,  只是一个方向</strong>,  所以我们需要真正的动作,  由于已经有了动词like, 所以我们只能用非谓语, 所以正确翻译是: I like to go to HuNan,   这里的to HuNan 修饰go 这个动作</p><h1>语法书阅读</h1><h2 id="复合关系代词">复合关系代词</h2><p>whichever = any one which   (任意一个)</p><p>whoever = anybody who (凡是…的人)  = no matter who  (做副词性连词的时候, 是 无论谁)</p><p>what = the thing which (所…的东西)  因此我们可以知道 what 前面是不能有名词的</p><p>whatever = anything that (所…的任何东西)  = no matther what (做副词性连词的时候  是 无论什么)  所以前面也不能有名词</p><p>However = no matter how (无论如何)  要记住 However 是可以做副词, 也可以做连词的, 只有做连词的时候才能 这么翻译</p><h1>个人小结</h1><h2 id="介词">介词</h2><p>难点</p><ul><li>介词种类繁多</li><li>表达意思难以判断</li><li>修饰对象如何查找</li><li>充当句子成分</li></ul><p>对于修饰对象而言, 一般是前面的名词, 或者 补充说明前面的动作  又或者充当句子成分</p><p>对于表达的意思, 我们通常可以先不看这个介词, 先看介词后面的东西是什么 然后 读一遍前面和后面的意思, 看中间翻译什么好理解(下下策)</p><h2 id="非谓语">非谓语</h2><h3 id="不定式">不定式</h3><p>形式:  to +  动词原形</p><p>可以充当的词性</p><ul><li>名词,  做主语, 宾语,表语</li><li>形容词  做定语</li><li>副词  做状语,  可以表示原因, 目的,手段, 方法,程度,结果</li></ul><p>我们可以通过判断不定式在句子中的位置来判断它其什么词性</p><p>名词 + 不定式 (形容词后置)   I  want water to drink</p><p>及物动词  +  不定式短语 (名词)   I want to drink water</p><p>完整句子  +  不定式短语(副词)  I  stop  the work to drink water</p><blockquote><p>我们发现,  如果是做形容词,  貌似不定式后面的动词是没有宾语的,  如果是做名词, 一般是在句子中做宾语, 且不定式的完整的, 及物动词后面会有宾语,   如果不是做副词,  我们一般不需要翻译多余的东西,  但是如果是做副词,  这里的翻译得根据不定式的作用来翻译  比如  为了, 去,因为</p></blockquote><p>否定形式就是  not + to 动词原形</p><h3 id="动名词">动名词</h3><p>动词ing 充当名词的,  这个最简单,没什么好说的</p><p>my dream is being a doctor</p><h3 id="分词">分词</h3><p>分词有两种:</p><ul><li>现在分词</li><li>过去分词</li></ul><p>他们单独使用都是做形容词,  只不过现在分词表示主动,进行,  过去分词表示被动,完成    但是如果是在谓语动词中, 他们通常是表示时态, 现在分词表示进行时态, 过去分词表示完成时态</p><p>做形容词的时候,  如果只有一个单词, 就放在被修饰的词前面,  如果有多个单词 就放在后面</p><p>难点</p><ol><li>起什么作用</li><li>做句子什么成分</li><li>修饰什么对象</li></ol><p>起什么作用  就需要结合 上下文意思来确定+</p><p>对于修饰什么对象,  我们可以看他前后是否有名词, 如果有名词就带入看语义是否通,  如果不通就带入句子主语看通不通</p><p>通过看他修饰什么对象,  大致能够看出是做什么成分</p><h3 id="区分动名词和分词">区分动名词和分词</h3><p>当 动名词 和 分词 都是修饰后面的名词的时候  这个时候就要区分开来,  不然很容易让我们误解意思</p><p>分词 是做形容词    动名词是做名词</p><p>a sleeping baby      a  sleeping bag     发现区别了吗?   前一个是&quot;睡觉的&quot;   而后一个就是 “睡觉”  这个活动的名词</p><p>书上写了一个可以区分大多数分词和动名词的方法    就是看后面的名词   如果是有生命的就是分词,  如果是无生命的就是动名词,  但是这个不绝对,  还是要通过翻译去对比  分词翻译成  …的   而动名词就翻译成  这个动词</p><h1>积累</h1><h2 id="名词短语-名词性从句">名词短语(名词性从句)</h2><p>名词短语具有名词的性质, 是由名词性从句简化而来的</p><ul><li>疑问副词形成的名词短语中, 疑问副词具有副词的性质, 不做不定式短语的宾语, 但是在疑问代词形成的名词短语中,  疑问代词具有名词的性质, 一定要做不定式的中动词或者介词的宾语  比如  what whom which      what to buy    whom to see        where to live(副词性)  how to do(副词性)</li></ul><h2 id="短语动词">短语动词</h2><p>短语动词是一个由动词与一个或多个后缀（如前置词或副词）组成的结构，它作为一个单独的意思单位工作。短语动词的结构和意义经常不能从其各个部分的字面意义预测出来。</p><p>短语动词有三种主要类型：</p><ol><li><p><strong>不及物短语动词</strong>：这种结构由一个动词和一个副词组成。例如：</p><ul><li>give up (放弃)</li><li>look after (照顾)</li><li>run out (用完)</li></ul></li><li><p><strong>及物短语动词</strong>：这种结构由一个动词、一个宾语和一个副词或前置词组成。例如：</p><ul><li>look after someone (照顾某人)</li><li>turn down the offer (拒绝提议)</li><li>pick up the book (捡起书)</li></ul></li><li><p><strong>不定式短语动词</strong>：这种结构由一个动词和一个不定式组成。例如：</p><ul><li>want to go</li><li>hope to see</li></ul></li></ol><p>在使用短语动词时，通常需要注意以下几点：</p><ul><li><p>位置：当短语动词是及物的时，通常不能将宾语置于动词和后缀之间，尤其是当宾语是代词时。</p><p>错误：pick it up the book<br>正确：pick up the book or pick it up</p></li><li><p>意义：短语动词的意义通常与其组成部分的单独意义不同。例如，“take off”可以表示飞机起飞，而不仅仅是“拿掉”或“脱下”。</p></li><li><p>语法：<strong>短语动词与它们的宾语之间的关系可能会影响句子的语法结构</strong>。例如，“look forward to”后面需要<strong>接名词或动名词</strong>，<strong>而不是不定式。</strong></p><p>错误：I look forward to meet you.<br>正确：I look forward to meeting you.</p></li></ul><p>这种动词词组后面的词 是副词, 而不是介词, 需要注意, 比如:</p><ol><li><p><strong>Look up to</strong></p><p>Many young athletes <strong>look up to</strong> him as a role model.<br>这里，“look up” 是短语动词，而 “to” 是连接后面宾语的介词。</p></li><li><p><strong>Stand up for</strong></p><p>You should <strong>stand up for</strong> what you believe in.<br>这里，“stand up” 是短语动词，而 “for” 是连接后面宾语的介词。</p></li><li><p><strong>Turn up at</strong></p><p>He always manages to <strong>turn up at</strong> the worst possible time.<br>这里，“turn up” 是短语动词，而 “at” 是连接地点的介词。</p></li></ol><h2 id="只能只用that的定语从句">只能只用that的定语从句</h2><ol><li><strong>序数词之后</strong><ul><li>She was the first student <strong>that</strong> passed the difficult exam.</li></ul></li><li><strong>最高级之后</strong><ul><li>He is the best player <strong>that</strong> has ever been in the team.</li></ul></li><li><strong>the very + 名词 之后</strong> (这里的very起强调作用, 不翻译)<ul><li>This is the very book <strong>that</strong> I’ve been looking for.</li></ul></li><li><strong>all 之后, that通常省略</strong><ul><li>All (that) I want is some peace and quiet.</li></ul></li><li><strong>the only + 名词</strong><ul><li>He is the only person <strong>that</strong> knows the truth.</li></ul></li><li><strong>关系词在从句中做表语表明身份</strong><ul><li>The man <strong>that</strong> he is now is much different from who he was a decade ago.</li></ul></li><li><strong>疑问词做先行词, 后面的关系词为了不和疑问词冲突</strong><ul><li>What <strong>that</strong> you said really surprised me.</li></ul></li></ol><h2 id="限定性定语从句的简化">限定性定语从句的简化</h2><p>如果关系代词为主语, 则可以简化</p><ol><li>删除关系词</li><li>动词变现在分词</li><li>如果动词为be 动词 将be 动词变成being然后省略</li></ol><p>举例</p><ol><li><strong>动词变现在分词</strong>：<ul><li>原句：The artist <strong>who paints</strong> these pictures is famous.</li><li>简化：The artist painting these pictures is famous.</li></ul></li><li><strong>如果动词为be动词，将be动词变为being然后省略</strong>：<ul><li>原句：The children <strong>who are</strong> waiting in the hall are tired.</li><li>简化：The children waiting in the hall are tired.</li><li>原句：The books <strong>that are sold</strong> in that store are expensive.  被动语态</li><li>简化：The books sold in that store are expensive.</li></ul></li></ol><p>有没有发现, 非谓语貌似就是这么省略来的?</p><h2 id="定语从句简化为不定式短语">定语从句简化为不定式短语</h2><ol><li><p><strong>当关系词前有介词时，可以简化为不定式短语</strong>:</p><ul><li>定语从句: The window <strong>through which you entered</strong> is broken.</li><li>不定式短语: The window <strong>to enter through</strong> is broken.</li></ul><p>注意: 与介词结合的不定式结构（如&quot;to enter through&quot;）可能在口语或非正式语境中听起来更自然，但在正式写作中，可能更偏向使用完整的定语从句。</p></li><li><p><strong>当关系词作为定语从句的宾语时，可以简化为不定式短语</strong>:</p><ul><li>定语从句: The book <strong>which you want to read</strong> is on the shelf.</li><li>不定式短语: The book <strong>to read</strong> is on the shelf.</li></ul><p>这里，“which you want to read&quot;的简化形式是&quot;to read”。但要注意，简化为不定式短语后，某些详细信息可能会丢失，例如这里就失去了&quot;you want&quot;的部分内容。所以使用时要确保上下文清晰，且不引起误解。</p></li></ol><h2 id="关系副词">关系副词</h2><p>关系副词有四种,  由 介词+which得来</p><ul><li>where = in which, at which, on which</li><li>when = in which, at which, on which</li><li>why = for which</li><li>how = in which</li></ul><p>要点</p><ul><li>在限定性定语从句中,  where不能省略  when 和 why通常可以省略  how 一定要省略</li><li>如果先行词在be动词之后做表语,  我们通常省略先行词(这样看起来就和名词性从句很像了)   that is the place  where he was born  = that is where he was born    that is the day when she will come  = that is when she will come    that is the reason why he left = that is why he left   that is the way he did it  = that is how he did it</li></ul><h2 id="准关系代词">准关系代词</h2><h3 id="种类">种类</h3><p>只有三个  than as but</p><h3 id="形成条件">形成条件</h3><p>than as but 之前如果有先行词, 那么就构成了准关系代词</p><h3 id="用法">用法</h3><p>than + the 先行词  + 关系代词</p><p>as + the 先行词  + 关系代词</p><p>there is no  + 名词 + but  = there is no + 名词 + 关系代词  + not</p><p>比如:</p><ul><li>i have more money than is needed  = i have more money than  the money which is needed</li><li>More guests than were invited came =  More guests than the guests who were invited  came</li><li>such a man as he (is) is bad  = such a man as the man who he is  is bad   (such + n之后绝不可以用like加以修饰)</li><li>there is noting but i can do  =  there is noting  which i can’t do</li></ul><h2 id="非谓语动词">非谓语动词</h2><h3 id="不定式">不定式</h3><h3 id="现在分词">现在分词</h3><p>现在分词做形容词的时候需要注意的点</p><ul><li>现在分词表主动   过去分词表被动</li><li>令人…的  是现在分词   感到…的 / 受到…的  是 过去分词</li><li>正在…的  是现在分词   即将…的/已经…的  是过去分词</li></ul><h2 id="倒置的主句和宾语从句">倒置的主句和宾语从句</h2><p>这种句式,也要注意</p><p>he book was interesting,  they found    =&gt; 其实是  they found  that  he book was interesting.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/06/27/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/06/27/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>操作系统概述</h1><h1>进程管理</h1><h1>内存管理</h1><h1>文件管理</h1><h1>输入输出(I/O)管理</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/06/27/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/06/27/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>趁着考研的机会,好好学一下,  所用语言是c/c++</p><p>我们在做题的时候不要钻牛角尖,  要根据书上的来,  比如对于单链表, 书上一般是默认只带有头指针,  比如说获取链表尾巴元素的时间复杂度就是O(n),不要钻牛角尖的以为可以自己设置一个尾指针, 然后时间复杂度就是O(1)  ,对你当然可以自己设计, 可是现在是在书上,理论</p><h1>基本概念</h1><p><strong>程序 = 数据结构 + 算法</strong></p><ul><li>数据:  <strong>数据是信息的载体</strong>, 是描述客观事物属性的数,字符及能被输入到计算机中处理的符号.  <strong>数据是计算机加工的原料</strong></li><li>数据元素: <strong>数据元素是数据的基本单位, 通常作为一个整体进行考虑和处理, 一个数据元素是由多个数据项组成的</strong>, 比如 一个学生就是一个数据元素  它由学号,姓名, 性别等数据项组成</li><li>数据项: <strong>数据项是构成数据元素的不可分割的最小单位</strong></li><li>数据对象: <strong>具有相同性质的数据元素的集合</strong></li><li>数据结构: <strong>数据元素相互之间存在一种或多种关系的集合</strong></li><li>数据类型: 原子类型(值不可再分), 结构类型(值可以再分,类似结构体), 抽象数据类型(定义数据的逻辑结构与其相关操作), <strong>抽象数据类型相当于定义了整个数据结构</strong></li></ul><p>数据对象和数据结构的区别:   数据对象是<strong>所有相同性质</strong>的数据元素的集合   而且 数据结构是 <strong>具有相同性质 且 相互之间有关系</strong>的数据元素集合,   比如说  所有学生都在同一个数据对象里面,  但是排名前一百的学生在一个数据结构里面也就是线性表里面,</p><h2 id="数据结构的三要性">数据结构的三要性</h2><p>在计算机科学中，数据结构的三要素通常指：数据的逻辑结构、数据的存储结构（也称物理结构）以及数据的操作。</p><ol><li><p><strong>数据的逻辑结构</strong>：逻辑结构是指数据对象中数据元素之间的相互关系。<strong>这个关系是对具体问题的抽象，与数据的存储无关</strong>。根据元素之间的关系，逻辑结构可以分为线性结构、树结构、图结构以及集合。</p><ul><li><strong>线性结构</strong>：<strong>数据元素之间存在一对一的关系</strong>。例如：数组、链表、栈、队列等。</li><li><strong>树结构</strong>：数据元素之间存在一对多的关系。例如：二叉树、B树、红黑树等。</li><li><strong>图结构</strong>：数据元素之间存在多对多的关系。例如：图、网络等。</li><li><strong>集合</strong>：<strong>数据元素之间没有明显的关系</strong>。</li></ul></li><li><p><strong>数据的存储结构</strong>：存储结构是指数据对象在计算机内存中的组织方式，<strong>也称为物理结构</strong>。主要有顺序存储和链式存储。</p><ul><li><strong>顺序存储结构</strong>：数据元素存储在连续的存储单元里，物理上的相邻也代表逻辑上的相邻。这种方式典型的如数组。</li><li><strong>链式存储结构</strong>：数据元素可以存储在内存的任意位置，通过链接（如指针）来建立数据元素之间的逻辑关系。这种方式典型的如链表。</li><li><strong>索引存储结构</strong>：索引存储结构是在存储元素信息的同时，还创建一种索引表，索引表中包含对主文件中数据元素的引用。通过索引，可以实现对数据的快速访问。(<strong>索引表是一般是线性结构</strong>, 一般有个键和值  键可以代表唯一的数据元素 值是数据元素的地址)</li><li><strong>散列存储结构</strong>：散列存储，也叫哈希存储，它是根据元素的关键字直接进行访问的。通常会有一个哈希函数将关键字映射到一个地址上。</li></ul></li><li><p><strong>数据的运算</strong>：<strong>这是定义在特定数据结构上的一系列处理数据的方法或者函数</strong>，这些操作可以是查找、插入、删除、排序等。这些操作要满足可行性（即算法的正确性）和有效性（即算法的高效性）。  <strong>运算的定义是针对逻辑结构, 运算的实现是针对存储结构</strong></p></li></ol><p>这三者相互关联，逻辑结构决定了数据的运算，而存储结构则是逻辑结构和数据运算在计算机中的实现基础。理解并掌握这三个要素，是理解和应用数据结构的关键。</p><p><strong>一般,  只要逻辑结构 和 运算有一个不相同,  我们就认为两者是不同的数据结构</strong></p><h2 id="算法">算法</h2><p>算法是<strong>解决特定问题的一系列明确的执行步骤</strong>。它是从输入开始，按照一定规则和步骤，经过有限次运算后，得到预期结果的过程。</p><p>算法具有以下五个基本特性：</p><ol><li><p><strong>有穷性</strong>：算法必须能在执行有限步骤之后结束，不能无限制地执行下去。</p></li><li><p><strong>确定性</strong>：算法的每一步必须清晰明确，没有歧义, <strong>对于相同的输入只能得到相同的输出</strong>。</p></li><li><p><strong>可行性</strong>：算法中描述的操作都是可以通过已经实现的<strong>基本操作执行有限次</strong>来实现。</p></li><li><p><strong>输入</strong>：一个算法有零个或多个输入。</p></li><li><p><strong>输出</strong>：一个算法至少有一个或多个输出，即算法的执行结果。</p></li></ol><p>在计算机科学中，算法是非常重要的概念。一个好的算法不仅能正确解决问题，还应该尽可能地优化时间复杂度和空间复杂度，使得在处理大规模数据时仍能保持良好的性能。算法的设计和分析是计算机科学的核心内容之一，也是计算机程序设计的关键。</p><p>一个好的算法通常需要满足以下五个特性：</p><ol><li><p><strong>正确性</strong>：算法应能正确地解决所指定的问题，对于合法的输入数据，应能得到满足要求的输出结果。此外，对于非法的、异常的输入数据，算法应做出相应的处理。</p></li><li><p><strong>可读性</strong>：算法应清晰、简洁，易于人理解，这样便于其他人员阅读、修改和维护。</p></li><li><p><strong>健壮性</strong>：算法需要对各种异常输入或者错误情况进行有效处理，使其在面对这些情况时不会崩溃或产生未预期的结果。</p></li><li><p><strong>效率和存储量需求</strong>：优秀的算法应具有尽可能低的时间复杂度和空间复杂度。在处理大量数据时，算法的效率尤为重要。同时，算法应尽量节省存储空间，减小对计算资源的消耗。</p></li><li><p><strong>可扩展性和可复用性</strong>：一个好的算法应具有良好的扩展性，能处理比现有需求更大或更复杂的问题。同时，如果算法具有一定的通用性，那么在其他场景或问题中也可能复用，从而提高编程效率。</p></li></ol><p>以上这些特性并不是孤立的，而是相互关联的。例如，为了提高效率，我们可能需要牺牲一些可读性；为了增加健壮性，我们可能需要增加一些错误处理的代码，这可能会影响效率。因此，在设计算法时，我们需要根据具体情况进行权衡和选择。</p><h2 id="时间复杂度">时间复杂度</h2><p>算法的时间复杂度是一种<strong>衡量算法运行时间长短的量化指标</strong>。它反映了随着输入数据规模的增大，算法执行时间的增长趋势。通常，<strong>我们关注的是最坏时间复杂度</strong>，因为它代表了算法在最糟糕情况下的执行时间。</p><p>时间复杂度的计算通常关注的是算法中基本操作的执行次数，而忽略了具体的硬件条件和运行环境等因素。我们通常用大O符号（O）来表示时间复杂度，<strong>大O符号表示的是问题规模n与算法执行时间增长率的上界关系</strong>, <strong>只保留了最高阶的部分,系数也不考虑</strong>。</p><p>下面是一些常见的算法时间复杂度，从低到高排列：</p><ol><li>常数阶O(1)</li><li>对数阶O(logn)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogn)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>K次方阶O(n^k) (k&gt;3)</li><li>指数阶O(2^n)</li><li>阶乘阶O(n!)</li><li>双阶乘阶O(n!!)</li><li>指数阶O(n^n)</li></ol><p>理解时间复杂度对于编程和算法分析都非常重要，它可以帮助我们预测算法的运行效率，并在多种算法之间做出合理的选择。</p><p><strong>这里需要注意的是  无论时间复杂度是多少,  问题规模是 n 而不是 O(n)</strong>, 问题规模是指n的数量</p><h2 id="空间复杂度">空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中<strong>临时占用存储空间大小的量度</strong>，它也是算法效率评价的重要指标之一。空间复杂度过高的算法可能会导致使用的内存超出硬件限制，导致程序无法正确运行。</p><p>空间复杂度的计算同样也是基于大O符号表示的，表示随着数据规模的增长，算法的存储空间需求如何变化。</p><h1>线性表(有序表)</h1><p>线性表是一种基本的数据结构，<strong>它是由n个具有相同特性的数据元素组成的<span style="color:red">有限序列</span></strong>。</p><p>线性表的特点是数据元素之间存在一对一的线性关系，也就是除首尾元素外，其他元素都有<em style="color:red">唯一的前驱和后继</em>。</p><p>线性表是一种基本的数据结构，具有以下几个主要特点：</p><ol><li><p><strong>有限性</strong>：线性表是由有限个数据元素组成的。</p></li><li><p><strong>有序性</strong>：线性表中的元素之间有明确的前后顺序关系。每个元素（除第一个元素外）都有唯一的直接前驱，每个元素（除最后一个元素外）都有唯一的直接后继。</p></li><li><p><strong>同质性</strong>：线性表中的所有元素都具有相同的数据类型或结构。</p></li><li><p><strong>相互独立</strong>：线性表中的元素之间是相互独立的，元素的变化只与其本身有关，不受其他元素的影响。</p></li><li><p><strong>可变性</strong>：线性表可以进行插入、删除、查找等操作，元素的个数和内容可以改变。</p></li></ol><p>线性表有两种常见的实现方式：数组和链表。</p><ol><li><p><strong>数组</strong>：数组是一种连续的存储结构，它的特点是支持随机访问，也就是说，可以在常数时间内访问任何位置的元素。但是数组的大小在创建时就已经固定，所以不能动态改变。此外，数组中的元素在内存中是连续存储的，所以在插入和删除元素时需要移动大量的元素，效率较低。</p></li><li><p><strong>链表</strong>：链表是一种非连续的存储结构，它的特点是插入和删除操作的效率很高，只需要改变一些指针的指向就可以了。但是链表不支持随机访问，访问某个元素需要从头开始遍历链表，所以访问效率较低。链表可以动态改变大小，更加灵活。</p></li></ol><p>线性表是数据结构中的基础，许多复杂的数据结构，如栈和队列，都是基于线性表实现的。理解线性表的性质和操作对于深入理解和应用数据结构非常重要。</p><h2 id="顺序表">顺序表</h2><p>顺序表是一种常见的线性表实现方式，它将元素存储在一段连续的存储单元里，每个元素所占用的存储单元相同，元素的逻辑顺序与其在存储单元中的物理顺序一致。也就是说，如果我们知道了某一个元素的存储地址，那么我们就可以直接计算出其它元素的地址，这就是顺序表支持随机访问的原因。</p><p><strong>顺序表的基本操作包括：</strong></p><ol><li><p><strong>插入</strong>：在顺序表的特定位置插入元素。若插入位置后有元素，则需要将这些元素后移，为新元素腾出空间。</p></li><li><p><strong>删除</strong>：删除顺序表中的某个元素。若删除位置后有元素，则需要将这些元素前移，填补空白。</p></li><li><p><strong>查找</strong>：按照元素值或者位置进行查找。</p></li><li><p><strong>修改</strong>：修改顺序表中某个位置的元素。</p></li></ol><p><strong>顺序表的优点：</strong></p><ol><li><p>访问速度快，支持随机访问，时间复杂度为O(1)。</p></li><li><p>结构简单，容易实现。</p></li></ol><p><strong>顺序表的缺点：</strong></p><ol><li><p>插入和删除操作需要移动大量元素，时间复杂度为O(n)。</p></li><li><p>需要一块连续的存储空间，可能会造成空间的浪费。如果存储空间不够，需要重新分配空间，操作复杂。</p></li></ol><p>在实际使用中，顺序表适用于元素数量固定，且主要进行查找操作的场景。如果需要频繁地进行插入和删除操作，可能链表是更好的选择。</p><h2 id="链表">链表</h2><h3 id="头结点">头结点</h3><p>根据是否包含头节点，链表可以分为带头节点的链表和不带头节点的链表。</p><p>带头节点的链表是指链表中的第一个节点（头节点）不存储实际的数据，只是起到一个标记的作用，方便链表的操作。</p><p>与之相反，不带头节点的链表中的第一个节点直接存储数据，并指向下一个节点。</p><p>带头节点的链表有以下优点：</p><ol><li><strong>统一了插入和删除操作</strong>：在带头节点的链表中，插入和删除操作可以统一进行，不需要特殊处理空链表或者头部和尾部的情况。</li><li><strong>方便处理空链表</strong>：头节点可以作为一个特殊的标记，用来表示链表为空，这样在处理空链表时不需要额外的判断。</li><li><strong>便于链表的遍历和返回</strong>：有了头节点，可以更容易地进行链表的遍历和返回链表的起始位置。</li></ol><p>总的来说，带头节点的链表在操作上更加方便和统一，使得代码的编写和理解更加简单。但是，头节点也会占用一定的额外空间。是否使用头节点，取决于具体的应用场景和设计考虑。</p><h3 id="头插法-和-尾插法">头插法 和 尾插法</h3><p>在链表的创建过程中，&quot;头插法&quot;和&quot;尾插法&quot;是两种常见的插入方法，用于向链表中添加新的元素。这两种方法的主要区别在于新元素添加到链表的位置。</p><p><strong>头插法</strong></p><p>头插法是将新的元素添加到链表的开头。具体操作如下：</p><ol><li>创建新的节点，并将待插入的数据放入节点中。</li><li>将新节点的指针指向当前的头节点。</li><li>更新头节点，使其指向新的节点。</li></ol><p>这样，每次插入的新节点都会成为链表的头节点。因此，使用头插法创建的链表中元素的顺序与输入的顺序是相反的。</p><p><strong>尾插法</strong></p><p>尾插法是将新的元素添加到链表的末尾。具体操作如下：</p><ol><li>创建新的节点，并将待插入的数据放入节点中。</li><li>找到链表的尾节点，将尾节点的指针指向新节点。</li><li>更新尾节点，使其指向新的节点。</li></ol><p>这样，每次插入的新节点都会成为链表的尾节点。因此，使用尾插法创建的链表中元素的顺序与输入的顺序是相同的。</p><p>这两种插入方法各有优缺点，具体应用哪种方法取决于具体需求。<strong>头插法的操作更简单，但会改变元素的原始顺序</strong>；<strong>尾插法可以保持元素的原始顺序，但需要额外的操作来维护尾节点。</strong></p><h2 id="循环链表">循环链表</h2><h1>栈 队列  数组</h1><h2 id="前言">前言</h2><p>本章 通常以选择题的形式考查,  <strong>栈和队列的实现是基于有序表的, 而且他们是受限的线性表,比如栈只能操作一端</strong>,因此有顺序表和链表两种实现</p><h2 id="栈">栈</h2><h3 id="定义">定义</h3><p>栈（Stack）是一种特殊的线性数据结构，它遵循 **LIFO（Last In First Out，即后进先出）**的原则。也就是说，最后一个添加进来的元素会被首先移除。</p><p>栈的主要操作包括：</p><ol><li><strong>Push</strong>：添加元素到栈顶。</li><li><strong>Pop</strong>：移除栈顶元素。</li><li><strong>Top/Peek</strong>：查看（但不移除）栈顶元素。</li><li><strong>isEmpty</strong>：检查栈是否为空。</li></ol><p>栈在许多领域都有应用，例如在算法（如深度优先搜索，括号匹配），操作系统（如内存管理，函数调用堆栈），编程语言的实现（如递归函数的实现）等方面都有重要应用。</p><h3 id="实现">实现</h3><h4 id="顺序表实现">顺序表实现:</h4><ul><li>元素为空的判断: 栈顶指针top == -1</li><li>入栈  st[++top] = v</li><li>出栈  v = st[top–]</li><li>查看栈顶元素  v = st[top]</li></ul><h4 id="单向链表实现-不带头结点">单向链表实现(不带头结点):</h4><ul><li>元素为空的判断: 栈顶指针head == NULL</li><li>入栈  node-&gt;next = head ;  head = node</li><li>出栈  v = head.v; node = head; head=head-&gt;next; free(node)</li><li>查看栈顶元素  v = head.v</li></ul><h3 id="共享栈">共享栈</h3><p>共享栈是一种特殊的栈结构，它允许在同一个数组中实现两个栈。这种结构是通过将一个数组的两端分别作为两个栈的栈底，然后让这两个栈向中间生长来实现的。这种设计有效地利用了数组空间，避免了单栈可能导致的空间浪费。</p><p>在共享栈的实现中，通常有如下几个主要的操作：</p><ol><li><strong>初始化</strong>：分别设置两个栈的栈底，一个在数组的起始位置，一个在数组的末尾位置。</li><li><strong>push</strong>：向指定的栈中添加元素。如果添加元素的栈是从数组起始位置开始的，那么新元素应被添加到当前栈顶的下一个位置；如果添加元素的栈是从数组末尾位置开始的，那么新元素应被添加到当前栈顶的前一个位置。</li><li><strong>pop</strong>：从指定的栈中删除元素，就是将对应栈的栈顶指针向栈底方向移动一位。</li><li><strong>isEmpty</strong>：检查指定的栈是否为空，只需要查看该栈的栈顶指针是否指向其栈底即可。</li></ol><p>需要注意的是，当两个栈的栈顶指针相遇时，说明数组已经满了，不能再向任何一个栈中添加元素。判满条件是 topb - topa == 1</p><p><strong>共享栈的一个主要优点是它能有效地利用空间，避免了一端空闲，另一端溢出的情况</strong></p><h3 id="做题方法">做题方法</h3><p>技巧</p><ol><li><p><strong>n个元素依次进栈 得到出栈顺序个数函数</strong> $ f(n) = \frac{C{n \choose 2n}}NaN $</p></li><li><p><strong>出栈顺序 应该满足这样一个要求,  一个元素前面的元素如果 没有在序列前出现,  那么他们在后面出现的时候 顺序不能改变</strong>, 这个其实就满足了, 后入栈的元素 一定要早出于 <strong>先入栈而且还存在与栈中的元素</strong>, 比如入栈顺序是 abcdef  这个时候 先出栈了一个 f 这个时候, 你会发现,  后面的元素顺序已经确定了 就是  fedcba 如果出栈了  af 那么 顺序就是  afedcb</p></li><li><p><em style="color:red">根据第二条,  我们可以通过出栈序列计算出栈需要最小存储空间  比如入栈序列为  abcdefg,  出栈序列为 bdcfeag  我们只需要看序列当前元素后面有多少个比自己早入栈的元素: 1 2 1 2 1 0 0   因此最小存储空间为 2+1 = 3  这是因为当前比自己早入栈的元素肯定在栈中</em></p></li></ol><p>注意点:</p><ul><li>顺序表中,  数组尾巴才是栈顶,切记,  所以打印数组元素的时候,  最后一个元素才是栈顶元素</li></ul><h2 id="队列">队列</h2><p>队列（Queue）是一种特殊的线性数据结构，它遵循 FIFO（First In First Out，即先进先出）的原则。也就是说，最先添加进来的元素会被首先移除。</p><p>队列的主要操作包括：</p><ol><li><strong>Enqueue</strong>：在队列尾部添加一个元素。</li><li><strong>Dequeue</strong>：从队列头部移除一个元素。</li><li><strong>Front/Peek</strong>：查看（但不移除）队列头部的元素。</li><li><strong>IsEmpty</strong>：检查队列是否为空。</li><li><strong>IsFull</strong>：检查队列是否已满。</li></ol><p>队列在许多领域都有应用，例如在算法（如宽度优先搜索，缓存实现），操作系统（如任务调度，打印任务队列），编程语言的实现（如事件队列）等方面都有重要应用。</p><p>队列也有多种不同的类型，包括但不限于：</p><ul><li><strong>线性队列</strong>：最基本的队列，按照FIFO原则进行操作。</li><li><strong>循环队列</strong>：在物理存储上是线性的，但逻辑上头尾相连形成一个环状结构，能更有效地利用存储空间。</li><li><strong>优先队列</strong>：每个元素都有一个优先级，元素出队的顺序由它们的优先级决定。</li><li><strong>双端队列</strong>（deque）：既可以在队头插入和删除元素，也可以在队尾插入和删除元素。</li></ul><h3 id="实现">实现</h3><h4 id="顺序表">顺序表:</h4><ul><li>判空: front == back</li><li>入队: q[back++] = v</li><li>出队: v = q[front++]</li></ul><h4 id="改进顺序表为循环队列">改进顺序表为循环队列</h4><p>首先，对于队列的长度n，我们需要分配一个长度为n+1的数组来存储队列的元素，<strong>留出一个空间作为“保护位”</strong>。这样是为了区分队列为空和队列为满的情况。</p><p>假设我们有一个大小为n+1的数组q，初始时，队头和队尾指针front和back都指向0。那么循环队列的操作可以如下定义：</p><ol><li><strong>判空</strong>：当 front == back 时，队列为空。</li><li><strong>判满</strong>：当 (back + 1) % (n + 1) == front 时，队列为满。这里用到了模运算来实现环状的逻辑结构。</li><li><strong>入队</strong>：先判断队列是否满，如果不满，先在队尾位置存放新的元素：q[back] = v，然后更新队尾指针：back = (back + 1) % (n + 1)。</li><li><strong>出队</strong>：先判断队列是否为空，如果不空，取出队头元素：v = q[front]，然后更新队头指针：front = (front + 1) % (n + 1)。</li></ol><p><strong>这就是将顺序表改进为循环队列的一种常见方法，它通过牺牲一个数组单元的存储空间，使得队列的判满和判空操作变得简单，并且避免了数组元素的移动。</strong></p><h4 id="链表">链表</h4><ul><li>判空: front == back</li><li>入队: back-&gt;next = node; back = node</li><li>出队: v = front-&gt;v; node = front;  front = front-&gt;next; free(node);</li></ul><h3 id="双端队列">双端队列</h3><p>双端队列（Double Ended Queue，简称 Deque）是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列两端入队和出队。</p><p>输入受限双端队列:  在双端队列上删除了新增的输入端</p><p>输出受限双端队列:   在双端队列上删除了新增的输出端</p><h3 id="做题方法">做题方法</h3><ul><li>**在循环顺序队列中, 要特别注意题目所指如何解决判满和判空操作  一般我们默认判空值rear == front  判满是  (rear+1) % Maxsize == front   , 但是题目有时不是如此,比如队头指针是元素头指针的前一个元素  这样 判空就是 (front +1) % Maxsize == rear  判满操作就是 rear == front **  还要注意队头指针和队头元素的区别,  它两位置是可能不一样的</li><li>对于<strong>输出受限的队列来说</strong>,  看有哪些出队顺序不可能是他产生的方法是:  将这个出队顺序放入到输出受限队列中, 看他是否能够输入元素产生这样一个队列,  比如  a b c d e  依次 入队 ,   对于 d b a c e 这个队列  它是能够产生的   先放入 a, 左b 右c 左d 右e,  而对于 d b c a e 它是不能够产生的, 因为左边出现了 b 在 c 之前,  总结:  <strong>对于输出受限队列来说,  从第一个输入的元素往两边依次遍历过去,  元素的入队顺序是不能变的</strong>,  对于这个总结, 我们就可以自己产生输出受限队列不可能产生的队列:   bdfaec  baced  decab(a的左边,e 出现在了d的左边)</li></ul><h2 id="栈和队列的应用">栈和队列的应用</h2><h3 id="括号匹配">括号匹配</h3><h3 id="表达式求值">表达式求值</h3><p>在数学和计算机科学中，表达式（expression）是符号和运算符的有序组合，表示一种计算。根据运算符的位置，我们通常可以将表达式分为中缀表达式，前缀表达式（或叫波兰式）和后缀表达式（或叫逆波兰式）。</p><p><strong>中缀表达式（Infix Expression）</strong>：<br>在中缀表达式中，运算符位于操作数之间。这是我们日常生活中最常用的表达式形式。例如：<code>2 + 3 * 4</code>。</p><p><strong>后缀表达式（Postfix Expression 或 Reverse Polish Notation）</strong>：<br>在后缀表达式中，运算符位于所有操作数的后面。例如，中缀表达式 <code>2 + 3 * 4</code> 对应的后缀表达式为 <code>2 3 4 * +</code>。</p><p>转换中缀表达式为后缀表达式的一个常见方法是使用一个栈来保存运算符，这个方法通常被称为“调度场算法”。</p><p>这两种表达式方式的一个重要区别是，在中缀表达式中运算符有优先级，需要用括号来改变运算顺序，而后缀表达式则不需要。这使得后缀表达式在计算机中处理起来更为方便，因为计算后缀表达式只需从左到右扫描一遍，不需要记住运算符的优先级，也不需要处理括号。</p><p><strong>中缀表达式 转后缀表达式</strong></p><p>例如:  A+B*(C-D) -E/F</p><p>一个用于存放操作符栈 st_op</p><p>一个用于存放后缀表达式的队列 q</p><p>依次遍历中缀表达式   A 入队列,  + 入栈;  B入队列;  *入栈;  (入栈; C入队列;  - 入栈; D 入队列; )将栈中(之前的元素全部出栈入队列 -入队列, 弹出(; - 将前面全部操作符出栈 有 * +,  E入队列; /入栈; F入队列; 弹出全部操作符到队列</p><p>A B C D - * + E F / -</p><p>上面就涉及到了优先级的问题, 当前栈顶优先级比自己高, 就弹出它放入到队列</p><h3 id="递归">递归</h3><p>递归是一种编程技术，其中一个函数通过直接或间接地调用自身来解决问题。<strong>递归函数通常被用来解决可以通过更小子问题的解来找到原问题解的那种问题。</strong></p><p>一个递归的实现通常包括以下两个主要部分：</p><ol><li><strong>基本情况也叫边界条件（Base Case）</strong>：这是递归调用链条中的最小问题，可以直接解决而不需要进一步的递归调用。基本情况的处理是递归函数正确工作的关键。</li><li><strong>递归调用（Recursive Case）</strong>：在递归调用部分，函数会将问题分解为更小的子问题，并通过递归调用自身来解决这些子问题。</li></ol><p>在编写递归函数时，需要特别注意避免无限递归，也就是说，我们需要保证在有限步骤内，每个递归调用都能到达一个基本情况。</p><p>递归在算法设计中是一个非常强大的工具，可以用来解决很多问题，比如搜索问题，排序问题（例如快速排序和归并排序），动态规划问题等。同时，很多数据结构，比如树和图，也有很多递归的操作。</p><h3 id="队列在计算机系统中的应用">队列在计算机系统中的应用</h3><p>队列是计算机科学中一个非常重要的数据结构，它在各种不同的计算机系统中都有着广泛的应用。下面是一些常见的应用场景：</p><ol><li><p><strong>操作系统</strong>：在操作系统中，多个进程可能会共享一个单一的处理器。操作系统使用一个进程队列来管理这些进程，按照一定的调度策略（比如先进先出、优先级调度等）来决定下一个要运行的进程。</p></li><li><p><strong>打印任务管理</strong>：在一个网络打印机中，打印任务会被放入一个队列中，打印机会按照队列中的顺序（通常是先进先出）依次打印。</p></li><li><p><strong>网络请求处理</strong>：在Web服务器中，服务器会用一个队列来管理来自客户端的请求，按照队列的顺序依次处理这些请求。当服务器的处理能力有限时，队列可以用来平衡请求的处理速度和请求的到达速度，防止服务器被过多的请求压垮。</p></li><li><p><strong>消息队列</strong>：在分布式系统中，消息队列是一种常见的数据交换方式。它允许不同的系统或者服务之间异步地交换信息。每个发送的消息都会被放入队列中，接收者可以从队列中取出并处理消息。</p></li><li><p><strong>图形化用户界面</strong>：在图形用户界面中，事件（比如点击、按键、鼠标移动等）会被放入一个事件队列中，然后按照队列的顺序被处理。这样可以确保事件的处理顺序与事件的发生顺序一致。</p></li><li><p><strong>数据缓冲</strong>：队列也常用于数据的缓冲，例如，在I/O操作，网络传输，生产者/消费者问题中，都可能使用队列作为数据的缓冲结构。</p></li></ol><p>这些仅仅是队列在计算机系统中应用的一部分例子，队列的应用场景非常广泛。</p><h2 id="数组和特殊矩阵">数组和特殊矩阵</h2><p>矩阵在计算机图形学和工程计算中有举足轻重的地位, 在数据结构中如何用最小的存储空间来存储矩阵变的格外重要.</p><h3 id="数组">数组</h3><p>数组是相同元素类型构成的有限序列, 数组是线性表的推广</p><p>数组是一种基本的数据结构，用于存储同一类型的连续元素。以下是关于数组的一些基本知识：</p><p><strong>定义与特性</strong>：</p><ol><li><p><strong>连续存储</strong>：数组中的元素在内存中是连续存储的，这意味着数组的每个元素都紧接着前一个元素存储。这使得可以通过基地址和偏移量快速定位和访问数组中的任意元素。</p></li><li><p><strong>固定大小</strong>：在大多数编程语言中，数组在创建时需要指定大小，且之后无法改变。</p></li><li><p><strong>索引访问</strong>：数组中的每个元素都可以通过索引（通常是整数）来访问，这通常是从0开始的。</p></li></ol><p><strong>常见操作</strong>：</p><ol><li><p><strong>读取</strong>：通过索引来读取元素，这是一个常数时间的操作。</p></li><li><p><strong>更新</strong>：通过索引来更新元素，这也是一个常数时间的操作。</p></li><li><p><strong>搜索</strong>：查找一个特定的元素在数组中的位置。在无序数组中，这通常需要遍历整个数组，所以时间复杂度是O(n)。在有序数组中，可以使用二分搜索，时间复杂度是O(log n)。</p></li><li><p><strong>插入和删除</strong>：在数组的末尾插入或删除元素是一个常数时间的操作。但在数组的开头或中间插入或删除元素需要移动元素，所以时间复杂度是O(n)。</p></li></ol><p><strong>应用场景</strong>：</p><ol><li><p><strong>存储数据</strong>：数组是存储和处理大量数据的基础，例如图像处理、数值计算等。</p></li><li><p><strong>查找表/映射</strong>：如果关键字是小整数，数组可以作为查找表或映射，通过关键字直接访问元素。</p></li><li><p><strong>实现其他数据结构</strong>：数组是许多其他数据结构的基础，例如栈、队列、堆、哈希表等。</p></li></ol><p><strong>注意事项</strong>：</p><ol><li><p><strong>越界问题</strong>：由于数组的大小是固定的，所以访问数组时需要确保索引不越界。</p></li><li><p><strong>内存利用</strong>：如果数据的数量或大小有大的变化，可能需要动态的数据结构，例如链表或动态数组，以更有效地使用内存。</p></li><li><p><strong>多维数组映射方法</strong>:  按行优先和按列优先, 需要注意区别</p></li></ol><h3 id="特殊矩阵的压缩">特殊矩阵的压缩</h3><p>对于矩阵压缩公式来说,  将矩阵坐标转化为数组坐标,  我们首先计算当前坐标对应的元素个数为n,  然后矩阵坐标是否可以从0开始, 如果是从0开始那么对应数组坐标就是  n  , 否则就是 n - 1(默认数组下标从0开始),   <strong>还要注意数组下标是否从0开始</strong></p><h4 id="对称矩阵">对称矩阵</h4><p><strong>对称矩阵</strong>:  上三角和下三角元素相同, 因此我们可以只存放下三角和主对角线的元素</p><p>用一个数组b来存放(下标从0开始)</p><p>获取 a(i,j)元素的公式为:</p><p>a(i,j) = b[k]  其中  当i&gt;=j 时 k = i*(i-1)/2 + j-1  当 i&lt;j 时  k = j*(j-1) /2+ i-1</p><h4 id="三角矩阵">三角矩阵</h4><p><strong>上三角元素全部相同,下三角不同矩阵压缩</strong>:   只需要先存储下三角, 然后再存放上上三角一个元素就行, 总共 存放n(n+1)/2 +1 个元素</p><p>a(i,j) = b[k] 其中当i&gt;=j 时 k = i*(i-1)/2 + j-1  当 i&lt;j 时  k = n(n+1)/2</p><p><strong>下三角元素全部相同,上三角不同矩阵压缩</strong>:</p><p>a(i,j) = b[k] 其中当i&gt;j 时 k = n(n+1)/2, 当 i&lt;=j 时   k = (2*n-i+2)*(i-1)/2 + j-i</p><h4 id="三对角矩阵">三对角矩阵</h4><p>三对角矩阵是一种特殊的矩阵，它只有主对角线上的元素以及主对角线两侧的元素（也就是对角线上的元素和对角线上下一行和上一列的元素）是非零的，其他位置的元素都是零。</p><p>假设我们有一个三对角矩阵，我们可以使用一个一维数组来存储非零元素，以节省存储空间。对于三对角矩阵，我们可以定义如下寻址公式（下标从0开始）：</p><p>设矩阵元素 a[i][j] 存在数组 b 中的位置 k，那么我们有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[k] = a[i][j] 其中 k = 2*i + j - 3 </span><br></pre></td></tr></table></figure><p>已知k能够推出i和j   i = (k+1)/3+1 j = k-2*i+3  这里的除法是c语言里面的取整除法</p><h4 id="稀疏矩阵">稀疏矩阵</h4><p><strong>矩阵中非零元素的个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>, 相对矩阵元素的个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 来说非常少, 即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≫</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s \gg t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 的矩阵称为稀䟽矩阵</strong>。 例如, 一个矩阵的阶为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>×</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">100 \times 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>, 该矩阵中只有少于 100 个非零元素。<br>若采用常规的方法存储稀疏矩阵, 则相当浪费存储空间, 因此仅存储非零元素。但通常非零 元素的分布没有规律, 所以仅存储非零元素的值是不够的, 还要存储它所在的行和列。因此, 将非零元素及其相应的行和列构成一个三元组 (行标, 列标, 值),。然后按照某种 规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。</p><p><strong>十字链表法存储</strong></p><p>十字链表是一种存储稀疏矩阵的方法，特别适合于非零元素分布比较均匀的稀疏矩阵。这种方法既可以快速访问任一元素，又可以快速对任一元素进行插入或删除操作。</p><p>在十字链表中，每个非零元素都对应一个结点，每个结点有5个字段：行、列、值、行的下一个元素、列的下一个元素。整个矩阵还有两个额外的头结点数组，分别表示每行和每列的第一个元素。</p><p>具体来说，设稀疏矩阵的行数为m，列数为n，那么十字链表包含如下内容：</p><ol><li>一维数组row[m]，表示m行的头结点，其中row[i]指向第i行的第一个非零元素。</li><li>一维数组col[n]，表示n列的头结点，其中col[j]指向第j列的第一个非零元素。</li><li>非零元素的结点，包含5个字段：行、列、值、行的下一个元素、列的下一个元素。</li></ol><p>十字链表法优点是在查找元素、插入元素和删除元素时，既可以沿着行方向操作，也可以沿着列方向操作。缺点是存储空间较大，因为每个非零元素都需要存储额外的信息（行、列、下一个行元素、下一个列元素）。</p><h3 id="总结">总结</h3><p>一定要记得这几个公式,  这样我们就能以不变应万变,   我们的公式 都是基于:  矩阵下标从1开始,  存放数组下标从0开始,  无论它题目从什么开始,  按行或者按列  或者上三角下三角,  我们都能转换到这几个公式上来</p><p>对称矩阵按照下三角按行存储   ==  <strong>对称矩阵按照上三角按列存储 交换i j位置</strong></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>⩾</mo><mi>j</mi><mtext> (下三角区和主对角线元素) </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mtext> (上三角区元素 </mtext><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub><mo fence="true">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k= \begin{cases}\frac{i(i-1)}{2}+j-1, &amp; i \geqslant j \text { (下三角区和主对角线元素) } \\ \frac{j(j-1)}{2}+i-1, &amp; \left.i&lt;j \text { (上三角区元素 } a_{i j}=a_{j i}\right)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6920000000000002em;"><span style="top:-3.6919999999999997em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1919999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6920000000000002em;"><span style="top:-3.6919999999999997em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">下三角区和主对角线元素</span><span class="mord">) </span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">上三角区元素</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1919999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>对称矩阵按照上三角按行存储 ==  <strong>对称矩阵按照下三角按行存储 交换i j 位置</strong></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>⩽</mo><mi>j</mi><mtext> (上三角区和主对角线元素) </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>&gt;</mo><mi>j</mi><mtext> (下三角区元素) </mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k= \begin{cases}\frac{(i-1)(2 n-i+2)}{2}+(j-i), &amp; i \leqslant j \text { (上三角区和主对角线元素) } \\ \frac{(j-1)(2 n-j+2)}{2}+(i-j), &amp; i&gt;j \text { (下三角区元素) }\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6920000000000002em;"><span style="top:-3.6919999999999997em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1919999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6920000000000002em;"><span style="top:-3.6919999999999997em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">上三角区和主对角线元素</span><span class="mord">) </span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">下三角区元素</span><span class="mord">) </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1919999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>三角矩阵按照上三角按行存储</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>⩽</mo><mi>j</mi><mtext> (上三角区和主对角线元素) </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>&gt;</mo><mi>j</mi><mtext> (下三角区元素) </mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k= \begin{cases}\frac{(i-1)(2 n-i+2)}{2}+(j-i), &amp; i \leqslant j \text { (上三角区和主对角线元素) } \\ \frac{n(n+1)}{2}, &amp; i&gt;j \text { (下三角区元素) }\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6920000000000002em;"><span style="top:-3.6919999999999997em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1919999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6920000000000002em;"><span style="top:-3.6919999999999997em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">上三角区和主对角线元素</span><span class="mord">) </span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">下三角区元素</span><span class="mord">) </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1919999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>三对角矩阵</p><p>3 条对角线上的元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><mn>1</mn><mo>⩽</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>⩽</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">a_{i j}(1 \leqslant i, j \leqslant n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi><mo>⩽</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">|i-j| \leqslant 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 在一维数组 B 中存放的下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn><mi>i</mi><mo>+</mo><mi>j</mi><mo>−</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k=2 i+j-3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 。(<em><em>可以理解为 2</em>(i-1) + j, 将前面所有行的主对角线右边的元素移动到本行的前面, 填充变成了一行,  所以前面每行只剩2个元素</em>*)</p><p>反之, 若已知三对角线矩阵中某元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 存放于一维数组 B 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个位置, 则可得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">i=\lfloor(k+1) /</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>+</mo><mn>1</mn><mo stretchy="false">⌋</mo><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mi>k</mi><mo>−</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3+1\rfloor, j=k-2 i+3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⌋</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 。例如, 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>3</mn><mo>+</mo><mn>1</mn><mo stretchy="false">⌋</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn><mo>−</mo><mn>2</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=\lfloor(0+1) / 3+1\rfloor=1, j=0-2 \times 1+3=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 存放的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>; 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>3</mn><mo>+</mo><mn>1</mn><mo stretchy="false">⌋</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>2</mn><mo>−</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=\lfloor(2+1) / 3+1\rfloor=2, j=2-2 \times 2+3=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 存放的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{2,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>; 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">k=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 时, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>3</mn><mo>+</mo><mn>1</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">i=\lfloor(4+1) / 3+1\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⌋</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>4</mn><mo>−</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">=2, j=4-2 \times 2+3=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>, 存放的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{2,3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 。</p><h1>串</h1><h2 id="前言">前言</h2><p>大纲只要求掌握字符串的模式匹配,  我们要重点掌握kmp算法的原理以及next数组的推理过程</p><h2 id="定义">定义</h2><p>串是由零个或者多个字符组成的有限序列,  串中任意多个连续的字符组成的子序列称为子串</p><p>两个串的长度,以及内容相等,那就说明两个串相等</p><h2 id="串的模式匹配">串的模式匹配</h2><p>这个通常是定位子串在主串中出现的位置</p><h3 id="暴力匹配">暴力匹配</h3><p>假设 子串长度为 l 主串长度为 L   依次枚举主串中从当前下标开始连续的l个元素是否和子串相等, 这个效率太低下了 时间复杂度为 O(mn)</p><h3 id="kmp算法">kmp算法</h3><p>我们发现暴力匹配的缺点就是,  当 子串中一个字符和主串中的不相同的时候, 就会抛弃掉所有已经匹配好的字符串, 然后再从子串 和 主串的下一个位置重新开始匹配(也就是回溯到子串开始位置, 主串当次匹配的起始位置的下一个位置),  所以这样就是效率低下的原因,  我们不妨来分析一下, 如果当前子串的字符和主串的字符不相同,  我们可以怎么样选择,   <em style="color:red">如果当前主串这个字符有可能成功的被匹配,  那么它一定只可能出现在子串的前面位置了</em>, 这个应该比较好理解吧?  如果是出现在后面的话, 那就完全不可能出现当前和子串不匹配的情况 ,     既然它只可能出现在子串的前面位置了,   <em style="color:red"> 我们完全可以不用回溯主串匹配的位置,  我们只需要将 当前子串匹配位置的移动到 “下一个可能匹配成功的位置” </em>   就是说,  如果当前主串这个字符想要在前面的子串中被匹配成功,  那么它前面一定有<strong>0个或者更多个字符记做n个</strong>被匹配成功了,  我们只需要将子串匹配位置移动到 n的位置就行了继续开始匹配,    所以我们现在要做的事情就是,  记录如果当前匹配失败了,  要移动到哪个位置就行了,  也就是next数组</p><p>补充一下:   有人可能就会有疑惑了,  你怎么保证你没有忽略掉正确答案?   是的,细心的人就发现了,  我们这次移动没有回溯主串, 这样势必抛弃了不少不可能的匹配,   证明如下:</p><p>如果匹配失败,  如果这个字符不会出现在匹配序列中, 那么它前面的 l-1 个元素都不可能了,  如果它能够出现在 匹配序列中,  利用已经匹配好的序列信息, 往回看,  这个匹配序列最长的前缀和后缀相等的长度是多少,  这就是它下一次该重新匹配的位置,因为我们<strong>要尽可能的保留前面匹配信息的长度</strong>,这样才不会漏掉可能匹配的序列, 重复如此, 直到当前字符匹配成功,或者没有成功,那就从主串当前位置下一个位置继续匹配.</p><h4 id="next-数组">next 数组</h4><p>找到当前子串字符前面序列的 最长 前缀和后缀相同的 长度, next 数组就记录这个值</p><p>求解思路</p><ul><li>初始化, 第一个元素下标 0 它如果匹配失败, 就应该去-1(也就是当前这个字符不可能出现在匹配序列中)</li><li>第 i + 1个位置的 next数组值,  是由 前 i 个序列字符 的最长前缀和后缀决定的,  因此 next[i+1] = j+1</li><li>如果 出现了 j == -1,  那就说明 这个字符根本就不可能是最长后缀,  如果跟它匹配失败, 就要重新从 第一个子串开始</li></ul><p>看代码吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;next)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> len = str.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第0个字符都匹配失败的话, 就是退到-1了</span></span><br><span class="line">    next.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于next[i+1] 的值是由前i个字符决定的, 因此, 我们只需要将i计算到  len-2</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// next[i+1] 的值是由前i个字符决定的, j==-1其实也是一种 str[i] == str[j] 只不过str[-1] 是一种不存在的存在</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || str[i] == str[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 由于str[i] == str[j]  所以 next[i+1] = j+1  也就是 如果当前元素匹配失败, 应该要回退到j+1这个位置继续匹配</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next.push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果str[i] != str[j]  就要去找next[j] 看他们是否相等</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配算法">匹配算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;next)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> len = str.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第0个字符都匹配失败的话, 就是退到-1了</span></span><br><span class="line">    next.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于next[i+1] 的值是由前i个字符决定的, 因此, 我们只需要将i计算到  len-2</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// next[i+1] 的值是由前i个字符决定的, j==-1其实也是一种 str[i] == str[j] 只不过str[-1] 是一种不存在的存在</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || str[i] == str[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 由于str[i] == str[j]  所以 next[i+1] = j+1  也就是 如果当前元素匹配失败, 应该要回退到j+1这个位置继续匹配</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next.push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果str[i] != str[j]  就要去找next[j] 看他们是否相等</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">funcKMP</span><span class="params">(<span class="built_in">string</span> mainstr, <span class="built_in">string</span> substr)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">    getNext(substr, next);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 这里的j只需要从0 开始, 它是代表子串的位置, 而不是回退的位置, 在求next算法中 j是代表回退的位置</span></span><br><span class="line">    <span class="type">int</span> len = mainstr.length();</span><br><span class="line">    <span class="type">int</span> len1 = substr.length();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || mainstr[i] == substr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == len1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> mainstr = <span class="string">&quot;abaabcaba&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> substr = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; funcKMP(mainstr, substr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="next-数组的优化">next 数组的优化</h4><p>对于  s[j] == s[next[j]] 的情况,   如果主串 i 位置  和 子串 j位置匹配失败了,  那么 势必在 主串位置  和 子串 next[j] 位置也会失败, 所以 我们需要优化一下next数组  如果 第i位置的下一个位置还和自己相等,  就让next[i] = next[j]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;next)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> len = str.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第0个字符都匹配失败的话, 就是退到-1了</span></span><br><span class="line">    next.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于next[i+1] 的值是由前i个字符决定的, 因此, 我们只需要将i计算到  len-2</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// next[i+1] 的值是由前i个字符决定的, j==-1其实也是一种 str[i] == str[j] 只不过str[-1] 是一种不存在的存在</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || str[i] == str[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 由于str[i] == str[j]  所以 next[i+1] = j+1  也就是 如果当前元素匹配失败, 应该要回退到j+1这个位置继续匹配</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str[i] == str[j])  <span class="comment">// 如果相等的话, 就不需要回溯到这个位置了,而是回溯到j位置对于的回溯位置,因为如果两个字符相等,那么如果回溯到这个位置, 还是会匹配失败</span></span><br><span class="line">            &#123;</span><br><span class="line">                next.push_back(next[j]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                next.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果str[i] != str[j]  就要去找next[j] 看他们是否相等</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>树与二叉树</h1><h2 id="前言">前言</h2><p>本章内容多以选择题的形式考查, 但也会涉及到树遍历相关的算法, 需要掌握各种树的定义和性质</p><h2 id="树的基本概念">树的基本概念</h2><p>树(Tree)是计算机科学中使用的一种抽象数据类型（ADT），或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p><p>具体地，树具有以下的特征：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树。</li></ul><p>树中的一些重要概念包括：</p><ul><li>节点的度(Degree)：<strong>节点的子树个数</strong></li><li>树的度：<strong>树中节点的最大度数</strong></li><li>叶节点（或叶子节点，外部节点）：度为0的节点</li><li>内部节点：度不为0的节点</li><li>父亲节点：若一个节点含有子节点，则这个节点称为其子节点的父节点</li><li>孩子节点：一个节点含有的子树的根节点称为该节点的孩子</li><li>兄弟节点：具有相同父节点的节点互称为兄弟节点</li><li><strong>节点的层次(Level)：从根开始定义起，根为第1层，根的子节点为第2层，以此类推</strong></li><li>树的高度(Height)：<strong>树中节点的最大层次</strong></li><li>节点的高度,深度:  高度只从根节点出发到当前节点层数,  深度指从当前节点向根节点出发</li><li>路径和路径长度：从节点n1到nk的路径为一个节点序列n1, n2, …, nk，路径长度为所经分支数目，<strong>通常为路径中最后一个节点的层次数减1</strong></li><li>子孙和祖先：节点n1到nk路径上，n1是nk的祖先，nk是n1的子孙</li></ul><p>这些是关于树的基本概念的简单介绍，理解这些概念对于深入理解树以及树的各种操作和算法都是很重要的。</p><h3 id="树的性质">树的性质</h3><p>树作为一种<strong>特殊的图</strong>，具有以下几个基本的性质：</p><ol><li><em style="color:red"><strong>树中的节点数目 = 所有分支数目 + 1</strong>：这个性质来自于树是连通无环图的特性，即树中任何两个节点之间只有一条路径。</em></li><li>**在非空树中，第i层的最多节点数为：**对于度为m的树，第i层的最多节点数为 m^(i-1)，这是因为每一个非叶节点都能产生m个子节点。</li><li><strong>高度为k的m叉树最多有m^0 + m^1 + m^2 + … + m^(k-1) = (m^k - 1) / (m - 1)个节点</strong>：这个公式可以通过等比数列求和公式推导出来。</li><li><em><em>含有n个节点的m叉树的最小深度 k ≥ logm [(n</em>(m-1)+1)]</em>*：当树中的节点全部分布在最后一层时，树的深度最大；当节点尽可能地分布在前面的层次，即除了最后一层，其它层的节点数达到最大时，树的深度最小。</li></ol><p>理解这些性质可以帮助我们更深入地理解树这种数据结构的特性，对于我们在解决实际问题中使用树结构有很大的帮助。</p><h2 id="二叉树">二叉树</h2><p>二叉树是一种特殊的树形数据结构，其定义如下：</p><p>一个二叉树是具有以下性质的有限集合：</p><ol><li>该集合可以为空（称为空二叉树）。</li><li>如果不为空，那么它由一个称为根的元素以及两个互不相交的、被分别称为左子树和右子树的二叉树组成。</li></ol><p>注意，这个定义是递归的。即，一个二叉树的左子树和右子树也都是二叉树。</p><p>在二叉树中，根节点是最上面的节点，每个非叶子节点都有一个或两个子节点，分别是左子节点和右子节点。左子节点和右子节点也可以看作是以它们为根的子二叉树的根节点。<strong>子节点从左到右被顺序排列</strong>。(二叉树是有序树,这里的有序不是说内容有序,而是结构有序)</p><p>二叉树的一个重要特性是，它的结构可以用链表进行表示和实现，每个节点包含一个数据字段和两个指向其左右子节点的指针。二叉树可以用于实现各种数据结构，如集合、映射和列表。</p><h3 id="特殊的二叉树">特殊的二叉树</h3><p>二叉树的各种特殊形式具有一些有用的性质，以下列出了一些常见的特殊二叉树：</p><ol><li><p><strong>满二叉树（Full Binary Tree）</strong>：每一个层级上的节点数都达到最大。<strong>也就是说，除了叶子节点之外，每一个节点都有两个子节点。</strong></p></li><li><p><strong>完全二叉树（Complete Binary Tree）</strong>：除了最后一层之外，<strong>每一层都被完全填充，且所有节点都保持向左对齐</strong>。在完全二叉树中，第i层至多有2^i个节点（i从0开始，根节点层为0）。</p></li><li><p><strong>平衡二叉树（Balanced Binary Tree）</strong>：也被称为AVL树。这是一种自平衡二叉搜索树，<strong>其中任何节点的两个子树的高度差最多为1。</strong></p></li><li><p><strong>二叉搜索树（Binary Search Tree，简称BST）</strong>：对于每个节点，其左子树中的所有元素的值都小于该节点，右子树中的所有元素的值都大于该节点。</p></li><li><p><strong>堆（Heap）</strong>：这是一种特殊的完全二叉树，具有一些特殊的性质，如最大堆和最小堆。在最大堆中，父节点的值总是大于或等于其子节点的值。在最小堆中，父节点的值总是小于或等于其子节点的值。</p></li><li><p><strong>红黑树（Red-Black Tree）</strong>：这是一种自平衡二叉查找树，每个节点额外持有一个存储位表示节点颜色，可以是红或黑。通过颜色的约束和调整，红黑树确保了一条从根节点到叶子节点的最长的可能路径不多于最短的可能路径的两倍长。这个特性使得红黑树成为实现关联数组的有效数据结构。</p></li><li><p><strong>B树和B+树</strong>：它们是自平衡的搜索树，主要用于磁盘或其他直接存取辅助设备中的数据存储。在数据库系统和文件系统中，B树和B+树的应用非常广泛。</p></li></ol><p>以上每种特殊的二叉树都具有特定的用途和性质，使其在特定情况下更有效率。</p><h3 id="二叉树的性质">二叉树的性质</h3><ol><li><p>在任何一颗二叉树中，如果其终端节点数（叶子节点数）为n0，度为2的节点数为n2，<strong>则n0 = n2 + 1。</strong>, 我们可以利用节点个数等于节点度数和+1推出这个公式, 但是这里我不这样推,  我想用另外一种方式来说明:  <em style="color:red">  只有在度为2的结点上才会多出来一个叶子节点, 度为1的结点不多出结点, 所以 在根节点的基础上,  多出来多少个度为2的结点,就多了多少个叶子节点, 所以 度为2的结点个数+1 = 度为0的个数 </em></p></li><li><p><em style="color:red">具有n个节点的完全二叉树的深度为floor(log2n) + 1 (底为2的对数，向下取整)。注意这里的公式, 它和  cell(log2(n+1))(向上取整) 的结果是一样的, 这个是二叉树独有的</em></p></li><li><p>如果对一颗有n个节点的完全二叉树（其深度为<strong>floor(log2n)+1</strong>）的节点按层序编号（从第1层到第log2n+1层，每层从左到右），对任一节点i (1&lt;=i&lt;=n) 有：</p><ul><li>如果i=1，则节点i是二叉树的根，无父节点；如果i&gt;1，则其父节点是节点i/2。</li><li>如果2i&gt;n，则节点i无左子女；否则，其左子女是节点2i。</li><li>如果2i+1&gt;n，则节点i无右子女；否则，其右子女是节点2i+1。</li></ul></li></ol><h3 id="二叉树与度为2的有序树的区别">二叉树与度为2的有序树的区别</h3><p>二叉树和度为2的有序树在结构上是有所区别的。</p><ol><li><p>二叉树（Binary Tree）：每个节点最多有两个子树（即度为2），子树有左右之分，即使只有一个子树，也要区分是左子树还是右子树。这意味着，即使一个节点只有一个子节点，我们也需要明确它是一个左子节点还是一个右子节点。</p></li><li><p>度为2的有序树：虽然每个节点也最多有两个子节点（度为2），但子节点之间没有左右之分。如果一个节点只有一个子节点，我们并不需要明确这个子节点是左还是右。</p></li></ol><p>简单来说，二叉树强调了左右子树的顺序，而度为2的有序树没有这个要求。</p><p>而且二叉树可以为空,  度为2的有序树至少三个结点</p><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的遍历主要有四种方式：前序遍历、中序遍历、后序遍历和层次遍历。</p><ol><li><p>前序遍历：先访问根节点，然后访问左子树，最后访问右子树。对于左、右子树的访问也是先访问根节点，然后访问左子树，最后访问右子树。</p></li><li><p>中序遍历：先访问左子树，然后访问根节点，最后访问右子树。对于左、右子树的访问也是先访问左子树，然后访问根节点，最后访问右子树。</p></li><li><p>后序遍历：先访问左子树，然后访问右子树，最后访问根节点。对于左、右子树的访问也是先访问左子树，然后访问右子树，最后访问根节点。</p></li><li><p>层次遍历（广度优先遍历）：按照树的层次从上到下、从左到右进行遍历。</p></li></ol><p>需要注意的是，前序、中序和后序遍历都是深度优先遍历的方式。</p><p>遍历二叉树的主要目的是访问每一个节点，而访问的顺序则取决于特定的应用场景。不同的遍历方式对应的是不同的节点访问顺序，这个顺序决定了遍历的特性以及它可能适用的场景。</p><p>以上所有的遍历方式都可以通过递归或者非递归（使用栈或队列）的方式来实现。</p><p>对于这个前序后序中序, 其实都是相对于当前元素来说,  如果当前元素的数据优先被使用就是 前序,  在左节点之后就是中序,  在右节点之后就是后序,   <strong>无论哪种顺序,  左右结点的前后顺序是不变的</strong></p><h3 id="非递归遍历">非递归遍历</h3><ul><li>前序遍历（根-左-右）：<ol><li>创建一个空栈，首先将根节点压入栈中。</li><li>当栈不为空时，弹出栈顶节点并访问。</li><li>先将该节点的右子节点（如果有）压入栈中。</li><li>再将该节点的左子节点（如果有）压入栈中。</li><li>重复步骤2~4，直到栈为空，遍历结束。</li></ol></li><li>中序遍历（左-根-右）：<ol><li>创建一个空栈，设置当前节点为根节点。</li><li>将当前节点入栈，设置当前节点为其左子节点。</li><li>如果当前节点为空，且栈不为空，则出栈一个节点并访问，设置当前节点为该节点的右子节点。</li><li>如果当前节点为空，且栈为空，则遍历结束。</li><li>重复步骤2~4，直到遍历结束。</li></ol></li><li>后序遍历（左-右-根）：<ol><li>创建两个空栈，栈1和栈2，将根节点压入栈1。</li><li>从栈1中弹出节点，将其压入栈2，<strong>并先将该节点的左子节点压入栈1，然后再压入右子节点</strong>(这里是为了让右节点先进入栈2,这样左节点的数据就会被优先访问)。</li><li>重复步骤2，直到栈1为空。</li><li>从栈2中弹出节点并访问，直到栈2为空，遍历结束。</li></ol></li></ul><h3 id="遍历序列构造二叉树">遍历序列构造二叉树</h3><p>中序序列可以和前序序列 或者 后序序列构成唯一的二叉树,  但是 前序序列和后序序列不能,  因为 这两个序列, 你是没办法得到唯一的左子树和右子树的,  有了 中序序列 和 前序或者后序中的任意一个,  就是划分出来 唯一的左右子树</p><p>给定二叉树的两种遍历序列（其中一种必须是中序遍历），可以唯一确定一个二叉树。下面分别以前序+中序和中序+后序为例，说明如何构造二叉树。</p><ol><li><strong>前序遍历+中序遍历构造二叉树：</strong><ul><li>在前序遍历序列中，第一个元素总是树的根节点。</li><li>在中序遍历序列中，根节点将序列分为两部分，左边是树的左子树，右边是树的右子树。</li><li>递归地将前述步骤应用于左子树和右子树，直到序列为空。</li></ul></li><li><strong>中序遍历+后序遍历构造二叉树：</strong><ul><li>在后序遍历序列中，最后一个元素总是树的根节点。</li><li>在中序遍历序列中，根节点将序列分为两部分，左边是树的左子树，右边是树的右子树。</li><li>递归地将前述步骤应用于左子树和右子树，直到序列为空。</li></ul></li></ol><p><strong>对于只给定一种遍历序列的情况（例如只给定前序遍历或后序遍历），通常无法唯一确定一个二叉树，除非树满足某些特殊的条件，例如它是一棵完全二叉树或满二叉树。</strong></p><h2 id="线索二叉树">线索二叉树</h2><p>线索二叉树是为了解决二叉树遍历时需要递归或者栈的问题，通过在原来二叉树空指针的位置加入&quot;线索&quot;，使得二叉树遍历不需要使用递归或栈。线索二叉树有前序线索二叉树，中序线索二叉树，后序线索二叉树，<strong>具体线索化过程依赖于遍历的顺序</strong>。</p><p><strong>定义</strong>：<br>在二叉树中，每个节点的左右指针域中有的会有多余的空间，这部分空间没有充分利用。我们可以用这部分空间存放指向该节点在某种遍历次序下的前驱和后继节点的指针（这些指针被称为线索）。</p><p>根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。</p><p><strong>特点</strong>：</p><ol><li>加强了节点间的横向联系，<strong>提高了查找某一节点在某种遍历序列中的前驱和后继节点的效率</strong>。</li><li>利用空闲的存储空间，节约了存储空间。</li><li>避免了递归或栈的使用，简化了遍历过程。</li></ol><p><strong>构建</strong>：<br>构建线索二叉树的主要过程就是在遍历二叉树的过程中，检查当前节点的左右子节点是否为空，如果为空则将其设置为指向前驱或后继的线索。</p><p><strong>遍历线索二叉树的时候，可以直接通过线索找到节点的前驱或后继节点，不需要使用递归或栈。</strong></p><p>总的来说，线索二叉树是一种通过添加线索，提高遍历效率并节省存储空间的特殊的二叉树。</p><h2 id="树和森林">树和森林</h2><p>在图论中，&quot;森林&quot;是一种特殊类型的图，其中没有任何形成闭环的边。换句话说，森林是一个无环连通图。如果将图论中的森林概念引入到树的数据结构，我们可以定义森林为：</p><p><strong>森林是0棵或多棵不相交的树的集合</strong>。换句话说，一个森林是由零棵或多棵树构成，<strong>这些树互不相交，也就是说，任何两棵树没有公共的顶点。</strong></p><p>如果从树的角度看，我们可以把森林看作是一棵树去掉根后剩下的部分。或者说，<strong>一棵树就是一个森林加上一个根</strong>。</p><p>值得注意的是，<strong>这些树（在森林中）可以是任何类型的树</strong>，例如，它们可以是二叉树、多叉树、AVL树、红黑树等。在树结构的许多应用中，森林都发挥着重要的作用，例如在计算机科学中的集合表示或者在自然语言处理中的句法解析等。</p><p>在树和森林的表示法中，常见的有以下几种：</p><ol><li><strong>双亲表示法</strong>：每个节点包含自身信息和双亲位置的索引。这种方法可以快速找到任一节点的双亲节点，但查找孩子节点或兄弟节点则比较困难。</li><li><strong>孩子表示法</strong>：将每个结点的孩子结点用单链表连接形成线性结构, 所以n个结点就有n个孩子链表, 叶子节点链表为空</li><li><strong>孩子兄弟表示法</strong>：每个节点有两个字段，一个是指向其第一个孩子的指针，另一个是指向其兄弟的指针。这种表示法只需要使用两个指针，比较简洁。</li><li><strong>二叉树表示法</strong>：通过将森林转化为二叉树进行表示。具体转化方式是：森林中每一棵树的根节点的左子树是它的第一棵子树，右子树是它的下一棵兄弟树。这样，原来的森林就转化为了一棵二叉树，可以利用二叉树的存储方式来存储森林。</li><li><strong>顺序存储表示法</strong>：用一维数组表示森林，每个节点占据一个数组元素。这种方法适用于节点数量固定不变的情况，但对于节点数量动态变化的情况，可能会导致存储空间的浪费。</li></ol><h3 id="森林和树转成二叉树">森林和树转成二叉树</h3><p>首先，我们来讨论如何将一个普通的树转化为二叉树：</p><ol><li>在树中，<strong>把兄弟节点用水平线相连，这样每个节点的所有子节点就形成了一个链表</strong>。</li><li>保持顺序不变，将每个节点的子节点链表转向，使其从垂直变为水平。这样，<strong>原来树中的每个节点的第一个子节点变成了二叉树中的左子节点</strong>，其余子<strong>节点都变成了这个前一个兄弟节点的右子节点</strong>。</li></ol><p>然后，我们来讨论如何将一个森林转化为二叉树：</p><ol><li><strong>先把森林中的每一棵树都转化为二叉树</strong>。</li><li>然后把所有二叉树按照顺序链接起来，<strong>第一棵二叉树不变，从第二棵二叉树开始，每棵二叉树的根节点都变成前一棵二叉树的根节点的右子节点。</strong></li></ol><p>以上就是树转二叉树和森林转二叉树的基本方法。其中，树转二叉树的方法也可以用来将森林中的每一棵树转化为二叉树。</p><h2 id="树和二叉树的应用">树和二叉树的应用</h2><h3 id="哈夫曼树">哈夫曼树</h3><p>哈夫曼树（Huffman Tree），也称为最优二叉树，是一种带权路径长度最短的二叉树。哈夫曼树的主要应用是在数据压缩领域，特别是在无损数据压缩中。这是因为哈夫曼树能够根据数据项出现的频率为其赋予短的编码，从而实现数据的有效压缩。</p><p>哈夫曼树的构建过程如下：</p><ol><li><p>根据给定的n个权值{w1, w2, …, wn}，构造n棵只有根节点的二叉树，这些节点成为哈夫曼树的初始森林。</p></li><li><p>在森林中选择两棵根节点的权值最小的树作为左右子树，构造一棵新的二叉树，同时将这两棵树从森林中删除。新二叉树的根节点的权值设为其左右子树上根节点的权值之和。</p></li><li><p>将新构造的二叉树加入到森林中。</p></li><li><p>重复步骤2和步骤3，直到森林中只剩一棵树，这棵树就是最终的哈夫曼树。</p></li></ol><p>在哈夫曼树中，树中每个节点的权值都大于或等于其子节点的权值。树的带权路径长度（weighted path length）为树中所有叶节点的权值与其路径长度之积的总和，也就是说，哈夫曼树的带权路径长度最小。</p><p>哈夫曼编码就是基于哈夫曼树进行的，每一步向左走记录一个0，向右走记录一个1(这个并不唯一, 有可能是相反的)，最后得到每个字符的哈夫曼编码。这种编码方式的优点是最小化了整体编码的平均长度，从而达到了数据压缩的目的。</p><h3 id="并查集">并查集</h3><p>并查集（Disjoint Set）是一种处理不相交集合（disjoint set）的数据结构。其核心思想是用一种树形结构来表示一系列不相交的集合，常用于解决一些元素分类问题。它有两个主要操作：并（Union）和查（Find）。</p><ol><li><p><strong>并（Union）</strong>：这个操作用于将两个集合合并成一个集合。一般情况下，为了更有效率地执行这个操作，我们会使用一种称为“按秩合并”的策略，即总是将较小的集合合并到较大的集合中。</p></li><li><p><strong>查（Find）</strong>：这个操作用于确定某个元素属于哪个集合。这通常通过找到元素的“代表元素”或者称为“根”来完成。在执行查操作的过程中，为了提高效率，我们通常会使用一种称为“路径压缩”的策略，<strong>即在查找的过程中，将元素的父节点直接设为根节点</strong>。</p></li></ol><p>并查集的实现通常基于一个数组。数组中的每个元素都有一个父节点，如果元素是集合的根，则父节点是其自身。此外，为了实现按秩合并，我们还需要一个额外的数组来保存每个元素的秩（即以元素为根的子树的高度）。</p><p>并查集在各种问题中都有应用，例如网络连通性问题、最小生成树问题等。其主要优点是对于m个操作，n个元素的问题，可以在O(mα(n))的复杂度内解决，其中α(n)是阿克曼函数的反函数，是一个增长非常慢的函数，在实际中可以认为其值不超过5，因此并查集的操作几乎可以被看做是线性的。</p><h2 id="做题总结">做题总结</h2><ul><li>完全二叉树度为1的结点个数,  要么是0个要么是1个</li><li>才用链表形式存储树,  n个结点 必有n+1个空指针   证明:  2*n - (n - 1)  用全部指针个数 -  被使用了的指针个数</li><li>索引二叉树中使用了 n+1 个索引数,  也就是 上面的空指针数量</li><li><strong>索引二叉树是一种物理结构</strong></li><li><strong>对于先序和后序相反的二叉树,  必须满足只有一个叶节点</strong></li><li>对于索引二叉树的题目,  我们可以画简单的图来表示,然后尝试连接空链域,然后作答</li><li>用二叉树表示森林的时候,  <strong>从根节点往右,  只要右指针不为空,就说明包含一个子树</strong></li><li>二叉树表示树的时候,  <strong>右节点是右边的兄弟结点</strong></li><li>树转化成二叉树的时候,   二叉树中无右孩子结点个数 = 树中度不为零的结点数量  + 1</li><li>森林和树对应的二叉树中,  左孩子结点为空,就代表它是叶子结点</li><li>森林中树的数量,   已知森林中 树结点数量总和为 n, 边的数量总和为 e  则 树的数量为  n-e ,  证明如下: 设树的数量为 x , 将树全部连接到一个结点  此时  总结点数量为  n+1 边的数量为  e+x  又满足  n+1 = e+x+1 所以 x = n-e</li></ul><p><strong>下面这张图很重要</strong></p><p><img src="/2023/06/27/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84assets/image-20230712223228345.png" alt="image-20230712223228345"></p><p>如果一个题目中有了遍历顺序,  无论是树还是森林,  我们只要把这个序列转化成  对应的二叉树序列,  然后, 根据这个二叉树的性质来做题,  比如如果这个二叉树是表示森林, 那么 根节点一直往右的结点就是每个树的根结点,   <strong>如果是森林, 那么根节点必没有右子树</strong></p><h2 id="none"></h2><h1>图</h1><h2 id="前言">前言</h2><p>主要掌握深度优先搜索和广度优先搜索算法, 掌握图的基本概念及基本性质,图的存储结构及其特性, 存储结构之间的相互转换,基于存储结构的遍历操作和各种应用.</p><h2 id="基本概念">基本概念</h2><p>图是一种复杂的非线性数据结构，用于表示物体间复杂的多对多关系。它由以下几部分构成：</p><ol><li><p><strong>顶点（Vertex）</strong>：图中的元素，也被称为节点。</p></li><li><p><strong>边（Edge）</strong>：图中的连接，它连接两个顶点。在无向图中，边没有方向；在有向图中，边有方向。</p></li><li><p><strong>无向图（Undirected Graph）</strong>：图中的所有边都没有方向。</p></li><li><p><strong>有向图（Directed Graph）</strong>：图中的一些或所有边有方向。</p></li><li><p><strong>带权图（Weighted Graph）</strong>：图的边附带了权值。</p></li><li><p><strong>路径（Path）</strong>：在图中从一个顶点到另一个顶点的顶点边序列。</p></li><li><p><strong>循环（Cycle）</strong>：在一个路径中，第一个顶点和最后一个顶点相同的路径。</p></li><li><p><strong>连通分量（Connected Component）</strong>：在无向图中，任意两个顶点通过路径相连的顶点集合。</p></li><li><p><strong>强连通分量（Strongly Connected Component）</strong>：在有向图中，任意两个顶点都存在双向路径的顶点集合。</p></li><li><p><strong>子图（Subgraph）</strong>：由图的部分顶点和部分边组成，边的端点仍在顶点集内的图。</p></li><li><p><strong>度（Degree）</strong>：对于无向图，顶点的度是与该顶点相关联的边的数目。对于有向图，度分为入度和出度，入度表示指向顶点的边的数量，出度表示从顶点出发的边的数量。</p></li><li><p>生成树: 在连通图中, 包含全部结点的极小连通子图,  也就是说 结点数为图的数量n, 但是边数只有n-1 而且 这n-1个边必须连通n个结点</p></li><li><p>生成森林: 在非连通图中,  连通分量的生成树的集合就构成了生成森林</p></li><li><p>简单路径,简单回路:  简单路径就是路径中不包含重复的结点, 简单回路就是 除了起始和结束结点相同,其他结点都不相同</p></li><li><p>有向树: 一个顶点入度为0, 其余结点入读为1的有向图 就是 有向树</p></li></ol><p>图广泛应用于社交网络、物联网、通信网络、交通网络、数据组织等许多领域。</p><h2 id="图的存储">图的存储</h2><ol><li><p><strong>邻接矩阵（Adjacency Matrix）</strong>：邻接矩阵是图最直接的一种存储结构，主要用一个二维数组来描述图中顶点之间的关系。邻接矩阵易于理解和实现，但是对于稀疏图（图中边的数量远小于顶点数量的平方）可能会造成空间的浪费，因为无论图的边的多少，都需要为每对顶点分配存储空间。</p><p>对于无权图，邻接矩阵通常用0或1表示顶点之间是否存在边；对于有权图，则在相应的位置存储权重值。对于无向图，其邻接矩阵是对称的；对于有向图，则不一定。</p></li><li><p><strong>邻接表（Adjacency List）</strong>：邻接表是一种更为紧凑的存储方式，特别适合于存储稀疏图。它主要由一个一维数组和几个链表组成。一维数组中的每个元素对应一个链表，链表中的元素则表示与该顶点相邻的其他顶点。邻接表比邻接矩阵更节省存储空间，但查询两个顶点之间是否存在边需要遍历链表，时间复杂度可能较高。</p></li><li><p><strong>邻接多重表</strong>：邻接多重表是一种针对<strong>无向图</strong>的存储方式，它既方便查找顶点的度，也方便找到与给定边相邻接的边。邻接多重表在邻接表的基础上，链表中的节点存储的信息更丰富，每个节点除了保存邻接点的信息外，还保存了与邻接点相连的边的信息。</p></li><li><p><strong>边集数组</strong>：边集数组是另一种适用于稀疏图的存储方式，它主要关注图的边，而不是顶点。边集数组由两个一维数组构成：一个存储图的顶点，另一个存储图的边和边的两个端点。</p></li><li><p><strong>十字链表（Orthogonal List）</strong>：十字链表是一种针对<strong>有向图</strong>的存储结构，它既可以方便地获取任一顶点的入度和出度，又可以方便地找到与某条弧邻接的弧。十字链表有两个链表，一个记录顶点的出度，一个记录顶点的入度。</p></li><li><p><strong>邻接矩阵链表（Adjacency Lists of Matrix）</strong>：它是邻接矩阵和邻接表的结合，它在存储图的结构信息时，结点数据部分采用邻接矩阵的存储方式，而结点的链接部分采用邻接表的存储方式。</p></li></ol><p>以上就是对图存储的详细总结，每种存储方式都有各自的适用场景，需要根据实际问题来选择合适的存储结构。</p><p><strong>十字链表是一种专门用于有向图存储的数据结构</strong>。对于每个顶点，它都有两个链表，一个记录该顶点的出边，另一个记录该顶点的入边。因此，十字链表不仅可以方便地找到与某个顶点邻接的所有顶点，<strong>还可以方便地获取任一顶点的入度和出度。</strong></p><p>十字链表的每个节点主要包含以下部分：</p><ol><li>数据域：保存顶点信息；</li><li>第一邻接点域：<strong>指向依附于该顶点的第一条出边</strong>； 通过这个链表能够找到所有的出边</li><li>第一入边域：<strong>指向依附于该顶点的第一条入边</strong>。通过这个链表能够找到所有的入边</li></ol><p>除了顶点的信息外，十字链表还需要保存边的信息。边的信息是一个单链表节点，主要包含以下部分：</p><ol><li>数据域：保存边的信息，比如权重等；</li><li>尾域：<strong>指向该边的弧尾(也就是, 出边是这条边的结点)</strong>；</li><li>头域：<strong>指向该边的弧头(也就是,入边是这条边的结点)</strong>；</li><li>头链域：指向下一条以该点为弧头的边，<strong>即这个结点的下一条入边</strong>；</li><li>尾链域：指向下一条以该点为弧尾的边，<strong>即这个点的下一条出边</strong>。</li></ol><p>以这样的方式，十字链表能够方便地获取任一顶点的入度和出度，以及依附于任一顶点的所有边，可以高效地进行各种有向图操作。但需要注意的是，十字链表的存储方式较为复杂，需要维护的指针较多，因此，在实际使用时，需要根据问题的具体情况来考虑是否选择使用十字链表。</p><h2 id="图的遍历">图的遍历</h2><p>图的遍历是一种基本的图操作，其目标是访问图中的每个顶点并做某种操作，但每个顶点只能被访问一次。图的遍历主要有两种策略：深度优先搜索（DFS）和广度优先搜索（BFS）。</p><ol><li><p><strong>深度优先搜索（DFS）</strong>：从图中的某一顶点开始进行遍历，沿着某一分支深入下去，直到无法继续为止，然后回溯至前一顶点，转向下一分支，重复此过程，直到所有顶点都被访问过。DFS类似于树的先序遍历。</p></li><li><p><strong>广度优先搜索（BFS）</strong>：从图中的某一顶点开始进行遍历，首先访问该顶点的所有邻接顶点，然后再对这些邻接顶点进行同样的处理，即首先访问这些邻接顶点的所有未被访问的邻接点，以此类推，直到所有顶点都被访问过。BFS类似于树的层次遍历。</p></li></ol><p>需要注意的是，由于图可能存在环，因此在遍历的过程中需要标记已访问过的节点，以防止陷入无限循环。此外，对于非连通图（即包含多个不相交的子图的图），需要从不同的顶点开始，重复上述过程，以确保访问到图中的所有顶点。</p><p>图的遍历应用广泛，包括路径查找，环检测，连通性检查，图的复制等许多问题。</p><h2 id="图的应用">图的应用</h2><h3 id="最小生成树">最小生成树</h3><p>最小生成树是图论中的一个重要概念，用于描述一个加权连通图中连接所有顶点的最小权值的树。</p><p>最小生成树的性质包括：</p><ol><li><p>包含图中所有顶点：一个图的最小生成树应包含图中的所有顶点。</p></li><li><p>树中只有 (n-1) 条边：如果一个图有 n 个顶点，那么其最小生成树只有 (n-1) 条边。</p></li><li><p>总权值最小：在所有可能的生成树中，最小生成树的权值总和最小。</p></li></ol><p>主要的最小生成树算法有：</p><ol><li><p><strong>普里姆（Prim）算法</strong>：从某一个顶点开始，每次选择当前已访问的顶点中距离最近的一个未访问顶点，将其添加到已访问顶点的集合中，直到所有顶点都被访问。</p></li><li><p><strong>克鲁斯卡尔（Kruskal）算法</strong>：按照边的权值从小到大的顺序选择边，如果这条边连接的两个顶点在已经生成的森林中不在同一棵树（即不形成环），那么就将这条边添加到最小生成树中。</p></li></ol><p>这两种算法都能有效地找到最小生成树，但是适用的场景略有不同。<strong>普里姆算法适合于稠密图</strong>，<strong>而克鲁斯卡尔算法适合于稀疏图</strong>。</p><p>无论是Prim算法还是Kruskal算法，在寻找最小生成树的过程中，都会遵循一个基本原则：<strong>在保证生成树连通的前提下，每次都选择权值最小的边加入到生成树中。这种每次选择当前最好的选项，也就是所谓的&quot;贪心&quot;策略，是最小生成树算法的共同思想。</strong></p><p>需要注意的是，虽然这种贪心策略在最小生成树问题上能够得到全局最优解，但在其他一些问题上，贪心策略可能无法得到全局最优解，因为它没有考虑到对未来决策的影响。</p><h3 id="最短路径">最短路径</h3><h4 id="迪杰斯特拉算法-单源路径">迪杰斯特拉算法(单源路径)</h4><p>迪杰斯特拉算法，是由荷兰计算机科学家Edsger Wybe Dijkstra在1956年发明的，用于求解给定源节点到图中所有其他节点的最短路径问题。它的主要思想是采用贪心算法的策略，每次寻找最短的边，并更新与其相邻的节点的最短路径。以下是算法的具体步骤：</p><ol><li><p><strong>初始化</strong>：首先设置一个集合，用来记录已经找到最短路径的节点。然后设置一个距离数组，距离数组的索引表示节点编号，值表示从源节点到该节点的最短路径长度。在开始时，源节点到自己的距离设为0，源节点到其他节点的距离设为无穷大。</p></li><li><p><strong>选择节点</strong>：在未被加入集合的节点中，选择一个距离源节点最近（即距离值最小）的节点，将其加入到集合中。初次选择时，将会选择源节点自身。</p></li><li><p><strong>更新距离</strong>：将新加入集合的节点，标记为当前节点。遍历与当前节点直接相连的所有未被加入集合的节点，比较从源节点到该节点的已知最短路径（即距离数组中的值）与从源节点经过当前节点到该节点的路径长度，如果后者更短，就更新该节点在距离数组中的值。</p></li><li><p><strong>重复步骤</strong>：重复步骤2和步骤3，直到所有节点都被加入到集合中，或者找不到新的可以加入集合的节点为止。这时，距离数组中的值就表示了从源节点到各节点的最短路径长度。</p></li></ol><p>值得注意的是，由于Dijkstra算法在选择节点时，总是选择距离源节点最近的节点，因此它不能处理图中包含负权边的情况。<strong>如果图中存在负权边，可能会导致已经被加入集合的节点的最短路径长度发生变化</strong>，这与Dijkstra算法的基本假设相矛盾。对于这种情况，可以使用其他算法如Bellman-Ford算法等来处理。</p><h4 id="floyd算法求各个顶点最短路径">Floyd算法求各个顶点最短路径</h4><p>Floyd算法，全称Floyd-Warshall算法，是一种解决&quot;所有节点之间的最短路径&quot;问题的动态规划算法。这种算法能够正确处理图中有向、无向以及存在负权边的情况，<strong>但不能处理存在负环的情况</strong>。以下是Floyd算法的基本步骤：</p><ol><li><p>初始化距离矩阵：首先，构建一个n×n的矩阵（n为图中节点数量），其中矩阵的第i行第j列的元素表示从节点i到节点j的边的权重。如果i和j之间没有直接的边，那么这个值被设置为正无穷。</p></li><li><p>动态规划更新距离：对于矩阵中的每一个元素，<strong>尝试通过所有其他的节点作为中间节点，看是否能够找到一条更短的路径</strong>。具体来说，对于矩阵中的每一个元素dist[i][j]，遍历所有的k（0≤k&lt;n），并将dist[i][j]更新为min(dist[i][j], dist[i][k]+dist[k][j])。</p></li><li><p>返回结果：最后，矩阵中的每一个元素dist[i][j]表示的就是从节点i到节点j的最短路径的长度。</p></li></ol><p>Floyd算法的时间复杂度是O(n^3)，其中n是图中节点的数量。尽管它比许多其他的最短路径算法更慢，但是它的优点是简单、直观，且能够处理所有节点对之间的最短路径问题。</p><h3 id="拓扑排序">拓扑排序</h3><p>在图论中，有向无环图（Directed Acyclic Graph，<strong>简称DAG</strong>）是一种特殊的图，它的特性就是没有形成环路（或者称为循环、回路）的有向边。由于其无环的特性，有向无环图在很多场合都有应用，如任务调度、数据分析、编译优化等。</p><p>AOV网（Activity On Vertex network）又称顶点活动图，是一种特殊的有向无环图（DAG，Directed Acyclic Graph），<strong>在AOV网中，每个顶点都对应一个活动，而边则表示活动之间的优先关系。</strong></p><p>**拓扑排序（Topological Sorting）**是针对有向无环图（DAG, Directed Acyclic Graph）的一种排序算法，它的结果是一个线性序列，满足对于图中的每对有向边(u, v)，u在序列中都出现在v之前。也可以理解为，如果存在一条从顶点u到顶点v的路径，那么在拓扑排序结果中，u总是出现在v的前面。</p><p>以下是一种常用的拓扑排序的步骤：</p><ol><li><p>找到图中所有入度为0的顶点，将它们放入队列。</p></li><li><p>从队列中移除一个顶点，将它添加到排序结果的尾部。</p></li><li><p>遍历由该顶点出发的所有边，将这些边指向的顶点的入度减1。如果某个顶点的入度减为0，那么将它加入到队列。</p></li><li><p>重复步骤2和3，直到队列为空。</p></li><li><p>如果得到的排序结果中包含的顶点数量和图中的顶点数量相同，那么这个排序就是图的一个拓扑排序。如果顶点数量不同，那么说明图中存在环，无法进行拓扑排序。</p></li></ol><p>拓扑排序在诸如项目调度、编译器的指令调度、解决具有依赖关系的任务等领域有广泛应用。</p><p><strong>逆拓扑排序就是 找出度为0的顶点, 然后删除所有以它为终点的边</strong></p><h3 id="关键路径">关键路径</h3><p>AOE（Activity On Edge）网络，又称边表示活动的网络，是一种特殊的有向图，其中的顶点表示事件，边表示活动，边上的权值通常表示活动的时间。AOE网络常用于项目管理中，如PERT（Program Evaluation Review Technique）/CPM（Critical Path Method）技术中，用于表示和分析任务的先后关系。</p><p>在一个AOE网络中：</p><ol><li><p>顶点代表事件，是一个状态或条件，通常表示活动的开始或结束。</p></li><li><p>边代表活动，是在两个事件之间发生的工作或任务。边上的权重通常代表完成这个活动所需的时间或资源。</p></li><li><p>AOE网是一个有向无环图，从开始事件到结束事件至少存在一条路径。</p></li><li><p>最长路径（即具有最大权重的路径）被称为关键路径，关键路径上的活动称为关键活动。这些活动是影响整个项目完成时间的关键，任何一个关键活动的延迟都会导致整个项目的延迟。</p></li><li><p>AOE网只存在一个入度为0的顶点, 也只存在一个出度为0的顶点</p></li></ol><p>AOE网和AOV网的区别在于  一个边有权值,另外一个没有,仅仅表示前后关系</p><p>在AOE（Activity On Edge）网络中，关键活动是那些最早开始时间等于最晚开始时间（或最早完成时间等于最晚完成时间）的活动。这些活动是非常重要的，因为任何关键活动的延误都会导致整个项目的延误。以下是如何计算这些参量的:</p><ol><li>最早开始时间（EST）和最早完成时间（EFT）：</li></ol><ul><li>EST: 对于一个具有多个前驱的顶点，其最早开始时间应该是所有前驱节点的最早完成时间的最大值。</li><li>EFT: 一旦确定了活动的EST，我们可以通过将活动的持续时间加到EST上来计算其EFT。</li></ul><p>计算EST和EFT的过程是从AOE网络的源节点（无入度的顶点）开始，按照拓扑排序的顺序进行的。</p><ol start="2"><li>最晚开始时间（LST）和最晚完成时间（LFT）：</li></ol><ul><li>LFT: 对于一个具有多个后继的顶点，其最晚完成时间应该是所有后继节点的最晚开始时间的最小值。</li><li>LST: 一旦确定了活动的LFT，我们可以通过从LFT中减去活动的持续时间来计算其LST。</li></ul><p>计算LST和LFT的过程是从AOE网络的汇点（无出度的顶点）开始，按照拓扑排序的逆序进行的。</p><ol start="3"><li>松弛时间（Slack Time）：每个活动的松弛时间等于其LST减去其EST，或者其LFT减去其EFT。</li></ol><p><strong>关键活动就是松弛时间为0的活动。它们构成了项目的关键路径，即整个项目中最长的路径，其长度决定了项目的最短完成时间。</strong></p><h2 id="做题总结">做题总结</h2><ul><li>对于非连通图 来说,   最多的边数便是  (n-1)*(n-2) / 2  单独拿出一个结点成为连通分量,  这样的话,边数是最多的  =&gt; 这样可以等价于已知边数求 最小节点数</li><li>已知结点数, 求图是连通的最小边数,  这个可以利用上面的结论, 求出非连通的图的最多边数+1 便是答案</li><li>连通分量是极大连通子图,<strong>它包含了里面的所有顶点和所有边</strong>, 因此<strong>生成树可能不是一个连通分量</strong></li><li>强连通分量是指 极大强连通子图,  它和极大连通子图还有有很大差别的, 极大连通子图是指一块的所有边和顶点,  而极大强连通子图是指 这个子图中  所有的顶点都有相互到达的弧</li></ul><h1>查找</h1><h2 id="前言">前言</h2><p>本章是考研命题的重点, 对于散列查找, 要掌握散列表的构造, 冲突解决方法, 查找成功和失败的平均查找长度,散列查找的特征和性能分析, 对于折半查找,应掌握折半查找的过程,构造判定树,分析平均查找长度,  B树和B+树 要要掌握基本概念与操作</p><h2 id="顺序查找">顺序查找</h2><h3 id="一般线性表的顺序查找">一般线性表的顺序查找</h3><h3 id="有序表的顺序查找">有序表的顺序查找</h3><p>这里和折半查找的思想还是有所不同的,  它是顺序往下比较, 如果发现条件不满足了,说明后续的元素肯定也不满足,直接返回查找失败</p><p>而且这里的有序表可以使用链式存储结构, 对于折半查找, 是不能使用链式的</p><h2 id="折半查找">折半查找</h2><h2 id="分块查找">分块查找</h2><h2 id="树形查找">树形查找</h2><h3 id="二叉排序树">二叉排序树</h3><p>二叉排序树， 又被称为二叉查找树或二叉搜索树，是一种特殊的二叉树。它或者是空树，或者是满足以下性质的二叉树：</p><ol><li><p>如果左子树不为空，则左子树上所有节点的值均小于它的根节点的值。</p></li><li><p>如果右子树不为空，则右子树上所有节点的值均大于它的根节点的值。</p></li><li><p>它的左、右子树也分别为二叉排序树。</p></li></ol><p>二叉排序树的主要操作有：插入、删除和查找。</p><ul><li><p><strong>插入操作</strong>：新插入的节点总是作为叶子节点，并且满足二叉排序树的性质。</p></li><li><p><strong>删除操作</strong>：删除节点时需要考虑以下三种情况：</p><ul><li><p>删除的节点是叶子节点，直接删除。</p></li><li><p>删除的节点只有一个子树（只有左子树或只有右子树），将其子树连到其父节点上。</p></li><li><p>删除的节点有两个子树，通常有两种处理方式：一种是找到这个节点的前驱（左子树中的最大值）或者后继（右子树中的最小值）来替代当前节点，然后删除这个前驱或后继节点；另一种是直接删除这个节点，然后重新构造左右子树。</p></li></ul></li><li><p><strong>查找操作</strong>：从根节点开始，如果查找的值等于当前节点的值，查找成功；如果查找的值小于当前节点的值，则继续在左子树中查找；如果查找的值大于当前节点的值，则继续在右子树中查找。</p></li></ul><p>二叉排序树的主要优点是查找、插入和删除的时间复杂度在平均情况下都为O(log n)，但在最坏情况下（如树变成链状结构）会退化到O(n)。为了解决这个问题，引入了平衡二叉排序树（如AVL树、红黑树等），它们在插入和删除时会通过旋转等操作来保持树的平衡，确保操作的时间复杂度始终为O(log n)。</p><h3 id="平衡二叉树">平衡二叉树</h3><p>平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，它的每一个节点的左右子树的高度差的绝对值不能超过1。平衡二叉树主要用于解决普通二叉查找树在数据极度偏斜时的效率问题，也就是说，对于任何一个节点来说，它的左子树和右子树的高度差不能超过1。</p><p><strong>平衡因子（Balance Factor）</strong>：某节点的左子树与右子树的高度差。在平衡二叉树中，所有节点的平衡因子只可能是 -1、0 或 1。</p><p>AVL树的特性是：对任一节点，其左子树和右子树的高度差的绝对值最多为1。也就是说，AVL树始终保持&quot;平衡&quot;的状态。当进行插入或删除导致平衡被破坏时，AVL树会通过旋转操作来恢复平衡。</p><p><strong>旋转操作</strong>：</p><ul><li>左旋（Right rotation）：针对右子树的高度大于左子树，且插入在右子树的右边的情况。也就是&quot;右-右&quot;情况，或简写为RR情况。</li><li>右旋（Left rotation）：针对左子树的高度大于右子树，且插入在左子树的左边的情况。也就是&quot;左-左&quot;情况，或简写为LL情况。</li><li>左右旋（Right-left rotation）：针对左子树的高度大于右子树，且插入在左子树的右边的情况。也就是&quot;左-右&quot;情况，或简写为LR情况。</li><li>右左旋（Left-right rotation）：针对右子树的高度大于左子树，且插入在右子树的左边的情况。也就是&quot;右-左&quot;情况，或简写为RL情况。</li></ul><p>AVL树的主要优点是查找、插入和删除的最坏情况时间复杂度都是O(log N)。然而，AVL树的缺点是每次插入或删除都可能需要一次或多次旋转来维持平衡，造成较大的开销。因此，当需要频繁插入和删除的时候，可以选择使用其它自平衡二叉搜索树，如红黑树等。</p><h3 id="红黑树">红黑树</h3><p>红黑树是一种自平衡二叉查找树，它在1972年由Rudolf Bayer首次提出，并在1978年由Leonidas J. Guibas和Robert Sedgewick进行了改进。红黑树的名字来源于节点可以被标记为红色或黑色。</p><p>在红黑树中，我们维护以下性质：</p><ol><li>每个节点都被赋予红色或黑色。</li><li>树的根节点是黑色的。</li><li>所有的叶子节点（这里指的是空的叶子节点，或称为NIL节点）都是黑色的。<strong>(相当于引入了n+1个外部结点)</strong></li><li>如果一个节点是红色的，那么它的两个子节点都是黑色的（也就是说，在红黑树中，不能有两个相邻的红色节点，红色节点是被黑色节点隔开的）。</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，包含相同数量的黑色节点。</li></ol><p>这些性质确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间复杂度都是对数级别的。<strong>红结点要么度为0,要么度为2</strong></p><ul><li><p><strong>插入操作</strong>：当插入一个节点时，我们首先按照二叉查找树的规则插入该节点。然后，我们将它标记为红色。插入红色节点可能会违反红黑树的性质，所以可能需要进行一些颜色调整和/或树旋转操作来修复可能的红黑树性质的破坏。</p></li><li><p><strong>删除操作</strong>：当删除一个节点时，我们首先按照二叉查找树的规则删除该节点。然后，我们通过颜色调整和/或树旋转操作来修复可能的红黑树性质的破坏。</p></li><li><p><strong>查找操作</strong>：查找操作和在普通的二叉查找树中完全一样。我们从根节点开始，如果查找的值等于当前节点的值，查找成功；如果查找的值小于当前节点的值，则继续在左子树中查找；如果查找的值大于当前节点的值，则继续在右子树中查找。</p></li></ul><p>红黑树是许多数据结构和算法的核心，例如Java的TreeMap和TreeSet，Linux内核的完全公平调度器，还有C++的标准模板库等都使用了红黑树。</p><h4 id="红黑树的插入">红黑树的插入</h4><p>插入结点都是红色结点, 如果使用黑色结点的话,那必然每次插入都会破坏红黑树的性质</p><p>设插入结点为 x 父节点为 p,  叔叔结点为 y  爷爷结点为 z</p><ol><li><p>如果父节点是黑色结点,则直接插入,无需调整</p></li><li><p>如果父节点是红色结点,  那么就需要调整,  如果叔叔结点(空节点也算)是黑结点,  那么在局部就能调整好</p></li></ol><ul><li>x是z的左子树的左孩子结点  对p  做LL(右旋)旋转</li><li>x是z的左子树的右孩子结点  对p 做 LR(先左后右) 旋转</li><li>x是z的右子树的左孩子   对 p 做 RL 旋转</li><li>x是z的右子树的右孩子  对p 做 RR旋转</li></ul><p>调整完毕后,  需要交换一下颜色,  将原先z的颜色 跟当前z的颜色对调  (也就是把原先z变成红色, 现在的z变成黑色)</p><ol start="3"><li>如果父节点是红色结点,而且叔叔结点是红色结点,  这种情况是增加黑高的唯一情况(可能增加也可能不增加),  这种情况需要现在局部调整好,然后再继续向上调整</li></ol><ul><li>将z的黑色变成红色, 将z的左右孩子变成黑色</li><li>把z当成插入结点, 如果z是根节点, 那么直接变成黑色, 黑高加1, 否则继续向上调整, 直到满足红黑树的性质</li></ul><p>对于插入节点的父亲结点是红色的总结:   如果叔叔结点是黑色, 那我们完全可以在局部调整好, 让这颗子树的高度不变, 即我们可以给叔叔那边的子树添加一个红结点,  如果叔叔结点也是红色, 那局部是调整不好的, 此时需要把爷爷结点变成红色, 叔叔和父节点变成黑色, 让把爷爷结点当成插入结点继续处理</p><h4 id="红黑树的删除">红黑树的删除</h4><ol><li>首先将红黑树的删除转变为二叉排序树的删除, 即转化为删除叶节点</li><li>经过上面步骤后得到要删除的结点x(假设在左子树), 父节点p, 兄弟结点 y, 兄弟结点左孩子yl 右孩子 yr</li><li>如果x为红色, 直接删除</li><li>如果x为黑色 将x视为双黑结点<ul><li>如果兄弟结点y为红色,   将p进行左旋,交换原来p与新p的颜色,变成后续情况(新y必为黑色)</li><li>如果兄弟结点y为黑色,   y的靠近x的子节点为红色,另外一个为黑色,  比如如果x在左边, 那么靠近它的就是yl, 将y进行右旋,交换现在的y和原来y的颜色, 变成下面这个情况</li><li>如果兄弟结点y为黑色,   y的远离x的子节点为红色,  比如如果x在左边, 那么远离它的就是yr, 将p进行左旋, 将yr变成黑色, 交换先p与原p的颜色</li><li>如果兄弟结点y为黑色, 且yr和yl都是黑色, 给p结点加一层黑色,x和y都去掉一层黑色, 如果p是双黑就继续向上调整p, 直到p为根节点,然后黑高减一</li></ul></li></ol><p>总结:  如果兄弟结点为红色, 或者兄弟结点的子节点有红色, 那么是可以在局部调整好的, 可以把这个多余红色变成黑色然后弥补删除节点后少了的黑高, 如果兄弟结点为黑色且其子节点都是黑色, 那么局部是不能调整好的,需要向上调整</p><h2 id="b树和b-树">B树和B+树</h2><p>B树，也称为平衡多路查找树，是一种对读写操作进行优化的自平衡的搜索树，能够保持数据有序。这种数据结构能够广泛应用于大型系统的文件系统和数据库系统里。</p><p>下面是B树的几个基本特性：</p><ol><li><p>B树的每个节点X都有以下属性：</p><ul><li>n[X]：存储在节点X中的关键字的数量</li><li>n[X]个关键字本身，已经从小到大排序：key1[X] &lt; key2[X] &lt; … &lt; keyn[X]</li><li>leaf[X]：一个布尔值，如果节点X是叶子节点，则为true，否则为false。</li></ul></li><li><p>B树的每个节点X还包含n[X]+1个指向其孩子的指针：c1[X], c2[X], …, cn[X]+1[X]。关键字ki[X]分割存储在各个孩子中的关键字，例如：所有在ci[X]中的关键字小于ki[X]，所有在ci+1[X]中的关键字大于ki[X]。</p></li><li><p>所有叶子节点都有相同的深度，即树的高度。</p></li><li><p>有上限和下限界定节点的关键字的数量。设t是树的最小度数：</p><ul><li>每个节点关键字的数量必须至少有t-1个，除了根节点外。</li><li>每个节点的关键字数量不能超过2t-1个。如果一个节点的关键字数量达到2t-1，称为满节点。</li></ul></li></ol><p>操作方面，B树支持查找、插入和删除操作：</p><ul><li><p><strong>查找</strong>：由于B树的定义，一个简单的从根节点到叶子节点的递归遍历过程可以找到关键字。</p></li><li><p><strong>插入</strong>：插入新的关键字到B树中，首先找到应该插入的位置（必须是叶子节点）。如果叶子节点未满（即关键字数量少于2t-1），那么直接在节点中插入关键字。否则，需要分裂节点并将关键字向上推到父节点，可能需要递归这个过程，直到找到一个未满的父节点或者创建新的根节点。</p></li><li><p><strong>删除</strong>：删除操作是最复杂的，首先需要找到关键字所在的节点。如果关键字在内部节点中，通常需要通过替换关键字和适当的重新组织子树，使问题简化为在叶子节点中删除关键字。叶子节点中的关键字可以直接删除，如果删除后节点仍满足关键字数量限制则完成，否则需要通过关键字借用或节点合并来维持B树的性质。</p></li></ul><p>B树的一个重要优点是能够保持树的高度较低，减少磁盘I/O操作，这使得它非常适合于大型存储系统中的数据查找。</p><h2 id="散列表">散列表</h2><p>散列表（Hash Table），也被称为哈希表或映射，是一种常用的数据结构，它能够在平均时间复杂度为O(1)的情况下插入、删除和查找元素。下面是散列表的基本概念和操作：</p><ol><li><p><strong>散列函数</strong>：散列表使用一种叫做散列函数（Hash Function）的函数来将输入（通常是一个关键字）映射到表中的一个位置。理想的散列函数能够将所有可能的输入均匀地分布在整个散列表上，这样可以最大程度地减少冲突。</p></li><li><p><strong>冲突解决</strong>：冲突是指两个或更多的输入通过散列函数映射到同一位置的情况。这是一个必须要解决的问题，因为它会影响到散列表的效率。常用的冲突解决方法有开放寻址（如线性探测、二次探测和双重散列）和链地址法。</p></li><li><p><strong>插入操作</strong>：要将一个元素插入到散列表中，我们先用散列函数计算出该元素应该放在哪个位置，然后将其放在那个位置。如果那个位置已经有其他元素了（即发生了冲突），我们就需要使用某种冲突解决方法来找一个新的位置。</p></li><li><p><strong>删除操作</strong>：首先使用散列函数找到要删除的元素在哪个位置，然后将其删除。如果使用的是开放寻址法解决冲突，还需要做一些额外的操作来保证其它元素仍然可以被找到。</p></li><li><p><strong>查找操作</strong>：和插入操作类似，先用散列函数计算出元素应该在哪个位置，然后在那个位置查找。如果没有找到或者那个位置有其他元素，我们需要使用之前的冲突解决方法来在表中其他位置寻找。</p></li><li><p><strong>扩容和缩容</strong>：当散列表中的元素太多（或太少）时，我们可能需要增大（或减小）散列表的大小以保持良好的性能。扩容和缩容通常涉及到创建一个新的散列表，然后将原散列表中的所有元素重新插入到新表中。</p></li><li><p><strong>负载因子</strong>：散列表的负载因子是指散列表中已经存储的元素数量和散列表的大小的比值。当负载因子过高时，冲突的可能性会增加，这会降低散列表的性能。因此，当负载因子达到一定阈值（如0.7）时，就需要进行扩容。</p></li></ol><p>注意，尽管散列表的平均时间复杂度为O(1)，但在最坏的情况下（所有的输入都映射到同一位置），插入、删除和查找的时间复杂度都可能达到O(n)，其中n为元素的数量。因此，散列表的性能在很大程度上取决于散列函数的质量和冲突解决方法的效率。</p><h2 id="做题总结">做题总结</h2><ul><li>对于折半查找的平均成功查找长度和失败查找长度我们可以这样来做 ( 1*1+2*2 + 3*4 + 4*8 + … h*2^(h-1)) 其中 h = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">log_2n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>(向上取整)  这个是总共的查找成功的次数  我们可以发现,  乘积后面这一项 其实就是二叉树每一层的结点最多数量,  但是最后一层的时候结点可能是没有充满的   除以n就是 平均成功查找长度,   而对于失败的查找长度, 我们需要画出对应的平衡二叉树,  去找度为1 和 度为0的结点,  然后用  (度为1的结点* h-1  + 度为0的结点*2*h)/n+1   <strong>根据这个公式  其实我们也可以不用画图   直接推算公式</strong>   n1 + 2n0-1 = n, 所以( n1(h-1) + 2n0*h ) /n+1 = (nh - n + 2n0 + h -1) / n+1 = h-1 + 2n0/(n+1)</li><li>折半查找生成的是一颗平衡二叉树,  所以 折半查找的速率 和 二叉排序树的速率还是有区别的</li><li>判断一个二叉树可不可能是折半查找生成树的时候, 我们先看它是不是平衡二叉树,  然后再根据树的结构给每个结点编号,如果它的中序序列是升序的, 那它就可能是折半查找生成树(说可能是因为 折半的时候中间位置可以向上取整,也可以向下取整)</li><li><strong>平衡二叉树具有这个公式:  nk代表第k层最小结点数     nh = nh-1 + nh-2 +1   其中n0 = 0 n1 = 1</strong>   达到最小结点数的情况,此时也是所有非叶子节点平衡因子为1的情况   证明:  只有每棵树的平衡因子为1或者-1的时候, 树节点才最少, 假设左子树高度为 h-1 右子树的高度为 h-2  ,  当前树的高度为h, 左右子树也满足最小结点, 所以当前树的结点个数为  nh = nh-1 + nh-2 +1</li><li>对于b树来说,   叶节点个数 = n+1 n代表关键字个数    这里的叶节点是 外部结点    因此 对于树的最小高度和最大高度问题  可以转换成叶节点的最大数量和最小数量</li><li>对于散列表的查找失败,  我们只需要看每个位置查找失败的次数</li></ul><h1>排序</h1><h2 id="前言">前言</h2><p>堆排序和快速排序还有归并排序是本章的重点,  应该要深入掌握各种排序思想, 排序过程和特征.</p><h2 id="基本概念">基本概念</h2><p>排序是将一组数据按照某种特定的顺序进行排列的过程。排序算法的设计是计算机科学中的一个重要主题，因为排序是数据处理中非常常见的需求，而且不同的排序算法适用于不同的场景和需求。</p><p>排序算法的分类：</p><ol><li><p><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，时间复杂度不能突破O(nlogn)，例如：冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序等。</p></li><li><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，可以达到线性时间复杂度，例如：计数排序、桶排序、基数排序等。</p></li></ol><p>根据算法稳定性还可以分为：</p><ul><li><p><strong>稳定排序算法</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p></li><li><p><strong>不稳定排序算法</strong>：如果a原本在b的前面，而a=b，排序之后a可能会在b的后面。</p></li></ul><p>每种排序算法都有其特点：</p><ul><li>冒泡排序：简单，但是效率较低，适用于小规模数据或者部分有序的数据。</li><li>选择排序：简单，但效率较低，不稳定，适用于小规模数据。</li><li>插入排序：相对简单，对部分有序的数据效率较高，稳定，适用于小规模数据或部分有序的数据。</li><li>快速排序：效率高，但极端情况下效率降低，不稳定，适用于大规模数据。</li><li>归并排序：效率高，稳定，但需要额外的内存空间，适用于对稳定性有要求的大规模数据。</li><li>堆排序：效率高，不稳定，适用于大规模数据。</li><li>计数排序、桶排序、基数排序：非比较排序，效率高，适用于一些特定条件的大规模数据。</li></ul><p>排序算法是一种基本的算法类型，学习理解各种排序算法，不仅可以帮助理解算法的设计和运作，也是许多更高级算法和数据结构的基础。</p><h2 id="插入排序">插入排序</h2><p>插入排序的基本思想是每步将一个待排序的记录，按其顺序码的大小插入到前面已经排序的序列中的适当位置，直到全部插入完成为止。</p><p>插入排序主要有三种形式：直接插入排序，折半插入排序，和希尔排序。</p><ol><li><p><strong>直接插入排序</strong>：其基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。<strong>直接插入排序是稳定的排序算法</strong>，最好情况下的时间复杂度为O(n)，最坏情况下的时间复杂度为O(n²)，平均情况下的时间复杂度也是O(n²)。</p></li><li><p><strong>折半插入排序</strong>：这是对直接插入排序算法的改进。由于在前面部分的排序过程中，插入一条记录需要比较的次数较多，所以改进的方法是将插入的记录的查找和后移同时进行。每次将待插入的记录与已排序区的中间记录比较，可以确定插入的位置范围，从而减少了比较的次数。<strong>折半插入排序是稳定的排序算法</strong>，时间复杂度为O(n²)。</p></li><li><p><strong>希尔排序</strong>：又称缩小增量排序，是对直接插入排序算法的改进，它对直接插入排序进行了简单而又高效的改进：先将待排序的序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序**。希尔排序是不稳定的排序算法**，最坏情况下的时间复杂度为O(n²)，但是实际的性能要好于O(n²)。</p></li></ol><p>以上三种排序方法都属于插入排序的范畴，但它们的效率和应用场景有所不同，可以根据实际需要选择使用。</p><h2 id="交换排序">交换排序</h2><p>交换排序的基本思想是通过不断地交换相邻的两个错位元素达到排序的目的。主要有冒泡排序和快速排序两种实现方式：</p><ol><li><p><strong>冒泡排序（Bubble Sort）</strong>：冒泡排序是一种简单的排序算法，通过重复地遍历要排序的列表，比较每对相邻的元素，如果它们的顺序错误就把它们交换过来，遍历列表的工作是重复地进行直到没有更多的交换为止。这种算法的名字由来是因为越小（或越大）的元素会经过交换慢慢“浮”到数列的顶端，仿佛这些元素在液体中像是气泡一样向上冒泡。冒泡排序是稳定的排序方法，时间复杂度为O(n²)。</p></li><li><p><strong>快速排序（Quick Sort）</strong>：快速排序是冒泡排序的一种改进，其基本思想是选择一个基准元素，通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<strong>快速排序是不稳定的排序方法</strong>，最坏情况下的时间复杂度为O(n²)，但在平均情况下时间复杂度为O(nlogn)，并且常数因子较小，因此在实际中快速排序的效率通常比其他的复杂度为O(nlogn)的排序算法要好。</p></li></ol><p>两种交换排序的方式在实际应用中都有广泛的使用，它们各有优缺点，可以根据具体的需求进行选择使用。</p><h2 id="选择排序">选择排序</h2><p>选择排序是一种简单直观的排序算法，它的工作原理如下：</p><ol><li>在未排序的序列中找到最小（或最大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。</li><li>以此类推，直到所有元素均排序完毕。</li></ol><p>选择排序有两种类型：简单选择排序和堆排序。</p><ul><li><p><strong>简单选择排序</strong>：是最基本的选择排序算法，它的基本思想是在每一趟排序中，从待排序的数据元素中选出最小（或最大）的一个元素，放在序列的起始位置，然后依次移动“窗口”，并在剩余的未排序元素中寻找最小（或最大）元素，放到已排序序列的末尾，直到全部待排序的数据元素排完。简单选择排序是不稳定的排序方法，时间复杂度为O(n²)。</p></li><li><p><strong>堆排序</strong>：堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆的定义是：具有n个元素的序列（h1,h2,…,hn)，当且仅当满足（hi&lt;=h2i, hi&lt;=h2i+1或者hi&gt;=h2i, hi&gt;=h2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其他元素自上而下、由左到右填入。堆排序的时间复杂度为O(nlogn)，<strong>堆排序是不稳定的排序方法</strong>，但是空间复杂度为O(1)。</p></li></ul><p>总结来说，选择排序在实际应用中使用不多，主要因为其效率较低，尤其是简单选择排序。然而，堆排序在需要排序大量数据，且对内存使用有较严格限制的场景下，仍有一定的使用价值。</p><h2 id="归并排序">归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效、<strong>稳定的排序算法</strong>，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。其主要包括两个过程：分解和合并。</p><ol><li><p><strong>分解</strong>：将需要排序的数组不断地一分为二，直到每个子数组只有一个元素为止。一个元素的数组自然是有序的。</p></li><li><p><strong>合并</strong>：将两个有序的子数组合并成一个有序的数组。重复这个过程，直到最后只剩下一个有序的数组。</p></li></ol><p><strong>步骤如下</strong>：</p><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列。</li><li>对这两个子序列分别进行归并排序。</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><p>归并排序的时间复杂度为 O(n log n)，空间复杂度为 O(n)。因为在合并阶段，需要额外的空间来临时存储合并后的结果。在实际应用中，归并排序适用于数据量大，且对稳定性有要求的情况。但由于其需要较大的额外空间，对于空间要求较高的场景则不太适合。</p><p>一般说归并排序，我们都是指自顶向下的归并排序，也就是首先进行分解，然后再合并。还有一种自底向上的归并排序，是先进行两两合并，然后四四合并，然后八八合并，直到最后全部合并完成。自底向上的归并排序常用于链表排序，因为链表的特性更适合从局部开始合并。</p><h2 id="基数排序">基数排序</h2><p>基数排序（Radix sort）是一种<strong>非比较型整数排序算法</strong>，其思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p>基本步骤是：</p><ol><li><p>从最低位开始，将所有数值进行分类，将其放入对应的桶中。</p></li><li><p>收集所有桶中的数值，按照桶的顺序（一般从0到9）将数值一次放回原来的序列中。</p></li><li><p>对下一个较高的位数进行1和2的步骤，直到所有的位数都被分类过。</p></li></ol><p>这种方法对于位数较少的数值排序效果非常好，特别是对于非负整数。其时间复杂度在最坏情况下为 O(nk)，其中 n 是输入的数值数量，k 是数值的最大位数。然而，这种方法对于位数较多或数值范围较大的数值，效率并不是很高，因为 k 会很大。而且这种方法只适用于整数排序，对于浮点数则需要额外的处理方法。</p><p><strong>基数排序是稳定的</strong>，也就是说，对于相等的元素，我们可以得到它们的原始相对顺序。另外，基数排序的过程是线性的，不需要比较操作。</p><h2 id="外部排序">外部排序</h2><p>外部排序是处理大数据量排序的一种方式，当要排序的数据无法全部加载到内存中时，我们需要使用到外部排序。外部排序最常见的算法是多路归并排序，其基本思想是分阶段进行。</p><p>在外部排序中，常常采用的是一种“排序-归并”的策略：</p><ol><li><p><strong>排序阶段</strong>：将大文件划分为n个能加载到内存中的小文件，然后分别加载到内存中进行排序（使用任意内部排序算法，比如快速排序），最后将排序好的小文件写回磁盘。</p></li><li><p><strong>归并阶段</strong>：将小文件合并为一个有序的大文件。因为每个小文件已经是有序的，我们可以对这些小文件进行归并排序。由于文件数量可能非常大，以至于无法全部加载到内存中，我们可以采用<strong>多路归并排序</strong>的方式。</p></li></ol><p>在多路归并排序中，首先采用归并的方式将小文件k路合并，得到n/k个新的小文件；然后再对新的小文件进行k路归并，如此循环下去，直到所有的小文件全部归并为一个大文件。</p><p>这个过程中，会用到一个最小堆来维护当前归并段中的最小值，每次从堆中取出最小值，并将该值所在文件的下一个值（如果有的话）加入堆中。通过这种方式，我们可以一次从所有文件中找出最小值，这样就能保证归并出来的大文件是有序的。(这个是我个人的想法, 但是书上是用的败者树,但是也都是为了最快选出最小值)</p><p>外部排序的主要瓶颈在于磁盘的I/O操作，因此在实际操作中，会采用各种手段来优化I/O操作，比如使用缓冲区，一次读写多个数据等。</p><h3 id="败者树">败者树</h3><p>败者树是一种特殊的树形数据结构，常用于实现多路归并排序。它的名字“败者树”来源于其构建方式：在一次比较中，“胜利”的节点提升至上一层，而“失败”的节点留在原地。换句话说，这棵树的“根”实际上保存的是“败者”。</p><p>具体来说，败者树是一种二叉树，树中每个节点保存两个信息：节点对应的值，以及一个指向其“败者”的指针。当我们要从多个有序队列中选择最小的元素时，我们只需要比较树的叶节点，然后按照一种特殊的方式更新树的内部节点。这种方式保证了树根处总是当前所有叶节点中的最小值。</p><p>下面是构建和使用败者树的一般步骤：</p><ol><li><p><strong>初始化</strong>：首先，将所有队列的第一个元素作为叶节点，构建一棵完全二叉树。每个内部节点保存其两个子节点中较大的一个元素，并保留一个指向较小元素的“败者”指针。</p></li><li><p><strong>寻找最小元素</strong>：由于根节点保存的是所有叶节点中的最小值，我们直接从根节点获取这个最小值。</p></li><li><p><strong>更新败者树</strong>：在从败者树中取出最小值后，我们需要从相应的队列中取出下一个元素，然后将这个新元素和败者树中的现有元素进行比较，更新败者树的结构。这个更新过程从叶节点开始，向上至根节点。  更新过程是:  将新元素与父节点比较, 更新败者,  然后拿胜者继续向上比较直到根节点, 此时将根节点更新为胜者</p></li><li><p><strong>重复步骤2和3</strong>，直到所有的元素都被处理完。</p></li></ol><p>通过这种方式，败者树能够在O(log n)的时间复杂度内，从多个有序队列中选取最小的元素，这使得它在实现多路归并排序时非常有用。</p><p>疑惑:  为什么沿着一条路径向上就能更新出胜者?</p><p><strong>因为每个结点存放虽然是败者,  但是它是左右子树中的一颗的最胜者,  所以, 一路向上比较就能得到最胜者,  可以这样理解,  第二名是第一名的败者,  但他是第三名的胜者啊</strong>,  如果更新了一个结点,  他先跟父节点也就是败者结点比较, 如果它失败了, 就让这个败者再向上挑战, 然后更新当前败者,  如果胜了, 就它继续向上比较,  这样直到根节点一定能得出胜者</p><h3 id="置换-选择排序-生成初始归并段-有序">置换-选择排序(生成初始归并段(有序))</h3><p>置换-选择排序是一种外部排序算法，专门针对内存空间不足，只能将部分数据加载到内存中的情况。置换-选择排序基于内存和磁盘的交互来进行数据排序。</p><p>这个算法的步骤如下：</p><ol><li><p><strong>初始化</strong>：选择内存中的第一个记录作为初始的最小记录。</p></li><li><p><strong>选择过程</strong>：在输入的剩余记录中选出关键字最小的记录。</p></li><li><p>如果这个最小记录的关键字大于内存中最小记录的关键字，那么将其和内存中的当前记录（即之前的最小记录）进行交换，并且更新内存中的最小记录。这个步骤被称为<strong>置换</strong>。</p></li><li><p>如果这个最小记录的关键字小于内存中最小记录的关键字，那么将其放入一个称为“败者树”的内存结构中。</p></li><li><p>重复步骤2-4，直到内存中的所有记录都被输出为一个有序的序列。<strong>这个序列被称为一个“初始归并段</strong>”。</p></li><li><p>重复步骤1-5，直到所有的输入记录都被输出到若干个初始归并段。</p></li><li><p>使用合并排序（如最佳归并树或K路归并等方法）将这些初始归并段合并成一个完全有序的序列。</p></li></ol><p>整个过程中，通过选取剩余记录中的最小值，并且只有在其大于内存中的当前最小记录时才进行置换，<strong>我们能够最大程度地利用内存空间，生成尽可能长的初始归并段，这有助于减少后续的归并操作，提高排序效率。</strong></p><p>值得注意的是，这个算法并非内部排序算法，而是针对外部存储（如磁盘）设计的排序算法。对于可以完全加载到内存中的数据，通常使用其他的内部排序算法会更高效。</p><h3 id="最佳归并树">最佳归并树</h3><p>最佳归并树是一种应用于外部排序和文件的多路归并等问题的数据结构。<strong>它的目标是最小化所有归并操作的总开销</strong>。这种适用于归并段中元素个数不同  也就是相当于多路哈夫曼树</p><p>构造最佳归并树的步骤大致如下：</p><ol><li><p>首先，我们要对所有待归并的文件（或者其他类型的数据集）进行评估，确定它们的大小或者说归并开销（通常用一些数值来表示）。</p></li><li><p>然后，我们以这些开销作为叶节点，开始构建一个多叉（例如k叉）树。这个树最初只有叶节点，没有内部节点。</p></li><li><p><strong>如果叶节点数合成不足以生成完全k叉树,我们需要添加虚拟结点</strong>   对于完全k叉树有   n0 = (k-1)nk + 1 所以 nk = (n0-1)/(k-1) 因此我们只需要看 u = (n0-1)%(k-1)  如果u是0那么就是满足的, 如果不是0  就需要补充  k-1-u个虚拟0结点</p></li><li><p>在每一步中，我们从所有的叶节点中选择k个权值最小的节点，然后将它们归并为一个新的内部节点。这个内部节点的权值等于这k个叶节点的权值之和。</p></li><li><p>我们将这k个叶节点从树中移除，并把新的内部节点加入到树中。</p></li><li><p>我们重复上述过程，直到树中只剩下一个节点。这个节点就是我们要找的最佳归并树的根节点。</p></li></ol><p>在最佳归并树中，权值最小的文件总是最先被归并，这就保证了总的归并开销最小。虚拟节点的存在则确保了我们可以构造出完全k叉树，而且不会对结果产生任何影响。</p><h2 id="做题">做题</h2><ul><li>比较排序比较次数最少为  2^t &gt;= n!  其中 t为比较次数</li><li>外部排序总时间 = 初始归并段时间(使用内部排序对每段排序)  +  外存读写时间  +  内部归并时间</li><li>在外部排序中  k路归并的树是一颗严格k叉树,  因此  h-1 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>k</mi></msub><mi>r</mi></mrow><annotation encoding="application/x-tex">log_kr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>(向上取整) = 归并趟数,   由于每次都需要对这整个文件进行读写,  因此每趟归并i/o读写次数是不变的,  我们要注重减少归并趟数,  可以通过增加归并路数k和减少初始归并段数r</li><li>归并路数为k, 初始归并段数为r, n为每趟归并元素个数,  则s趟归并排序的比较次数  =  s (n-1) (k-1) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>k</mi></msub><mi>r</mi></mrow><annotation encoding="application/x-tex">log_kr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>(向上取整)  (n-1)(k-1) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>r</mi></mrow><annotation encoding="application/x-tex">log_2r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>(向上取整) (n-1)(k-1) / <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">log_2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>(向上取整)   可以看出如果一直增大k的话,  比较次数是在增加的, (k-1) / <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">log_2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>(向上取整)是k的增函数,   这种情况是因为k增加后导致了, 从k个归并段中选出一个元素的时间变慢了,  因此我们得优化算法, 使用败者树来得到元素, 就不需要k-1次 而是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">log_2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>(向上取整)次  此时比较次数 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>r</mi></mrow><annotation encoding="application/x-tex">log_2r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>(向上取整) (n-1)      这样就与k无关了, 但是这不意味着k越大越好,  因为k越大,需要的缓冲区就越多,  当内存不够的时候, 也会使得内外存读写次数增加</li><li>最佳归并树不同于归并树, 归并树的叶节点都在同一层,  而最佳归并树不是这样的,  当归并段个树相同的时候, 最佳归并树就跟普通归并树一样了,  对于最佳归并树 它是采用了哈夫曼树的思想,  让权值最小, 此时读写次数最少,   如果初始段个数不足以满足严格k叉树的要求, 我们需要补充虚拟段数, 即长度为0的段     判断准则为:  nk*(k-1) + 1= n0 =&gt; nk = (n0-1)/(k-1)  如果n0-1 % k-1 ==0 则说明满足, 否则就需要补充  (k-1) -  (n0-1 % k-1) 个0段</li></ul><h1>总结</h1><h1>额外补充</h1><h2 id="存储密度">存储密度</h2><p>存储密度是衡量数据存储效率的一个重要指标，它表示数据元素值所占存储空间与数据结构总占用存储空间的比率。公式表达如下：</p><p>存储密度 = <strong>数据元素值所占存储空间 / 数据结构总占用存储空间</strong></p><p>数据元素值所占存储空间是指实际存储数据元素值所需的空间，而数据结构总占用存储空间则是包括存储数据元素值、元素之间的关系以及其他信息所需的全部空间。</p><p>存储密度的值介于0和1之间，值越接近1，表示存储利用率越高，空间效率越高。反之，值越接近0，表示存储利用率越低，空间效率越低。</p><p>例如，在顺序存储结构中，只需要存储数据元素本身，没有额外的空间需求，因此存储密度接近或等于1。<strong>而在链式存储结构中，除了存储数据元素本身，还需要额外的空间来存储指向下一元素的指针，因此其存储密度一般小于1。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/06/27/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/06/27/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1>计算机网络体系结构</h1><h1>物理层</h1><h1>数据链路层</h1><h1>网络层</h1><h1>传输层</h1><h1>应用层</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2023/06/27/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2023/06/27/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>计算机系统概述</h1><h2 id="计算机系统层次结构">计算机系统层次结构</h2><h3 id="计算机系统的组成">计算机系统的组成</h3><p>硬件系统+软件系统,   硬件是指有形的物理设备, 软件是指硬件上运行的程序和数据</p><h3 id="计算机组成和计算机体系结构">计算机组成和计算机体系结构</h3><p>计算机组成（Computer Organization）和计算机体系结构（Computer Architecture）是两个相关但又有所区别的领域。它们都关注计算机系统的设计，但从不同的角度。以下是这两者的主要差异：</p><ol><li><p><strong>定义与焦点</strong>：</p><ul><li><strong>计算机体系结构</strong>：关注系统的高层设计，如指令集、数据类型、寻址模式和计算机的功能抽象。简而言之，它是描述硬件和软件如何交互以及如何实现功能的接口和规范。</li><li><strong>计算机组成</strong>：更注重硬件组件的具体实现和组织，如数据路径、控制逻辑、内存组织、输入/输出处理和流水线设计等。</li></ul></li><li><p><strong>抽象层级</strong>：</p><ul><li><strong>计算机体系结构</strong>：在更高的抽象层级。它定义了指令集以及如何进行高级运算，但不涉及具体如何在硬件上实现这些运算。</li><li><strong>计算机组成</strong>：在较低的抽象层级。它关注如何使用电子部件和逻辑来实现体系结构中定义的功能。</li></ul></li><li><p><strong>应用领域</strong>：</p><ul><li><strong>计算机体系结构</strong>：对于编译器设计师、操作系统开发者和应用程序开发者来说，理解体系结构是非常重要的，因为他们需要确保他们的软件与给定的体系结构兼容。</li><li><strong>计算机组成</strong>：对于硬件设计师和电子工程师来说，理解计算机组成是关键的，因为他们需要构建和组织硬件来满足体系结构的要求。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><strong>计算机体系结构</strong>：定义一台机器应该有哪些指令（例如，加法、乘法、加载、存储等）以及这些指令应该如何工作。</li><li><strong>计算机组成</strong>：描述如何在硬件中实现这些指令，例如，为了实现加法指令，我们可能需要一个加法器、数据寄存器和其他控制逻辑。</li></ul></li></ol><p>总之，计算机体系结构关注“设计的是什么”，而计算机组成关注“如何实现这个设计”。两者紧密相关，但各自关注不同的设计和实现细节。</p><h2 id="概念">概念</h2><ul><li><strong>存储元件</strong>用来存储一位二进制代码,   <strong>存储单元</strong>包含若干个存储元件,  它能够包含一连串二进制代码,  这串二进制代码被称为<strong>存储字</strong>,  位数称为<strong>存储字长</strong>, 存储字长一般是一个字节或者是字节的偶数倍</li><li>机器字长(简称为字长)  是指一次整数运算能够处理的位数, 通常等于运算器位数,</li></ul><h2 id="做题总结">做题总结</h2><ul><li>CPU执行时间 = 总指令时间周期数/主频  = 总指令时间周期数*时钟周期 = cpi * 指令数量 / 主频</li><li>MIPS = 指令条数 / (执行时间 * 10 ^ 6) = x/(x*CPI*T * 10^6 ) = 主频 / (CPI*10^6)</li><li>(M,G,T,P,E,Z)FLOPS  每秒执行浮点数次数   M = 10^6 G = 10^9 T = 10^12 P = 10^15 E = 10^18 Z = 10^21</li></ul><h1>数据的表示和运算</h1><h2 id="数制与编码">数制与编码</h2><h3 id="采用二进制编码原因">采用二进制编码原因</h3><p>计算机采用二进制编码有多种原因，其中最主要的是基于实际硬件实现的便利性和效率。以下是使用二进制的主要原因：</p><ol><li><p><strong>简化硬件设计</strong>：二进制只有两个状态：0 和 1，这与电子开关的基本工作原理相匹配，即开（ON）或关（OFF）。使用二进制编码可以轻松地用这些开关状态表示信息。例如，一个开关处于关闭状态可以表示0，而开启状态可以表示1。</p></li><li><p><strong>可靠性</strong>：由于只有两种状态，二进制系统在处理噪声或其他干扰时更加鲁棒。例如，一个模拟系统可能受到细微的电压变化的影响，而二进制系统只需区分两种状态，因此更能够容忍小的误差或干扰。</p></li><li><p><strong>逻辑运算</strong>：基于二进制的电子逻辑门（如AND、OR和NOT门）的设计和实现相对简单。这些逻辑门是计算机运行的基础。</p></li><li><p><strong>简化算术运算</strong>：在二进制下，算术运算（如加法和乘法）可以通过简单的位操作实现，这在硬件上更易于实现。</p></li><li><p><strong>存储和传输</strong>：二进制编码使得信息的存储和传输更加一致和简单。不论是处理文本、图像、音频还是视频，所有信息最终都可以转换为二进制形式并通过相同的基础硬件进行处理。</p></li><li><p><strong>历史和技术进展</strong>：早期的计算机和计算机设备（如继电器和真空管）更容易以二进制方式工作。随着技术的进步，这种方法已经被证明是非常有效的，因此被继续沿用。</p></li></ol><p>尽管二进制是最常用的编码方式，但在特定的应用和技术中，也有使用其他编码系统（如三进制、四进制等）的尝试。然而，由于上述原因，二进制已经成为了主流的选择。</p><h3 id="进制转换">进制转换</h3><p>进制转换是计算机科学中的基础概念，尤其在考研408中也是经常被考察的内容。以下是常用的进制转换方法，包括整数和小数部分：</p><ol><li><p><strong>二进制与十进制之间的转换</strong>：</p><ul><li><strong>整数部分</strong>：<ul><li>从二进制转为十进制：按权展开，即从最低位开始，每一位的值乘以2的相应次方，然后求和。</li><li>从十进制转为二进制：通过连续除以2并取余数的方法。<strong>除基取余法</strong></li></ul></li><li><strong>小数部分</strong>：<ul><li>从二进制转为十进制：从小数点后的第一位开始，每一位的值乘以2的相应负次方，然后求和。</li><li>从十进制转为二进制：通过连续乘以2并取整数部分的方法。<strong>乘积取整法</strong></li></ul></li></ul></li><li><p><strong>二进制与八进制之间的转换</strong>：</p><ul><li><strong>整数部分</strong>：每三位二进制数对应一位八进制数。</li><li><strong>小数部分</strong>：同样，每三位二进制小数对应一位八进制小数。</li></ul></li><li><p><strong>二进制与十六进制之间的转换</strong>：</p><ul><li><strong>整数部分</strong>：每四位二进制数对应一位十六进制数。</li><li><strong>小数部分</strong>：同样，每四位二进制小数对应一位十六进制小数。</li></ul></li><li><p><strong>十进制与八进制、十六进制之间的转换</strong>：</p><ul><li>通常先将十进制数转为二进制，然后再从二进制转为八进制或十六进制。</li></ul></li></ol><p>注意：在进行进制转换时，尤其是涉及小数部分，可能会遇到无法精确转换的情况，这时通常会取一个近似值。</p><p>在考研408的复习中，掌握这些基本的进制转换方法是非常重要的，因为它们是很多计算机科学概念的基础。</p><h3 id="真值和机器数">真值和机器数</h3><ol><li><strong>真值</strong>：<ul><li>真值是一个数学上的概念，表示数的实际值，包括它的正负。(也就是带有&quot;+&quot;,&quot;-&quot;的数)</li><li>例如，+5的真值是+5，-5的真值是-5。</li></ul></li><li><strong>机器数</strong>：<ul><li>机器数是计算机中用来表示一个数的二进制形式。对于正数，其真值和机器数是相同的；但对于负数，机器数是其补码形式。(使用数字代替正负号)</li><li>在大多数现代计算机系统中，负数的表示采用的是“二进制补码”形式。这意味着负数的机器数是其绝对值的二进制反码加1得到的。</li><li>例如，假设我们要在一个8位的系统中表示数字-5：<ol><li>+5的二进制形式是：0101</li><li>取反得到：1010</li><li>加1得到：1011 因此，-5的机器数是1011。</li></ol></li></ul></li></ol><h3 id="原码-反码-补码-移码">原码,反码,补码,移码</h3><p>当我们在计算机中表示和处理整数，特别是负整数时，就会涉及到原码、反码、补码和移码这些表示方法。以下是这些概念的总结：</p><ol><li><p><strong>原码</strong>：</p><ul><li>原码是最直观的二进制表示方法。最高位是符号位：0表示正数，1表示负数。其余位表示该数的绝对值。</li><li>例如：+7的原码为：0111，-7的原码为：1111（假设我们使用4位表示）。</li></ul></li><li><p><strong>反码</strong>：</p><ul><li>正数的反码与其原码相同。</li><li>负数的反码是保持符号位不变，然后对原码的数值部分取反。</li><li>例如：+7的反码为：0111，-7的反码为：1000。</li></ul></li><li><p><strong>补码</strong>：</p><ul><li>正数的补码与其原码相同。</li><li>负数的补码是其反码加1。</li><li>例如：+7的补码为：0111，-7的补码为：1001。</li><li>补码是现代计算机中最常用的表示方法，因为它使得加法和减法运算更为简单。</li></ul></li><li><p><strong>移码</strong>：</p><ul><li>移码常用于浮点数的指数部分。它是通过将原码加上一个固定的偏移量（通常是2的(n-1)次方，其中n是位数）来得到的。</li><li>对于4位表示，偏移量是2^3 = 8。所以，+7的移码是：0111 + 1000 = 1111，-7的移码是：1111 + 1000 = 0111。</li><li>移码的主要优点是它可以使得负数的排序和正数相同。</li></ul></li></ol><h2 id="运算">运算</h2><h3 id="移位运算">移位运算</h3><ul><li>逻辑移位</li><li>算数移位</li><li>循环移位</li></ul><h3 id="加减运算">加减运算</h3><ul><li>原码加减法(了解即可)</li><li>补码加减法</li></ul><p>溢出方法判别  两个相同符号位运算数的结果符号位不同 就是溢出</p><ul><li>一位符号法:  两种情况  1 1 0  和 0 0 1  所以表达式为 V = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mover accent="true"><mi>S</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover><mi>S</mi></mrow><annotation encoding="application/x-tex">AB\overline{S} + \overline{A} \overline{B} S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></li><li>双符号法:  只有两个符号位不同的时候才算溢出  1 0 代表负溢出  0 1 代表正溢出  1 1 代表负数不溢出  0 0 代表正数不溢出</li><li>符号进位与最高位进位判别法 (做异或操作, 0 代表不溢出 1 代表溢出)</li></ul><p><strong>无论采用什么方法判断溢出,   存储的时候都是存放一位符号位,  只是在运算的时候,才把符号位的值同时放到ALU中(因为一个正确的数, 双符号位相同), 所以也就是说只在ALU中采用双符号位</strong></p><h3 id="乘除运算">乘除运算</h3><h4 id="原码一位乘法">原码一位乘法</h4><p>符号位和数值为分开计算   乘积符号位由符号位运算得出  数值位由数值绝对值计算得出</p><p>这个过程其实就是累加的过程</p><ol><li>部分积和被乘数在计算过程中采用双符号位,部分积初始值为0, 部分积最终存放的是高位数值</li><li>如果当前乘数最低位为1, 则部分积加上被被乘数,   然后部分积和乘数都<strong>逻辑右移一位</strong> ( 部分积右移 溢出的是低位部分积)</li><li>重复步骤2  n次</li><li>将最终部分积高位与低位合并的结果的符号位设置成 符号位异或的结果</li></ol><p><strong>可以发现一共做n次加法 n次移动</strong></p><h4 id="补码一位乘法-booth算法">补码一位乘法(Booth算法)</h4><p>这个算法步骤中符号位是参与运算的, 而且运算数都是补码计算, 它和原码一位乘法累加过程相似, 但是每一步是加法还是减法是需要另外计算的</p><ol><li>部分积和被乘数在计算过程中采用双符号位,部分积初始值为0, 部分积最终存放的是高位数值</li><li>乘数末尾新增一位0(不参与计算,用于确定是加被乘数还是减被乘数)</li><li>靠乘数最后两位选出部分积是加被乘数还是减被乘数, 1 1 和 0 0 代表 + 0 ,  1 0 代表 - 被乘数 , 0 1 代表 + 被乘数</li><li>将乘数 逻辑右移, 部分积 <strong>算数右移一位</strong>(溢出的是低位部分积)</li><li>重复3,4步骤 n次</li><li>最后将部分积  再进行一次3步骤</li><li>最终部分积高位与低位合并的结果 <strong>就是计算结果的补码</strong></li></ol><p><strong>可以发现一共做n+1次加法 n次移动</strong></p><blockquote><p>我发现一个问题就是, 书上貌似都是小数乘法, 但是如果是整数乘法,我感觉这些乘法是不太对的 我觉得应该要左移被乘数然后和部分积相加,   或者说需要改一下第7步, 低位就是最终结果</p></blockquote><h4 id="原码除法-不恢复余数法">原码除法(不恢复余数法)</h4><p>除法其实就是做减法</p><p>数值位计算过程</p><ol><li>取两个数的绝对值</li><li>先将被除数的绝对值-除数绝对值 相当于 +除数绝对值的补码</li><li>根据计算出来的值称为余数  如果是正数  商的最后一位为1  商和余数都左移一位  然后-除数绝对值,  如果是负数 商的最后一位为0  商和余数都左移一位  然后 + 除数绝对值  (<strong>逻辑左移</strong>)</li><li>重复 3步骤 n 次  (最后一步得到余数后, 还要给商设置一次值,根据3的规则)</li><li>如果最后的余数为负数, 需要再加上除数绝对值</li><li>最后将符号位做异或运算当做商的符号位</li></ol><h4 id="补码除法-加减交替法">补码除法(加减交替法)</h4><p>符号位与数值位一起参加运算</p><ol><li>如果被除数与除数同号就 - 除数, 异号就加上除数</li><li>根据计算出来的值称为余数  如果与除数同号就  商的最后一位为1  商和余数都左移一位  然后-除数,  如果与除数异号就 商的最后一位为0  商和余数都左移一位  然后 + 除数  (<strong>算数左移</strong>)</li><li>重复 2 步骤 n次( 最后一步得到余数后, 如果对商没有特殊要求,  最后一位置1 )</li></ol><h2 id="数据类型转换">数据类型转换</h2><h3 id="有符号数与无符号数相互转换">有符号数与无符号数相互转换</h3><p>二者在内存中的二进制表示方式还是相同,  但是解释方式不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = (<span class="type">unsigned</span> <span class="type">int</span>)a;  <span class="comment">// b = 2^32-1</span></span><br></pre></td></tr></table></figure><h3 id="不同字长整数之间的转换">不同字长整数之间的转换</h3><p>大字长向小字长转换 直接截取大字长低位给小字长</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = (<span class="type">int</span>)<span class="number">0b11000000000000000000000000000000</span>; <span class="comment">//-1073741824</span></span><br><span class="line"><span class="type">short</span> b = (<span class="type">short</span>)a; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>小字长向大字长转换  将小字长数据放入到大字长低位,  高位用小字长符号位填充(如果小字长是无符号数就用0填充)</p><p>(char 类型就是8位无符号整数)</p><h2 id="数据的存储与排列">数据的存储与排列</h2><h3 id="大端小端存储">大端小端存储</h3><p>由于每个数据只会有一个内存地址, 如果是多字节数据接下来的连续若干个地址构成了这个数据,  这样就会涉及到排列问题</p><ul><li>大端方式   从大大小排列  高位在前  低位在后   也就是高位在低地址, 低位在高地址</li><li>小端方式  从小到大排列  低位在前 高位在后  也就是低位在低地址 高位在高地址</li></ul><p>如果地址从左到右依次增加,  那么大端方式的话 就相当于顺序存放一个数,   小端就相当于逆序**(字节内有序)**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x01234567</span></span><br><span class="line"><span class="comment">// 01 23 45 67  大端</span></span><br><span class="line"><span class="comment">// 67 45 23 01  小端 </span></span><br></pre></td></tr></table></figure><h3 id="边界对齐方式存储">边界对齐方式存储</h3><ul><li>边界对齐方式能够使  半字数据和字数据都能各自存放在一个存储单元中, 不会分布在不同的存储单元中, 但是会浪费一定的空间, 优点是提高指令和数据的读写速度</li><li>边界不对齐方式  可以充分利用存储空间,   但是一个字或者半字数据会存放在不同的存储单元中, 这样读取一个字或者半字的指令或者数据的时候,需要多次访存</li></ul><h2 id="浮点数的表示与运算">浮点数的表示与运算</h2><blockquote><p>浮点数就是小数点位置不固定的数,  这里的不固定不是指小数点会真正的移动,  而是指通过缩放数据, 让小数点逻辑移动</p></blockquote><h3 id="表示格式">表示格式</h3><p>符号位 阶码  尾数</p><ul><li>符号位取值 0 1 代表正负</li><li>阶码或者叫指数   用移码表示  这里还隐约包含了  基数  通常采用 2    阶码就反应了浮点数小数点实际位置</li><li>尾数的位数反应了精度  尾数部分通常用原码表示</li></ul><h3 id="浮点数的规格化">浮点数的规格化</h3><p>定义:  通过调整尾数和阶码的大小,  让非零浮点数的尾数部分最高位是一个有效值</p><p>规范化的尾数绝对值肯定满足   1/R &lt;= |M| &lt;= 1   R代表基数   M代表尾数值</p><h3 id="ieee754标准">IEEE754标准</h3><p>IEEE 754标准是一个定义浮点数算术的国际标准，广泛应用于计算机和数字系统中。以下是该标准的总结：</p><ol><li><p><strong>基本组成</strong>：</p><ul><li><strong>符号位（Sign bit）</strong>：决定浮点数的正负。0表示正数，1表示负数。</li><li><strong>指数（Exponent）</strong>：表示浮点数的阶数。使用一个偏移（bias）格式来表示。2^(n-1) - 1</li><li><strong>尾数（Mantissa 或 Fraction）</strong>：表示浮点数的有效数字。</li></ul></li><li><p><strong>主要格式</strong>：</p><ul><li><strong>单精度（32位）</strong>：<ul><li>符号位：1位</li><li>指数：8位，偏移值为127   2^7 -1</li><li>尾数：23位</li></ul></li><li><strong>双精度（64位）</strong>：<ul><li>符号位：1位</li><li>指数：11位，偏移值为1023   2^10 -1</li><li>尾数：52位</li></ul></li></ul></li><li><p><strong>特殊值</strong>：</p><ul><li><strong>零（0）</strong>：有正零和负零，指数和尾数都为0。</li><li><strong>无穷（Infinity）</strong>：正无穷和负无穷，指数为最大值，尾数为0。</li><li><strong>NaN（Not a Number）</strong>：表示不是一个数的值，如0除以0的结果。指数为最大值，尾数不为0。</li></ul></li><li><p><strong>规格化与非规格化数</strong>：</p><ul><li><strong>规格化数</strong>：<strong>尾数部分的隐含的最高位是1</strong>。例如，对于单精度，它是1.xxxxx的形式。</li><li><strong>非规格化数</strong>：当指数部分为全0时，表示的数是非规格化的，隐含的最高位是0。这允许表示接近于0的非常小的数。</li></ul></li><li><p><strong>舍入模式</strong>：<br>IEEE 754标准定义了多种舍入模式，包括最近偶数舍入（默认模式）和向正无穷、向负无穷、向零舍入等。</p></li><li><p><strong>操作和异常</strong>：<br>标准定义了浮点数的基本操作（如加、减、乘、除等）以及可能的异常情况（如溢出、下溢、除以零等）和它们的处理方式。</p></li></ol><p>IEEE 754标准为浮点数的表示和运算提供了一个统一和一致的框架，被广泛采用于现代计算机和数字系统中。理解这个标准的基本概念和特点对于计算机科学和工程领域是非常重要的。</p><h3 id="浮点数的加减运算">浮点数的加减运算</h3><p>对阶:  小阶通过尾数右移 阶码增加 像大阶对其   这样的话会舍弃掉有效位 产生误差影响精度</p><p>尾数求和:  将对阶后的尾数运算即可   运算后的尾数不一定是规格化的,  此后还需要规格化</p><p>舍入: 在对阶和尾数右规式, 为了保证运算精度, 一般将低位溢出的两位保留下来参加中间运算过程, 最后将运算结果舍入</p><p>常见舍入方法:</p><ul><li>0舍1入法:  类似于四舍五入, 保留位的最高位为0则舍去  保留位的最高位为1 <strong>尾数末位+1</strong>   这样可能导致尾数溢出, 需要再一次右规</li><li>恒置1法:  如果保留的两位中 存在一个1, 则<strong>尾数末位设置为1</strong></li><li>截断法: 直接舍去</li></ul><p>溢出判断:  浮点数的溢出判断是根据阶码来判断的,  如果阶码全0  则表示下溢出,  全1 则表示上溢出</p><h2 id="浮点数和定点数的区别">浮点数和定点数的区别</h2><p>浮点数和定点数是数字系统中两种不同的数值表示方法。它们各自有其优点和缺点，适用于不同的应用场景。以下是它们之间的主要区别：</p><ol><li><p><strong>定义</strong>：</p><ul><li><strong>浮点数</strong>：浮点数的表示方式类似于科学记数法，其中数值的小数点位置可以“浮动”。一个浮点数由符号位、指数和尾数三部分组成。</li><li><strong>定点数</strong>：定点数的小数点位置是固定的。它由整数部分和小数部分组成，小数点的位置在表示中是固定不变的。</li></ul></li><li><p><strong>表示范围和精度</strong>：</p><ul><li><strong>浮点数</strong>：由于其指数的存在，浮点数可以表示非常大或非常小的数值，但精度可能会受到限制，特别是对于非常大或非常小的数值。</li><li><strong>定点数</strong>：定点数的表示范围受到其整数和小数部分的位数的限制，但在其表示范围内，精度是固定的。</li></ul></li><li><p><strong>计算复杂性</strong>：</p><ul><li><strong>浮点数</strong>：浮点数的算术运算（如加、减、乘、除）相对复杂，需要专门的硬件支持，如浮点数算术单元（FPU）。</li><li><strong>定点数</strong>：定点数的算术运算相对简单，可以在没有专门浮点硬件的系统上高效地执行。</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>浮点数</strong>：适用于需要处理大范围数值或高精度计算的应用，如科学计算、图形处理等。</li><li><strong>定点数</strong>：常用于嵌入式系统、数字信号处理等领域，其中硬件资源可能有限，但需要快速、确定的计算性能。</li></ul></li><li><p><strong>硬件和存储</strong>：</p><ul><li><strong>浮点数</strong>：通常需要更多的硬件资源和存储空间来表示和处理。</li><li><strong>定点数</strong>：通常更加紧凑，需要较少的硬件资源和存储空间。</li></ul></li><li><p><strong>误差和精度</strong>：</p><ul><li><strong>浮点数</strong>：可能会引入舍入误差，特别是在连续的算术运算中。</li><li><strong>定点数</strong>：误差通常是固定的，但数值范围受到限制。</li></ul></li></ol><p>总的来说，浮点数和定点数都是数字系统中表示数值的方法，选择哪种方法取决于特定的应用需求、硬件资源和性能要求。</p><h2 id="做题技巧">做题技巧</h2><ul><li>对于补码反码来说,  数值部分越大, 对应的真值也越大</li><li>对于正数来说, 反码,补码,原码是相同的, 只有移码不同,  而对于负数来说, 就都有可能不同了,   移码和补码只有符号位相反</li><li>对于并行加法器来说,  加法器没有区别,  只是进位的产生不再是串行产生了,  而是并行产生, 由一个CLA电路根据各位数值计算而来</li><li>对于减法运算来说,  低位进位都是1, 代表选用减法运算, 然后减少要取反+1</li><li>对于边界对齐的计算机来说, 一般按照机器字长来对齐, 不够的就用空白来填</li><li><strong>对于IEEE754标准, 将其他数据转换为 浮点数的时候,  阶码一定要加上偏移值,   浮点数转换为其他数的时候, 阶码一定要减去偏移值</strong></li><li>浮点数变成定点数  尾数左移阶码表示数量    定点数变成浮点数  右移尾数   阶码增加</li></ul><h1>存储器系统</h1><h2 id="存储器的概述">存储器的概述</h2><h3 id="存储器的分类">存储器的分类</h3><h4 id="按照作用层次分类">按照作用层次分类</h4><p>存储器按照作用层次可以分为几个不同的级别，每个级别都有其特定的性能特点、容量和成本。以下是按作用层次分类的存储器：</p><ol><li><p><strong>寄存器（Registers）</strong>：</p><ul><li><strong>位置</strong>：位于CPU内部。</li><li><strong>特点</strong>：访问速度极快，但容量非常有限。</li><li><strong>用途</strong>：存储即将被处理的指令、数据或地址。</li></ul></li><li><p><strong>高速缓存（Cache Memory）</strong>：</p><ul><li><strong>位置</strong>：位于CPU芯片上或接近CPU的位置。</li><li><strong>特点</strong>：访问速度快，但容量相对有限且成本较高。</li><li><strong>用途</strong>：暂存经常访问的数据和指令，减少CPU与主存之间的速度差异。</li></ul></li><li><p><strong>主存储器（Main Memory，通常指RAM）</strong>：</p><ul><li><strong>位置</strong>：位于CPU外部，通过内存总线与CPU连接。</li><li><strong>特点</strong>：访问速度比高速缓存慢，但容量较大且成本较低。</li><li><strong>用途</strong>：存储操作系统、应用程序和当前处理的数据。</li></ul></li><li><p><strong>辅助存储器（Secondary Memory 或 Mass Storage）</strong>：</p><ul><li><strong>位置</strong>：通常位于计算机的外部。</li><li><strong>特点</strong>：访问速度比主存储器慢得多，但提供大量的存储空间，成本较低。</li><li><strong>用途</strong>：长期存储数据、程序和信息。常见的辅助存储器包括硬盘、SSD、光盘和磁带。</li></ul></li><li><p><strong>离线存储（Offline Storage）</strong>：</p><ul><li><strong>位置</strong>：不直接连接到计算机系统。</li><li><strong>特点</strong>：需要人工干预才能访问，通常用于备份或长期存储。</li><li><strong>用途</strong>：数据备份、归档。例如，外部硬盘、光盘、磁带等。</li></ul></li></ol><p>这些存储器层次形成了一个存储器层次结构，从上到下，访问速度逐渐减慢，但容量逐渐增大，成本每位逐渐降低。这种层次结构的设计是为了平衡性能和成本，确保计算机系统能够高效地运行。</p><h4 id="按照存储介质">按照存储介质</h4><p>按照存储介质分类，存储器可以分为以下几种类型：</p><ol><li><p><strong>半导体存储器</strong>：</p><ul><li><strong>特点</strong>：基于半导体技术，如硅。</li><li><strong>例子</strong>：<ul><li><strong>RAM（Random Access Memory）</strong>：<ul><li><strong>SRAM（Static RAM）</strong>：使用触发器作为存储单元，速度快，常用作CPU的高速缓存。</li><li><strong>DRAM（Dynamic RAM）</strong>：使用电容作为存储单元，需要定期刷新，主要用作主存储器。</li></ul></li><li><strong>ROM（Read-Only Memory）</strong>：只读存储器，用于存储固定数据或程序。</li><li><strong>Flash Memory</strong>：可以电擦写的非易失性存储器，常用于USB驱动器、SD卡和SSD。</li></ul></li></ul></li><li><p><strong>磁性存储器</strong>：</p><ul><li><strong>特点</strong>：使用磁介质来存储数据。</li><li><strong>例子</strong>：<ul><li><strong>硬盘驱动器（HDD）</strong>：使用磁盘片和读写头来存储和访问数据。</li><li><strong>磁带</strong>：主要用于数据备份和长期存储。</li><li><strong>磁芯存储</strong>：早期计算机中使用的存储技术，现已过时。</li></ul></li></ul></li><li><p><strong>光学存储器</strong>：</p><ul><li><strong>特点</strong>：使用光介质和激光技术来存储数据。</li><li><strong>例子</strong>：<ul><li><strong>CD（Compact Disc）</strong></li><li><strong>DVD（Digital Versatile Disc）</strong></li><li><strong>Blu-ray Disc</strong></li></ul></li></ul></li><li><p><strong>机械存储器</strong>：</p><ul><li><strong>特点</strong>：基于机械移动部件。</li><li><strong>例子</strong>：早期的打孔卡和打孔纸带。</li></ul></li><li><p><strong>固态驱动器（SSD）</strong>：</p><ul><li><strong>特点</strong>：没有机械部件，基于闪存技术。</li><li><strong>例子</strong>：现代的SSD驱动器，用于替代传统的硬盘驱动器，提供更快的读写速度。</li></ul></li><li><p><strong>相变存储器</strong>：</p><ul><li><strong>特点</strong>：使用材料的相变（从结晶态到非结晶态）来存储数据。</li><li><strong>例子</strong>：某些特定的光盘技术和新型非易失性存储器。</li></ul></li><li><p><strong>磁阻和自旋转移磁阻存储器</strong>：</p><ul><li><strong>特点</strong>：基于磁阻效应或自旋转移磁阻效应。</li><li><strong>例子</strong>：MRAM（磁阻随机存取存储器）。</li></ul></li></ol><p>这些存储介质类型涵盖了从早期计算机技术到现代高速存储解决方案的各种技术。选择哪种存储介质取决于特定的应用需求、性能要求和成本考虑。</p><h4 id="按照存储方式分类">按照存储方式分类</h4><p>按照访问方式分类，存储器可以分为以下几种类型：</p><ol><li><p><strong>随机访问存储器（Random Access Memory, RAM）</strong>：</p><ul><li><strong>特点</strong>：可以在任意顺序下访问任何地址的存储位置，每次访问的时间基本相同。</li><li><strong>例子</strong>：DRAM（Dynamic RAM）、SRAM（Static RAM）。</li></ul></li><li><p><strong>只读存储器（Read Only Memory, ROM）</strong>：</p><ul><li><strong>特点</strong>：数据被预先写入，通常在生产过程中，并且在正常操作中不可更改。</li><li><strong>例子</strong>：PROM（Programmable ROM）、EPROM（Erasable PROM）、EEPROM（Electrically Erasable PROM）。</li></ul></li><li><p><strong>顺序访问存储器（Sequential Access Memory）</strong>：</p><ul><li><strong>特点</strong>：数据只能按照一定的顺序访问，不像RAM那样可以随机访问。</li><li><strong>例子</strong>：磁带是典型的顺序访问存储器。</li></ul></li><li><p><strong>直接访问存储器（Direct Access Memory）</strong>：</p><ul><li><strong>特点</strong>：可以直接访问到存储器的某个位置，但访问时间可能会根据位置的不同而有所变化。(先找到一个局部位置,  然后局部位置顺序访问)</li><li><strong>例子</strong>：硬盘驱动器（HDD）。</li></ul></li><li><p><strong>关联存储器（Associative Memory 或 Content-Addressable Memory, CAM）</strong>：</p><ul><li><strong>特点</strong>：基于数据内容而不是地址来进行搜索。当提供一个数据片段或关键字时，关联存储器可以快速找到与之匹配的完整记录。</li><li><strong>例子</strong>：某些高速缓存实现和路由器中的查找表。</li></ul></li><li><p><strong>寄存器存储器（Register Memory）</strong>：</p><ul><li><strong>特点</strong>：位于CPU内部，为CPU提供快速访问的小块存储空间。</li><li><strong>例子</strong>：指令寄存器、累加器、数据寄存器等。</li></ul></li></ol><p>这些分类基于存储器的访问机制和特性。在实际应用中，不同的访问方式适用于不同的用途和性能要求。</p><h4 id="按信息可保存性分类">按信息可保存性分类</h4><p>按照信息的可保存性分类，存储器可以分为以下几种类型：</p><ol><li><p><strong>易失性存储器（Volatile Memory）</strong>：</p><ul><li><strong>特点</strong>：当电源关闭或断电时，存储在其中的数据会丢失。</li><li><strong>例子</strong>：<ul><li><strong>RAM</strong>：包括DRAM（Dynamic RAM）和SRAM（Static RAM）。</li></ul></li></ul></li><li><p><strong>非易失性存储器（Non-Volatile Memory）</strong>：</p><ul><li><strong>特点</strong>：即使在断电或关闭电源后，数据仍然可以被保存。</li><li><strong>例子</strong>：<ul><li><strong>ROM（Read-Only Memory）</strong>：包括PROM、EPROM、EEPROM等。</li><li><strong>Flash Memory</strong>：如USB闪存驱动器、SSD和SD卡。</li><li><strong>硬盘驱动器（HDD）</strong></li><li><strong>光盘</strong>：如CD、DVD和Blu-ray Disc。</li><li><strong>磁带</strong></li></ul></li></ul></li><li><p><strong>半易失性存储器（Semi-Volatile Memory）</strong>：</p><ul><li><strong>特点</strong>：介于易失性和非易失性存储器之间。在正常情况下，它表现得像非易失性存储器，但在某些条件下（如高温或特定的电子操作）数据可能会丢失。</li><li><strong>例子</strong>：某些特定的Flash Memory或磁阻存储器（MRAM）可能被认为是半易失性的，尽管这种分类不太常见。</li></ul></li></ol><p>这些分类基于存储器保存数据的能力，特别是在断电或关闭电源时。在实际应用中，选择哪种类型的存储器取决于特定的数据保存需求和应用场景。</p><h3 id="存储器性能指标">存储器性能指标</h3><p>主要有三个指标: 存储容量, 单位成本, 存储速度</p><ol><li>存储容量 = 存储字数 * 存储字长   字数代表存储空间大小   字长代表一次存取操作数据量</li><li>单位成本 = 总成本 / 总容量</li><li>存储速度:  数据传输率 = 数据宽度 / 存储周期<ul><li><strong>存取时间</strong>:    是从发出读取或写入请求到存储器响应并提供所需数据或确认写入完成的时间。简单地说，它是从请求开始到数据可用（对于读操作）或数据被成功写入（对于写操作）的时间。</li><li><strong>存取周期</strong>: 是连续两次存储访问操作之间所需的最小时间间隔。它包括了<strong>存取时间</strong>以及为<strong>下一个访问操作预留的额外时间</strong>。这个额外的时间通常是为了确保<strong>存储器内部的操作完成，如数据线和地址线的稳定</strong>。</li></ul></li></ol><h3 id="多级层次存储系统">多级层次存储系统</h3><p>多级层次存储系统主要是为了解决  容量大 速度快 成本低 三个相互制约的矛盾</p><p>多级层次存储系统是计算机存储的一个设计概念，它通过组合不同性能和成本的存储技术，旨在提供接近最快存储速度的性能，同时保持较低的总体成本。这种系统的核心思想是：经常访问的数据应该存储在快速但昂贵的存储介质中，而不经常访问的数据则存储在慢速但便宜的存储介质中。</p><p>以下是多级层次存储系统的主要层次：</p><ol><li><p><strong>寄存器</strong>：</p><ul><li><strong>位置</strong>：CPU内部。</li><li><strong>特点</strong>：极高的访问速度，但容量非常有限。</li><li><strong>用途</strong>：存储即将处理的指令和数据。</li></ul></li><li><p><strong>高速缓存（Cache）</strong>：</p><ul><li><strong>位置</strong>：位于CPU内部或接近CPU。</li><li><strong>特点</strong>：高速访问，但容量有限且成本较高。</li><li><strong>用途</strong>：存储经常访问的数据和指令，减少CPU与主存之间的速度差异。</li></ul></li><li><p><strong>主存储器（RAM）</strong>：</p><ul><li><strong>位置</strong>：位于CPU外部。</li><li><strong>特点</strong>：访问速度较快，容量大于Cache但小于辅助存储器，成本适中。</li><li><strong>用途</strong>：存储操作系统、应用程序和正在处理的数据。</li></ul></li><li><p><strong>辅助存储器（如硬盘、SSD）</strong>：</p><ul><li><strong>位置</strong>：通常位于计算机的外部。</li><li><strong>特点</strong>：较大的存储容量，访问速度慢于RAM但快于离线存储，成本较低。</li><li><strong>用途</strong>：长期存储数据和程序。</li></ul></li><li><p><strong>离线存储/备份存储（如磁带、光盘）</strong>：</p><ul><li><strong>位置</strong>：可能需要人工干预才能访问。</li><li><strong>特点</strong>：巨大的存储容量，但访问速度最慢，成本最低。</li><li><strong>用途</strong>：数据备份、归档和长期存储。</li></ul></li></ol><p>在多级层次存储系统中，数据会根据其访问频率和重要性在不同的层次之间移动。例如，当CPU需要某个数据项时，它首先会在寄存器或高速缓存中查找。如果没有找到，它会继续在RAM中查找，然后是硬盘或SSD，以此类推。</p><p>这种层次结构的设计是为了平衡性能和成本，确保计算机系统能够以最低的成本提供最高的性能。</p><p>cache - 主存层 数据调动  是由 硬件自动完成, 对任何程序员透明(也就是不能也不需要干涉)   主存-辅存层之间的数据调用是硬件+操作系统共同完成,  所以对应用程序员是透明的</p><h2 id="主存储器">主存储器</h2><p>主存储器由DRAM 实现  cache层则由 SRAM实现,   DRAM的每位价格是低于SRAM的,速度也慢,  价格差异主要在SRAM集成度低,需要多个元器件, 需要更多的硅, 而DRAM里面就一个电容和晶体管</p><h3 id="sram-和-dram">SRAM 和 DRAM</h3><h4 id="sram">SRAM</h4><p>SRAM（Static Random Access Memory）是一种随机访问存储器，与DRAM相比，它有其独特的特点和应用。以下是对SRAM的总结：</p><ol><li><p><strong>基本结构</strong>：</p><ul><li>SRAM单元通常由<strong>六个晶体管</strong>组成，而不是像DRAM那样由一个电容和一个晶体管组成。</li></ul></li><li><p><strong>静态性质</strong>：</p><ul><li>SRAM的“静态”名称意味着它不需要定期刷新来保持其内容。<strong>只要电源供应持续，数据就会保持不变</strong>。</li></ul></li><li><p><strong>速度</strong>：</p><ul><li>SRAM比DRAM快。这是因为SRAM不需要刷新，并且其内部结构允许更快速的数据访问。</li></ul></li><li><p><strong>成本与密度</strong>：</p><ul><li>由于SRAM单元需要更多的晶体管，它的密度低于DRAM，这也使得其成本相对较高。</li></ul></li><li><p><strong>功耗</strong>：</p><ul><li>在待机模式下，SRAM通常消耗的功率比DRAM少，但在活动模式下，由于不需要刷新，SRAM的功率消耗可能较低。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>由于其速度优势，SRAM通常用作CPU的高速缓存（如L1、L2或L3缓存）。</li><li>它也用于其他需要快速访问的应用，如实时系统的数据存储。</li></ul></li><li><p><strong>稳定性</strong>：</p><ul><li>SRAM比DRAM更稳定，因为它不依赖于电容来存储数据，因此不受电容放电的影响。</li></ul></li><li><p><strong>物理大小</strong>：</p><ul><li>由于SRAM单元需要更多的晶体管，它通常比DRAM大，这限制了它在某些高密度应用中的使用。</li></ul></li></ol><p>总的来说，SRAM由于其速度和稳定性优势，主要用于高速缓存和其他需要快速数据访问的应用，但其高成本和低密度使其不适合作为主存储器。</p><h4 id="dram">DRAM</h4><p>DRAM（Dynamic Random Access Memory）是一种随机访问存储器，广泛用于计算机和其他电子设备的主存储器。以下是对DRAM的总结：</p><ol><li><p><strong>基本结构</strong>：</p><ul><li>DRAM单元通常由一个电容和一个晶体管组成。电容存储数据（充电表示1，放电表示0），而晶体管作为控制开关，决定是否访问电容。</li></ul></li><li><p><strong>动态性质</strong>：</p><ul><li>DRAM的“动态”名称来源于其需要定期刷新来保持其内容。电容会随时间自然放电，因此需要定期重新充电以保持存储的数据。</li></ul></li><li><p><strong>速度</strong>：</p><ul><li>DRAM的访问速度比SRAM慢，部分原因是由于刷新操作。但与硬盘和其他非易失性存储相比，其速度仍然非常快。</li></ul></li><li><p><strong>成本与密度</strong>：</p><ul><li>由于DRAM单元的结构简单（只需要一个电容和一个晶体管），它具有较高的密度，这使得其成本相对较低，尤其是在大容量配置中。</li></ul></li><li><p><strong>功耗</strong>：</p><ul><li>DRAM在刷新时会消耗功率，但其功率需求通常低于SRAM，尤其是在高性能操作中。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>DRAM是现代计算机、游戏机、服务器和许多其他设备的主要主存储器形式。</li><li>它也被用于图形卡中，称为GDDR（与标准DRAM有所不同，特别优化用于图形数据）。</li></ul></li><li><p><strong>稳定性</strong>：</p><ul><li>由于需要定期刷新，DRAM在无电情况下不能长时间保持数据。</li></ul></li><li><p><strong>物理大小</strong>：</p><ul><li>DRAM的物理尺寸较小，这使得它能够在有限的空间内提供大量的存储容量。</li></ul></li></ol><p>总的来说，DRAM由于其成本效益、高密度和合理的速度，成为了现代电子设备中的主要存储技术。但其需要定期刷新的特性也为系统设计带来了额外的考虑。</p><p>刷新方式</p><ol><li><strong>集中刷新（Concentrated Refresh）</strong>：<ul><li><strong>描述</strong>：在一个短时间内连续进行所有必要的刷新操作，然后在较长的时间段内不进行任何刷新。这意味着在一个特定的时间窗口内，DRAM会连续地进行多次刷新操作。</li><li><strong>优点</strong>：在刷新之外的时间，DRAM完全可用于正常的读/写操作，不会受到刷新的干扰。</li><li><strong>缺点</strong>：在集中刷新期间，DRAM可能无法响应正常的读/写请求，从而导致性能下降。 <strong>存在死时间</strong></li></ul></li><li><strong>分散刷新（Distributed Refresh）</strong>：<ul><li><strong>描述</strong>：刷新操作在时间上均匀分布，而不是集中在一个短时间内。这意味着在一个给定的时间段内，刷新操作会定期发生，但每次只刷新一小部分。(<strong>前半段时间正常读写, 后半段用来刷新, 这样整个系统的存取周期增长了)</strong></li><li><strong>优点</strong>：由于刷新操作被分散，DRAM大部分时间都可以响应正常的读/写请求，从而减少了刷新对性能的影响。 <strong>不存在死时间</strong></li><li><strong>缺点</strong>：需要更复杂的控制逻辑来确保在整个操作期间都进行了足够的刷新。</li></ul></li><li><strong>异步刷新（Asynchronous Refresh）</strong>：<ul><li><strong>描述</strong>：刷新操作与正常的读/写操作完全独立，可以在任何时间进行。这意味着刷新操作不必等待当前的读/写操作完成，反之亦然。(<strong>内部有一个逻辑电路, 每隔一段时间发起一次刷新请求</strong>)</li><li><strong>优点</strong>：提供了极大的灵活性，允许DRAM在高负载条件下优化性能。<strong>降低了死时间</strong></li><li><strong>缺点</strong>：可能需要更复杂的控制逻辑和更高的带宽来同时处理读/写和刷新操作。</li></ul></li></ol><p><strong>刷新操作对CPU是透明的,</strong>  刷新的单位是行, 由芯片内部自动生成行地址, 而且刷新操作不需要选片</p><h3 id="主存储器的基本组成">主存储器的基本组成</h3><p>存储元 -&gt; 存储单元 -&gt; 存储体</p><p>地址单元是指 具有相同地址的存储单元构成的一个单位   可以按照字节编址, 也可以按照字编址. 现代计算机基本使用字节编址</p><h3 id="多模块存储器">多模块存储器</h3><p>多模块存储器是一种空间并行技术, 利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率</p><h4 id="单体多字存储器">单体多字存储器</h4><p>单体多字存储器是一种存储器结构，其中一个存储体内部包含多个字（数据单元）。这种结构的主要目的是提高数据传输的带宽和效率。</p><p>在单体多字存储器中，每个存储地址可以访问一个数据块，而不仅仅是一个单独的数据字。例如，如果我们说一个存储器是“4字存储器”，那么每个存储地址可能会映射到4个连续的数据字。</p><p><strong>特点</strong>：</p><ol><li><p><strong>并行性</strong>：在单体多字存储器中，尽管数据是顺序存储的，但多个数据字可以<strong>并行地被读取或写入</strong>。例如，如果一个存储器配置为4字存储器，那么在一个时钟周期内，它可能能够并行地读取或写入4个数据字。这与传统的存储器不同，后者可能在同一个时钟周期内只能访问一个数据字。( <strong>访问的字会放到缓存中,如果没有全部处理的话,下一次就是访问缓存, 而不是访问内存</strong>)</p></li><li><p><strong>高带宽</strong>：由于每次访问可以获取多个数据字，因此数据的传输率得到提高。</p></li><li><p><strong>连续存储</strong>：在物理存储中，相关的数据字通常是连续存储的，这有助于提高顺序访问的效率。</p></li><li><p><strong>复杂的控制逻辑</strong>：由于每个地址映射到多个数据字，所以控制逻辑可能会变得更复杂，特别是在数据需要被分散到不同的位置或从多个位置收集时。</p></li></ol><p><strong>应用</strong>：</p><p>单体多字存储器在需要高带宽和高数据传输率的应用中特别有用，例如图形处理或某些高性能计算任务。</p><p>然而，这种存储器结构并不总是最优的选择，因为它可能会增加成本和复杂性，尤其是在不需要连续高带宽的应用中。在选择存储器结构时，设计者需要权衡这些优缺点。</p><h4 id="多体并行存储器">多体并行存储器</h4><p>多体并行存储器由 多体模块组成, 每个模块都有相同的容量和存取速度, 各个模块又有独立的读写控制电路, 地址寄存器和数据寄存器,  他们既能并行工作, 又能交叉工作</p><p>高位交叉编址:   高位地址决定模块号 低位地址决定块内地址    如果是顺序访问主存块的话, 我们会发现 基本都是在同一个模块里面访问,这个跟普通的存储器没有区别, 也就是说没有利用到并行的优点   (顺序方式)</p><p>低位交叉编址:  低位地址决定模块号 高位地址决定块内地址  如果是顺序访问主存块的话,  我们会发现它基本会依次访问各个模块, 这样就能利用到并行的优点, 在上一个模块的还在等待可以被访问的时候,  我们可以访问下一个模块. 采用这种方式编址的存储器称为  <strong>交叉存储器</strong></p><p>假设各个模块的存取周期为 T, 总线的传输周期为r  如果要满足流水线方式存取, 那就需要  <strong>模块数 m &gt;= T/r</strong>   证明:  在第一个模块被访问后  需要T时间后才能访问,  那么这个时间内我们需要访问其他模块,  也就是  (m-1) * r &gt;= T-r.     所以连续访问m个字需要的时间为  T+(m-1)*r  (书上是这么写) ,  但是还有另外一种说法,  就是在一定时间t内能够访问多少个字,  那就是  t/r个字</p><h2 id="主存与cpu的连接">主存与CPU的连接</h2><h3 id="主存的扩展">主存的扩展</h3><h3 id="存储芯片的地址分配与片选">存储芯片的地址分配与片选</h3><h2 id="外部存储器">外部存储器</h2><h3 id="磁盘存储器">磁盘存储器</h3><h3 id="固态硬盘">固态硬盘</h3><p>基于闪存的技术,和U盘没有本质区别,  本质上还是一个ROM</p><h2 id="高速缓冲区">高速缓冲区</h2><h3 id="局部性原理">局部性原理</h3><h3 id="cache的基本工作原理">cache的基本工作原理</h3><ul><li>数据查找</li><li>地址映射</li><li>替换策略</li><li>写入策略</li></ul><h2 id="做题技巧">做题技巧</h2><ol><li>DRAM的芯片容量较大,  地址位数多,  为了减少芯片地址引脚数, 通常采用地址引脚复用技术,  行列地址使用相同的引脚先后两次输入, 这样可以减少一半的引脚数</li><li>关于DRAM 与 SRAM 最小引脚数问题 一般涉及几个方面</li></ol><ul><li><strong>片选线（Chip Select, CS）</strong>：用于选择特定的存储器芯片。在多芯片配置中，片选线可以帮助确定哪个芯片被选中进行读写操作。</li><li><strong>读写控制线</strong>：<ul><li><strong>R/W</strong>：这是一个双向控制线，用于指示是读操作还是写操作。对于某些存储器，读写控制可能会分为两个单独的线（例如，一个读控制线和一个写控制线）。</li></ul></li><li><strong>地址线</strong>：<ul><li><strong>DRAM</strong>：由于DRAM通常使用多路复用技术，所以它的地址线数量通常是总地址位数的一半。例如，一个有16M个存储位置的DRAM可能只需要11根地址线（因为2^11 = 2048，而2048x2048 = 16M）。</li><li><strong>SRAM</strong>：SRAM不使用多路复用，所以它的地址线数量等于其地址位数。</li></ul></li><li><strong>数据线</strong>：数据线的数量通常与存储器的数据宽度相匹配。例如，8位宽的存储器会有8条数据线。</li><li><strong>电源和地线</strong>：这些线为存储器提供电源。通常有VCC（或VDD）和GND。</li><li><strong>输出使能线（Output Enable, OE）</strong>：在某些设计中，这个线用于控制数据线上的输出。当OE被激活时，存储器的输出被放到数据线上。</li><li><strong>其他控制线</strong>：根据特定的存储器设计和应用，可能还有其他的控制线，如刷新控制线（特别是对于DRAM）。</li><li><strong>行选通线（Row Address Strobe, RAS）</strong>：当RAS信号被激活时，它告诉DRAM接下来的地址信息是行地址。这个行地址确定了DRAM中的一个特定行。</li><li><strong>列选通线（Column Address Strobe, CAS）</strong>：当CAS信号被激活时，它告诉DRAM接下来的地址信息是列地址。这个列地址与之前的行地址一起确定了DRAM中的一个特定单元。(<strong>对于DRAM地址复用来说, 我们可以使用行列选通线与片选线共用</strong>)</li></ul><ol start="3"><li>ROM 只读存储器具有随机访问的功能,  但是他不是随机访问存储器RAM</li><li>DRAM一次完整的刷新占用一个存储周期,  相当于读出来之后立即写回,<strong>其实就相当于一次访存</strong></li><li><strong>切莫粗心大意, 对于  8K 这种 一定不要写成了  2^18  它是 2^13</strong></li><li>cache只是主存的副本, 所以它算不上存储系统的容量</li><li>在计算cache总容量的时候, 一定要考虑每行还有对应的标记项,  有效位一定有,  标记位一定有   替换位和修改位 要看采用的替换策略和写回策略</li></ol><h1>指令系统</h1><h1>中央处理器(CPU)</h1><h2 id="做题总结">做题总结</h2><ul><li>微处理器是相对于大型处理器来说的,  无论是采用微程序控制器还是硬布线控制器,  微机的CPU都是微处理器</li><li>uPC决定微指令的执行顺序   PC 决定指令的执行顺序</li><li>指令周期是指CPU从主存取出并执行一条指令的时间,  指令周期由若干个机器周期(也称CPU周期) 组成,  比如取值周期, 间址周期,执行周期,中断周期, 这些都是机器周期,   机器周期由若干个时钟周期组成,  一般机器周期由存储周期决定</li></ul><h1>总线</h1><h1>输入输出(I/O)系统</h1><h1>额外补充</h1><h2 id="组合逻辑电路和时序逻辑电路">组合逻辑电路和时序逻辑电路</h2><p>组合逻辑电路和时序逻辑电路是数字逻辑设计中的两个基本概念。它们的主要区别在于是否涉及时间或时序的概念。</p><ol><li><p><strong>组合逻辑电路</strong>：</p><ul><li><p><strong>定义</strong>：组合逻辑电路的输出仅仅依赖于当前的输入值，而与先前的输入或状态无关。</p></li><li><p>特点</p><p>：</p><ul><li>没有记忆功能。</li><li>任何时候，相同的输入都会产生相同的输出。</li></ul></li><li><p><strong>常见元件</strong>：基本逻辑门（如AND、OR、NOT）、多路复用器、解码器、编码器等。</p></li><li><p><strong>应用</strong>：算术逻辑单元（ALU）、解码器、编码器等。</p></li></ul></li><li><p><strong>时序逻辑电路</strong>：</p><ul><li><p><strong>定义</strong>：时序逻辑电路的输出不仅依赖于当前的输入，还依赖于先前的输入或状态。这意味着它具有记忆功能。</p></li><li><p>特点</p><p>：</p><ul><li>有记忆功能，能够存储信息。</li><li>输出取决于当前输入和先前的状态。</li></ul></li><li><p><strong>常见元件</strong>：触发器（如D触发器、JK触发器、T触发器）、计数器、寄存器、时钟等。</p></li><li><p><strong>应用</strong>：存储元件、计数器、状态机等。</p></li></ul></li></ol><p><strong>总结</strong>：</p><ul><li>组合逻辑电路是“无记忆”的，其输出完全由当前输入决定。</li><li>时序逻辑电路具有“记忆”功能，其输出由当前输入和先前的状态共同决定。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++</title>
      <link href="/2023/06/22/C%E5%92%8CC++/c++/"/>
      <url>/2023/06/22/C%E5%92%8CC++/c++/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>这里我们只做c++部分的总结, 还有一些和c语言不同的地方</p><h2 id="版本">版本</h2><table><thead><tr><th style="text-align:left">发布时间</th><th style="text-align:left">通称</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">2020</td><td style="text-align:left">C++20, C++2a</td><td style="text-align:left">ISO/IEC 14882:2020</td></tr><tr><td style="text-align:left">2017</td><td style="text-align:left">C++17</td><td style="text-align:left">第五个C++标准</td></tr><tr><td style="text-align:left">2017</td><td style="text-align:left">coroutines TS</td><td style="text-align:left">协程库扩展</td></tr><tr><td style="text-align:left">2017</td><td style="text-align:left">ranges TS</td><td style="text-align:left">提供范围机制</td></tr><tr><td style="text-align:left">2017</td><td style="text-align:left">library fundamentals TS</td><td style="text-align:left">标准库扩展</td></tr><tr><td style="text-align:left">2016</td><td style="text-align:left">concurrency TS</td><td style="text-align:left">用于并发计算的扩展</td></tr><tr><td style="text-align:left">2015</td><td style="text-align:left">concepts TS</td><td style="text-align:left">概念库，用于优化编译期信息</td></tr><tr><td style="text-align:left">2015</td><td style="text-align:left">TM TS</td><td style="text-align:left">事务性内存操作</td></tr><tr><td style="text-align:left">2015</td><td style="text-align:left">parallelism TS</td><td style="text-align:left">用于并行计算的扩展</td></tr><tr><td style="text-align:left">2015</td><td style="text-align:left">filesystem TS</td><td style="text-align:left">文件系统</td></tr><tr><td style="text-align:left">2014</td><td style="text-align:left">C++14</td><td style="text-align:left">第四个C++标准</td></tr><tr><td style="text-align:left">2011</td><td style="text-align:left">-</td><td style="text-align:left">十进制浮点数扩展</td></tr><tr><td style="text-align:left">2011</td><td style="text-align:left">C++11</td><td style="text-align:left">第三个C++标准</td></tr><tr><td style="text-align:left">2010</td><td style="text-align:left">-</td><td style="text-align:left">数学函数扩展</td></tr><tr><td style="text-align:left">2007</td><td style="text-align:left">C++TR1</td><td style="text-align:left">C++技术报告：库扩展</td></tr><tr><td style="text-align:left">2006</td><td style="text-align:left">-</td><td style="text-align:left">C++性能技术报告</td></tr><tr><td style="text-align:left">2003</td><td style="text-align:left">C++03</td><td style="text-align:left">第二个C++标准</td></tr><tr><td style="text-align:left">1998</td><td style="text-align:left">C++98</td><td style="text-align:left">第一个C++标准</td></tr></tbody></table><h1>数据类型</h1><p>多出了一些类型</p><ul><li>bool</li><li>class</li></ul><h1>存储类</h1><ul><li>auto 自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：<strong>声明变量时根据初始化表达式自动推断该变量的类型</strong>、<strong>声明函数时函数返回值的占位符</strong></li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><p><strong>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</strong></p><h1>引用</h1><p>这个是c++多出来的东西, 它相当于一个变量的别名,操作它就像在操作它引用的变量一样,  这样可以传递引用数据给函数, <strong>解决修改形参不能影响实参的问题</strong></p><h1>函数</h1><ul><li>c++ 中 函数是支持重载的</li><li>函数参数可以有默认值, 但是必须是最右边连续的若干个参数</li><li><strong>c++11多出了Lambda表达式</strong></li></ul><h2 id="lambda表达式">Lambda表达式</h2><p>Lambda 表达式具体形式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p><strong>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为</strong>, 但是访问行为是通过capture控制的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]      // 沒有定义任何变量。使用未定义变量会引发错误。</span><br><span class="line">[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。</span><br><span class="line">[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。</span><br><span class="line">[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。</span><br><span class="line">[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span><br><span class="line">[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span><br></pre></td></tr></table></figure><p>如果使用了 =  那么被捕获的变量是const类型的,  不能修改这个变量,  如果被捕获的是一个对象,那么是无法通过这个变量调用它的非常量成员函数的</p><blockquote><p>通过引用方式传入一定要保证在Lambda函数使用期间这个值要存在,没有销毁</p></blockquote><h1>类和对象</h1><h2 id="一些函数">一些函数</h2><p>C++ 类中的构造函数、析构函数和其他相关函数是类设计的核心部分，它们负责对象的创建、初始化、复制、移动和销毁。下面是对这些函数的简要总结：</p><ol><li><p><strong>构造函数 (Constructor)</strong>: 用于创建和初始化对象。构造函数可以有不同的形式：</p><ul><li><strong>默认构造函数</strong>：无需任何参数，用于创建类的默认对象。</li><li><strong>带参数的构造函数</strong>：允许传递参数，用于根据这些参数初始化对象。</li><li><strong>拷贝构造函数</strong>：以同类的另一个对象为参数，用于创建一个新对象作为原对象的副本。</li><li><strong>移动构造函数</strong>：以同类的右值引用作为参数，用于支持将资源从一个对象转移到另一个对象。</li></ul></li><li><p><strong>析构函数 (Destructor)</strong>: 用于在对象生命周期结束时进行清理。析构函数没有参数，也不返回任何值。它通常用于释放对象占用的资源，如动态分配的内存。</p></li><li><p><strong>拷贝赋值运算符</strong>：允许将一个对象的内容复制到另一个已经存在的对象中。这通常涉及深拷贝和浅拷贝的考虑。</p></li><li><p><strong>移动赋值运算符</strong>：允许将一个对象的资源“移动”到另一个已经存在的对象中。这通常用于优化性能，避免不必要的资源复制。</p></li><li><p><strong>友元函数 (Friend Function)</strong>: 虽然不是类的成员函数，但可以访问类的所有私有和保护成员。</p></li></ol><h2 id="this">this</h2><p>在C++中，<code>this</code>是一个特殊的指针，它在每个类的非静态成员函数中都可用。<code>this</code>指针指向调用当前成员函数的对象。这意味着，通过<code>this</code>指针，成员函数可以访问调用它的对象的其他成员。</p><p>以下是关于<code>this</code>指针的一些重要点：</p><ol><li><strong>隐式参数</strong>：<code>this</code>在所有非静态成员函数中都是可用的，即使你在函数参数列表中没有明确声明它。</li><li><strong>常量指针</strong>：<code>this</code>是一个常量指针，这意味着你不能改变<code>this</code>指向的对象。</li><li><strong>成员访问</strong>：<code>this</code>通常用于在成员函数内部访问对象的其他成员（包括数据成员和其他成员函数）。</li><li><strong>链式调用</strong>：<code>this</code>指针常常被用于实现链式函数调用。如果一个成员函数返回<code>*this</code>，那么可以连续调用同一对象的多个成员函数</li></ol><p><strong>C++编译器在编译类的成员函数时，会为这些函数添加一个额外的参数，通常是作为第一个参数，这个额外的参数就是<code>this</code>指针，它指向调用该成员函数的对象。</strong></p><p>当我们调用一个成员函数时，例如 <code>obj.func()</code>, 实际上这会被编译成类似 <code>func(&amp;obj)</code> 这样的形式。这样，即使我们没有明确写出<code>this</code>，成员函数内部也能通过<code>this</code>指针来访问对象的数据成员和其他成员函数。</p><h2 id="静态成员">静态成员</h2><p>在 C++ 中，使用 <code>static</code> 关键字声明的类成员具有以下特性：</p><ol><li><strong>静态成员变量</strong>：<ul><li>所有该类的对象共享同一个静态成员变量，即类的所有实例都会使用同一份数据。</li><li>静态成员变量只有一个类级别的存储空间，不会随着对象的创建和销毁而创建或销毁。</li><li><strong>静态成员变量需要在类定义外进行单独的定义和初始化</strong>。(类里面的静态变量相当于只是声明,需要在外部定义) 站在c语言的角度其实就好理解了,  如果在类里面就能初始化这个静态变量的话,  那岂不是说这个变量是在这个文件里面定义,  那这样的话, 如果多个文件包含了这个头文件, 必然报错</li><li>静态成员变量可以通过对象访问，也可以通过类名访问。</li></ul></li><li><strong>静态成员函数</strong>：<ul><li>静态成员函数可以在不创建对象的情况下直接使用类名来调用，它只能访问静态成员变量和静态成员函数，不能访问非静态成员变量或非静态成员函数。</li><li>静态成员函数不含有 <code>this</code> 指针。</li></ul></li></ol><h2 id="友元">友元</h2><p>在C++中，<code>friend</code>关键字被用来声明友元，它能够让一个函数或者类访问其他类的私有和保护成员。以下是关于友元的一些主要特点：</p><ol><li><strong>友元函数</strong>：如果一个<strong>函数(可以是类的成员函数,也可以是全局函数)被声明为一个类的友元</strong>，那么这个函数可以访问这个类的所有成员（包括私有和保护成员）。友元函数不是这个类的成员，也不受类的访问控制规则的约束。友元函数在类外定义，但需要在类内通过<code>friend</code>关键字声明。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OtherClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(): <span class="built_in">value</span>(<span class="number">10</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 将OtherClass的特定成员函数声明为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">OtherClass::accessMyClass</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 全局函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(MyClass &amp;obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessMyClass</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value in MyClass: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;  <span class="comment">// 可以访问私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendFunction</span><span class="params">(MyClass &amp;obj)</span> </span>&#123;</span><br><span class="line">    obj.value = <span class="number">10</span>; <span class="comment">// 可以访问私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>friendFunction</code>被声明为<code>MyClass</code>的友元函数，所以它可以访问<code>MyClass</code>的私有成员<code>value</code>。</p><ol start="2"><li><strong>友元类</strong>：如果一个类被声明为另一个类的友元，那么这个类的所有成员函数都可以访问另一个类的所有成员（包括私有和保护成员）。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOtherClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyOtherClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOtherClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(MyClass &amp;obj)</span> </span>&#123;</span><br><span class="line">        obj.value = <span class="number">10</span>; <span class="comment">// 可以访问私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyOtherClass</code>被声明为<code>MyClass</code>的友元类，所以<code>MyOtherClass</code>的成员函数<code>function</code>可以访问<code>MyClass</code>的私有成员<code>value</code>。</p><ol start="3"><li><p><strong>友元的使用</strong>：虽然友元提供了一种突破类的封装性的方法，但是它应该谨慎使用。过度使用友元可能会破坏封装性和隐藏性，这可能会导致代码更难理解和维护。在大多数情况下，可以通过其他方式（如公有成员函数）来访问私有和保护成员。</p></li><li><p><strong>友元和继承</strong>：友元关系不能被继承。<strong>如果类B是类A的友元，并且类C继承了类A，那么类B不是类C的友元。同样，如果类B是类A的友元，并且类B继承了类D，那么类D不是类A的友元。</strong></p></li></ol><h2 id="常量对象-常量成员函数">常量对象,常量成员函数</h2><p>在C++中，常量对象和常量成员函数有如下的特性：</p><ol><li><p><strong>常量对象</strong>：<strong>如果一个对象被声明为常量，那么在其生命周期内，它的值都不能被改变</strong>。这种对象常常用于保存不应该被修改的值，例如配置信息或者全局设置。常量对象必须在创建时初始化。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x现在是一个常量，不能被修改</span></span><br><span class="line"><span class="type">const</span> MyClass obj; <span class="comment">// obj是一个常量对象，不能修改其任何成员变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量成员函数</strong>：如果一个成员函数被声明为常量，那么在该成员函数内，不能修改任何非静态成员变量的值。常量成员函数通过在函数参数列表后添加<code>const</code>关键字来声明。这种函数常常用于定义在逻辑上应该不修改成员变量值的操作，例如访问器（getter）函数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>getValue</code>是一个常量成员函数，它不能修改<code>value</code>成员变量的值。</p></li><li><p><strong>常量对象和常量成员函数的关系</strong>：<strong>常量对象只能调用常量成员函数，非常量对象可以调用常量成员函数和非常量成员函数</strong>。这是因为常量对象不能修改其成员变量的值，而常量成员函数保证了它不会修改成员变量的值，所以只有常量成员函数才能在常量对象上调用。</p></li></ol><p><strong>一个常量成员函数和一个非常量成员函数，即使他们的参数完全相同，也被视为重载（overloaded）</strong>。在 C++ 中，成员函数的常量性被视为函数签名的一部分，因此，下面两个函数会被视为两个不同的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 非常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 常量成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>func()</code>和<code>func() const</code>是两个不同的函数，一个是常量成员函数，一个是非常量成员函数。当你有一个非常量对象时，两者都可以被调用，<strong>但是如果有一个具体的操作需要改变对象状态，那么非常量版本的函数将被调用,如果要调用常量版本函数,需要转化成常量对象</strong>；如果操作不需要改变对象状态，常量版本的函数将被调用。如果你有一个常量对象，只有常量成员函数可以被调用，尝试调用非常量成员函数将导致编译错误。</p><p>以上是关于C++中常量对象和常量成员函数的基本介绍，理解这些概念对于编写更安全和更高效的C++代码非常重要。</p><h2 id="运算符重载">运算符重载</h2><p>C++允许我们对大多数内置的运算符进行重载，从而使我们可以使用自然的符号来操作自定义数据类型。下面是关于C++运算符重载的一些重要内容：</p><ol><li><p><strong>基本规则</strong>：你可以为任何自定义数据类型（比如类或结构体）重载运算符。运算符重载函数可以是成员函数或非成员（但需声明为友元）函数。需要注意的是，运算符重载并不改变运算符的优先级。</p></li><li><p><strong>成员与非成员</strong>：大多数运算符可以通过<strong>成员函数或非成员函数进行重载</strong>。但有几个例外：赋值运算符（<code>= </code>）、下标运算符（<code>[]</code>）、函数调用运算符（<code>()</code>）和成员访问运算符（<code>-&gt;</code>）只能通过成员函数重载。<strong>如果存在成员运算符重载和非成员运算符重载，编译器会优先调用成员运算符重载</strong></p></li><li><p><strong>一元和二元运算符</strong>：一元运算符（例如<code>++</code>，<code>--</code>，<code>-</code>，<code>!</code>等）通常作为成员函数重载，没有参数。二元运算符（例如<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>等）通常有一个参数作为成员函数重载，或两个参数作为非成员函数重载。</p></li><li><p><strong>复合赋值运算符</strong>：像<code>+=</code>，<code>-=</code>，<code>*=</code>等复合赋值运算符也可以被重载。它们通常作为成员函数重载，有一个参数。</p></li><li><p><strong>关系和逻辑运算符</strong>：关系运算符（<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>）和逻辑运算符（<code>&amp;&amp;</code>，<code>||</code>）通常作为非成员函数重载，以便对两个参数进行操作。尽管这些可以作为成员函数重载，但在使用中可能会产生歧义。</p></li><li><p><strong>输入/输出运算符</strong>：流插入运算符<code>&lt;&lt;</code>和流提取运算符<code>&gt;&gt;</code>通常作为非成员函数重载，因为它们的左操作数通常是<code>std::ostream</code>或<code>std::istream</code>对象，而不是自定义类型。</p></li><li><p><strong>限制</strong>：并非所有的运算符都可以重载。有些运算符，例如<code>.</code>（点运算符），<code>.*</code>（点星运算符），<code>::</code>（作用域解析运算符），<code>sizeof</code>（大小运算符）以及三目运算符<code>?:</code>不能被重载。</p></li><li><p><strong>自然性和一致性</strong>：虽然运算符重载提供了大量的自由度，但是滥用运算符重载可能会导致代码难以理解和维护。<strong>当你选择重载一个运算符时，你应该让它的行为尽可能地符合程序员对这个运算符的直觉</strong>。例如，<code>+</code>运算符应该总是表示一种合并或添加操作，而不应该被用来表示一种完全不相关的操作。</p></li></ol><p>以上就是关于C++运算符重载的基本介绍，理解这个概念对于编写更自然和更高效的C++代码非常重要。</p><blockquote><p>前置运算符++ 和 – 作为一元运算符  后置 运算符++ 和 – 作为二元运算符</p></blockquote><h2 id="继承">继承</h2><p>C++的继承是面向对象编程的一个重要特性，它允许我们创建一个新的类（派生类）来继承一个已有类（基类）的特性，并可以增加新的特性。以下是关于C++继承的一些关键内容：</p><ol><li><p><strong>基础</strong>：在C++中，一个类可以从一个或多个已有的类继承特性。单继承表示一个类只能从一个类继承，多继承表示一个类可以从多个类继承。</p></li><li><p><strong>访问控制</strong>：<strong>派生类可以访问基类的公有和保护成员，但不能访问基类的私有成员</strong>。</p></li><li><p><strong>继承类型</strong>：C++支持三种类型的继承：公有继承（public）、保护继承（protected）和私有继承（private）。公有继承是最常用的，它表示公有和保护成员的访问级别在<strong>派生类中保持不变</strong>。保护继承意味着所有基类的公有和保护成员在派生类中都变为保护的。私有继承表示所有基类的公有和保护成员在派生类中都变为私有的。</p></li><li><p><strong>构造和析构</strong>：<strong>派生类的构造函数会自动调用基类的默认构造函数，然后执行派生类自己的构造函数</strong>。如果需要调用基类的其他构造函数，你需要在派生类的构造函数<strong>初始化列表中显式调用</strong>。析构的顺序与构造的顺序相反，首先执行派生类的析构函数，然后执行基类的析构函数。</p></li><li><p><strong>函数重载和覆盖</strong>：如果派生类定义了一个与基类中的函数具有<strong>相同名称和参数的函数</strong>，那么这个函数会覆盖基类的函数，这就是所谓的<strong>函数覆盖</strong>。如果派生类的函数与基类的函数名相同，但<strong>参数不同，那么它就是函数重载</strong>。</p></li><li><p><strong>虚函数和多态</strong>：虚函数允许我们利用指向基类的指针或引用来调用派生类中的函数，这就是多态的基础。如果基类指针或引用指向的是派生类对象，那么调用的是派生类的函数。这就是所谓的运行时多态性。</p></li><li><p><strong>抽象类</strong>：如果一个类包含至少一个纯虚函数（用<code>= 0</code>声明的虚函数），那么这个类就是抽象类。抽象类不能被实例化，只能作为基类。派生类必须实现所有的纯虚函数，除非派生类也是抽象类。</p></li></ol><p>以上就是关于C++继承的主要内容。理解和使用继承是掌握面向对象编程的关键。</p><h2 id="多态">多态</h2><p>多态是面向对象编程的三大特性之一（封装、继承和多态）。在C++中，多态可以分为两种主要类型：编译时多态（也称为静态多态）和运行时多态（也称为动态多态）。</p><p><strong>1. 编译时多态：</strong></p><p>编译时多态主要是通过函数重载和模板实现的。函数重载允许在同一作用域内有多个名称相同但参数列表不同的函数。编译器会根据函数的调用上下文（具体的参数类型和数量）在编译时确定调用哪个函数。模板则是一种泛型编程机制，它允许你编写能够处理不同类型的数据的代码，而具体的类型在编译时确定。</p><p><strong>2. 运行时多态：</strong></p><p>运行时多态是通过虚函数实现的。如果一个类（基类）有一个或多个虚函数，并且有另一个类（派生类）继承了这个类并重写了这些虚函数，那么通过基类的指针或引用调用这些函数时，实际上调用的是派生类的版本。这个决定是在运行时作出的，因此称为运行时多态。</p><p>以下是一个运行时多态的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base* basePtr = &amp;derived; </span><br><span class="line">    basePtr-&gt;<span class="built_in">print</span>(); <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>print()</code>是<code>Base</code>类的虚函数，<code>Derived</code>类重写了这个函数。我们使用<code>Base</code>类的指针<code>basePtr</code>指向一个<code>Derived</code>类的对象，然后通过这个指针调用<code>print()</code>函数，实际上调用的是<code>Derived</code>类的版本。</p><p>值得注意的是，运行时多态在C++中需要满足以下条件：</p><ol><li>必须存在继承关系。</li><li>基类中的函数必须是虚函数，并在派生类中被重写。</li><li>必须通过基类的指针或引用来调用这些函数。</li></ol><h3 id="多态的原理">多态的原理</h3><p>在C++中，运行时多态是通过虚函数表（vtable）和虚函数表指针（vptr）实现的。虚函数表是一个存储类的虚函数地址的表，每一个具有虚函数的类都有自己的虚函数表；虚函数表指针是一个指向虚函数表的指针，每一个具有虚函数的对象都有一个虚函数表指针。</p><p>以下是具体的工作原理：</p><ol><li><strong>虚函数表的创建</strong>：当一个类被定义时，如果这个类有虚函数（包括从基类继承来的虚函数），编译器就会为这个类生成一个虚函数表。虚函数表是一个存储函数地址的数组，其中每个条目对应于一个虚函数。虚函数表的确切布局和内容取决于虚函数的声明顺序和继承结构。</li><li><strong>虚函数表指针的创建</strong>：当一个对象被创建时，如果这个对象的类有虚函数，那么这个对象就会包含一个虚函数表指针。这个指针指向这个对象的类的虚函数表。</li><li><strong>调用虚函数</strong>：当通过指针或引用调用虚函数时，编译器会生成代码来获取对象的虚函数表指针，然后通过这个指针查找虚函数表，找到虚函数的地址，然后调用这个函数。</li></ol><p>这种机制使得编译器在编译时无需知道对象的确切类型，只需要知道对象有一个虚函数表指针，并且知道如何通过这个指针和虚函数的声明找到虚函数的地址，就可以在运行时动态地调用正确的函数。这就是C++运行时多态的原理</p><h3 id="虚析构函数-抽象类">虚析构函数 抽象类</h3><p><strong>1. 虚析构函数</strong></p><p>在C++中，如果<strong>基类指针指向派生类对象</strong>，并且<strong>通过基类指针来删除派生类对象</strong>，<strong>如果基类的析构函数不是虚函数，那么就只会调用基类的析构函数，而不会调用派生类的析构函数</strong>，这可能会导致资源泄露。为了解决这个问题，<strong>如果一个类可能被用作基类，并且可能通过基类指针来删除派生类对象，那么应该将析构函数声明为虚函数。</strong></p><p><strong>2. 纯虚函数</strong></p><p>纯虚函数是没有定义的虚函数，声明时在函数的结尾处添加<code> = 0</code>。纯虚函数主要用于定义接口，它们在基类中没有定义，在派生类中必须被重写。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>3. 抽象类</strong></p><p>包含纯虚函数的类被称为抽象类。抽象类不能实例化，它的主要目的是作为基类，定义接口供派生类实现。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteClass::pureVirtualFunction()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>AbstractClass</code>是一个抽象类，<code>ConcreteClass</code>是一个派生类，它实现了<code>AbstractClass</code>的纯虚函数<code>pureVirtualFunction</code>。因此，我们可以创建<code>ConcreteClass</code>的实例，但不能创建<code>AbstractClass</code>的实例。</p><h1>模板</h1><p>在C++中，模板是用于实现泛型编程的工具。它们允许程序员创建可以处理不同数据类型的函数或类，而不必为每个类型都编写单独的代码。C++模板包括两种类型：函数模板和类模板。</p><ol><li><strong>函数模板</strong>：函数模板用于创建可以适应多种类型的函数。基本语法如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过参数生成</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 显式指定</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的<code>T</code>是一个占位符，表示任何数据类型。当函数被调用时，编译器会根据传入参数的实际类型生成相应的函数。</p><ol start="2"><li><strong>类模板</strong>：类模板允许程序员创建能够处理任意数据类型的类。基本语法如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="comment">// 类定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和函数模板一样，这里的<code>T</code>也是一个占位符，表示任何数据类型。当创建类的实例时，编译器会根据指定的实际类型生成相应的类。</p><p>在使用模板时，还需要注意以下几点：</p><ul><li>模板参数不仅可以是<code>typename</code>，也可以是<code>class</code>。在模板参数中，它们是相同的。</li><li>模板可以有多个参数，它们用逗号隔开。例如，<code>template &lt;typename T, typename U&gt;</code></li><li>在调用模板函数或实例化模板类时，如果编译器能够自动推断模板参数类型，可以不明确指定模板参数类型。例如，<code>func(5)</code>对于上述的<code>func</code>模板，编译器会自动推断<code>T</code>为<code>int</code>。</li><li>特化是模板的一个重要特性。它允许程序员为特定类型提供模板的特殊实现。例如，程序员可以为上述的<code>func</code>模板提供一个特别处理<code>int</code>类型的版本。</li></ul><p>这就是C++模板的基本概念。模板是C++中非常强大的特性，它使得C++能够支持泛型编程。</p><h1>输入输出</h1><p>在C++的iostream库中，有很多用于输入/输出的函数。这个库提供了四个主要的数据流对象：<code>cin</code>，<code>cout</code>，<code>cerr</code>和<code>clog</code>，分别对应于标准输入，标准输出，标准错误和标准日志。</p><h2 id="istream常用成员函数">istream常用成员函数</h2><p><code>istream</code>类在C++标准库中用于读取数据。这里是<code>istream</code>类的一些常用成员函数：</p><ol><li><p><strong>读取操作</strong>：</p><ul><li><code>istream&amp; operator&gt;&gt;(istream&amp; is, T&amp; value)</code>: 重载的输入运算符用于从输入流中读取不同类型的数据（例如整数、浮点数、字符串等）。</li><li><code>istream&amp; getline(istream&amp; is, string&amp; str, char delim)</code>: 从输入流中读取一行，直到遇到分隔符（默认为’\n’）为止，并将结果存储在字符串中。</li><li><code>istream&amp; get(char&amp; c)</code>: 从输入流中读取一个字符并存储在传入的字符变量中。</li></ul></li><li><p><strong>流状态查询</strong>：</p><ul><li><code>bool good() const</code>: 如果流未遇到任何错误，则返回<code>true</code>。</li><li><code>bool eof() const</code>: 如果流到达了文件末尾，则返回<code>true</code>。</li><li><code>bool fail() const</code>: 如果流在非致命错误（如格式错误）后失败，则返回<code>true</code>。</li><li><code>bool bad() const</code>: 如果流在致命错误（如读/写操作失败）后失败，则返回<code>true</code>。</li></ul></li><li><p><strong>位置和格式控制</strong>：</p><ul><li><code>streampos tellg()</code>: 返回当前的输入流位置。</li><li><code>istream&amp; seekg(streampos pos)</code>: 设置输入流的位置到指定的<code>pos</code>。</li><li><code>istream&amp; ignore(streamsize n = 1, int delim = EOF)</code>: 从输入流中忽略最多<code>n</code>个字符，或者直到遇到<code>delim</code>字符为止。</li></ul></li></ol><p>这只是<code>istream</code>类的一部分，它还包含许多其他方法，例如对于不同数据类型的特殊化输入运算符，以及控制流格式和错误处理的方法。</p><h1>STL</h1><p>C++标准模板库（STL，Standard Template Library）提供了一套功能丰富的模板类和函数，这些模板类和函数主要分为四大部分：容器（containers）、算法（algorithms）、迭代器（iterators）和函数对象（functors）。</p><ol><li><p><strong>容器（Containers）</strong>：容器是用来管理某一类对象的集合。STL提供了多种类型的容器，可以分为序列容器和关联容器两大类。</p><ul><li><p><strong>序列容器</strong>：包括<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>（C++11引入）、<code>array</code>（C++11引入）和<code>string</code>。</p></li><li><p><strong>关联容器</strong>：包括<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>、以及它们的无序版本（C++11引入）：<code>unordered_set</code>、<code>unordered_multiset</code>、<code>unordered_map</code>、<code>unordered_multimap</code>。</p></li><li><p><strong>容器适配器</strong>：包括<code>stack</code>、<code>queue</code>、<code>priority_queue</code>。</p></li></ul></li><li><p><strong>算法（Algorithms）</strong>：STL提供了一大批算法，包括对序列进行操作的算法（如<code>sort</code>、<code>find</code>、<code>count</code>、<code>replace</code>等），以及对数值进行操作的算法（如<code>accumulate</code>、<code>inner_product</code>等）。</p></li><li><p><strong>迭代器（Iterators）</strong>：迭代器提供了一种方法，使得程序员能够依次访问容器中的元素，而不需要关注容器的内部结构。根据功能的不同，迭代器可以分为五种类型：输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。</p></li><li><p><strong>函数对象（Functors）</strong>：函数对象是行为类似函数的对象，其类定义了<code>operator()</code>。STL中提供了一些预定义的函数对象，如<code>less</code>、<code>greater</code>、<code>plus</code>、<code>minus</code>等，它们都定义在<code>&lt;functional&gt;</code>头文件中。</p></li></ol><p>此外，STL还包括一些辅助功能：</p><ul><li><p><strong>分配器（Allocators）</strong>：用于控制容器中的内存分配。</p></li><li><p><strong>适配器（Adapters）</strong>：包括容器适配器（如<code>stack</code>、<code>queue</code>、<code>priority_queue</code>）、迭代器适配器（如<code>reverse_iterator</code>、<code>move_iterator</code>）、函数适配器（如<code>bind</code>、<code>negate</code>）。</p></li><li><p><strong>类型特性（Type Traits）</strong>：是一种模板编程技巧，用于在编译时推断类型的属性。例如，<code>is_integral</code>可以检查一个类型是否是整数类型。</p></li></ul><p>以上是STL的主要组成部分，这些模板库共同构成了C++的强大功能，使其在许多场合下都可以进行高效、方便的编程。</p><h2 id="迭代器">迭代器</h2><p>迭代器（Iterators）是一种在C++中用于遍历容器（如数组和链表）的元素的方法。迭代器的工作方式类似于指针：通过迭代器，你可以访问和修改其指向的元素。</p><p>迭代器提供了一种通用的接口，无论容器的实现方式如何，你都可以使用相同的方式来遍历和操作容器中的元素。这使得编写泛型代码更加简单和方便。</p><p>C++ STL提供了几种不同类型的迭代器，这些迭代器按照支持的操作可以分为五类：</p><ol><li><p><strong>输入迭代器（Input Iterators）</strong>：输入迭代器可以用来从容器读取元素，<strong>但不能用来修改元素</strong>。输入迭代器只能一次向前移动。</p></li><li><p><strong>输出迭代器（Output Iterators）</strong>：输出迭代器可以用来向容器写入元素，<strong>但不能用来读取元素</strong>。输出迭代器只能一次向前移动。</p></li><li><p><strong>前向迭代器（Forward Iterators）</strong>：前向迭代器可以用来读取和写入元素。前向迭代器只能一次向前移动。</p></li><li><p><strong>双向迭代器（Bidirectional Iterators）</strong>：双向迭代器可以用来读取和写入元素。双向迭代器可以向前或向后移动。</p></li><li><p><strong>随机访问迭代器（Random Access Iterators）</strong>：随机访问迭代器可以用来读取和写入元素。<strong>随机访问迭代器可以进行任意的跳转</strong>。</p></li></ol><p>双向迭代器（Bidirectional Iterators）和随机访问迭代器（Random Access Iterators）都是C++ STL中的迭代器种类，它们都可以用于访问和修改容器中的元素。</p><p><strong>共同功能：</strong></p><ol><li><p><strong>正向迭代</strong>：双向迭代器和随机访问迭代器都可以用<code>++</code>操作符来向前移动，例如<code>++iter</code>或<code>iter++</code>。</p></li><li><p><strong>反向迭代</strong>：双向迭代器和随机访问迭代器都可以用<code>--</code>操作符来向后移动，例如<code>--iter</code>或<code>iter--</code>。</p></li><li><p><strong>解引用</strong>：双向迭代器和随机访问迭代器都可以用<code>*</code>操作符来访问当前元素，例如<code>*iter</code>。</p></li><li><p><strong>成员访问</strong>：双向迭代器和随机访问迭代器都可以用<code>-&gt;</code>操作符来访问当前元素的成员，例如<code>iter-&gt;member</code>。</p></li><li><p><strong>比较</strong>：双向迭代器和随机访问迭代器都可以用<code>==</code>和<code>!=</code>操作符来比较两个迭代器是否相等。</p></li></ol><p><strong>不同功能：</strong></p><ol><li><p><strong>跳跃迭代</strong>：只有随机访问迭代器支持跳跃迭代，也就是一次移动多个位置。你可以用<code>+</code>或<code>-</code>操作符，或者用<code>+=</code>或<code>-=</code>操作符来移动迭代器。例如，<code>iter + 5</code>或<code>iter - 5</code>，<code>iter += 5</code>或<code>iter -= 5</code>。</p></li><li><p><strong>比较顺序</strong>：只有随机访问迭代器支持<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>操作符来比较两个迭代器的顺序。</p></li><li><p><strong>随机访问</strong>：只有随机访问迭代器支持<code>[]</code>操作符来随机访问元素，例如<code>iter[5]</code>。</p></li></ol><p>双向迭代器主要用于可以前后移动的容器，如<code>list</code>、<code>set</code>、<code>map</code>等，而随机访问迭代器用于可以随机访问的容器，如<code>vector</code>、<code>deque</code>、<code>array</code>等。</p><h2 id="排序规则">排序规则</h2><p>对于大多数的容器(set,map) 和 算法 (sort) 来说,  默认排序规则是从小到大排序  而对于 priority_queue来说是从大到小排序,  他们所谓的排序规则是指 <strong>我们提供的函数指针和函数对象 执行后的返回值,  如果返回true  那么认为前一个元素比后一个元素小,  否则就认为前一个元素比后一个元素大</strong>,  所以对于大多数容器和算法来说  如果排序规则返回了 true ,就认为两个元素相对位置(<strong>这里的相对位置只有前后一说</strong>)不变,  否则相对位置就要改变,   但是对于 priority_queue 来说   如果排序规则返回了 true 就需要改变位置, 否则不变</p><h2 id="容器">容器</h2><p>C++标准模板库（STL）提供了一系列容器，它们可以用来存储和操作数据。下面是一些主要的C++容器：</p><ol><li><p><strong>序列容器</strong>：存储元素的线性集合。</p><ul><li><p><code>std::vector</code>：动态数组，提供快速的随机访问，而且在末尾添加或删除元素也很快。但在中间位置插入或删除元素较慢。</p></li><li><p><code>std::deque</code>：双端队列，提供快速随机访问，且在头部或尾部添加或删除元素都很快。但在中间位置插入或删除元素较慢。</p></li><li><p><code>std::list</code>：双向链表，提供快速的插入和删除，但不支持随机访问。</p></li><li><p><code>std::forward_list</code>：单向链表，只支持向前迭代，插入和删除速度快，但不支持随机访问。</p></li><li><p><code>std::array</code>：固定大小的数组，提供快速随机访问，但大小在编译时需要确定，且不能改变。</p></li></ul></li><li><p><strong>容器适配器</strong>：使用其他容器进行封装，提供特定的接口。</p><ul><li><p><code>std::stack</code>：提供后入先出（LIFO）的数据访问模式。</p></li><li><p><code>std::queue</code>：提供先入先出（FIFO）的数据访问模式。</p></li><li><p><code>std::priority_queue</code>：队列中的每个元素都有一个优先级，优先级最高的元素先出队。</p></li></ul></li><li><p><strong>关联容器</strong>：使用关键字进行数据访问。</p><ul><li><p><code>std::set</code>：存储键的集合，每个键只出现一次，键自动排序。</p></li><li><p><code>std::multiset</code>：存储键的集合，允许键有多个重复，键自动排序。</p></li><li><p><code>std::map</code>：键值对集合，每个键只出现一次，键自动排序。</p></li><li><p><code>std::multimap</code>：键值对集合，允许键有多个重复，键自动排序。</p></li></ul></li><li><p><strong>无序关联容器</strong>：使用哈希函数进行数据访问，不自动排序。</p><ul><li><p><code>std::unordered_set</code>：存储键的集合，每个键只出现一次，键不自动排序。</p></li><li><p><code>std::unordered_multiset</code>：存储键的集合，允许键有多个重复，键不自动排序。</p></li><li><p><code>std::unordered_map</code>：键值对集合，每个键只出现一次，键不自动排序。</p></li><li><p><code>std::unordered_multimap</code>：键值对集合，允许键有多个重复，键不自动排序。</p></li></ul></li></ol><p>以上这些容器都在<code>&lt;container名字&gt;</code>头文件中定义，例如，<code>std::vector</code>在<code>&lt;vector&gt;</code>头文件中定义，<code>std::map</code>在<code>&lt;map&gt;</code>头文件中定义。</p><p>每种容器都有其特定的特性和使用场景，选择合适的容器可以优化性能和资源使用。</p><h2 id="函数算法">函数算法</h2><p>C++ STL（Standard Template Library）为我们提供了大量的算法函数，它们都在 <code>&lt;algorithm&gt;</code>, 关于详细信息可以查看<a href="https://zh.cppreference.com/w/cpp/header/algorithm">官网</a></p><h1>c++11新特性</h1><ul><li>统一初始化的方式</li><li>成员变量默认初始值</li><li>auto关键字 自动类型推断</li><li>类型推断符 decltype , 这个对于函数模板返回值很有用  配合上auto关键字</li><li>智能指针</li><li>基于范围的for循环</li><li>右值引用 和 move</li><li>无序容器(通过hash表实现)  unordered_map</li><li>正则表达式</li><li>Lambda表达式</li><li>强制类型转化 static_cast interpret_cast const_cast dynamic_cast</li><li>异常处理</li></ul><h2 id="强制类型转化">强制类型转化</h2><ol><li><p><strong>static_cast</strong>：这是最通用的强制类型转换操作符。<strong>它可以用于基本数据类型之间的转换，如整数到浮点数，浮点数到整数，也可以用于枚举类型到整数，甚至可以用于将一个指针转换为另一个指针类型，或将一个成员函数指针转换为另一个成员函数指针</strong>。需要注意的是，虽然 <code>static_cast</code> 比 C 风格的类型转换更为安全，但仍可能造成数据丢失或不可预见的结果，因此必须谨慎使用。</p></li><li><p><strong>dynamic_cast</strong>：这个操作符主要应用在<strong>多态类型的安全转换上</strong>。它通常用于将<strong>基类的指针或引用转换为派生类的指针或引用</strong>，但前提条件是这个基类需要有虚函数。如果转换失败，如试图将指针或引用转换为不正确的类型，<code>dynamic_cast</code> 会返回 nullptr（对于指针）或者抛出一个 <code>bad_cast</code> 异常（对于引用）。使用 <code>dynamic_cast</code> 可以增强程序的安全性，但由于其需要在运行时进行类型检查，因此性能开销较大。</p></li><li><p><strong>reinterpret_cast</strong>：<strong>这是最不安全的类型转换操作符。它可以转换任意类型的指针为其他类型的指针</strong>，<strong>也可以转换任意类型的整数为指针（反之亦然）</strong>。因为 <code>reinterpret_cast</code> 可能产生无法预见的结果，所以除非你完全确定自己在做什么，否则应当避免使用 <code>reinterpret_cast</code>。</p></li><li><p><strong>const_cast</strong>：这个操作符用于移除对象的 <code>const</code>、<code>volatile</code> 或者 <code>const volatile</code> 修饰。需要注意的是，使用 <code>const_cast</code> 去除 <code>const</code> 修饰并进行<strong>修改的对象必须本身是一个非 <code>const</code> 对象，否则结果是未定义的</strong>。</p></li></ol><p>这些强制类型转换操作符提供了强大的工具，但是也需要谨慎使用。一般来说，你应该尽量避免使用强制类型转换，尤其是在不确定的情况下。在许多情况下，正确的类型设计和良好的编程习惯可以避免强制类型转换的需要。</p><h1>额外补充</h1><h2 id="g-编译器版本对应c-版本">g++编译器版本对应c++版本</h2><p>要查看你的 g++ 编译器支持的 C++ 版本，你可以使用 <code>g++ --version</code> 命令来查看你当前的 g++ 版本。</p><p>然后你可以参考下面的对应关系，这些是 g++ 编译器与支持的 C++ 标准之间的对应关系：</p><ul><li>G++ 4.8.1 及以上版本支持 C++11。</li><li>G++ 4.9.2 及以上版本支持 C++14。</li><li>G++ 5.2 及以上版本支持 C++17。</li><li>G++ 8.1 及以上版本支持 C++20。</li></ul><p>请注意，这些仅是最低版本要求，新的编译器版本通常会包含对老版本 C++ 标准的支持以及新版本中的 bug 修复。</p><p>你还可以在编译时指定所需的 C++ 版本。例如，如果你想使用 C++14，可以使用 <code>-std=c++14</code> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++14 your_file.cpp</span><br></pre></td></tr></table></figure><p>另外，你也可以用 <code>-std=c++11</code>、<code>-std=c++17</code>、<code>-std=c++20</code> 等来指定其他 C++ 版本。</p><p>不同的版本的 C++ 有不同的功能，因此在编写代码时，了解你的编译器支持的 C++ 版本是非常重要的。</p><h2 id="默认成员函数">默认成员函数</h2><p>在C++中，类的特殊成员函数包括默认构造函数、拷贝构造函数、移动构造函数、析构函数、拷贝赋值运算符和移动赋值运算符。这些特殊成员函数在特定的情况下会被隐式定义（即自动生成）或者在某些条件下被禁用。了解它们的行为和触发条件对于正确使用C++面向对象编程非常重要。</p><h3 id="1-默认构造函数">1. 默认构造函数</h3><ul><li><strong>触发条件</strong>：当没有为类定义任何构造函数时，编译器会为类自动生成一个默认构造函数。</li><li><strong>行为</strong>：自动生成的默认构造函数会尝试初始化类的所有成员变量。对于类类型成员，将调用其默认构造函数；对于内置类型成员（如<code>int</code>、<code>double</code>等），如果在类内部没有进行初始化，则它们将不被初始化（其值是未定义的）。</li></ul><h3 id="2-拷贝构造函数">2. 拷贝构造函数</h3><ul><li><strong>触发条件</strong>：当一个对象以值传递的方式被函数接受，或从函数返回时；或者当一个对象通过另一个同类型对象进行初始化时。</li><li><strong>行为</strong>：自动生成的拷贝构造函数会逐个拷贝非静态成员变量，使用其对应类型的拷贝构造函数。</li></ul><h3 id="3-移动构造函数-c-11及之后">3. 移动构造函数（C++11及之后）</h3><ul><li><strong>触发条件</strong>：当对象被初始化为右值（例如临时对象或显式转换为右值的对象）时。</li><li><strong>行为</strong>：自动生成的移动构造函数会逐个“移动”非静态成员变量，使用其对应类型的移动构造函数。移动通常意味着资源的所有权从源对象转移到目标对象，源对象被置于有效但不确定的状态。</li></ul><h3 id="4-析构函数">4. 析构函数</h3><ul><li><strong>触发条件</strong>：对象生命周期结束时（例如，局部对象的函数返回时，或通过<code>delete</code>释放动态分配的对象时）。</li><li><strong>行为</strong>：自动生成的析构函数会逐个调用非静态成员变量的析构函数。</li></ul><h3 id="5-拷贝赋值运算符">5. 拷贝赋值运算符</h3><ul><li><strong>触发条件</strong>：当一个对象被赋值为同类型的另一个对象时。</li><li><strong>行为</strong>：自动生成的拷贝赋值运算符会逐个拷贝赋值非静态成员变量，使用其对应类型的拷贝赋值运算符。</li></ul><h3 id="6-移动赋值运算符-c-11及之后">6. 移动赋值运算符（C++11及之后）</h3><ul><li><strong>触发条件</strong>：当一个对象被赋值为同类型的右值时。</li><li><strong>行为</strong>：自动生成的移动赋值运算符会逐个移动赋值非静态成员变量，使用其对应类型的移动赋值运算符。</li></ul><h3 id="规则与细节">规则与细节</h3><ul><li><strong>规则</strong>：<strong>如果你声明了任何构造函数，编译器不会自动生成默认构造函数</strong>。<strong>如果你声明了拷贝构造函数、移动构造函数、拷贝赋值运算符或移动赋值运算符中的任何一个，编译器不会自动生成拷贝构造函数和拷贝赋值运算符</strong>。C++11中，声明拷贝构造函数或拷贝赋值运算符会阻止移动构造函数和移动赋值运算符的自动生成。</li><li><strong>删除的函数</strong>：你可以通过将特殊成员函数标记为<code>= delete</code>来显式禁用它们，例如<code>MyClass(const MyClass&amp;) = delete;</code>。</li><li><strong>默认的函数</strong>：C++11允许你通过<code>= default</code>来要求编译器生成默认的特殊成员函数实现，即使已经声明了其他构造函数，例如<code>MyClass() = default;</code>。</li></ul><p>理解这些规则对于设计符合预期行为的类至关重要，尤其是在涉及资源管理（如动态内存分配、文件句柄、互斥锁等）时，正确使用或禁用这些特殊成员函数可以避免资源泄露、双重释放和其他错误。</p><h2 id="文本模式和二进制模式的区别">文本模式和二进制模式的区别</h2><p>本质上它两没有区别, 在打开文件的时候都是二进制读取,  虽然所有文件都是以二进制形式存储的，<strong>但我们如何解释这些数据取决于我们以什么模式打开文件。</strong></p><p>在文本模式中，我们把数据看作是字符，由换行符、制表符等特殊字符组成的行。例如，如<strong>果你在文本模式下读取一个文件，当你在windows上读取到一个代表换行的字符序列\r\n的时候，C++将把它转换为\n, 那这样就少了一个字符,当你在文本模式下在windows中写入一个文件的时候,如果遇到一个\n, C++会把它转化为 \r\n 那这样岂不是多了一个字符,  所以在处理非文本的时候,一定要使用二进制模式</strong></p><p>在二进制模式中，我们不试图解释数据，只是直接读取和写入。这对于非文本文件（如图像或声音文件）或者需要精确控制你读写的数据的应用来说非常有用。</p><h2 id="命名空间">命名空间</h2><p>C++ 的命名空间是一个范围，它主要被用于组织代码以避免名称冲突。在一个大型的软件项目中，如果不使用命名空间，那么当项目越来越大，名称冲突的可能性就越来越高。命名空间可以帮助我们更好地组织代码，提高代码的可读性和可维护性。</p><p>下面是关于命名空间的一些主要特点：</p><ol><li><p><strong>命名空间定义</strong>：命名空间通过关键字 <code>namespace</code> 定义，后面跟着命名空间的名称。命名空间的主体部分是一对大括号，其中包含了命名空间的所有成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>访问命名空间中的成员</strong>：可以使用命名空间名称和作用域解析运算符 <code>::</code> 来访问命名空间中的成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyNamespace::a = <span class="number">10</span>;</span><br><span class="line">MyNamespace::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>using 声明和 using 指示</strong>：<code>using</code> 声明可以让我们不必在每次访问命名空间中的成员时都使用命名空间名。<code>using</code> 指示使得命名空间中的所有名称都可以直接访问。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MyNamespace;  <span class="comment">// now we can directly use a and func()</span></span><br></pre></td></tr></table></figure></li><li><p><strong>命名空间可以嵌套</strong>：你可以在一个命名空间中定义另一个命名空间。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Outer &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">namespace</span> Inner &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Outer::x = <span class="number">10</span>;  <span class="comment">// access the member of Outer namespace</span></span><br><span class="line">Outer::Inner::y = <span class="number">20</span>;  <span class="comment">// access the member of Inner namespace</span></span><br></pre></td></tr></table></figure></li><li><p><strong>命名空间别名</strong>：你可以为命名空间定义别名，以便于在代码中更方便地使用。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS = MyVeryLongNamespaceName;</span><br><span class="line">NS::<span class="built_in">func</span>();  <span class="comment">// same as MyVeryLongNamespaceName::func()</span></span><br></pre></td></tr></table></figure></li><li><p><strong>匿名命名空间</strong>：如果一个命名空间没有给出名称，它就是匿名命名空间。在同一个文件中，匿名命名空间中的所有成员都可以直接访问，就像它们是全局范围的一样。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;  <span class="comment">// has internal linkage, can be directly accessed within the same file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>全局命名空间</strong>：所有没有在明确的命名空间中声明的代码都在全局命名空间中。</p></li></ol><p>请注意，C++ 标准库中的所有内容都在 <code>std</code> 命名空间中。在使用标准库的类或函数时，我们通常需要使用 <code>std::</code> 作为前缀，或者</p><p>使用 <code>using</code> 指示引入整个 <code>std</code> 命名空间（但在大型项目中，出于避免命名冲突的考虑，通常不推荐这样做）。</p><p>命名空间是一种重要的代码组织和设计工具，正确使用命名空间可以帮助我们编写出更清晰、更易于维护的代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC学习</title>
      <link href="/2023/06/12/C%E5%92%8CC++/MFC/"/>
      <url>/2023/06/12/C%E5%92%8CC++/MFC/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p><strong>唯一一个必须重写的 CWinApp 成员函数是 InitInstance。</strong></p><h1>自定义控件</h1><p>在MFC应用程序中自定义按钮样式涉及到从<code>CButton</code>类派生一个新的类，并重写相关的消息处理函数以实现自定义的绘制逻辑。下面是一个基本的步骤指南和示例，展示如何创建一个具有自定义样式的按钮：</p><h2 id="步骤-1：创建自定义按钮类">步骤 1：创建自定义按钮类</h2><ol><li><p><strong>创建一个新的类</strong>：在你的MFC项目中，派生一个新类，比如命名为<code>CMyButton</code>，从<code>CButton</code>基类继承。</p></li><li><p><strong>添加消息映射</strong>：在你的类声明中，使用<code>DECLARE_MESSAGE_MAP()</code>宏，并在cpp文件中添加<code>BEGIN_MESSAGE_MAP</code>和<code>END_MESSAGE_MAP</code>宏来映射你想要处理的消息。</p></li><li><p><strong>重写<code>DrawItem</code>方法</strong>：<code>DrawItem</code>是<code>CButton</code>中的一个虚函数，用于绘制按钮的外观。你需要在你的类中重写这个函数来实现自定义绘制逻辑。</p></li></ol><h3 id="示例代码">示例代码</h3><p>以下是一个简化的自定义按钮类的示例，展示了如何重写<code>DrawItem</code>方法来改变按钮的样式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyButton.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span>         <span class="comment">// MFC core and standard components</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyButton</span> : <span class="keyword">public</span> CButton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DECLARE_DYNAMIC</span>(CMyButton)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyButton</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CMyButton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawItem</span><span class="params">(LPDRAWITEMSTRUCT lpDrawItemStruct)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyButton.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyButton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_DYNAMIC</span>(CMyButton, CButton)</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyButton, CButton)</span><br><span class="line">    <span class="comment">// 在这里可以添加其他消息处理器</span></span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyButton::DrawItem</span><span class="params">(LPDRAWITEMSTRUCT lpDrawItemStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDC dc;</span><br><span class="line">    dc.<span class="built_in">Attach</span>(lpDrawItemStruct-&gt;hDC); <span class="comment">// 绑定设备上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lpDrawItemStruct-&gt;rcItem获取按钮的矩形区域</span></span><br><span class="line">    RECT rc = lpDrawItemStruct-&gt;rcItem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置按钮背景和文本颜色</span></span><br><span class="line">    dc.<span class="built_in">FillSolidRect</span>(&amp;rc, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 用红色填充按钮背景</span></span><br><span class="line">    dc.<span class="built_in">SetTextColor</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)); <span class="comment">// 设置文本为白色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制按钮文本</span></span><br><span class="line">    CString strText;</span><br><span class="line">    <span class="built_in">GetWindowText</span>(strText); <span class="comment">// 获取按钮上的文本</span></span><br><span class="line">    dc.<span class="built_in">DrawText</span>(strText, &amp;rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line"></span><br><span class="line">    dc.<span class="built_in">Detach</span>(); <span class="comment">// 解除设备上下文的绑定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤-2：在对话框中使用自定义按钮">步骤 2：在对话框中使用自定义按钮</h2><h3 id="方式一">方式一</h3><ol><li><p><strong>在对话框的头文件中声明自定义按钮类的对象</strong>。</p></li><li><p><strong>在资源编辑器中为按钮分配一个控件ID</strong>（如果还没有）。</p></li><li><p><strong>在对话框类的<code>OnInitDialog</code>函数或相应初始化位置，使用<code>SubclassDlgItem</code>函数将ID与自定义按钮控件关联起来</strong>。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设控件ID是IDC_MY_CUSTOM_BUTTON，并且已经添加了CMyButton m_MyCustomButton成员变量</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMyDialog::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将按钮控件子类化</span></span><br><span class="line">    m_MyCustomButton.<span class="built_in">SubclassDlgItem</span>(IDC_MY_CUSTOM_BUTTON, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE  unless you set the focus to a control</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二">方式二</h3><p>直接通过绑定变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line"><span class="built_in">DDX_Control</span>(pDX, IDC_BUTTON1, loginBtn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意不要同时使用方式1和方式二</p></blockquote><h2 id="步骤三-开启所有者绘制">步骤三: 开启所有者绘制</h2><p><img src="/2023/06/12/C%E5%92%8CC++/MFC/../img/MFCassets/image-20240306155759941.png" alt="image-20240306155759941"></p><p>通过这些步骤，你可以实现具有自定义样式的按钮，包括背景色、文本颜色、甚至是更复杂的绘制逻辑，如渐变背景、图标等。</p><h1>菜单栏</h1><h3 id="通过设置对话框直接添加菜单栏">通过设置对话框直接添加菜单栏</h3><p><img src="/2023/06/12/C%E5%92%8CC++/MFC/../img/MFCassets/image-20230826213402649.png" alt="image-20230826213402649"></p>]]></content>
      
      
      <categories>
          
          <category> 框架学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 需要复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言学习</title>
      <link href="/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>两年前学的c语言,好久没用了, 忘得差不多了, 现在重新学习一下,用博客记录下来,常回来复习复习</p><table><thead><tr><th style="text-align:left">发布时间</th><th style="text-align:left">通称</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">1972</td><td style="text-align:left">-</td><td style="text-align:left">C语言的原始版本由Dennis Ritchie在贝尔实验室开发。</td></tr><tr><td style="text-align:left">1978</td><td style="text-align:left">K&amp;R C</td><td style="text-align:left">Brian Kernighan和Dennis Ritchie发布《C程序设计语言》第一版，介绍了C语言的经典版本。</td></tr><tr><td style="text-align:left">1989</td><td style="text-align:left">ANSI C (C89)</td><td style="text-align:left">美国国家标准学会（ANSI）发布C语言的第一个官方标准，ANSI X3.159-1989，通常被称为ANSI C。</td></tr><tr><td style="text-align:left">1990</td><td style="text-align:left">ISO C</td><td style="text-align:left">国际标准化组织（ISO）采纳ANSI C标准，发布ISO/IEC 9899:1990。</td></tr><tr><td style="text-align:left">1999</td><td style="text-align:left">C99</td><td style="text-align:left">发布新标准，引入了新的语言特性，如//注释和长整型。</td></tr><tr><td style="text-align:left">2011</td><td style="text-align:left">C11</td><td style="text-align:left">最新的C语言标准，引入了对并发的支持和其他一些新特性。</td></tr></tbody></table><h1>预处理器</h1><h2 id="定义">定义</h2><p>在C语言中，预处理器（preprocessor）是一个在<strong>编译阶段前执行的程序</strong>，它可以对源代码做一些预处理工作。预处理器通过预处理指令（preprocessor directives）来完成这些工作，预处理指令都以<code>#</code>符号开头。</p><p>以下是一些常见的预处理指令：</p><ol><li><p><strong>#include</strong>：这个指令用于包含头文件。例如，<code>#include &lt;stdio.h&gt;</code>会在当前源代码文件中插入stdio.h头文件的内容。这样，我们就可以使用在stdio.h中声明的函数和宏了。</p></li><li><p><strong>#define</strong>：这个指令用于定义宏。<strong>宏可以看作是一个文本替换工具</strong>，预处理器会在编译前将所有宏替换为其定义的内容。例如，<code>#define PI 3.14</code>定义了一个宏PI，预处理器会把源代码中所有的PI替换为3.14。</p></li><li><p><strong>#undef</strong>：这个指令用于取消已定义的宏。例如，<code>#undef PI</code>会取消PI宏的定义，之后的代码就不能使用PI宏了。</p></li><li><p><strong>#if, #else, #elif, #endif</strong>：这些指令用于条件编译。预处理器会根据条件来决定是否编译某段代码。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Debug information...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果DEBUG被定义为1，那么printf语句会被编译和执行。如果DEBUG被定义为0，那么printf语句会被忽略。</p></li><li><p><strong>#ifdef, #ifndef</strong>：这些指令也用于条件编译，但它们检查的是某个宏是否已被定义。例如，<code>#ifdef DEBUG</code>会检查DEBUG宏是否已定义，如果已定义，就编译随后的代码。</p></li></ol><p>预处理器还有一些其他的功能，如错误处理、源文件包含等。预处理器的作用虽然不如编译器和链接器显著，<strong>但它在处理源代码、改善代码复用性、模块化等方面起着重要作用。</strong></p><h2 id="功能">功能</h2><p>预处理器的主要功能包括：</p><ol><li><strong>文件包含（Inclusion of Files）</strong>：预处理器通过<code>#include</code>指令包含头文件。这使得程序员可以将程序的各个部分分开在不同的文件中编写，并通过这个功能将他们链接在一起。</li><li><strong>宏替换（Macro Replacement）</strong>：预处理器通过<code>#define</code>指令定义宏，然后在程序中替换这些宏。这是一种非常有效的方式来定义程序中要使用的常量。<strong>这个东西非常好用,很多框架也在用, 这个能帮我们少写很多代码, 所以看起来他就是个文本替换工具</strong></li><li><strong>条件编译（Conditional Compilation）</strong>：预处理器通过<code>#if</code>，<code>#elif</code>，<code>#else</code>和<code>#endif</code>等指令进行条件编译。这使得程序员可以根据特定的条件选择性地编译代码的一部分。</li><li><strong>编译错误和警告的处理</strong>：预处理器可以通过<code>#error</code>和<code>#warning</code>指令来发出编译错误和警告。这对于程序调试非常有用。</li><li><strong>行控制（Line Control）</strong>：预处理器通过<code>#line</code>指令来控制<code>__LINE__</code>和<code>__FILE__</code>这两个内置宏的值。这使得程序员可以控制在错误报告中显示的行号和文件名。</li><li><strong>定义判断</strong>：预处理器通过<code>#ifdef</code>，<code>#ifndef</code>和<code>#undef</code>指令来判断一个宏是否已经定义，并据此决定是否编译某部分代码。</li></ol><p>通过以上功能，预处理器为C语言提供了丰富的编程灵活性，有助于模块化编程，提高代码复用性，使得源代码更易于阅读和维护。</p><p>举个例子吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AAA_AAA_</span></span><br><span class="line">你好啊, 我不会被编译</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _AAA_AAA_</span></span><br><span class="line">我也不会被编译</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ifdef 和 if的区别在于  if是检查后面这个东西有没有被定义和它的值是不是真,  而infdef是看后面这个东西有没有被定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我会被编译&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc预编译一下可以发现确实如此</p><p><img src="/2023/06/12/C%E5%92%8CC++/c%E8%AF%AD%E8%A8%80/../img/c%E8%AF%AD%E8%A8%80assets/image-20230615193432089.png" alt="image-20230615193432089"></p><h2 id="define">#define</h2><p>这个东西太好用了,以至于要单独拿一个部分出来总结</p><p><code>#define</code>是C语言预处理器中的一个非常有用的指令，主要用于定义宏（macros）。它可以有两种基本形式：对象式宏（object-like macros）和函数式宏（function-like macros）。</p><ol><li><p><strong>对象式宏</strong>：这是最简单的宏定义形式，它将一个名称定义为一个特定的值。例如：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br></pre></td></tr></table></figure><p>在这个例子中，PI就被定义为3.14159。在预处理阶段，预处理器会将代码中所有的PI替换为3.14159。</p></li><li><p><strong>函数式宏</strong>：函数式宏可以带有参数，看起来更像一个函数。例如：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) ((X) * (X))</span></span><br></pre></td></tr></table></figure><p>在这个例子中，SQUARE就被定义为一个计算其参数平方的宏。使用SQUARE(2)会被预处理器替换为((2) * (2))，结果是4。</p></li></ol><p>这些宏在预处理阶段就已经展开并替换，<strong>所以它们不会像函数那样带来调用的开销</strong>。但是，过度使用宏可能会导致代码难以阅读和理解，因为宏只是简单的文本替换，不会进行类型检查。</p><h3 id="高级方法">高级方法</h3><h4 id="定义for循环">定义for循环</h4><p>这个是不可以很好减少我们写for循环?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FI(n) for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FJ(n) for(int j = 0; j &lt; n; j++)</span></span><br></pre></td></tr></table></figure><h4 id="定义多行宏">定义多行宏</h4><p>有时候把后面的东西写在一行有点难受,我们可以用\换行, 但是在代码中还是一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> F(n1,n2) for(int i = 0; i &lt; n1; i++) \</span></span><br><span class="line"><span class="meta"> for (int j = 0; j &lt; n2; j++) \</span></span><br></pre></td></tr></table></figure><h4 id="参数类型宏">参数类型宏</h4><p><strong>宏的参数可以出现类型</strong>(其实也就是字符串替换), 因此我们是不是可弄一个好用的malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(n, type) (type*)malloc(n * sizeof(type))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* nums = MALLOC(<span class="number">10</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><h4 id="none"># ##</h4><p>在用#define 定义时 , 斜杠(&quot;\&quot;)是用来续行的，&quot;#“将<strong>参数字符串化</strong>。”##&quot;则用来<strong>连接前后两个参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> toString(str)  #str</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test(str) #str<span class="string">&quot;test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONCATENATE(a, b) a ## b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CONCATENATE</span><span class="params">(num, <span class="number">1</span>)</span> = <span class="number">10</span>;  <span class="comment">// 创建一个变量 num1   替换后就是 int num1 = 10</span></span><br><span class="line">print(<span class="string">&quot;%s&quot;</span>,toString(<span class="number">123</span>));  <span class="comment">//很方便的将一个数字变成字符串,但是要注意,这里填变量也会变成字符串</span></span><br><span class="line">print(<span class="string">&quot;%s&quot;</span>,toString(num1));  <span class="comment">//这里输出就是 num1这个字符串</span></span><br></pre></td></tr></table></figure><p>在使用<code>#define</code>时，你应当注意到一些常见的问题。首先，因为预处理器只是进行文本替换，所以可能会出现预期外的效果。例如，<strong>函数宏中的参数如果不用括号包围，可能会因为运算符优先级的问题导致错误</strong>。其次，过度使用宏可能会使代码变得难以理解和维护。尽管宏可以提供强大的功能，但应当谨慎使用。</p><p>注意点:</p><ul><li>宏不能递归 #define func(a, b)  func(a,b)  比如这个, 宏只会替换一次,  但是宏可以嵌套</li><li><strong>宏的参数可以出现类型，但是函数做不到</strong></li><li>参数的副作用  比如 a++ 这种就尽量不要成为宏的参数</li><li>宏产生的代码是不能调试的</li></ul><p><strong>最后请记住宏就是个文本工具, 它肯定是不知道我们变量的值是什么的</strong></p><h2 id="error">#error</h2><p>在C语言中，<code>#error</code> 指令是一种预处理器指令，用于在<strong>编译时生成错误消息</strong>。当编译器遇到 <code>#error</code> 指令时，它会停止编译过程，并显示指定的错误消息。这通常用于在编译时检查代码的特定条件，以确保代码的正确性或配置的有效性。</p><ol><li><strong>示例场景</strong>:<ul><li><strong>检查宏是否已定义</strong>:<br>假设你的程序需要一个特定的宏定义来编译。你可以使用 <code>#error</code> 来确保这个宏已被定义。如果没有定义，编译过程将停止，并显示一个错误消息。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> REQUIRED_MACRO</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;REQUIRED_MACRO is not defined&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><strong>检查编译环境</strong>:<br>如果你的代码只能在特定的编译环境下运行（例如特定的操作系统或硬件架构），你可以使用 <code>#error</code> 来确保代码不会在不支持的环境中编译。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__linux__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;This code is only for Linux&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><strong>版本检查</strong>:<br>如果你的代码依赖于特定版本的库或编译器，你可以使用 <code>#error</code> 来检查版本并在不兼容的情况下产生编译错误。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ &lt; 199901L</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;C99 or a later version is required&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>使用 <code>#error</code> 指令是一种有效的方法来确保代码在预期的条件下被编译，从而避免潜在的运行时问题。</p><h1><strong>数据类型</strong></h1><h2 id="定义">定义</h2><p>C语言中的数据类型是用于声明变量或函数的关键部分。一个数据类型定义了一种数据的范围和特性。C语言主要有以下几种数据类型：</p><ol><li><p><strong>基本数据类型</strong>：C语言有四种基本数据类型：</p><ul><li><strong>整型(int)</strong>：用于表示无小数的数，包括正整数、负整数和0。还有短整型（short）、长整型（long）和长长整型（long long）等更具体的类型。</li><li><strong>浮点型(float)</strong>：用于表示有小数的数，例如3.14、0.1234等。</li><li><strong>双精度浮点型(double)</strong>：比浮点型具有更高的精度，适用于需要极高精度的计算。</li><li><strong>字符型(char)</strong>：用于表示单个字符。(<strong>无符号数</strong>)</li></ul></li><li><p><strong>派生数据类型</strong>：由基本数据类型派生出的数据类型，包括：</p><ul><li><strong>数组(Array)</strong>：存储相同类型数据的有序集合。</li><li><strong>指针(Pointer)</strong>：指针类型是一种特殊的数据类型，它存储的是其他数据类型的内存地址。</li><li><strong>结构体(struct)</strong>：结构体是一种聚合数据类型，可以包含不同类型的数据。</li><li><strong>联合体(union)</strong>：联合体是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。它只能存储一种类型的数据，但可以是任意类型。</li><li><strong>枚举(enum)</strong>：枚举是一种用户自定义的数据类型，它允许你将一组整数值赋予有意义的名字，以提高程序的可读性。</li></ul></li><li><p><strong>void类型</strong>：void类型表示没有值。这是一种特殊的数据类型，<strong>通常用于定义无返回值的函数和没有参数，或者空指针, 或者任何类型</strong>。</p></li></ol><p><strong>每种数据类型都有其特定的取值范围和存储需求，这些都依赖于你所使用的系统和编译器</strong>。</p><p>C语言还允许定义自己的数据类型，通常通过typedef关键字实现。例如，可以通过typedef创建一个新的数据类型名，然后使用这个新的数据类型名来定义变量。</p><p>在编写程序时，选择适当的数据类型非常重要，因为它会影响数据如何被存储在内存中，以及如何使用这些数据。</p><h2 id="常用数值范围宏">常用数值范围宏</h2><p>在C语言中，可以通过在&lt;limits.h&gt;和&lt;float.h&gt;这两个头文件中定义的一些宏来获取各种数据类型的最大值和最小值。这些值可能会因编译器或平台的不同而有所不同，但通常符合特定的标准。</p><p>以下是一些常见数据类型的最大值和最小值的宏：</p><ol><li><strong>整数类型（包括short、int、long、long long）</strong>：可以通过以下宏来获取：<ul><li><code>INT_MIN</code> / <code>INT_MAX</code>：int类型的最小值和最大值。</li><li><code>LONG_MIN</code> / <code>LONG_MAX</code>：long类型的最小值和最大值。</li><li><code>SHORT_MIN</code> / <code>SHORT_MAX</code>：short类型的最小值和最大值。</li><li><code>LLONG_MIN</code> / <code>LLONG_MAX</code>：long long类型的最小值和最大值。</li></ul></li><li><strong>字符类型（char）</strong>：<ul><li><code>CHAR_MIN</code> / <code>CHAR_MAX</code>：char类型的最小值和最大值。</li></ul></li><li><strong>浮点类型和双精度浮点类型（float、double）</strong>：可以通过以下宏来获取：<ul><li><code>FLT_MIN</code> / <code>FLT_MAX</code>：float类型的最小正值和最大正值。</li><li><code>DBL_MIN</code> / <code>DBL_MAX</code>：double类型的最小正值和最大正值。</li></ul></li></ol><p>在使用这些宏之前，需要包含对应的头文件，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="常量">常量</h2><p>在 C 语言中，常量（constants）是固定值，它们在程序运行过程中不能被修改。常量可以是任何基本数据类型，例如整数常量、浮点常量、字符常量，还有字符串字面量等。常量必须在定义的时候就初始化好, 不然会报错</p><h2 id="类型转换">类型转换</h2><p>在C语言中，类型转换用于将一种数据类型转换为另一种。类型转换有两种基本形式：隐式类型转换（也称为自动类型转换）和显式类型转换（也称为强制类型转换或类型强制转换）。</p><ol><li><p><strong>隐式类型转换</strong>：当我们进行不同数据类型的混合运算时，编译器会自动进行类型转换。这种类型转换是隐式的，即程序员无需明确指定。在这种情况下，较小的数据类型会被转换为较大的数据类型。例如，如果你将一个<code>int</code>类型和一个<code>double</code>类型的值进行加法运算，<code>int</code>值会被自动转换为<code>double</code>类型，然后进行运算。</p></li><li><p><strong>显式类型转换</strong>：有时候，我们需要手动进行类型转换，这称为显式类型转换，或者称为强制类型转换。在C语言中，可以通过将目标类型放在括号中，并放在要转换的变量或表达式前面来实现。例如，如果你想将<code>double</code>类型的变量转换为<code>int</code>类型，可以这样做：<code>int x = (int) y;</code>，其中<code>y</code>是一个<code>double</code>类型的变量。</p></li></ol><p>值得注意的是，类型转换可能会引起数据丢失或溢出。例如，如果你将一个<code>double</code>类型的值强制转换为<code>int</code>类型，小数部分将会被丢弃。如果你将一个超过<code>int</code>范围的<code>long</code>类型的值强制转换为<code>int</code>类型，可能会导致数据溢出。</p><p>最后，C语言还有一种特殊的类型转换，叫做类型提升。当较小的整数类型（如<code>char</code>或<code>short</code>）用作算术表达式的一部分时，它们会被提升为较大的整数类型（通常是<code>int</code>）。这是C语言为了运算效率和结果精度做的一种优化。</p><h1>存储类别说明符</h1><p><code>static</code>, <code>extern</code>, 和 <code>const</code> 在 C 语言中被称为存储类别说明符（Storage Class Specifiers）。它们用于指定变量、函数或声明的范围（可见性）、生命周期、以及是否可以被修改。</p><p>让我们来看一下这些存储类别说明符的意义：</p><ol><li><p><strong>static</strong>：在变量和函数前使用 <code>static</code> 关键字，<strong>会使得它们的作用域局限于声明它们的源文件内, 跨.cpp和.c文件是无法共享和使用的</strong>。对于局部变量，<code>static</code> 也改变了它们的生命周期，使得它们在程序的整个运行期间都存在，而不仅仅是在声明它们的函数或代码块执行时存在。</p></li><li><p><strong>extern</strong>：<code>extern</code> 关键字用于声明一个变量或函数在别的源文件中已经被定义。这样，这个变量或函数就可以在其他文件中被使用，即使它是在另一个源文件中定义的。</p></li><li><p><strong>const</strong>：<code>const</code> 关键字用于指定一个变量的值不能被修改（即，这个变量是只读的）。这对于防止无意的修改非常有用，也可以让编译器进行一些优化。</p></li></ol><p>除了这三个关键字，C 语言中还有其他的存储类别说明符，如 <code>auto</code> 和 <code>register</code>。不过，<code>auto</code> 是默认的，不常显式地用在代码中，<code>register</code> 关键字的作用在现代编译器中已经基本被忽视。</p><h2 id="static">static</h2><p>在 C 语言中，<code>static</code>关键字有几个不同的用途，具体取决于它的使用环境：</p><ol><li><p><strong>静态局部变量</strong></p><p>当 <code>static</code> 关键字用于函数内部的变量时，它改变了该变量的存储期。通常情况下，函数内的局部变量在函数被调用时创建，函数返回时销毁。但如果局部变量被声明为 <code>static</code>，则其生命周期在程序运行时始终存在。这意味着，当函数被多次调用时，静态局部变量的值在调用之间保持不变。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，<code>count</code> 变量每次调用 <code>foo</code> 函数时都会增加。但是你在外界是无法访问的</p></li><li><p><strong>静态全局变量</strong></p><p>如果 <code>static</code> 关键字用于函数外部的变量，它限制了该变量的链接作用域（linkage）到定义它的文件。换句话说，<code>static</code> 全局变量只能在定义它的源文件中访问，其他源文件不能访问。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// This variable is only accessible within file1.c</span></span><br></pre></td></tr></table></figure></li><li><p><strong>静态函数</strong></p><p>和静态全局变量类似，<code>static</code> 也可以用于函数，<strong>使得函数只能在定义它的源文件中访问。</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;  <span class="comment">// This function is only accessible within file1.c</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>static</code> 关键字使你能够控制变量和函数的可见性，从而更好地封装代码。此外，静态局部变量还允许你保持在函数调用之间保持状态，而不必使用全局变量。</p><h2 id="extern">extern</h2><p>在 C 语言中，<code>extern</code> 关键字主要用于以下两种场景：</p><ol><li><p><strong>声明全局变量</strong>：如果一个全局变量在一个源文件中被定义，并且你想在另一个源文件中使用这个全局变量，那么你需要在那个源文件中用 <code>extern</code> 关键字声明这个变量。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.c</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVar; <span class="comment">// Now, globalVar can be used in File2.c</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>globalVar</code> 在 File1.c 中被定义，并在 File2.c 中通过 <code>extern</code> 关键字被声明，所以它可以在 File2.c 中使用。</p></li><li><p><strong>声明函数</strong>：如果一个函数在一个源文件中被定义，并且你想在另一个源文件中调用这个函数，那么你需要在那个源文件中用 <code>extern</code> 关键字声明这个函数。然而，在实际使用中，<strong>函数默认就是</strong> <code>extern</code> 的，所以一般省略不写 <code>extern</code>。通常，在头文件中声明函数，然后在源文件中包含这个头文件，就可以在源文件中调用这个函数。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File1.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>; <span class="comment">// `extern` is implicit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;File1.h&quot;</span> <span class="comment">// Now, func() can be called in File2.c</span></span></span><br></pre></td></tr></table></figure></li></ol><p>在这个例子中，<code>func</code> 在 File1.c 中被定义，并在 File1.h 中被声明（这里 <code>extern</code> 是隐含的），所以它可以在 File2.c 中被调用。</p><p>总的来说，<code>extern</code> 关键字用于声明在其他地方定义的全局变量或函数。这提供了一种在多个源文件间共享变量和函数的方式。</p><blockquote><p>如果用 extern 修饰变量时赋值,  那可就是定义了  比如  extern  int a = 10;  这可就不是引入外部变量然后对他赋值了,  那就是在此处定义一个变量赋值为10  然后可以被外部引用了,</p></blockquote><h1>运算符</h1><p>以下是C语言运算符的优先级和结合性的一个总结。优先级从高到低排列：</p><table><thead><tr><th>优先级</th><th>运算符</th><th>描述</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td><code>()</code> <code>[]</code> <code>-&gt;</code> <code>.</code> <code>++</code> <code>--</code></td><td>函数调用、数组下标、指针运算、成员访问、自增自减</td><td>从左到右</td></tr><tr><td>2</td><td><code>!</code> <code>~</code> <code>+</code> <code>-</code> <code>*</code> <code>&amp;</code> <code>(类型名)&#123;列表&#125;</code> <code>sizeof</code></td><td>逻辑非、按位非、一元加减、解引用、取地址、复合字面量、大小</td><td>从右到左</td></tr><tr><td>3</td><td><code>*</code> <code>/</code> <code>%</code></td><td>乘法、除法、取模</td><td>从左到右</td></tr><tr><td>4</td><td><code>+</code> <code>-</code></td><td>加法、减法</td><td>从左到右</td></tr><tr><td>5</td><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>左移、右移</td><td>从左到右</td></tr><tr><td>6</td><td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于、小于等于、大于、大于等于</td><td>从左到右</td></tr><tr><td>7</td><td><code>==</code> <code>!=</code></td><td>等于、不等于</td><td>从左到右</td></tr><tr><td>8</td><td><code>&amp;</code></td><td>按位与</td><td>从左到右</td></tr><tr><td>9</td><td><code>^</code></td><td>按位异或</td><td>从左到右</td></tr><tr><td>10</td><td><code>|</code></td><td>按位或</td><td>从左到右</td></tr><tr><td>11</td><td><code>&amp;&amp;</code></td><td>逻辑与</td><td>从左到右</td></tr><tr><td>12</td><td><code>||</code></td><td>逻辑或</td><td>从左到右</td></tr><tr><td>13</td><td><code>?:</code></td><td>条件运算符</td><td>从右到左</td></tr><tr><td>14</td><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td>赋值运算符</td><td>从右到左</td></tr><tr><td>15</td><td><code>,</code></td><td>逗号运算符</td><td>从左到右</td></tr></tbody></table><p>请注意，虽然这个表格提供了一种方便的方式来记忆运算符的优先级和结合性，但在实践中，为了避免可能的混淆和错误，最好尽可能地使用括号来明确表达你的意图。</p><p>运算符在编程中使用频繁，有一些重要的细节需要注意。以下是一些常见的C语言运算符相关的注意点：</p><ol><li><p><strong>短路行为</strong>：逻辑运算符 <code>&amp;&amp;</code>（逻辑与）和 <code>||</code>（逻辑或）有所谓的&quot;短路&quot;行为。如果 <code>&amp;&amp;</code> 运算符的左操作数为 <code>false</code>，则不会计算右操作数，因为整个表达式的结果已经可以确定为 <code>false</code>。同理，如果 <code>||</code> 运算符的左操作数为 <code>true</code>，则不会计算右操作数，因为整个表达式的结果已经可以确定为 <code>true</code>。这种行为可能会影响到代码的执行流程，特别是当操作数有副作用（如修改变量或执行函数）时。</p></li><li><p><strong>优先级和结合性</strong>：C语言中的运算符优先级和结合性经常引起混淆。比如，<code>&amp;&amp;</code> 的优先级比 <code>||</code> 高，这意味着 <code>a || b &amp;&amp; c</code> 等同于 <code>a || (b &amp;&amp; c)</code>，而非 <code>(a || b) &amp;&amp; c</code>。使用括号可以让代码更清晰，更易于理解。</p></li><li><p><strong>自增和自减</strong>：<code>++</code>（自增）和 <code>--</code>（自减）运算符有前缀和后缀两种形式，它们的行为有所不同。前缀形式（如 <code>++i</code>）先改变变量的值，然后返回改变后的值；后缀形式（如 <code>i++</code>）先返回变量当前的值，然后改变变量的值。在表达式中使用自增或自减运算符时要特别注意。</p></li><li><p><strong>赋值运算符</strong>：赋值运算符 <code>=</code> 会返回一个值，这个值就是被赋值的值。这意味着你可以在一个表达式中进行多重赋值，如 <code>a = b = c = 0;</code>，它会从右到左执行，首先把 <code>c</code> 设置为 <code>0</code>，然后把 <code>b</code> 设置为 <code>c</code> 的值（也就是 <code>0</code>），最后把 <code>a</code> 设置为 <code>b</code> 的值（也就是 <code>0</code>）。</p></li><li><p><strong>除法运算符</strong>：在整数除法中，如果除数和被除数有一个是负数，结果如何取整是由具体的实现定义的。例如，<code>-5 / 2</code> 的结果可能是 <code>-2</code> 或 <code>-3</code>，这取决于你的编译器。为了避免这种模糊性，最好始终确保除数和被除数都是正数，或者使用浮点除法。</p></li></ol><p>这里讲一下我以前一直疑惑的点,  看一下下面这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i,<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, ch = %c\n&quot;</span>, i, ch);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = func(<span class="number">0</span>, <span class="string">&#x27;A&#x27;</span>) || func(<span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>) &amp;&amp; func(<span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// i = 0, ch = A</span></span><br><span class="line"><span class="comment">// i = 1, ch = B</span></span><br><span class="line"><span class="comment">// i = 2, ch = C</span></span><br></pre></td></tr></table></figure><p>我以前的理解就是人的思维方式  既然&amp;&amp;优先级高 我就应该先过来计算&amp;&amp;的两个式子,  所以应该要先输出B,C这两个,  可是计算机内部可不是这样处理的,  <strong>我们可以简单的理解为按照顺序将中缀表达式变成后缀表达式, 并且中间这些式子比如函数啊, 都计算好了</strong></p><h1>数组</h1><p>在 C 语言中，数组是一个存储相同数据类型元素的固定大小连续内存块。以下是关于 C 语言中数组的基本总结：</p><ol><li><p><strong>数组声明和初始化</strong>：在 C 语言中，可以在声明数组的同时进行初始化。例如，<code>int arr[5] = &#123;1, 2, 3, 4, 5&#125;;</code> 声明了一个名为 arr 的整型数组，大小为 5，同时给它赋予了一组初始值。</p><p>如果没有初始化，数组的元素将默认为零（对于全局和静态数组）或<strong>垃圾值</strong>（对于局部数组）。</p><p>数组的大小必须是一个常量表达式。</p></li><li><p><strong>数组访问</strong>：可以通过索引访问数组元素。索引是在方括号中指定的整数，例如 <code>arr[0]</code> 访问的是数组的第一个元素。</p><p>注意，C 语言的数组索引是从 0 开始的。也就是说，对于一个大小为 n 的数组，合法的索引范围是 0 到 n-1。</p></li><li><p><strong>数组长度</strong>：C 语言没有内置的方式来获取数组的长度。一种常见的技巧是使用 <code>sizeof(arr) / sizeof(arr[0])</code> 来计算数组的长度。</p></li><li><p><strong>多维数组</strong>：C 语言支持多维数组。例如，<code>int matrix[3][4];</code> 声明了一个 3x4 的整型二维数组。</p></li><li><p><strong>数组作为函数参数</strong>：当数组作为函数参数时，实际上传递的是数组的引用（或者说是数组的指针），而不是数组本身。因此，函数可以修改数组的内容，但不能获取数组的长度（除非额外提供长度信息）。</p></li><li><p><strong>字符数组和字符串</strong>：字符数组经常被用来存储 C 风格的字符串。C 风格的字符串是字符数组的一种特殊用法，字符串以 ‘\0’ 字符结束。</p></li></ol><p>总的来说，数组是 C 语言中最基本的数据结构之一，用于存储和操作大量的相同类型的数据。</p><h1>控制结构</h1><p>在 C 语言中，控制流语句决定了程序的执行路径。以下是一些基本的控制流语句的总结：</p><ol><li><p><strong>if 语句</strong>：它用于根据条件判断是否执行某个代码块。形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 true 时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 false 时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>for 循环</strong>：用于重复执行某个代码块一定次数。形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 true 时重复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>while 循环</strong>：用于在满足条件时重复执行代码块。形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块在 condition 为 true 时重复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>do…while 循环</strong>：它是 while 循环的变种，无论条件是否满足，都会执行一次代码块。形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure></li><li><p><strong>switch 语句</strong>：根据表达式的值，从多个选项中选择一条路径执行。形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:语句<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:语句<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意：<code>break</code> 语句用于结束 switch 结构或循环结构；<code>continue</code> 语句用于结束当前迭代，直接跳到下一次迭代。这两个也是 C 语言中常见的控制流语句。</p><h1>枚举</h1><p>好的，让我们来详细讨论一下 C 语言中的枚举。</p><p>在 C 语言中，枚举（enum）是一种用户定义的数据类型，它可以由一组命名的整数常量组成。枚举是一种抽象数据类型，用于创建一组命名的整数值，这些值通常表示某种特定的实际意义。</p><p>下面是如何定义枚举类型的一个基本示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>color</code> 是枚举的名字，<code>RED</code>、<code>GREEN</code> 和 <code>BLUE</code> 是枚举的成员。在默认情况下，<code>RED</code> 被赋值为 <code>0</code>，<code>GREEN</code> 被赋值为 <code>1</code>，<code>BLUE</code> 被赋值为 <code>2</code>。这是因为在 C 中，<strong>枚举成员的计数始终从 <code>0</code> 开始，除非你手动指定一个不同的开始值。</strong>,</p><p>你也可以为枚举成员指定特定的值。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> RED = <span class="number">1</span>, GREEN = <span class="number">4</span>, BLUE = <span class="number">8</span> &#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>RED</code> 被赋值为 <code>1</code>，<code>GREEN</code> 被赋值为 <code>4</code>，<code>BLUE</code> 被赋值为 <code>8</code>。<strong>没有指定值的枚举元素，其值为前一元素加 1</strong></p><p>定义了枚举类型之后，就可以使用它来创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">myColor</span>;</span></span><br><span class="line">myColor = GREEN;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>myColor</code> 是一个 <code>color</code> 枚举的变量，它被赋值为 <code>GREEN</code>，也就是 <code>4</code>。</p><p>枚举在编程中很有用，因为它们可以用来创建易于理解和维护的代码。通过使用枚举，你可以将一组有关的名字与一组相关的值关联起来，这些值可以在你的程序中用来表示具有特定意义的数据。</p><p>值得注意的是，虽然枚举类型的成员本质上是整数，但你不能直接将整数赋值给枚举变量，除非你进行类型转换。例如，下面的代码是错误的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">myColor</span> =</span> <span class="number">4</span>;  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>而应该写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">myColor</span> =</span> (<span class="keyword">enum</span> color)<span class="number">4</span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>这是因为 C 语言要求类型的严格一致。通过将整数转换为枚举类型，你告诉编译器你知道你正在做什么，所以它不会抱怨。但是，应该避免这种情况，除非你确实需要这样做，因为这可能会导致错误。</p><h1>指针</h1><p>在C语言中，指针的形式可以根据它们指向的数据类型和维度（如单个变量、数组、多维数组等）以及指针本身的级别（如指向指针的指针）来区分。下面列举了C语言中常见的不同形式的指针：</p><ol><li><p><strong>基本指针</strong>：指向单个变量的指针。</p><ul><li>例如：<code>int *ptr;</code> 指向一个整数。</li></ul></li><li><p><strong>数组指针</strong>：指向数组的指针。</p><ul><li>例如：<code>int (*ptr)[10];</code> 指向一个有10个整数的数组。</li></ul></li><li><p><strong>指针数组</strong>：数组，其元素为指针。</p><ul><li>例如：<code>int *ptr[10];</code> 是一个包含10个指向整数的指针的数组。</li></ul></li><li><p><strong>指向指针的指针</strong>（多级指针）：指向另一个指针的指针。</p><ul><li>例如：<code>int **ptr;</code> 是一个指向指向整数的指针的指针。</li></ul></li><li><p><strong>指向函数的指针</strong>：指向函数的指针，可以用来调用函数。</p><ul><li>例如：<code>int (*ptr)(int);</code> 指向一个接受一个整数参数并返回整数的函数。</li></ul></li><li><p><strong>指针指向动态分配的内存</strong>：使用如 <code>malloc</code> 或 <code>calloc</code> 分配的内存块的指针。</p><ul><li>例如：<code>int *ptr = malloc(10 * sizeof(int));</code> 分配了10个整数大小的内存，并将地址赋给 <code>ptr</code>。</li></ul></li><li><p><strong>结构体指针</strong>：指向结构体的指针。</p><ul><li>例如：<code>struct MyStruct *ptr;</code> 指向 <code>MyStruct</code> 类型结构体的指针。</li></ul></li><li><p><strong>指向结构体成员的指针</strong>：指向结构体成员的指针。</p><ul><li>例如：<code>int *ptr;</code> 其中 <code>ptr</code> 可以指向一个结构体的整型成员。</li></ul></li><li><p><strong>指向多维数组的指针</strong>：指向多维数组的指针。</p><ul><li>例如：<code>int (*ptr)[10][10];</code> 指向一个10x10整数数组的指针。</li></ul></li><li><p><strong>指向联合体的指针</strong>：指向联合体（union）的指针。</p><ul><li>例如：<code>union MyUnion *ptr;</code> 指向 <code>MyUnion</code> 类型联合体的指针。</li></ul></li><li><p><strong>void指针</strong>：类型不明确的指针，可以指向任何类型。</p><ul><li>例如：<code>void *ptr;</code> 可以指向任何类型的数据。</li></ul></li><li><p><strong>const指针</strong>：指向常量的指针，指向的值不能通过这个指针修改。</p><ul><li>例如：<code>const int *ptr;</code> 指向一个常整数的指针。</li></ul></li><li><p><strong>指向const的指针</strong>：指针本身是常量，不能指向其他地址。</p><ul><li>例如：<code>int * const ptr;</code> 是一个指向整数的常指针。</li></ul></li></ol><p>*  可以看做解析地址中的内容,   int* p[5] 由于[] 高于*  所以p[5]就相当于数组,  然后* 代表这个五个元素的解析地址内容是int ,  int (*p)[5]  由于改变优先级   *p 代表p指向的内容  就是一个int [5] 的数组了,  所以p指向了一个大小为5的数组</p><h1>函数指针</h1><p>函数指针是 C 语言中的一种强大工具，它们允许程序员创建更灵活的函数和数据结构。这是关于 C 语言中函数指针的基本总结：</p><ol><li><p><strong>函数指针的定义</strong>：函数指针就像其他指针一样，它存储了一个地址。但是，这个地址不是变量的地址，而是函数的地址。例如，如果你有一个名为 <code>foo</code> 的函数，那么表达式 <code>&amp;foo</code> 就是一个函数的地址，你可以将它赋值给一个函数指针。</p><p>函数指针的声明包括函数的返回类型和参数类型。例如，以下代码定义了一个指向返回类型为 <code>int</code> 且接受两个 <code>int</code> 参数的函数的指针：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>这里，<code>funcPtr</code> 是指针的名字，<code>int (int, int)</code> 描述了函数的类型。</p></li><li><p><strong>函数指针的使用</strong>：你可以使用函数指针来调用函数。例如：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = funcPtr(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这会调用 <code>funcPtr</code> 指向的函数，传入参数 <code>2</code> 和 <code>3</code>，并将返回值赋值给 <code>result</code>。</p></li><li><p><strong>函数指针的赋值</strong>：你可以将一个函数的地址赋值给一个函数指针。例如，如果你有一个如下的函数：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将它的地址赋值给一个函数指针：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcPtr = &amp;add;</span><br></pre></td></tr></table></figure><p>现在，<code>funcPtr</code> 指向了 <code>add</code> 函数，你可以通过它来调用 <code>add</code>。</p></li><li><p><strong>函数指针作为函数参数</strong>：函数指针可以作为其他函数的参数。这使得你可以创建更灵活的函数，这些函数可以接受不同的行为作为参数。例如，你可以创建一个接受一个函数作为参数的函数，根据这个参数来执行不同的操作。</p></li><li><p><strong>函数指针作为函数返回值</strong>：函数也可以返回函数指针，这可以用于创建返回函数的工厂函数等高级模式。</p></li></ol><p>总的来说，函数指针是一种非常强大的工具，它们可以让你的 C 程序有更高的灵活性和动态性。虽然函数指针的语法有点复杂，但一旦你理解了它们的工作原理，你就会发现它们非常有用。</p><h1>从源代码到可执行文件</h1><p>编译器在编译源代码的过程中，会经过几个步骤：预处理、编译、汇编和链接。</p><ol><li><strong>预处理</strong>：预处理器处理源代码中的 <code>#include</code>、<code>#define</code> 等预处理指令。当你在 C 代码中使用 <code>#include</code> 指令时，预处理器会将这个头文件的全部内容复制到源文件中。<strong>这一步并不涉及编译，只是文本处理</strong>。</li><li><strong>编译</strong>：<strong>编译器将预处理后的源代码转换成汇编语言</strong>。</li><li><strong>汇编</strong>：汇编器将编译器生成的汇编语言转换成目标文件，<strong>也就是机器代码</strong>。</li><li><strong>链接</strong>：<strong>链接器将所有的目标文件和需要的库链接成一个可执行文件</strong>。在这个过程中，链接器需要解决外部符号（extern）的引用问题，也就是确定这些符号的具体位置。</li></ol><p>这个四个步骤对应的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i       # 预处理</span><br><span class="line">gcc -S test.i -o test.s       # 编译</span><br><span class="line">gcc -c test.s -o test.o       # 汇编</span><br><span class="line">gcc test1.o test2.o -o output # 链接</span><br></pre></td></tr></table></figure><p>在这里我们就可以解释extern的作用了</p><p>在 C 语言中，<code>extern</code> 关键字用于<strong>声明一个变量或函数，而不是定义它</strong>。这意味着我们在一个文件中声明一个变量或函数，可以在其他文件中使用它。</p><p><strong>当我们在一个源文件中定义一个全局变量或函数</strong>，其他源文件中使用这个变量或函数的文件就必须通过 <code>extern</code> 来声明它的存在(当然,如果是在头文件里面,你也可以通过include)。实际的定义只能在一个源文件中进行，声明可以在多个文件中进行。</p><blockquote><p>当然,你也是可以不用extern关键字, 然后再别的地方做声明,  但是这个让别人不好区分,会很容易产生迷惑,  不过这个也看链接器的行为,  我的建议如果不是使用引入头文件的方式的话, 就都写上extern</p></blockquote><p>举个例子吧</p><p>这个是test2.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>里面定义了一个函数和变量,但是我希望外部使用,这个是test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &quot;test2.c&quot;  我们这里也可以使用include的方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是使用include的方式的话,那么是可以直接编译test.c运行的,  但是如果是使用extern的方式的话,还得编译test2.c 然后链接起来就可以了</p><p>这里又引出了一个点:  <strong>.h文件是不是简化了我们的代码, 让我们少用了extern关键字</strong>,</p><h1>更深入的从源代码到可执行文件</h1><h1>头文件和源文件</h1><p>在 C 语言中，<code>.h</code> 和 <code>.c</code> 文件在编译过程中的作用主要有以下几点：</p><ol><li><strong>头文件（.h）</strong>：头文件主要用于<strong>声明</strong>函数、变量和类型。通过这些声明，你可以在其他文件中使用这些函数、变量和类型，即使它们在其他文件中定义。通常，你会在头文件中声明函数和全局变量，然后在一个源文件中定义它们。这样，其他源文件就可以通过包含相应的头文件来使用这些函数和全局变量。<strong>头文件最终是会被展开在每一个引入它的源文件中的</strong>, 所以我们最终还是要看源文件</li><li><strong>源文件（.c）</strong>：<strong>源文件用于定义函数和全局变量</strong>。这是编译器真正需要去编译的代码。每个源文件通常会包含一个或多个函数和全局变量的定义。在编译过程中，编译器会为每个源文件生成一个目标文件（.o 文件）。</li></ol><p>头文件通过 <code>#include</code> 指令被包含在源文件中。当编译器看到 <code>#include &quot;file.h&quot;</code> 指令时，它会将 “file.h” 的内容插入到源文件中，然后继续编译。这样，源文件就可以访问在 “file.h” 中声明的函数和全局变量。</p><p>在链接阶段，链接器会将所有的目标文件链接在一起，形成一个可执行的程序。<strong>链接器需要确保每个函数和全局变量只被定义一次</strong>，否则会出现链接错误。这就是为什么你不能在多个源文件中定义同一个函数或全局变量。 <strong>所以说,我们尽量只在头文件里面做声明,不要做定义</strong>, 因为头文件引入后会把里面的变量一起带过来, 但是如果不是static这种存储类别的话, 那肯定就都是全局变量,那这不就乱套了吗? 但是函数声明和变量声明是可以在.h文件里面声明的</p><p>总的来说，头文件（.h）用于声明，源文件（.c）用于定义。在编译阶段，编译器编译源文件；在链接阶段，链接器将目标文件链接在一起，形成一个可执行的程序。</p><p><strong>在头文件中 函数的声明默认是extern  但是变量的话默认是定义</strong></p><h1>常用库</h1><h2 id="assert-h">assert.h</h2><p>这个库函数只包含了一个宏就是assert, 它用来检测一个东西是不是false(null和0)</p><p>我们来看一下宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> assert(expr)(__ASSERT_VOID_CAST (0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> assert(expr)\</span></span><br><span class="line"><span class="meta">  ((expr)\</span></span><br><span class="line"><span class="meta">   ? __ASSERT_VOID_CAST (0)\</span></span><br><span class="line"><span class="meta">   : __assert_fail (__STRING(expr), __FILE__, __LINE__, __ASSERT_FUNCTION))</span></span><br></pre></td></tr></table></figure><p>我们发现,如果我们在引入assert.h之前如果定义了NDEBUG的话, 那么assert宏对应的函数就不会做事情了</p><h2 id="ctype-h">ctype.h</h2><p>在 C 语言中，<code>ctype.h</code> 是一个库，它包含一些用于<strong>测试和转换字符的函数</strong></p><ol><li><code>int isalnum(int c)</code>: 检查传入的字符是否是字母或数字。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int isalpha(int c)</code>: 检查传入的字符是否是字母。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int iscntrl(int c)</code>: 检查传入的字符是否是控制字符（ASCII 值在 0x00 和 0x1f 之间，以及 0x7f 的字符）。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int isdigit(int c)</code>: 检查传入的字符是否是数字（0-9）。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int isgraph(int c)</code>: 检查传入的字符是否有图形表示（即，它是一个可打印字符，且不是空格）。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int islower(int c)</code>: 检查传入的字符是否是小写字母。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int isprint(int c)</code>: 检查传入的字符是否是可打印字符（包括空格）。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int ispunct(int c)</code>: 检查传入的字符是否是标点符号。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int isspace(int c)</code>: 检查传入的字符是否是空格字符。空格字符包括：空格(’ ‘)，换行符(’\n’)，回车(’\r’)，水平制表符(’\t’)，垂直制表符(’\v’)，换页符(’\f’)。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int isupper(int c)</code>: 检查传入的字符是否是大写字母。如果是，则返回非零值；如果不是，返回 0。</li><li><code>int isxdigit(int c)</code>: 检查传入的字符是否是十六进制数字。这包括：0-9，a-f 和 A-F。如果是，则返回非零值；如果不是，返回 0。</li></ol><p>转换函数：</p><ol><li><code>int tolower(int c)</code>: 如果传入的字符是大写字母，将其转换为小写字母。如果输入不是大写字母，该函数返回输入不变。</li><li><code>int toupper(int c)</code>: 如果传入的字符是小写字母，将其转换为大写字母。如果输入不是小写字母，该函数返回输入不变。</li></ol><h2 id="stdio-h">stdio.h</h2><p><code>stdio.h</code> 是 C 语言的标准输入输出库，其中包含了大量用于文件和流相关操作的函数、宏和类型。下面详细罗列了一些主要的部分：</p><p><strong>类型</strong></p><ol><li><code>FILE</code>: 这是一个用于文件处理的重要类型，它提供了一个输入/输出流的接口。</li></ol><p><strong>宏</strong></p><ol><li><code>EOF</code>: <strong>当达到文件末尾或者发生错误时，很多函数会返回此宏。其值通常为-1</strong>。</li><li><code>NULL</code>: 这是一个特殊的指针值，用于表示指针没有指向任何内容。</li><li><code>BUFSIZ</code>: 这个宏表示系统的文件缓冲区大小。</li><li><code>FILENAME_MAX</code>: 这个宏指定了文件名的最大长度。</li><li><code>FOPEN_MAX</code>: 这个宏定义了系统可以同时打开的文件数量。</li><li><code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>: 这些宏用于 <code>fseek</code> 函数，用于定位到文件的开始、当前位置或者结束位置。</li><li><code>TMP_MAX</code>: 这个宏定义了 <code>tmpnam</code> 函数能够返回的不同的文件名的数量。</li></ol><p><strong>全局变量</strong></p><ol><li><code>stdin</code>: 这是指向标准输入的 <code>FILE</code> 类型指针。</li><li><code>stdout</code>: 这是指向标准输出的 <code>FILE</code> 类型指针。</li><li><code>stderr</code>: 这是指向标准错误的 <code>FILE</code> 类型指针。</li></ol><p><strong>文件访问</strong></p><ol><li><p><code>FILE *fopen(const char *filename, const char *mode)</code>: 打开名为 filename 的文件，并返回一个与该文件关联的 FILE 对象的指针。mode 参数确定文件的访问模式。</p></li><li><p><code>int fclose(FILE *stream)</code>: 关闭与 FILE 对象关联的文件。如果成功，返回 0，如果出错，返回 EOF。</p></li><li><p><code>int remove(const char *filename)</code>: 删除名为 filename 的文件。如果成功，返回 0，如果出错，返回非零值。</p></li><li><p><code>int rename(const char *oldname, const char *newname)</code>: 将 oldname 文件重命名为 newname。如果成功，返回 0，如果出错，返回非零值。</p></li><li><p><code>FILE *tmpfile(void)</code>: 创建一个临时文件，并以读/写模式打开。返回一个与该文件关联的 FILE 对象的指针。</p></li></ol><p><strong>格式化输入/输出</strong></p><ol start="6"><li><p><code>int printf(const char *format, ...)</code>: 根据指定的格式 format，输出格式化的数据到 stdout。</p></li><li><p><code>int fprintf(FILE *stream, const char *format, ...)</code>: 根据指定的格式 format，输出格式化的数据到指定的 FILE 流 stream。</p></li><li><p><code>int sprintf(char *str, const char *format, ...)</code>: <strong>根据指定的格式 format，将格式化的数据写入字符串 str</strong>。</p></li><li><p><code>int scanf(const char *format, ...)</code>: 从 stdin 中读取格式化输入。</p></li><li><p><code>int fscanf(FILE *stream, const char *format, ...)</code>: 从给定的 FILE 流 stream 中读取格式化输入。</p></li><li><p><code>int sscanf(const char *str, const char *format, ...)</code>: <strong>从字符串 str 中读取格式化输入</strong>。</p></li></ol><p><strong>字符输入/输出</strong></p><ol start="12"><li><p><code>int fgetc(FILE *stream)</code>: 从给定的 FILE 流 stream 中获取一个字符。</p></li><li><p><code>char *fgets(char *str, int n, FILE *stream)</code>: <strong>从给定的 FILE 流 stream 中读取一行</strong>，并存储到 str 所指向的字符串中。</p></li><li><p><code>int fputc(int c, FILE *stream)</code>: 将字符 c 写入到给定的 FILE 流 stream 中。</p></li><li><p><code>int fputs(const char *str, FILE *stream)</code>: 将字符串 str 写入到给定的 FILE 流 stream 中。</p></li><li><p><code>int getc(FILE *stream)</code>: 从给定的 FILE 流 stream 中获取一个字符。</p></li><li><p><code>int getchar(void)</code>: 从 stdin 中获取一个字符。</p></li><li><p><code>char *gets(char *str)</code>: 从 stdin 读取一行，并存储到 str 所指向的字符串中,<strong>这个函数现在已经不太常用了,因为他不安全</strong>。</p></li><li><p><code>int putc(int c, FILE *stream)</code>: 将字符 c 写入到给定的 FILE 流 stream 中。</p></li><li><p><code>int putchar(int c)</code>: 将字符 c 写入到 stdout。</p></li><li><p><code>int puts(const char *str)</code>: 将字符串 str 和一个尾随的换行符写入 stdout。</p></li><li><p><code>int ungetc(int c, FILE *stream)</code>: 将字符 c 退回到给定的 FILE 流 stream。</p></li></ol><p><strong>直接输入/输出</strong></p><ol start="23"><li><p><code>size_t fread(void *ptr, size_t size, size_t count, FILE *stream)</code>: 从给定的 FILE 流 stream 中读取数据，并存储到 ptr 所指向的数组。</p></li><li><p><code>size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream)</code>: 将 ptr 所指向的数组中的数据写入到给定的 FILE 流 stream。</p></li></ol><p><strong>文件定位</strong></p><ol start="25"><li><p><code>int fseek(FILE *stream, long offset, int whence)</code>: 设置给定的 FILE 流 stream 的文件位置和偏移量。</p></li><li><p><code>long ftell(FILE *stream)</code>: 返回给定的 FILE 流 stream 中的当前文件位置。</p></li><li><p><code>void rewind(FILE *stream)</code>: 设置给定的 FILE 流 stream 的文件位置到文件开始。</p></li></ol><p><strong>错误处理</strong></p><ol start="28"><li><p><code>void clearerr(FILE *stream)</code>: 清除给定的 FILE 流 stream 的文件结束和错误指示器。</p></li><li><p><code>int feof(FILE *stream)</code>: 检查给定的 FILE 流 stream 的文件结束指示器。</p></li><li><p><code>int ferror(FILE *stream)</code>: 检查给定的 FILE 流 stream 的错误指示器。</p></li><li><p><code>void perror(const char *str)</code>: 打印一条错误消息到 stderr。</p></li></ol><h1>补充</h1><h2 id="变量声明位置">变量声明位置</h2><p><strong>在 C99（1999年发布的C语言标准）及以后的版本中，你可以在代码的任何位置声明和定义变量</strong>。在此之前的C89/C90标准中，变量必须<strong>在代码块或函数的开头被声明</strong>。</p><p>举个例子，在C89/C90中，你需要这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在C99及以后的版本中，你可以这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，变量<code>i</code>就在<code>for</code>循环的初始化部分被声明和定义。</p><p>如果你不确定自己的编译器支持哪个版本的C语言，你可以查阅编译器的文档或者在线搜索相关信息。对于GCC和Clang这类编译器，你可以使用命令行参数<code>-std=c99</code>（或者更新的版本，如<code>-std=c11</code>，<code>-std=c17</code>等）来指定C语言的版本。</p><h2 id="true和false">true和false</h2><p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。<strong>注意字符0 可不是0, '\0’才是0</strong></p><h2 id="指针的运算">指针的运算</h2><p>指针只支持相同类型之间减运算,  而且 计算的值 =  (指针a的值 - 指针b的值)/(指针类型字节大小) ,  还有就是指针和整数之间的加法运算 计算值  = 指针地址值 + 整数*指针类型字节大小   (这里可以使用变量)</p><blockquote><p>注意, 比如 int* a = &amp;d  这里说的指针类型字节大小  是指这样的  sizeof(int)</p></blockquote><h2 id="默认初始化">默认初始化</h2><p>在 C 语言中，变量的默认初始化取决于它们被声明的位置。局部变量和全局变量的默认初始化是不同的：</p><ol><li><strong>局部变量</strong>：这些变量在函数内部声明。如果你不显式地初始化局部变量，那么它们的初始值是不确定的(因为它被分配在栈中的一个位置, 但是这个位置之前是有数据的)，即所谓的“垃圾值”。在使用局部变量之前，你总是应该先为它们赋值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 局部变量 x，不确定的初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>全局变量</strong>：这些变量在函数外部声明，可在程序的任何地方访问。如果你不显式地初始化全局变量，那么<strong>编译器会为它们赋予默认</strong>值。对于不同的数据类型，这些默认值如下：<ul><li>整型（int）和字符型（char）：默认值为 0</li><li>浮点型（float）和双精度浮点型（double）：默认值为 0.0</li><li>指针（pointer）：默认值为 NULL</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">// 全局变量 x，默认初始化为 0</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>静态变量</strong>：无论是静态局部变量还是静态全局变量，如果你不显式地初始化它们，<strong>那么编译器会为它们赋予默认值，规则与全局变量相同。</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x; <span class="comment">// 静态局部变量 x，默认初始化为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，对于变量的初始化，显式初始化总是一个好的编程习惯，因为它可以使你的代码更清晰，更易于理解，也可以避免由于未初始化的变量引起的不可预期的行为。</p><h2 id="typedef">typedef</h2><p><code>typedef</code> 是 C 语言中的一个关键字，用于为<strong>现有的数据类型创建一个新的名称</strong>（别名）。这可以用来增加代码的可读性和可维护性。以下是关于 <code>typedef</code> 的一些主要概念：</p><ol><li><p><strong>基本使用</strong>：你可以用 <code>typedef</code> 为任何数据类型定义一个新的名字。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Length;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个新的名字 <code>Length</code>，它是 <code>int</code> 的别名。现在，你可以使用 <code>Length</code> 来定义变量，就像使用 <code>int</code> 一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length x, y, z;</span><br></pre></td></tr></table></figure></li><li><p><strong>与结构体结合使用</strong>：<code>typedef</code> 经常与结构体（<code>struct</code>）一起使用，以避免在定义结构体变量时需要写 <code>struct</code> 关键字。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> gpa;</span><br><span class="line">&#125; Student;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个新的名字 <code>Student</code>，它是 <code>struct Student</code> 的别名。这样，我们就可以直接使用 <code>Student</code> 来定义结构体变量，而不需要写 <code>struct</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s1, s2;</span><br></pre></td></tr></table></figure></li><li><p><strong>与指针类型结合使用</strong>：你可以使用 <code>typedef</code> 为指针类型定义新的名字，这可以使代码更清晰。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* IntPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*hello)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 函数指针</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个新的名字 <code>IntPtr</code>，它是 <code>int*</code> 的别名。这样，我们就可以使用 <code>IntPtr</code> 来定义指针变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntPtr p, q;</span><br></pre></td></tr></table></figure></li></ol><p>总的来说，<code>typedef</code> 是一个很有用的工具，可以帮助你使代码更加清晰和一致。不过，你也应该注意，过度使用 <code>typedef</code> 可能会导致代码变得难以理解和维护，因此要适度使用。</p><p>注意点:</p><p>看下面这两个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p><strong>其中第一个是 对struct node 起了一个别名node , 第二个是定义了一个结构体变量变量名字是node</strong></p><h2 id="typedef和define的区别">typedef和define的区别</h2><p><code>typedef</code>和<code>define</code>都可以用于为现有类型创建别名，但它们有一些关键的区别：</p><ol><li><p><strong>处理方式</strong>：<code>typedef</code>是由编译器处理的，它创建的是类型的别名。而<code>define</code>是由预处理器处理的，它创建的是宏。</p></li><li><p><strong>类型检查</strong>：<code>typedef</code>提供类型检查，如果你试图为不兼容的类型使用别名，编译器会给出警告或错误。但是，<code>define</code>没有类型检查，它只是在预处理阶段进行文本替换。</p></li><li><p><strong>作用范围</strong>：<code>typedef</code>具有作用范围，<strong>它的有效范围是从声明点到声明所在的块或源文件的结束</strong>。而<code>define</code>没有作用范围，它在定义后的所有地方都有效，直到取消定义（<code>#undef</code>）或者文件结束。</p></li><li><p><strong>与结构体和联合体的交互</strong>：<code>typedef</code>可以与<code>struct</code>，<code>union</code>和<code>enum</code>等关键字一起使用，从而避免在声明这些类型的变量时需要写关键字。而<code>define</code>不能实现这个功能。</p></li></ol><p>例如，比较以下两种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Node struct Node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然<code>define</code>也能创建别名，但是在处理类型（尤其是复杂的类型，如结构体、联合体和函数指针）时，<code>typedef</code>通常更为优秀和灵活。在许多情况下，<code>typedef</code>可以使代码更清晰、更具可读性。</p><h2 id="可变参数">可变参数</h2><h3 id="定义">定义</h3><p>在C语言中，当函数的参数数量是可变的，我们称之为可变参数。为了处理这种情况，C语言在 <code>&lt;stdarg.h&gt;</code> 库中提供了一组宏。以下是这些宏的概述：</p><ol><li><p><code>va_list</code>: 这是一个用于储存可变参数信息的类型。</p></li><li><p><code>va_start(va_list ap, last_arg)</code>: 这个宏初始化 <code>ap</code> 变量以供 <code>va_arg</code> 和 <code>va_end</code> 宏使用。<code>last_arg</code> 是函数中最后一个非可变的参数。</p></li><li><p><code>va_arg(va_list ap, type)</code>: 这个宏检索 <code>ap</code> 变量所指向的下一个参数，并以 <code>type</code> 类型返回。每次调用 <code>va_arg</code> 之后，<code>ap</code> 都会更新以指向下一个参数。</p></li><li><p><code>va_end(va_list ap)</code>: 这个宏清理 <code>ap</code> 变量，并使其失效。在完成所有的 <code>va_arg</code> 调用之后，你应当调用 <code>va_end</code>。</p></li></ol><p>以下是一个使用这些宏的示例，它接收一个整数和一个可变参数列表，然后打印出所有的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_numbers</span><span class="params">(<span class="type">int</span> n, ...)</span> &#123;</span><br><span class="line">    va_list valist;</span><br><span class="line">    va_start(valist, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = va_arg(valist, <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(valist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print_numbers(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>print_numbers</code> 函数可以接收任意数量的整数参数。它首先使用 <code>va_start</code> 初始化 <code>valist</code>，然后使用 <code>va_arg</code> 获取每个参数，最后使用 <code>va_end</code> 结束参数列表的处理。注意，程序必须知道参数的正确类型和数量，否则结果可能是不确定的。在这个例子中，参数的数量由 <code>n</code> 参数提供，参数的类型被硬编码为 <code>int</code>。</p><h3 id="原理">原理</h3><p>C语言的可变参数列表依赖于函数调用协议（calling convention），这是指<strong>编译器如何在内存中安排函数的参数、返回值，以及如何在函数调用和返回时保存和恢复状态。</strong>(<strong>取决于它怎么翻译成汇编</strong>),  所以我们使用它提供的东西能保证一致性,  如果我们贸然使用指针操作可能有时候不对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void test(int a, int b)&#123;</span><br><span class="line">    int* d = &amp;a;</span><br><span class="line">    int* f = &amp;b;</span><br><span class="line">    printf(&quot;a = %p b = %p&quot;,&amp;a,&amp;b);</span><br><span class="line">    int c = a-b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10,b = 20;</span><br><span class="line">    test(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过查看汇编发现,   它是通过寄存器传递参数的,  然后再把寄存器的值放入到栈中,然后再使用栈里面的数据,入栈顺序是 a先入栈, b在入栈(栈是从高地址往低地址增长),所以a的地址 - b的地址  = 4  (这里是参数从左往右入栈 在centos7上)</p><blockquote><p>这里其实也不严谨,  仅仅通过地址来判断的话,  其实说明不了参数的入栈顺序,  它有时候使用的是寄存器,  因为我们使用了它的地址, 所以他把这个数放到了堆栈里面,  然后再获取这个放入它位置</p></blockquote><h2 id="命令行参数">命令行参数</h2><p>在 C 语言中，命令行参数通过 main 函数的两个参数传递：<code>argc</code>（参数计数）和 <code>argv</code>（参数向量）。</p><p><code>int main(int argc, char *argv[])</code></p><p>这是 main 函数的另一种常见形式，用于接收命令行参数。</p><ol><li><p><code>argc</code>：这是一个整数，表示在命令行中输入的参数数量。这总是至少为 1，因为程序名称本身就是第一个参数。</p></li><li><p><code>argv</code>：这是一个字符指针的数组，其中每个指针都指向一个字符串，即在命令行中输入的一个参数。这些参数是以空格分隔的字符串。</p></li></ol><p>例如，如果你有一个名为 <code>program</code> 的程序，你可以在命令行中以如下方式运行它：</p><p><code>./program arg1 arg2 arg3</code></p><p>在这种情况下，<code>argc</code> 的值为 4 （包括程序名称 <code>program</code>），<code>argv</code> 是一个指向四个字符串的指针的数组，分别为 <code>&quot;./program&quot;</code>, <code>&quot;arg1&quot;</code>, <code>&quot;arg2&quot;</code> 和 <code>&quot;arg3&quot;</code>。</p><p>注意，<code>argv[0]</code> <strong>始终是程序的名称</strong>，<code>argv[1]</code> 是第一个参数，以此类推，<code>argv[argc]</code> <strong>是一个空指针</strong>。</p><p>使用这些参数，可以在运行程序时向程序传递一些特定的输入或选项。</p><h2 id="静态链接库">静态链接库</h2><h3 id="定义">定义</h3><p>静态链接库是一种在编译时连接的库。<strong>这种库的所有代码和数据都被编译进了最终的可执行文件中</strong>。在程序运行时，静态库中的函数或数据不需要再从其他文件或位置加载，它们已经存在于可执行文件中。</p><p>下面是关于静态链接库的一些关键点：</p><ol><li><p>编译时包含：静态库在**编译时(这里的编译是指从源代码到生成可执行文件的过程,其实说链接更准确)**就被包含到可执行文件中。这意味着，运行可执行文件不需要额外的动态链接库。</p></li><li><p>完整性：由于静态库被编译到可执行文件中，所以在不同的系统上，这个文件不需要依赖其他库文件就可以运行。这种特性使得静态链接库非常适合于分发软件，尤其是当你不确定目标系统是否安装了必要的库文件时。</p></li><li><p>大小：因为所有必要的库代码都被包含在可执行文件中，所以使用静态库的程序通常比使用动态库的程序大。</p></li><li><p>版本控制：<strong>使用静态库可以避免一些由于库版本不匹配导致的问题。这是因为库的特定版本在编译时就被固定了</strong>。</p></li><li><p>性能：<strong>静态库的另一个优势是，它们通常会提供更好的性能。这是因为静态链接的代码在编译时就已经确定了，不需要在运行时动态解析符号或进行其他运行时链接步骤。</strong></p></li><li><p>缺点：静态库的主要缺点是他们会增加最终可执行文件的大小。此外，<strong>如果多个应用程序都使用同一静态库，那么每个应用程序都需要包含库的副本，这可能会浪费存储空间和内存</strong>。同时，<strong>更新库的版本时，所有使用该库的程序都需要重新编译和链接</strong>。</p><blockquote><p>如果静态库函数接口,全局变量这些东西没变, 这个程序是不需要重新修改代码编译的, 但是一定需要重新链接</p></blockquote></li></ol><h3 id="不同工具集创建方式">不同工具集创建方式</h3><p>代码如下</p><p>add.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;add.h&quot;</span><br><span class="line"></span><br><span class="line">int add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>add.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">int add(int a, int b);</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;add.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int c = add(a, b);</span><br><span class="line">    printf(&quot;a + b = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用gcc工具集">使用gcc工具集</h4><ol><li><p><strong>编译生成目标文件</strong>：首先，你需要编译<code>add.c</code>，生成<code>add.o</code>目标文件。在命令行中，你可以键入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o</span><br></pre></td></tr></table></figure></li><li><p><strong>生成静态库</strong>：使用<code>ar</code>命令，你可以将<code>add.o</code>打包成静态库<code>libadd.a</code>。在命令行中，你可以键入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libadd.a add.o <span class="comment"># 后面可以跟多个目标文件</span></span><br></pre></td></tr></table></figure><p>这会生成一个名为<code>libadd.a</code>的静态库。</p></li><li><p><strong>编译并链接</strong>：然后，你需要编译<code>main.c</code>，并链接到<code>libadd.a</code>库。在命令行中，你可以键入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c -o main.o</span><br><span class="line">gcc -static main.o -L. -ladd -o main <span class="comment"># 这里使用static是为了强制使用静态库</span></span><br></pre></td></tr></table></figure><p>这里，<code>-L.</code>告诉编译器去当前目录(<code>.</code>)查找库，<code>-ladd</code>表示链接名为<code>add</code>的库(即<code>libadd.a</code>)。这会生成一个名为<code>main</code>的可执行文件。</p></li><li><p><strong>运行</strong>：最后，你可以运行<code>main</code>。在命令行中，你可以键入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>这将会打印出<code>a + b = 30</code>。</p></li></ol><p>以上步骤默认所有文件都在同一目录下进行，如果文件或者库在其他目录，需要根据实际情况修改路径。同时，假设你的系统中已经正确安装了GCC和相关工具。</p><h4 id="使用vs工具集">使用vs工具集</h4><p>在Windows环境中，可以使用Microsoft提供的<code>lib</code>命令来生成静态库文件。下面是生成静态库文件的步骤：</p><ol><li><p><strong>编译生成目标文件</strong>：首先，你需要编译<code>add.c</code>，生成<code>add.obj</code>目标文件。在命令行中，你可以键入如下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /c add.c</span><br></pre></td></tr></table></figure><p>这个命令将会编译<code>add.c</code>并生成<code>add.obj</code>文件。这里需要注意的是，<strong>Microsoft的编译器生成</strong>的是<code>.obj</code>文件，而不是<code>.o</code>文件。</p></li><li><p><strong>生成静态库</strong>：然后，你可以使用<code>lib</code>命令将<code>add.obj</code>打包成静态库<code>add.lib</code>。在命令行中，你可以键入如下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib /OUT:add.lib add.obj</span><br></pre></td></tr></table></figure><p>这个命令将会生成<code>add.lib</code>静态库。</p></li><li><p><strong>编译并链接</strong>：然后，你需要编译<code>main.c</code>，并链接到<code>add.lib</code>库。在命令行中，你可以键入如下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /Fe:main.exe main.c add.lib</span><br></pre></td></tr></table></figure><p>这个命令将会生成一个名为<code>main.exe</code>的可执行文件。</p></li><li><p><strong>运行</strong>：最后，你可以运行<code>main.exe</code>。在命令行中，你可以键入如下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.exe</span><br></pre></td></tr></table></figure><p>这将会打印出<code>a + b = 30</code>。</p></li></ol><p>以上步骤默认所有文件都在同一目录下进行，如果文件或者库在其他目录，需要根据实际情况修改路径。同时，假设你的系统中已经正确安装了Visual Studio和相关工具，<code>cl</code>和<code>lib</code>命令能够在命令行中被正确找到。</p><h3 id="注意点">注意点</h3><p><strong>静态库的全局变量和函数 是不能跟其他静态库以及主程序冲突的</strong></p><h2 id="动态链接库">动态链接库</h2><h3 id="定义">定义</h3><p>动态链接库，是一种包含了程序可以在运行时调用的函数和数据的二进制文件。动态库在程序运行时被加载进内存，可以被多个正在运行的程序共享。相比静态库，动态库有以下特点和优点：</p><ol><li><p><strong>内存高效</strong>：由于同一动态库的单一实例可以被多个程序共享，因此动态库有助于节省内存。</p></li><li><p><strong>更新方便</strong>：当动态库更新时，只需替换磁盘上的动态库文件即可，不需要重新编译和链接使用该库的程序。</p></li><li><p><strong>动态加载</strong>：程序在运行时可以动态加载和卸载动态库。这在需要在运行时扩展功能时非常有用。</p></li><li><p><strong>减小二进制文件大小</strong>：使用动态库可以减小二进制文件的大小，因为库函数并未链接进二进制文件，而是在运行时动态加载。</p></li></ol><p>然而，动态库也有其不足之处：</p><ol><li><p><strong>版本兼容性问题</strong>：如果动态库的新版本改变了API或者ABI，那么旧的程序可能会因为找不到需要的函数或者数据而失败。</p></li><li><p><strong>分布和部署的复杂性</strong>：使用动态库的应用程序需要在分布和部署时包含动态库，或者确保目标系统已经安装了正确版本的动态库。</p></li><li><p><strong>性能</strong>：动态链接在一些情况下可能会比静态链接稍慢一些，因为需要在运行时进行符号解析。</p></li><li><p><strong>安全性</strong>：动态库可能会被恶意修改或替换，从而导致使用该库的程序行为异常。</p></li></ol><p>总的来说，动态库提供了一种灵活、高效的方式来共享代码和数据，但是也增加了一些复杂性。选择使用静态库还是动态库取决于你的具体需求和环境。</p><h3 id="变量作用域">变量作用域</h3><p>在 C 语言中，<strong>动态库（DLL 在 Windows 或 .so 在 Unix/Linux）与主程序之间的命名空间是分开的</strong>。这意味着，即使动态库中的全局变量与主程序中的全局变量同名，它们也是完全不同的变量，互不影响。</p><p>例如，如果你在主程序 <code>main.c</code> 中定义了一个全局变量 <code>int x;</code>，然后在动态库 <code>lib.c</code> 中也定义了一个全局变量 <code>int x;</code>，编译和链接过程不会产生错误或警告，因为这两个 <code>x</code> 变量在不同的命名空间中。</p><p>在运行时，主程序和动态库都会有各自的 <code>x</code> 变量的拷贝。主程序只能访问和修改它自己的 <code>x</code>，动态库只能访问和修改它自己的 <code>x</code>。<strong>如果你想在主程序中访问动态库中的 <code>x</code>，或者在动态库中访问主程序中的 <code>x</code>，你需要提供相应的接口函数。</strong></p><p><strong>需要注意的是，这个行为是 C 语言特性，与操作系统或编译器无关。</strong></p><blockquote><p>这个和静态链接库还是有很大区别的</p></blockquote><h3 id="搜索路径">搜索路径</h3><p>在Windows和Linux系统中，动态链接库（DLLs 在Windows，.so 在Linux）的搜索路径有所不同。以下是关于两种操作系统如何搜索这些库的简要概述：</p><p><strong>Windows中的DLL搜索路径</strong></p><ol><li><strong>应用程序的目录</strong>：首先，Windows会查找包含应用程序的可执行文件的目录。比如，如果你正在运行位于<code>C:\Program Files\MyApp\MyApp.exe</code>的应用程序，Windows就会首先查找<code>C:\Program Files\MyApp</code>目录下的DLL文件。</li><li><strong>系统目录</strong>：其次，Windows会查找系统目录，即<code>C:\Windows\System32</code>。对于64位系统，32位的DLL会在<code>C:\Windows\SysWOW64</code>目录下。</li><li><strong>Windows目录</strong>：然后，Windows会查找Windows目录，即<code>C:\Windows</code>。</li><li><strong>当前目录</strong>：此外，Windows也会查找当前工作目录。当前工作目录是指当前活动的文件路径，这个路径可以被应用程序改变。需要注意的是，从Windows XP SP2开始，为了增加系统的安全性，<strong>当前目录在默认情况下不再被包含在DLL搜索路径中</strong>。(<strong>这个目录是你执行程序的目录</strong>)</li><li><strong>PATH环境变量指定的目录</strong>：最后，Windows会按照它们在PATH环境变量中出现的顺序来查找这些目录。PATH环境变量包含一个或多个目录的列表，这些目录之间用分号（;）分隔。</li></ol><p>需要注意的是，这种行为可以通过一些API函数（例如 <code>SetDllDirectory</code>）或者Manifest文件进行更改。</p><p><strong>Linux中的.so搜索路径</strong></p><p>Linux系统搜索.so文件通常遵循以下顺序：</p><ol><li>LD_LIBRARY_PATH 环境变量中指定的目录。这是一个由冒号分隔的目录列表。</li><li><code>/etc/ld.so.cache</code> 文件中列出的目录，这个文件包含了已知动态库的列表。</li><li><code>/lib</code> 目录</li><li><code>/usr/lib</code> 目录</li></ol><p>这个过程也可以通过修改 <code>/etc/ld.so.conf</code> 文件或者添加新的 <code>.conf</code> 文件到 <code>/etc/ld.so.conf.d</code> 目录来定制。每次修改后，都需要运行 <code>ldconfig</code> 命令更新 <code>/etc/ld.so.cache</code> 文件。</p><p>这些只是默认行为，特定的应用程序或库可能会改变这种行为，例如通过使用 <code>dlopen</code> 函数的完全限定路径。</p><p><strong>无论是在Windows还是Linux系统中，如果系统在某个目录下找到了所需的动态链接库（DLL 或 .so 文件），系统就会立即停止搜索，并且加载找到的那个库文件。</strong></p><h2 id="整数类型的转换">整数类型的转换</h2><h3 id="等字长有无符号转换">等字长有无符号转换</h3><p>不改变二进制位, 只改变解释方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = -1</span><br><span class="line">unsigned int b = a; //4294967295   </span><br></pre></td></tr></table></figure><h3 id="不等字长转换">不等字长转换</h3><p>高到低:  高字节直接截断低位  赋值给  低字节</p><p>低到高(<strong>这里是看低字节是否有符号</strong>)</p><ol><li>低字节数无符号,  高字节数高位都补0,  高字节数低位直接赋值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> b = a; <span class="comment">// 65535</span></span><br></pre></td></tr></table></figure><ol start="2"><li>低字节数有符号,  高字节数高位补符号位, 高字节数低位直接赋值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = a; <span class="comment">//4294967295</span></span><br></pre></td></tr></table></figure><h2 id="文件打开模式">文件打开模式</h2><p>在C语言中使用 <code>fopen</code> 函数打开文件时指明是以二进制模式还是文本（字符）模式打开，主要是因为不同操作系统对文件的处理方式存在差异，<strong>特别是在处理换行符时。</strong></p><h3 id="文本模式-character-mode">文本模式 (Character Mode)</h3><p>在文本模式下打开文件时，C标准库会根据运行平台的惯例对文件的内容进行某些转换。最常见的例子是换行符的处理：</p><ul><li>在 <strong>Windows</strong> 系统中，文本文件的换行符通常表示为回车符和换行符的组合 (<code>\r\n</code>)。</li><li>而在 <strong>Unix/Linux</strong> 和 <strong>macOS</strong> 系统中，换行符通常只是一个换行符 (<code>\n</code>)。</li></ul><p>当您在文本模式下读取或写入文件时，C标准库会自动将这些换行符转换为适合于您的操作系统的格式。例如，在Windows上，当您从文件中读取数据时，每个 <code>\r\n</code> 序列会被转换为 <code>\n</code>；当您写入数据时，每个 <code>\n</code> 会被转换为 <code>\r\n</code>。</p><h3 id="二进制模式-binary-mode">二进制模式 (Binary Mode)</h3><p>在二进制模式下，文件被视为字节流，不进行任何转换。这对于非文本文件（如图像、音频、视频或任何自定义格式的数据文件）尤其重要，因为在这些文件中，任何字节的改变都可能导致文件损坏。</p><h3 id="为什么这很重要">为什么这很重要</h3><p>区分这两种模式很重要，因为错误地选择模式可能会导致数据不正确地读取或写入，特别是当您的程序需要在多种操作系统上运行时。例如，如果您在Windows上以文本模式打开一个二进制文件，并试图读取或写入数据，可能会不经意间改变文件中的 <code>\r\n</code> 字节序列，从而损坏文件。</p><h3 id="结论">结论</h3><p>因此，在使用 <code>fopen</code> 时指定正确的文件模式是确保文件数据正确读取和写入的关键，尤其是当您的程序需要在不同的操作系统上运行时。在处理纯文本数据时使用文本模式，在处理二进制数据（或当文件格式需要跨平台一致时）使用二进制模式。</p><h1>gcc的用法</h1><h2 id="基本参数">基本参数</h2><ul><li>-E  只做预处理</li><li>-S 转化成汇编</li><li>-c 生成目标文件</li><li>-o 输出文件名字 (使用上面三个参数)</li></ul><h3 id="static">static</h3><p>强制使用静态链接,  这意味着会链接所有使用到的库函数,   包括c语言提供的库,  一定要确保使用到的函数所在的静态库存在于  库搜索目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static main.o -L. -l add -o main</span><br></pre></td></tr></table></figure><p>比如在我centos8中执行这个命令就报错了,  因为这个系统里面没有libc.a这个静态库(它会默认链接),  所以</p><p>即使你的代码没有直接使用到标准库函数，<code>gcc</code> 编译和链接时仍然会引用标准 C 库（<code>libc</code>），因为一些基本的运行时支持功能（比如程序启动和退出代码）通常都在 <code>libc</code> 里面实现。</p><h3 id="i-i的大写">I (i的大写)</h3><p><strong>指定额外的头文件搜索路径,可以是相对也可以是绝对路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c add.c -I.. -o main</span><br></pre></td></tr></table></figure><h3 id="l-l的小写">l(L的小写)</h3><p>指定额外库, 后面跟库名字,当使用 <code>-l</code> 选项时，你只需要提供库的基本名称，不需要文件扩展名和<code>lib</code> 前缀。</p><ul><li>例如，对于 <code>libadd.a</code> 或 <code>libadd.so</code>，使用 <code>-ladd</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  main.o -L. -l add -o main</span><br></pre></td></tr></table></figure><p>不过默认情况下，<code>gcc</code> 优先链接动态库。如果你想确保链接静态库，你可以使用 <code>-static</code> 标志或明确指定库的完整名称和路径。推荐后者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc  main.o -L. -l:libadd.a -o main</span><br><span class="line">gcc  main.o /root/Code/gccTest/day02/libadd.a -o main</span><br></pre></td></tr></table></figure><h3 id="l">L</h3><p>指定额外<strong>库路径</strong>, 可以是相对路径, 也可以是绝对路径,   这个跟上面的参数搭配使用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  main.o -L. -l add -o main</span><br></pre></td></tr></table></figure><h2 id="生成动态库">生成动态库</h2><p>创建动态库（在Linux/Unix系统上通常是<code>.so</code> 文件，在Windows上是 <code>.dll</code> 文件）与创建静态库略有不同。以下是在Linux上使用 <code>gcc</code> 创建动态库的步骤：</p><h3 id="1-编写源代码">1. 编写源代码</h3><p>假设你有两个源文件 <code>file1.c</code> 和 <code>file2.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function1 from a shared library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function2 from a shared library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-编译源代码">2. 编译源代码</h3><p>使用 <code>-fPIC</code> 选项编译源代码文件，该选项表示生成位置无关代码（Position Independent Code）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC file1.c -o file1.o</span><br><span class="line">gcc -c -fPIC file2.c -o file2.o</span><br></pre></td></tr></table></figure><h3 id="3-创建共享库">3. 创建共享库</h3><p>使用 <code>-shared</code> 选项链接目标文件，并使用 <code>-o</code> 选项指定输出的共享库文件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared file1.o file2.o -o libmysharedlib.so</span><br></pre></td></tr></table></figure><p>这会创建一个名为 <code>libmysharedlib.so</code> 的动态库。</p><h3 id="4-使用动态库">4. 使用动态库</h3><p>要使用这个动态库，你可以在编译你的主程序时指定这个库。例如，如果你的主程序是 <code>main.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    function1();</span><br><span class="line">    function2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译主程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -lmysharedlib -o main</span><br></pre></td></tr></table></figure><p>这里，<code>-L.</code> 指定库的搜索路径为当前目录，<code>-lmysharedlib</code> 指定链接到名为 <code>mysharedlib</code> 的库。</p><h3 id="5-设置库路径">5. 设置库路径</h3><p>在运行你的程序前，确保系统知道在哪里找到动态库。你可以通过设置 <code>LD_LIBRARY_PATH</code> 环境变量来做这件事：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>这将当前目录添加到 <code>LD_LIBRARY_PATH</code> 环境变量中。</p><h3 id="6-运行你的程序">6. 运行你的程序</h3><p>现在你可以运行你的主程序了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>在Windows系统上，创建和使用动态库（<code>.dll</code> 文件）的过程略有不同，并且使用的是不同的工具和命令。</p><h3 id="什么是位置无关">什么是位置无关</h3><p><code>-fPIC</code> 是一个编译选项，用于生成位置无关代码（Position Independent Code, PIC）。这种代码类型可以从任何内存地址执行，不受固定地址限制，这是创建共享库所必需的。</p><h3 id="为什么需要位置无关代码？">为什么需要位置无关代码？</h3><ul><li><p><strong>共享库</strong>：<br>当你创建一个共享库（<code>.so</code>或<code>.dll</code>）时，它可以被多个执行文件（程序）同时使用。系统不可能事先知道这些执行文件将被加载到内存的什么位置，也不可能事先知道它们将使用的共享库将被加载到什么位置。因此，共享库中的代码必须能够从任何内存地址运行，这就是为什么它们必须被编译为位置无关代码的原因。</p></li><li><p><strong>动态加载</strong>：<br>另一个需要PIC的场景是动态加载，例如，当一个程序在运行时动态加载一个插件或模块。由于程序无法事先知道这些插件将被加载到什么位置，所以插件必须使用位置无关代码。</p></li></ul><h3 id="pic的工作原理：">PIC的工作原理：</h3><ul><li><strong>位置无关代码使用相对地址（而不是绝对地址）来访问数据和调用函数</strong>。也就是说，<strong>它不直接引用内存地址</strong>。相反，它使用基于运行时地址的偏移来访问数据和函数。</li><li>在运行时，动态链接器负责处理这些相对地址和偏移，以确保代码正确执行。</li></ul><h3 id="使用-fpic：">使用 <code>-fPIC</code>：</h3><p>使用 <code>-fPIC</code> 选项编译源文件时，编译器会生成这种类型的代码，使得生成的目标文件可以被链接到一个共享库中。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC source.c -o source.o</span><br></pre></td></tr></table></figure><p>这将编译 <code>source.c</code> 为一个位置无关的目标文件 <code>source.o</code>。</p><h2 id="简化输出汇编">简化输出汇编</h2><ul><li><strong><code>-O0</code></strong>：设置优化级别为0，表示不进行任何优化。</li><li><strong><code>-fverbose-asm</code></strong>：在生成的汇编代码中添加额外的注释，以更好地说明代码的来源。</li><li><strong><code>-masm=intel</code></strong>：使用 Intel 语法生成汇编代码，而不是默认的 AT&amp;T 语法。</li><li><strong><code>-nostdlib</code></strong>：不使用标准库和启动文件。这意味着你的代码不能依赖于标准C库的任何功能。</li><li><strong><code>-ffreestanding</code></strong>：告诉编译器代码是在一个不依赖于标准库的环境中运行的。</li><li><strong><code>-fno-asynchronous-unwind-tables</code></strong>：不生成用于异步异常处理的表格。这有助于减少一些平台上的额外的 <code>.cfi</code> 指令。</li><li><strong><code>-fno-stack-protector</code></strong>：不生成堆栈保护代码，这通常用于防止栈溢出攻击。</li><li><strong><code>-fomit-frame-pointer</code></strong>：不使用帧指针，这可以在某些平台上减少对某些寄存器的依赖。</li><li><strong><code>-fno-plt</code></strong>：避免生成过程链接表（Procedure Linkage Table, PLT）调用，这对于某些涉及动态链接的场景有意义。</li><li><strong><code>-fno-leading-underscore</code></strong>：在某些平台上，符号名默认可能有一个前导的下划线。这个选项告诉编译器不要添加这个下划线。</li><li><strong><code>-fno-builtin</code></strong>：不使用任何内建函数，即 GCC 的内部优化函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -O0 -fverbose-asm -masm=intel -nostdlib -ffreestanding -fno-asynchronous-unwind-tables -fno-stack-protector -fomit-frame-pointer -fno-plt -fno-leading-underscore -fno-builtin </span><br><span class="line">    your_source_file.c -o output_asm_file.s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输入输出字符问题">输入输出字符问题</h2><h3 id="输入前的处理">输入前的处理</h3><ul><li><p><strong><code>scanf</code> 系列函数</strong>：这些函数在遇到非空白字符前会忽略空白字符，包括空格、制表符和换行符。所以如果输入流开始处是换行符，<code>scanf</code> 会跳过它继续寻找非空白字符。</p></li><li><p><strong><code>getchar</code> 和 <code>fgetc</code></strong>：这两个函数逐个字符读取输入流，包括换行符。如果下一个字符是换行符，它们会读取这个换行符。</p></li><li><p><strong><code>gets</code> 和 <code>fgets</code></strong>：<code>gets</code> 从输入流中读取直到换行符但不包括换行符本身，然后丢弃换行符；<code>fgets</code> 也读取直到换行符，但包括换行符本身，换行符被包含在返回的字符串中。</p></li></ul><h3 id="输入后的处理">输入后的处理</h3><ul><li><p><strong><code>scanf</code> 系列函数</strong>：如果<code>scanf</code>读取的格式不包括换行符，它会在完成读取后留下换行符在输入流中。这意味着换行符没有被消耗，还在缓冲区里等待下一个输入操作处理。</p></li><li><p><strong><code>getchar</code> 和 <code>fgetc</code></strong>：当这两个函数读取换行符时，它们会将其从输入流中移除。也就是说，换行符被读取并消耗掉了。</p></li><li><p><strong><code>gets</code> 和 <code>fgets</code></strong>：对于<code>gets</code>，换行符被读取后会被丢弃，不包含在返回的字符串中；而<code>fgets</code>会包含换行符在返回的字符串中，并从输入流中移除换行符。</p></li></ul><h3 id="总结">总结</h3><ul><li>不同的输入函数对换行符的处理方式不同，这对于程序的行为和用户输入的处理非常关键。</li><li>理解每个函数如何处理换行符有助于预防输入时的错误和意外行为，特别是在连续使用多个输入函数的情况下。</li></ul><h1>一些不太好的用法</h1><h2 id="使用函数不声明">使用函数不声明</h2><blockquote><p>如果通过gcc是可以这样的,  g++貌似就不行了</p></blockquote><p>在C语言编程中，你可以在一个源文件（比如 <code>main.c</code>）中调用一个函数，而不需要在同一个源文件中声明或定义它。然而，为了让程序可以成功编译和链接，你必须在编译时确保链接器可以找到这个函数的定义。</p><p>下面是一个简单的例子：</p><ol><li>假设你有两个源文件：<code>main.c</code> 和 <code>helper.c</code>。</li></ol><ul><li><p><code>main.c</code> 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    myFunction();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>helper.c</code> 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from myFunction!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>你可以分别编译这两个源文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c      <span class="comment"># 这将生成 main.o</span></span><br><span class="line">gcc -c helper.c    <span class="comment"># 这将生成 helper.o</span></span><br></pre></td></tr></table></figure><ol start="3"><li>然后你可以链接这两个对象文件来创建一个可执行文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o helper.o -o myProgram</span><br></pre></td></tr></table></figure><p>在这个例子中，即使 <code>main.c</code> 文件中没有 <code>myFunction</code> 的声明，程序仍然可以成功编译和链接，因为 <code>myFunction</code> 的定义在 <code>helper.o</code>（从 <code>helper.c</code> 编译得到）中可用。</p><p>然而，即使这种方法可以工作，但在调用函数之前在源文件中提供函数声明通常是一个好习惯，因为这可以在编译时捕获类型不匹配和其他错误。如果你没有在 <code>main.c</code> 中提供 <code>myFunction</code> 的声明或定义，你应该在 <code>main.c</code> 中包含一个头文件（例如 <code>helper.h</code>），该头文件包含 <code>myFunction</code> 的声明：</p><ul><li><code>helper.h</code> 文件：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>然后在 <code>main.c</code> 文件中包含这个头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    myFunction();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>一些有趣的尝试</h1><h2 id="大小端">大小端</h2><p>如何判断我们的电脑对于多字节数据是大端还是小端,   我当时的想法想得到所有位来判断,  这样是不行的,  因为运算的数是拿到寄存器里面来运算的, 不存在什么大小端,  因此我们得通过单字节指针char*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int x = 1;</span><br><span class="line">    char *c = (char *)&amp;x;</span><br><span class="line"></span><br><span class="line">    if (*c)  // 如果*c是1就说明是小端</span><br><span class="line">        printf(&quot;Little-Endian\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;Big-Endian\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据的按边界存储">数据的按边界存储</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs2019使用</title>
      <link href="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>一个解决方案对应多个项目</h1><p>在vs2019中 解决方案是一个容器,它可以包含多个项目</p><h2 id="创建一个空白解决方案">创建一个空白解决方案</h2><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612225900504.png" alt="image-20230612225900504"></p><h2 id="创建项目">创建项目</h2><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612230214227.png" alt="image-20230612230214227"></p><p>这样我们就可以把多个项目在vs2019中打开了</p><h1>项目调用</h1><p>有时候我们希望一个项目能够调用另外一个项目,我们可以这样</p><p>现在有两个项目, 一个Dao,一个Service,  其中Service需要通过Dao项目访问数据库</p><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612230843154.png" alt="image-20230612230843154"></p><h2 id="将dao项目输出为lib">将Dao项目输出为lib</h2><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612231039248.png" alt="image-20230612231039248"></p><h2 id="在service项目中引入">在Service项目中引入</h2><h3 id="指定头文件">指定头文件</h3><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612231338073.png" alt="image-20230612231338073"></p><h3 id="指定库地址">指定库地址</h3><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612232646864.png" alt="image-20230612232646864"></p><h2 id="定义项目依赖">定义项目依赖</h2><p>这一步不是必须的,  你可以手动将Dao项目生成为lib,  这里是自动生成lib</p><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612233059903.png" alt="image-20230612233059903"></p><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230612233112397.png" alt="image-20230612233112397"></p><p><strong>如果我们没有修改Dao里面的代码,  是不会重新对Dao进行构建的, 这一点很重要</strong></p><h1>动态链接库DLL生成</h1><h2 id="方式一-使用-declspec-dllexport-创建dll">方式一 使用 __declspec(dllexport) 创建dll</h2><p>Math.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MATHLIBRARY_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATHLIBRARY_API __declspec(dllexport) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATHLIBRARY_API __declspec(dllimport) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了确保使用c++编译器的时候能够正确被连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">MATHLIBRARY_API <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> MATHLIBRARY_API <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MATHLIBRARY_API</span> <span class="title">Math</span> &#123;</span>   <span class="comment">// 注意 MATHLIBRARY_API 一定要在class右侧</span></span><br><span class="line">public:</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里的MATHLIBRARY_API其实做两个用处的,  如果是生成dll的话,  那就是导出,  否则就是是引入dll</p><blockquote><p>注意这里也可以导出变量和类</p></blockquote><p>Math.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//#define MATHLIBRARY_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">sum += a + b;</span><br><span class="line"><span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Math::sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后添加一个宏, 当然, 这里我们也可以直接在代码上面写, 比如上面注释掉那部分</p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019使用assets/image-20230621175457266.png" alt="image-20230621175457266" style="zoom:67%;"><p>修改程序输出为dll</p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019使用assets/image-20230621175602417.png" alt="image-20230621175602417" style="zoom: 67%;"><p>然后生成, 生成东西如下</p><p><img src="/2023/06/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vs2019%E4%BD%BF%E7%94%A8/../img/vs2019%E4%BD%BF%E7%94%A8assets/image-20230621175703035.png" alt="image-20230621175703035"></p><ol><li><code>.dll</code> 文件：这是动态链接库（DLL）文件本身。这是一个二进制文件，它包含了你的代码编译后的机器代码以及其他一些信息，例如资源（如图标、图片、对话框等）、元数据（例如导出的函数和类、导入的函数和类等）等。你的程序在运行时可以加载这个DLL，并使用其中的函数和类。</li><li><code>.exp</code> 文件：这是导出文件（export file）。它包含了你的DLL导出的函数和数据的信息。当链接器生成DLL时，它会首先生成一个.exp文件，然后再生成DLL和.lib文件。.exp文件通常不需要分发，它主要是在构建过程中使用。</li><li><code>.lib</code> 文件：这是导入库（import library）。<strong>当你的程序在编译时链接到这个DLL时</strong>，链接器会使用这个.lib文件来找到DLL中的函数和类。.lib文件包含了DLL中导出的函数和类的名称以及它们在DLL中的位置。你可以把.lib文件看作是一个索引，链接器可以用它来在DLL中找到函数和类。</li><li><code>.pdb</code> 文件：这是程序数据库（program database）文件。它包含了调试信息，例如源文件的位置、变量的名称、函数的堆栈信息等。当你在Visual Studio中调试你的程序时，调试器会使用.pdb文件来找到源代码的位置，并显示变量的值、函数的调用堆栈等信息。.pdb文件通常不需要分发，除非你想让其他人能够调试你的DLL。</li></ol><p>以上就是这四种文件类型的基本解释。需要注意的是，通常你只需要分发 <code>.dll</code> 和 <code>.lib</code> 文件，其他的 <code>.exp</code> 和 <code>.pdb</code> 文件主要是在构建和调试过程中使用。</p><h2 id="方式二-模块定义文件">方式二  模块定义文件</h2><p><code>.def</code>文件被称为模块定义文件（Module-Definition File）。这种文件类型是微软Visual Studio的一部分，主要用于为Windows的动态链接库（DLLs）和可执行文件（EXEs）提供信息。</p><p>模块定义文件可以包含很多种信息，例如DLL的描述、DLL数据的段名称和特性、函数导出等等。这些信息可以影响到链接器如何处理DLL或可执行文件。</p><p>比如，你可以通过模块定义文件来导出DLL中的符号。在<code>.def</code>文件中，可以使用<code>EXPORTS</code>关键字列出你希望导出的所有符号。这可以作为<code>__declspec(dllexport)</code>的替代方法来导出符号。</p><p>模块定义文件虽然在一些场合下仍然有用，但是现代的C++代码通常会选择使用<code>__declspec(dllexport)</code>和<code>__declspec(dllimport)</code>来控制符号的导出和导入，因为这种方式更加直观和灵活。</p><p>在Windows环境下创建一个模块定义文件的模板可以是如下的形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY &quot;libraryname&quot; </span><br><span class="line">EXPORTS </span><br><span class="line">    function1 @1 </span><br><span class="line">    function2 @2 </span><br><span class="line">    function3 @3 </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在这个模板中:</p><ul><li><p><code>LIBRARY &quot;libraryname&quot;</code> 是声明此模块定义文件对应的库的名字，<code>&quot;libraryname&quot;</code>需要替换成你的实际库名。</p></li><li><p><code>EXPORTS</code> 是导出函数的声明。在这之后，你需要列出你想要从 DLL 中导出的所有函数。每一个函数后面的 @ 符号和数字是可选的，用于指定函数在导出表中的索引。</p></li></ul><p>请注意，模块定义文件的内容会根据实际需求变化，上述仅仅是一个基本的模板。你可能需要根据你的实际需求对其进行修改。</p><p><strong>现在我们通常使用第一种方式</strong></p><h2 id="注意点">注意点</h2><p>在Windows中，如果你的函数或者变量没有使用<code>__declspec(dllexport)</code>进行显式导出，它们仍然会被编译并打包到DLL中，但是它们不会被DLL的导出表所列出。这意味着，尽管这些函数和变量存在于DLL中，但是在DLL的外部是无法直接访问到它们的。</p><p>实际上，一个DLL文件可以被看作是一个包含了一组函数和数据的容器。当你创建一个DLL时，所有的源代码都会被编译，并且所有的函数和数据都会被包含在DLL中。然后，通过使用<code>__declspec(dllexport)</code>关键字，你可以选择哪些函数和数据应该被添加到DLL的导出表中，也就是哪些函数和数据可以被DLL的用户访问。</p><p>因此，如果你没有使用<code>__declspec(dllexport)</code>导出任何函数或数据，那么你的DLL将不会对外部公开任何接口。然而，DLL中的所有代码仍然存在，并且可以在DLL内部被其他函数和数据访问。</p><p>另外，如果你希望在DLL中隐藏某些函数或数据，你也可以使用<code>__declspec(dllexport)</code>关键字的对立面，即<code>__declspec(dllimport)</code>。这个关键字可以阻止函数或数据被导出，即使它们在源代码中被定义了出来。</p><p>**如果一个DLL没有暴露任何函数或数据（**即没有使用<code>__declspec(dllexport)</code>关键字导出任何接口），那么它在DLL的外部将几乎无法使用。</p><p>当你创建一个DLL时，目的通常是为了提供一些函数或数据给其他的应用程序或者DLL来使用。这些函数和数据被称为DLL的“导出符号”。如果一个DLL没有导出任何符号，那么其他的应用程序或者DLL就无法直接访问到DLL中的任何代码。</p><p>然而，<strong>即使一个DLL没有导出任何符号，也不意味着它是完全无用的。DLL中的代码仍然可以执行</strong>，如果DLL被设计为在加载时执行某些操作（例如，初始化静态数据或执行其他一些代码），那么这些操作仍然会在DLL被加载时执行。但是，这种情况相对罕见，并且通常只用于特殊的情况。</p><p>通常情况下，如果你创建一个DLL，你应该至少导出一个函数或数据供其他代码使用。否则，创建DLL的意义就不大了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s总结</title>
      <link href="/2023/06/05/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s%E6%80%BB%E7%BB%93/"/>
      <url>/2023/06/05/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>资源对象</h1><h2 id="pod">pod</h2><p><code>Pod</code> 代表的是集群上处于运行状态的一组 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器</a> 的集合, 也就是说一个pod里面可以有多个容器,  <strong>容器是容器运行时的最小调度单位</strong>, <strong>在k8s中pod才是最小调度单位</strong></p><p>当在你的集群中运行了某个 Pod，但是 Pod 所在的 <a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a> 出现致命错误时， <strong>所有该节点上的 Pod 的状态都会变成失败</strong>。Kubernetes 将这类失败视为最终状态： <strong>即使该节点后来恢复正常运行</strong>，也需要创建新的 <code>Pod</code> 以恢复应用。</p><p>任何给定的 Pod （由 UID 定义）从不会被“重新调度（rescheduled）”到不同的节点； 相反，这一 Pod 可以被一个新的、几乎完全相同的 Pod 替换掉。 如果需要，新 Pod 的名字可以不变，但是其 UID 会不同。</p><p><strong>一个pod里面的容器在同一个网络命名空间 可以通过localhost 互相访问</strong></p><h3 id="容器重启策略">容器重启策略</h3><ol><li><code>Always</code>：无论容器的退出状态码是什么，都将重启容器。这是默认策略。</li><li><code>OnFailure</code>：只有当容器以非零状态码退出时，才会重启容器。</li><li><code>Never</code>：不论容器的退出状态码是什么，都不会重启容器。</li></ol><p>容器重启不会删除pod,当重启次数超过一定次数后, 这个pod就会进入CrashLoopBackOff, 所以这个</p><h3 id="init容器">init容器</h3><p>在 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 内的应用容器启动之前运行。Init 容器可以包括一些<strong>应用镜像中不存在的实用工具和安装脚本</strong>。可以通过挂载卷的方式为其他应用容器做一些事情,  如果有多个init容器的话, 会按照顺序依次执行init容器,然后启动主容器, 如果失败的话,后面的容器和主容器都不会启动, 而且会按照重启策略来进行操作,   所以说我们可以在init容器中做一些先决条件判断, 等到满足了再退出init容器, 然后继续启动其他init容器和主容器</p><blockquote><p>init容器是在pause之后运行, pause 会配置网络和容器卷</p></blockquote><blockquote><p>只有修改init容器的镜像才会重启pod,其他都不会影响</p></blockquote><p>举一个官网例子解释一下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo The app is running! &amp;&amp; sleep 3600&quot;</span>]  <span class="comment"># 只有当myservice和mydb服务都可用时，才会执行该容器的命令</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        [</span><br><span class="line">          <span class="string">&quot;sh&quot;</span>,</span><br><span class="line">          <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">          <span class="string">&quot;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&quot;</span>,</span><br><span class="line">        ]  <span class="comment"># 通过nslookup命令检查myservice服务是否可用，如果不可用则休眠2s，然后再次检查，直到myservice服务可用</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        [</span><br><span class="line">          <span class="string">&quot;sh&quot;</span>,</span><br><span class="line">          <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">          <span class="string">&quot;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&quot;</span>,</span><br><span class="line">        ] <span class="comment"># 通过nslookup命令检查mydb服务是否可用，如果不可用则休眠2s，然后再次检查，直到mydb服务可用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="探针">探针</h3><p>在 Kubernetes 中，探针（Probe）是 Kubernetes 使用的一种机制，<strong>通过其中的一些函数来检测 Pod 中容器的状态</strong>。这些探针检查的状态包括是否存活、是否已就绪以及是否能够成功运行等。根据探测结果，Kubernetes 可以做出相应的决定，如重启容器、重新调度、以及发送服务不可用的信号。</p><p>有三种类型的探针：</p><ol><li><strong>Liveness Probe</strong>：这种探针用来检测容器是否还在运行。如果探针检测失败，<strong>Kubernetes 将会杀掉并重启容器</strong>。</li><li><strong>Readiness Probe</strong>：这种探针用来检测容器是否已准备好接收请求。如果探针检测失败**，Pod 会从其服务的 Endpoint 中被移除**，直至探针再次成功。<strong>不会干掉容器</strong></li><li><strong>Startup Probe</strong>：这种探针用来检测应用程序在启动过程中是否成功。如果这个探针失败到指定次数，Kubernetes 将会杀掉并重启容器，如果探测成功，其他探针才会开始工作, <strong>只要检测成功之后就不会再检测</strong></li></ol><p>存活探针 和就绪探针   他们分别用来检测 容器是否存活  和 是否就绪   关于为什么需要存活探针这个很好说明,  当容器不能正常工作的时候但是容器又不会自己退出的话, pod其实还是运行状态的,但是k8s是检测不出来的,  所以我们需要一个存活探针来定义检测容器是否正常运行,如果不能正常工作的话就重启容器</p><p>探针检测机制有三种</p><ol><li><strong>ExecAction</strong>：在容器内执行指定命令，如果返回零则认为成功。 对应资源字段 exec</li><li><strong>TCPSocketAction</strong>：对指定端口上的容器进行 TCP 检查，如果端口开放则认为成功。 对应资源字段 tcpSocket</li><li><strong>HTTPGetAction</strong>：对指定的端口和路径上的容器进行 HTTP Get 请求，如果返回状态码在 200 到 399 之间则认为成功。 对应资源字段 httpGet</li></ol><blockquote><p>就绪探针也会一直工作</p></blockquote><h3 id="容器生命周期钩子函数">容器生命周期钩子函数</h3><p>当一个容器启动后，Kubernetes 将立即发送 postStart 事件,调用指定的钩子函数；在容器被终结之前， Kubernetes 将发送一个 preStop 事件,调用指定的钩子函数。容器可以为每个事件指定一个处理程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: lifecycle-demo-container</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 6000&quot;]</span><br><span class="line">      lifecycle:</span><br><span class="line">        postStart:</span><br><span class="line">          exec:</span><br><span class="line">            command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo &#x27;postStart Hook: Everything is up and running!&#x27; &gt; /usr/share/message&quot;]</span><br><span class="line">        preStop:</span><br><span class="line">          exec:</span><br><span class="line">            command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo &#x27;preStop Hook: Preparing for shutdown!&#x27; &gt; /usr/share/message&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>生命周期钩子 <code>postStart</code> 和 <code>preStop</code> 中的命令的输出并不会被写入到容器的 stdout 或 stderr，因此你不能通过 <code>kubectl logs</code> 命令查看这些输出</p></blockquote><h3 id="dns策略">DNS策略</h3><p>在 Kubernetes 中，每个 Pod 都有一个 DNS 策略，它决定了 Pod 中容器的 <code>/etc/resolv.conf</code> 文件如何被配置。这个文件被用来解析 DNS 请求。DNS 策略可以设置为以下几种值：</p><ul><li><code>Default</code>: 默认情况下，Pod 的 DNS 解析配置从节点上继承。</li><li><code>ClusterFirst</code>: 如果 Pod 运行在启用了 DNS 的集群中，并且 Pod 的 <code>dnsPolicy</code> 被设置为 <code>ClusterFirst</code>，那么当 Pod 尝试访问一个服务（如 <code>my-svc.my-namespace.svc.cluster-domain.example</code>），它首先会使用集群内部的 DNS 服务进行名称解析。</li><li><code>ClusterFirstWithHostNet</code>: 对于使用了主机网络的 Pod，其 DNS 解析配置应设为 <code>ClusterFirstWithHostNet</code>。这将让这些 Pod 能够通过 Kubernetes 的 DNS 服务解析其他服务的名称，同时也能解析主机网络中的 DNS。</li><li><code>None</code>: 如果设置为 <code>None</code>，你可以通过 <code>dnsConfig</code> 选项自定义 DNS 解析参数。</li></ul><p>对于pod里面的/etc/resolv.conf解释</p><ul><li><code>search default.svc.cluster.local svc.cluster.local cluster.local</code>：这是搜索域条目，<strong>当试图访问一个没有指定全域名（FQDN）的主机时，系统会尝试在这些域名后面添加这个搜索域</strong>，以便完成主机名的解析。比如，在这个设置下，如果你尝试访问 <code>headless-service</code>，那么系统首先会尝试解析 <code>headless-service.default.svc.cluster.local</code>，如果没有找到，那么会尝试解析 <code>headless-service.svc.cluster.local</code>，最后会尝试解析 <code>headless-service.cluster.local</code>。</li><li><code>nameserver 10.1.0.10</code>：<strong>这是 DNS 服务器的 IP 地址，这个 IP 地址是 Kubernetes 集群内部的 DNS 服务器</strong>（通常是 CoreDNS 或 kube-dns）的 IP 地址。</li><li><code>options ndots:5</code>：这是一个设置项，表示如果一个域名中包含的点的数量大于等于这个值，那么就会直接进行全域名解析，而不会再添加搜索域。在这个设置下，如果你尝试访问 <code>a.b.c.d.e</code>（这个域名中包含了 4 个点），那么系统就会直接尝试进行全域名解析，而不会添加搜索域。</li></ul><p>在我们自定义dns的时候, 也就是配置上面三项东西</p><h3 id="静态pod">静态pod</h3><p>静态pod是在每个结点上执行的,它是通过kubelet进行管理创建的,  但是无法通过apisever去管理它,  因此他也不能使用一些集群中的资源,比如pvc,configmap,service 等等</p><h2 id="命名空间">命名空间</h2><p>在 Kubernetes 中，命名空间（Namespace）<strong>是一种将集群资源分隔成多个虚拟集群的机制</strong>。命名空间为名称提供了一个范围。<strong>资源的名称需要在命名空间内保持唯一，但不需要跨命名空间保持唯一</strong>。不同的命名空间可以有相同名称的资源。</p><p>命名空间的主要用途包括：</p><ol><li><p><strong>资源隔离</strong>：命名空间可以用来在物理集群中创建多个虚拟集群。每个命名空间的资源（如 Pod、服务和部署等）是隔离的，<strong>这可以防止一个命名空间中的应用干扰其他命名空间中的应用</strong>。</p></li><li><p><strong>权限控制</strong>：命名空间可以和 RBAC（基于角色的访问控制）一起使用，以限制用户或应用对特定命名空间的访问。例如，你可以创建一个命名空间，然后授予一个用户对该命名空间的编辑权限，这样该用户就可以在这个命名空间中创建和管理资源，但不能影响其他命名空间。</p></li><li><p><strong>资源配额</strong>：命名空间还可以和 Resource Quotas 一起使用，以限制命名空间可以使用的资源数量。例如，你可以为一个命名空间设置一个限制，以防止它使用过多的 CPU 或内存资源。</p></li><li><p><strong>组织和标签</strong>：命名空间也可以用来组织和标记资源。这对于大型集群或多租户集群特别有用，你可以使用命名空间将相关的应用和服务组织在一起，或者将开发环境、测试环境和生产环境的资源分隔开。</p></li></ol><p>总的来说，命名空间是 Kubernetes 中的一个重要概念，它提供了一种有效的方式来隔离、管理和组织集群资源。</p><h2 id="deployments">Deployments</h2><p>Deployment 是一种高级概念，<strong>用于描述预期的应用程序状态</strong>，并使 Kubernetes <strong>能够改变实际状态以达到预期状态</strong>。当我们修改了描述状态的时候, k8s会帮我们去改变实际状态达到预期状态,  比如我们缩放pod数量,以及修改容器镜像.</p><p>资源文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span> <span class="comment"># 名字</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># pod副本数量</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 必须字段</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 匹配什么样的pod  这里必须和下面的pod的标签一样</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 必须字段</span></span><br><span class="line">    <span class="attr">metadata:</span> <span class="comment"># 这里面不需要name属性, 由k8s自动生成</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># pod 标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span> <span class="comment"># pod具体的东西</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名字</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line"></span><br><span class="line">          <span class="attr">ports:</span> <span class="comment"># 容器使用pod的端口</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在 Kubernetes 中，当你进行滚动更新时，可以设置两个关键的参数来控制更新过程中 Pod 的数量：</p><ol><li><strong><code>maxSurge</code></strong>：这个参数定义了相对于所需 Pod 数量的最大超出值。这意味着你可以在更新过程中允许有多少个额外的 Pod。这些额外的 Pod 可以保证在更新过程中有足够的容量来处理应用的负载。这个参数可以是绝对数字（例如 “5”）或者是百分比（例如 “20%”）。</li><li><strong><code>maxUnavailable</code></strong>：<strong>这个参数定义了相对于所需 Pod 数量的最大不可用值</strong>。这意味着你可以在更新过程中允许有多少个 Pod 是不可用的。这个参数可以是绝对数字（例如 “5”）或者是百分比（例如 “20%”）。</li></ol><h2 id="replicaset">ReplicaSet</h2><p>它通常用来保证给定数量的、完全相同的 Pod 的可用性</p><p>Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 <strong>因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet</strong></p><h2 id="statefulset">statefulset</h2><p><strong>无论怎么调度，每个 Pod 都有一个永久不变的 ID</strong>。</p><ul><li>稳定的、唯一的网络标识符。<strong>这个只是标识符,不是ip, 把pod删除之后, 名字不变,但是ip是会变的</strong></li><li>稳定的、持久的存储。</li><li>有序的、优雅的部署和扩缩。</li><li>有序的、自动的滚动更新。</li></ul><h2 id="daemonset">DaemonSet</h2><p>DaemonSet 是 Kubernetes 中的一种工作负载对象，<strong>它确保了在每一个或某些特定的集群节点上都运行一个 Pod 的副本</strong>。</p><p>DaemonSet 在以下场景中非常有用：</p><ol><li><p><strong>集群级别的日志收集</strong>：例如，你可能希望在每个节点上都运行一个日志收集的 Pod，如 Fluentd 或 Logstash，以收集该节点上所有 Pod 的日志。</p></li><li><p><strong>集群级别的监控</strong>：例如，你可能希望在每个节点上都运行一个监控的 Pod，如 Prometheus Node Exporter，以收集该节点的硬件和操作系统指标。</p></li><li><p><strong>节点级别的网络配置</strong>：例如，你可能希望在每个节点上都运行一个网络代理的 Pod，如 Calico 或 kube-proxy，以处理网络路由和负载均衡。</p></li></ol><p>DaemonSet 通过在新节点加入集群时自动在其上部署 Pod，以及在节点被移除时自动删除这些 Pod，来保证每个或某些特定的节点上都有 Pod 运行。这使得 DaemonSet 在需要在每个节点上运行特定服务的场景中非常有用。</p><h2 id="service">service</h2><p>在Kubernetes（K8s）中，Service是一种抽象，用于将运行在一组Pods上的应用程序公开为网络服务。与Pod的生命周期相对独立，Service用于连接到Pod。</p><p>这里有一些Service的主要用途和特性：</p><ol><li><p><strong>负载均衡和服务发现</strong>：Service可以用作内部的负载均衡器，并且可以通过其DNS名称被发现。每个Service都有一个IP地址（在Service的生命周期内不变），其他Pod可以通过这个IP地址连接到Service。此外，Kubernetes还提供DNS服务，每个Service在Kubernetes集群内部都有一个DNS名称，可以使用此名称连接到Service。</p></li><li><p><strong>稳定的网络接口</strong>：当背后的Pod被销毁和重新创建时，Service保持其IP地址和DNS名称不变，这为Pods提供了一个稳定的接口。</p></li><li><p><strong>支持多种服务发现模式</strong>：Service支持多种服务发现模式，包括使用环境变量和DNS进行服务发现。</p></li><li><p><strong>网络策略</strong>：可以使用NetworkPolicies来定义允许哪些Pod连接到Service。</p></li><li><p><strong>服务代理</strong>：Service可以公开集群的内部Pods以供外部访问。例如，你可以使用NodePort或LoadBalancer类型的Service将Pods公开到集群外部。</p></li></ol><p>总的来说，Kubernetes中的Service主要用于管理访问Pods的网络访问策略，并为Pods提供负载均衡和服务发现。下面是一个简单地配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service-hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-hello</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>  <span class="comment"># 暴露类型,这个只能在集群内部访问, 还有NodePort 可以在集群外部访问,  还有一个LoadBalancer可以多做一个负载均衡</span></span><br></pre></td></tr></table></figure><p>在集群内部我们可以使用 serviceip+端口访问  在集群外部我们可以使用 nodeip +端口访问   在pod里面 我们可以通过前两种方式访问, 也可以通过 &lt;servicename&gt;.&lt;namespace&gt;.svc.&lt;clusterdomain&gt; 的域名访问, 后面这个clusterdomain没有设置的话就不用写</p><h3 id="无头服务">无头服务</h3><p>在定义service的时候将ClusterIP 指定为None, 这样的话就不会分配ip给service</p><p>在 Kubernetes 中，无头服务（Headless Service）主要是用来对同一个服务的多个后端 Pod 进行服务发现。无头服务与常规服务的主要区别在于，无头服务没有一个稳定的集群 IP 地址，而是直接返回后端 Pod 的 IP 地址列表。<strong>当应用程序需要直接与单个后端 Pod 进行通信</strong>，或者需要知道后端所有 Pod 的 IP 地址时，无头服务就非常有用</p><p>无头服务能够为每个pod生成一个dns记录,  记录格式如下   podname.servicename.namespace.svc.cluster.local  例如一个mysql的pod的域名如下  mysql-statefulset-0.mysql-service.default.svc.cluster.local,</p><h2 id="ingress">ingress</h2><p>Ingress是Kubernetes提供的一种HTTP路由资源，它允许在集群中的服务接收从集群外部来的HTTP和HTTPS流量。Ingress包含一组路由规则，这些规则指导外部的入站连接到集群中的服务。</p><p>Ingress可以提供以下功能：</p><ol><li><p><strong>路径基于的路由</strong>：你可以配置Ingress以便基于URL路径来路由流量。例如，请求路径为&quot;/user&quot;的请求可以被路由到&quot;users&quot;服务，而路径为&quot;/products&quot;的请求可以被路由到&quot;products&quot;服务。</p></li><li><p><strong>主机名基于的路由</strong>：你也可以配置Ingress以便基于请求的主机名来路由流量。例如，&quot;<a href="http://user.example.com">user.example.com</a>&quot;的请求可以被路由到&quot;user&quot;服务，而&quot;<a href="http://products.example.com">products.example.com</a>&quot;的请求可以被路由到&quot;products&quot;服务。</p></li><li><p><strong>SSL/TLS终止</strong>：Ingress允许你定义SSL/TLS证书，以便你的服务可以接收安全的HTTPS连接。</p></li><li><p><strong>负载均衡</strong>：Ingress可以工作在多个副本的服务上，提供负载均衡。</p></li></ol><p>使用Ingress的方式有很多种，这主要取决于你所使用的Ingress controller。Ingress controller是实现Ingress的一个组件，它负责实现Ingress的规则。有许多第三方提供了Ingress controller，例如NGINX, Traefik, HAProxy等。</p><p>为了使用Ingress，需要安装一个Ingress controller，并定义一个或多个Ingress资源。Ingress资源包含了路由规则的定义，例如如何根据请求路径或主机名路由流量。</p><p>我这里使用nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.7.1/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure><p>这是一个使用Ingress的例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-hello</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">hello.djm.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">nginx-service-hello</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">hello2.djm.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">nginx-service-hello2</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><p>在这个例子中，任何到&quot;<a href="http://myapp.example.com">myapp.example.com</a>&quot;的HTTP请求都会被路由到名为&quot;my-service&quot;的服务，服务的端口为8080。</p><h2 id="定向调度">定向调度</h2><p>将pod调度到指定的结点上, 通过标签选择器指定到指定的结点上</p><p>我们给某个结点打个标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes work1 ssd=666</span><br></pre></td></tr></table></figure><p>然后再资源配置文件里面指定需要结点具有标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: selectnode-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: selectnode-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: selectnode-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: selectnode-container</span><br><span class="line">          image: nginx</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line">      nodeSelector:</span><br><span class="line">        ssd: &quot;666&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管 NodeSelector 很简单易用，但是它有一些缺点和局限性：</p><ol><li><strong>不支持复杂表达式</strong>：NodeSelector 只支持基于等式的匹配，例如 “disktype=ssd”。这就意味着你不能使用更复杂的表达式，例如否定（not in）或者范围选择。</li><li><strong>没有软约束</strong>：NodeSelector 提供的是硬性约束，这意味着如果没有符合条件的节点，Pod 就无法被调度。然而，有时我们可能想要的是一种&quot;偏好&quot;（preference）或者&quot;软&quot;约束，即如果可能，Pod应该被调度到符合条件的节点，但是如果没有符合条件的节点，Pod 也可以被调度到其他节点。</li><li><strong>没有排他性</strong>：如果你想让某些节点只运行特定的 Pod，或者让某些 Pod 只运行在特定的节点，NodeSelector 无法满足这种需求。你需要使用 taints 和 tolerations 来实现这种排他性。</li></ol><p>因为以上的缺点，Kubernetes 在 NodeSelector 的基础上引入了更强大的节点选择机制，如 Node Affinity/Anti-Affinity 和 Taints and Tolerations。这些更先进的机制可以提供更多的灵活性，满足更多复杂的需求。</p><h2 id="亲和性">亲和性</h2><h1>容器卷</h1><h2 id="configmap">configMap</h2><h3 id="定义">定义</h3><p>ConfigMap 是 Kubernetes 中用于存储配置数据的一种资源对象。<strong>它用于将配置信息与容器分离，并以一种解耦的方式将配置注入到容器中</strong>。下面是 ConfigMap 的一些常见用途和用法：</p><ol><li><p><strong>应用配置</strong>：你可以将应用程序的配置参数（如数据库连接字符串、日志级别、环境变量等）存储在 ConfigMap 中，并将它们注入到容器中，使得应用程序能够动态获取配置信息。</p></li><li><p><strong>命令行参数</strong>：如果你的容器需要特定的命令行参数来启动或配置应用程序，你可以将这些参数存储在 ConfigMap 中，并在容器启动时将其传递给应用程序。</p></li><li><p><strong>环境变量</strong>：你可以将环境变量存储在 ConfigMap 中，并将它们注入到容器中，以便应用程序能够访问这些环境变量。</p></li><li><p><strong>配置文件</strong>：你可以将配置文件存储在 ConfigMap 中，并将它们挂载到容器中的指定路径，以供应用程序读取。</p></li><li><p><strong>共享配置</strong>：你可以创建一个 ConfigMap，并将其共享给多个 Pod，这样这些 Pod 就可以共享相同的配置信息。</p></li></ol><p>ConfigMap 的使用方式有两种：</p><ul><li><p><strong>环境变量注入</strong>：将 ConfigMap 中的配置数据以环境变量的形式注入到容器中。这种方式适用于配置信息较少的情况，可以通过在 Pod 的配置中使用 <code>env</code> 字段来设置环境变量。</p></li><li><p><strong>卷挂载</strong>：将 ConfigMap 中的配置数据以文件的形式挂载到容器中。这种方式适用于配置信息较多、或者需要以文件形式进行操作的情况，可以通过在 Pod 的配置中使用 <code>volumes</code> 和 <code>volumeMounts</code> 字段来挂载 ConfigMap。</p></li></ul><p>总的来说，ConfigMap 提供了一种灵活、可扩展的方式来管理容器的配置数据，并且能够与其他 Kubernetes 资源对象（如 Deployment、StatefulSet、DaemonSet 等）无缝集成。</p><blockquote><p>在 Kubernetes 中，如果使用了 ConfigMap 卷，当 ConfigMap 的内容发生更改时，这些更改最终会反映到挂载了这个 ConfigMap 的 Pod 中。这是由 kubelet 实现的，它会定期检查挂载的 ConfigMap 是否是最新的，并根据需要更新它。</p><p>然而，由于 kubelet 使用了本地缓存，并且这个缓存是基于 TTL (Time To Live) 机制的，所以从 ConfigMap 更新到 Pod 的延迟可能会达到 kubelet 的同步周期 + ConfigMap 缓存的 TTL。默认情况下，这个延迟可能会达到 2 分钟。</p></blockquote><h3 id="创建方式">创建方式</h3><h4 id="通过命令行直接创建">通过命令行直接创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap &lt;映射名称&gt; &lt;数据源&gt;</span><br></pre></td></tr></table></figure><p>创建文件类型的configmap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap testconfigmap --from-file=./configMap/</span><br></pre></td></tr></table></figure><p><img src="/2023/06/05/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s%E6%80%BB%E7%BB%93/../img/testassets/image-20230526112219490.png" alt="image-20230526112219490"></p><p>自定义键名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap testconfigmap --from-file=mykey=./configMap/test.properties --from-file=./configMap/test2.properties</span><br></pre></td></tr></table></figure><p><img src="/2023/06/05/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s%E6%80%BB%E7%BB%93/../img/testassets/image-20230526112852490.png" alt="image-20230526112852490"></p><p>创建环境变量类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap testconfigmap2 --from-env-file=./configMap/test.properties</span><br></pre></td></tr></table></figure><p><img src="/2023/06/05/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s%E6%80%BB%E7%BB%93/../img/testassets/image-20230526112442031.png" alt="image-20230526112442031"></p><h4 id="使用yaml配置文件">使用yaml配置文件</h4><p>使用k8s的资源对象形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: special-config</span><br><span class="line">  namespace: default</span><br><span class="line">data:</span><br><span class="line">  SPECIAL_LEVEL: very</span><br><span class="line">  SPECIAL_TYPE: charm</span><br><span class="line">  my-file.txt: |</span><br><span class="line">    Hello, this is the content of my file.</span><br><span class="line">    This is the second line.</span><br><span class="line">    And here is the third line.</span><br></pre></td></tr></table></figure><p>结合Kustomize 来使用,  定义一个名字为Kustomization.yaml 的文件, 必须是这个文件名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configMapGenerator:</span><br><span class="line">- name: special-config-2</span><br><span class="line">  literals:</span><br><span class="line">  - special.how=very</span><br><span class="line">  - special.type=charm</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -k .</span><br></pre></td></tr></table></figure><blockquote><p>对于configmap里面的东西, 最终都会在pod里面产生一个 key 文件  文件内容为 value</p></blockquote><h3 id="使用">使用</h3><p>pod里面引入它</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">      <span class="attr">envFrom:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">testconfigmap-5fcc4d2fdt</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">djm</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">         <span class="attr">configMapKeyRef:</span></span><br><span class="line">         <span class="attr">name:</span> <span class="string">testconfigmap-5fcc4d2fdt</span> </span><br><span class="line">         <span class="attr">key:</span> <span class="string">test.properties</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">testconfigmap-5fcc4d2fdt</span></span><br><span class="line">        <span class="comment"># items:   如果使用了这个配置项的话,就会按照需要的数据挂载</span></span><br></pre></td></tr></table></figure><h2 id="emptydir">emptyDir</h2><p><strong>当pod在结点上运行的时候这个emptyDir就存在了</strong>,<code>emptyDir</code> 卷不是持久化的，它的生命周期与所在的 Pod 相关联。当 Pod 被删除时，<code>emptyDir</code> 卷中的数据也会被清空。如果需要在容器之间共享数据并且需要持久化，可以考虑使用其他类型的持久化卷，如 <code>hostPath</code>、<code>PersistentVolumeClaim</code> 等。 主要用于在 Pod 的容器之间共享数据</p><h2 id="hostpath">hostPath</h2><p>它允许将主机（节点）上的文件或目录直接挂载到 Pod 中的容器中。</p><p>使用 hostPath 卷，可以在 Pod 中访问主机上的文件系统资源，这对于需要与主机交互或需要访问主机上的特定文件或目录的应用程序非常有用。</p><p>hostPath 卷的使用需要小心，因为它可以让容器访问主机上的敏感文件和目录。在使用 hostPath 卷时，请务必确保对主机上的文件和目录进行了适当的限制和安全配置，以避免潜在的安全风险。</p><p>以下是 hostPath 卷的一些常见用途：</p><ol><li>日志文件：容器可以将日志文件写入主机上的特定目录，这样可以方便地通过主机上的工具或进程对日志进行处理和分析。</li><li>配置文件：某些应用程序可能需要读取主机上的特定配置文件，例如数据库连接信息或证书文件。</li><li>主机资源访问：某些应用程序可能需要与主机上的设备进行交互，例如读取传感器数据或控制硬件。</li></ol><p>需要注意的是，hostPath 卷对于跨节点或跨集群的场景并不适用，因为它依赖于主机上的文件系统路径。在使用 hostPath 卷时，需要考虑安全性、可移植性和主机资源的限制。</p><h2 id="secret">Secret</h2><h3 id="定义">定义</h3><p>在 Kubernetes 中，Secret <strong>用于存储和管理敏感数据</strong>，如密码、API 密钥、证书等。Secret 的主要目的是提供一种安全且可管理的方式，用于在应用程序和容器中存储敏感信息。</p><p>以下是一些使用 Secret 的常见场景和用途：</p><ol><li><p>存储数据库凭据：Secret 可以用于存储数据库的用户名和密码，以供应用程序连接和认证数据库时使用。这样可以避免将敏感信息直接硬编码到应用程序的代码中。</p></li><li><p>存储 API 密钥和令牌：Secret 可以用于存储与外部服务通信所需的 API 密钥、令牌或访问凭据。这样可以在应用程序中引用 Secret，而不必明文存储这些敏感信息。</p></li><li><p>存储证书和密钥：Secret 可以用于存储 TLS/SSL 证书和私钥，以供应用程序启用加密通信。这对于保护应用程序的网络通信是至关重要的。</p></li><li><p>共享配置文件：Secret 可以用于共享容器之间的配置文件，如配置文件、密钥文件等。这样可以确保敏感的配置数据得到安全地传递和存储。</p></li><li><p>指定镜像拉取凭据：Secret 可以用于存储私有镜像仓库的认证凭据，以便容器可以拉取受保护的镜像。</p></li></ol><p>Secret 以编码形式存储在 Kubernetes 中，只有具有访问权限的实体才能解码和使用其中的数据。Secret 可以在 Pod 中被挂载为 Volume 或作为环境变量注入到容器中，以便应用程序可以方便地访问和使用其中的敏感数据。</p><p>需要注意的是，尽管 Secret 可以提供一定程度的安全性，但仍然需要谨慎处理和管理敏感数据。确保对 Secret 的访问权限进行适当的配置，并遵循最佳实践来保护敏感数据的安全性。</p><h3 id="创建">创建</h3><h4 id="使用命令行">使用命令行</h4><p>它的创建方式跟configmap是差不多的,只不过中间多了一个类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic mysql --from-literal=username=djm --from-literal=password=12345</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secrets mysql -o jsonpath=&#x27;&#123;.data.username&#125;&#x27; | base64 --decode</span><br><span class="line">kubectl get secrets mysql -o jsonpath=&#x27;&#123;.data.password&#125;&#x27; | base64 --decode</span><br></pre></td></tr></table></figure><h4 id="使用配置文件">使用配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span>  <span class="comment"># 这里必须使用base64编码的东西</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MWYyZDFlMmU2N2Rm</span></span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">stringData:</span>  <span class="comment"># 这样可以不编码</span></span><br><span class="line">  <span class="attr">config.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    apiUrl: &quot;https://my.api.com/api/v1&quot;</span></span><br><span class="line"><span class="string">    username: &lt;user&gt;</span></span><br><span class="line"><span class="string">    password: &lt;password&gt; </span></span><br></pre></td></tr></table></figure><p>如果果某个主键同时出现在 <code>data</code> 和 <code>stringData</code> 字段中，<code>stringData</code> 所指定的键值具有高优先级。</p><h4 id="使用kustomize">使用Kustomize</h4><p>必须叫做kustomization.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">secretGenerator:</span><br><span class="line">- name: database-creds</span><br><span class="line">  literals:</span><br><span class="line">  - username=admin</span><br><span class="line">  - password=1f2d1e2e67df</span><br></pre></td></tr></table></figure><h3 id="使用">使用</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># name 必须与下面的卷名匹配</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/secret-volume</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Secret 数据通过一个卷暴露给该 Pod 中的容器</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">test-secret</span></span><br><span class="line">        <span class="comment"># items:  默认是拿到所有的键和值</span></span><br><span class="line">        <span class="comment"># - key: xxx</span></span><br><span class="line">        <span class="comment"># - path: xxx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="subpath">subpath</h2><p>使用 <code>subPath</code> 字段可以在共享同一卷的多个容器中选择不同的子路径来挂载，以实现对特定子路径的独立访问和修改。</p><h3 id="使用">使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-lamp-site</span><br><span class="line">spec:</span><br><span class="line">    containers:</span><br><span class="line">    - name: mysql</span><br><span class="line">      image: mysql</span><br><span class="line">      env:</span><br><span class="line">      - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">        value: &quot;rootpasswd&quot;</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - mountPath: /var/lib/mysql</span><br><span class="line">        name: site-data</span><br><span class="line">        subPath: mysql</span><br><span class="line">    - name: php</span><br><span class="line">      image: php:7.0-apache</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - mountPath: /var/www/html</span><br><span class="line">        name: site-data</span><br><span class="line">        subPath: html</span><br><span class="line">    volumes:</span><br><span class="line">    - name: site-data</span><br><span class="line">      persistentVolumeClaim:</span><br><span class="line">        claimName: my-lamp-site-data</span><br></pre></td></tr></table></figure><p>使用环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: container1</span><br><span class="line">    env:</span><br><span class="line">    - name: POD_NAME</span><br><span class="line">      valueFrom:</span><br><span class="line">        fieldRef:</span><br><span class="line">          apiVersion: v1</span><br><span class="line">          fieldPath: metadata.name</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    command: [ &quot;sh&quot;, &quot;-c&quot;, &quot;while [ true ]; do echo &#x27;Hello&#x27;; sleep 10; done | tee -a /logs/hello.txt&quot; ]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir1</span><br><span class="line">      mountPath: /logs</span><br><span class="line">      # 包裹变量名的是小括号，而不是大括号</span><br><span class="line">      subPathExpr: $(POD_NAME)</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">  volumes:</span><br><span class="line">  - name: workdir1</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /var/log/pods</span><br></pre></td></tr></table></figure><p>这样能够让容器只能访问卷中的一部分数据,做到安全隔离</p><ol><li><strong>文件或目录的隔离：</strong> 如果一个卷被多个容器共享，并且每个容器只需要访问卷中的特定文件或目录，那么可以使用<code>subPath</code>为每个容器指定不同的路径。这样，每个容器只能看到卷中的一部分内容，而不是整个卷。</li><li><strong>保护重要文件：</strong> 有时候，一个卷可能包含一些重要的文件或目录，我们不希望容器修改或删除它们。在这种情况下，我们可以使用<code>subPath</code>将卷中的非关键部分映射到容器，保护关键文件不被容器访问。</li><li><strong>多容器应用程序：</strong> 对于需要多个容器共同工作的应用程序（例如，一个容器写入数据，另一个容器读取和处理数据），可以使用<code>subPath</code>来确保每个容器都能访问到它需要的数据部分。</li></ol><h2 id="nfs安装">nfs安装</h2><p>安装nfs工具包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils  </span><br></pre></td></tr></table></figure><p>nfs服务器上执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">共享文件夹地址</span></span><br><span class="line">echo &quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot; &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl enable rpcbind --now</span><br><span class="line">systemctl enable nfs-server --now</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure><p>需要使用的服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showmount -e 192.168.100.3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line">mount -t nfs 192.168.100.3:/nfs/data /nfs/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入一个测试文件</span></span><br><span class="line">echo &quot;hello nfs server&quot; &gt; /nfs/data/test.txt</span><br></pre></td></tr></table></figure><h2 id="pv-和pvc">PV 和PVC</h2><p>在Kubernetes中，PersistentVolume (PV) 和 PersistentVolumeClaim (PVC) 是两种API资源，用于抽象存储细节并提供一个统一的管理模式。这样可以使用户和管理员与底层存储系统的实现细节解耦。</p><ol><li><p>PersistentVolume (PV)：PV是集群中的一部分存储，它已经由管理员提前配置好。这是集群中的资源，就像节点(Node)是集群的资源一样。PV是卷的插件，像volumes一样，但是具有独立于任何使用PV的特定Pod的生命周期。这个API对象用于存储和使用者的细节分离，比如NFS，Ceph，GlusterFS，AWS EBS，Azure Disk或GCE PD等。</p></li><li><p>PersistentVolumeClaim (PVC)：PVC则是用户存储的请求。它和Pod类似，Pod会消耗node资源，而PVC会消耗PV资源。PVC可以请求特定大小和访问模式的存储（如可以读写一次，或者可以读写多次）。</p></li></ol><p>简单的说，管理员创建了PV，用户创建PVC去使用PV。通过PVC可以挂载到Pod上，就像挂载磁盘一样。这个过程和真实世界中用户去申请存储空间的过程类似：系统管理员会配置可供用户使用的存储，然后用户根据需要去申请使用。PV和PVC的设计就是为了模拟这个过程，使得Kubernetes集群内部的存储管理变得更加通用和灵活。</p><p>这里使用nfs作为存储服务</p><p>创建pv</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nfs-pv0</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">200Mi</span>  <span class="comment"># 容量大小</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span>  <span class="comment"># 文件系统类型</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>  <span class="comment"># 访问模式 有 ReadWriteOnce、ReadOnlyMany、ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span>  <span class="comment"># 回收策略</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span>  <span class="comment"># 存储类型名字,在pvc中使用</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data</span> <span class="comment"># NFS 共享路径</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.3</span> <span class="comment"># NFS 服务器 IP 地址</span></span><br></pre></td></tr></table></figure><p>创建pvc</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">100Mi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;nfs&quot;</span>  <span class="comment"># 和 pv 中的 storageClassName 对应</span></span><br></pre></td></tr></table></figure><h2 id="storageclass">StorageClass</h2><p>StorageClass 是 Kubernetes 中的一个 API 对象，它用于描述管理员提供的一种 “类”。不同的 “类” 可能会映射到不同的服务质量等级，备份策略，或由群集管理员确定的其他策略。例如，一个集群可能有多个 StorageClass 对象，一个使用 SSD，另一个使用慢速磁盘。</p><p>当管理员创建了一个 StorageClass，用户就可以在他们的 PersistentVolumeClaim 中引用这个 StorageClass，<strong>以动态的方式申请 PersistentVolume</strong>。当创建 PersistentVolumeClaim 时，Kubernetes 的存储控制器将自动创建和配置相应的 PersistentVolume。</p><p><a href="https://blog.csdn.net/weixin_49343462/article/details/121831380">搭建链接</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: local-storage  # StorageClass 名称</span><br><span class="line">provisioner: nfs.csi.k8s.io  # Provisioner 名称</span><br><span class="line">parameters:</span><br><span class="line">  server: 192.168.100.3  # NFS 服务器 IP 地址</span><br><span class="line">  share: /nfs/data/  # NFS 共享路径</span><br><span class="line">reclaimPolicy: Delete  # 回收策略,貌似不起作用</span><br><span class="line">volumeBindingMode: WaitForFirstConsumer  # 绑定模式, WaitForFirstConsumer 表示等待第一个消费者的时候再绑定, Immediate 表示立即绑定</span><br><span class="line">mountOptions:</span><br><span class="line">  - vers=3</span><br><span class="line">  - noresvport</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://github.com/djmnb/blog/blob/master/%E4%BB%A3%E7%A0%81%E5%92%8C%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF/%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6/html/volume/storageclass-nfs-Test.yaml">配置文件地址</a></p><h1>补充</h1><h2 id="deployment和replaceset的区别">deployment和replaceset的区别</h2><p>Deployment 和 ReplicaSet 在 Kubernetes 中都用于管理 Pod 的生命周期，但他们之间有一些重要的区别：</p><ol><li><p><strong>更新策略</strong>：当你更改 Pod 模板时，<strong>Deployment 会自动更新所有由其管理的 Pod</strong>，这是通过滚动更新实现的。而当你更改 ReplicaSet 的 Pod 模板时，<strong>它不会更新现有的 Pod，只会影响将来创建的 Pod</strong>。</p></li><li><p><strong>版本控制</strong>：Deployment 在执行滚动更新时，会为每个新的 Pod 模板创建一个新的 ReplicaSet，并保留旧的 ReplicaSet，这样就可以轻松地回滚到之前的版本。而 ReplicaSet 不支持这种版本控制和回滚机制。</p></li><li><p><strong>用途</strong>：通常，你会直接使用 Deployment 来管理 Pod，因为它提供了更多的功能，如滚动更新和版本控制。而 ReplicaSet 通常由 Deployment 在幕后创建和管理，你不常直接使用 ReplicaSet。</p></li></ol><p>总的来说，Deployment 和 ReplicaSet 都可以确保一定数量的 Pod 正在运行，但 Deployment 提供了更多的功能，包括滚动更新和版本控制。而 ReplicaSet 更简单，主要在幕后由 Deployment 管理，也可以用于一些更简单的用途，例如保持一定数量的 Pod 在运行，不需要版本控制和滚动更新等功能。</p><h2 id="deployment-和-statefulset的区别">deployment 和 statefulset的区别</h2><p>容器卷确实能够提供持久化存储，但对于有状态应用，这通常是不够的。<strong>因为有状态应用的每个副本可能需要访问到它自己的数据，而 Deployment 并不保证一个 Pod 总是能访问到同一个卷</strong>。这是因为 Deployment 中的 Pod 没有<strong>稳定的网络标识</strong>，当一个 Pod 被删除并重新创建时，<strong>它的网络标识会改变，这就导致了它可能无法再访问到之前的数据</strong>。</p><p>而 StatefulSet 解决了这个问题。它为每个副本提供了稳定的网络标识和持久化存储，这样每个副本就能够一直访问到自己的数据，即使它被删除并重新创建。</p><h2 id="configmap-secret的热更新">configmap/secret的热更新</h2><p>如果pod是环境变量引入了其中的东西 或者是 挂在文件的时候使用了subpath项,那是无法热更新只有删除pod重新启动, 如果是挂载容器卷而且没有使用subpath的方式,那是可以更新的</p><h2 id="给端口命名">给端口命名</h2><p>在端口映射的时候,给pod里面的容器端口指定名字, 这样可以在后续使用,但是要注意这个命名不能超过15个字符,  这样我们如果修改了端口,就不用一个个去改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">     - name: http-port</span><br><span class="line">       containerPort: 80</span><br><span class="line">   livenessProbe:</span><br><span class="line">     httpGet:</span><br><span class="line">       path: /index.html</span><br><span class="line">       port: http-port</span><br><span class="line">     initialDelaySeconds: 15</span><br><span class="line">     periodSeconds: 20</span><br><span class="line">     failureThreshold: 4</span><br><span class="line">   readinessProbe:</span><br><span class="line">     httpGet:</span><br><span class="line">       path: /index.html</span><br><span class="line">       port: http-port</span><br><span class="line">     initialDelaySeconds: 5</span><br><span class="line">     periodSeconds: 10</span><br><span class="line">     failureThreshold: 2</span><br><span class="line">     timeoutSeconds: 1</span><br></pre></td></tr></table></figure><h2 id="无头service和service的区别">无头service和service的区别</h2><p>在 Kubernetes 中，Service 和 Headless Service 都可以为一组 Pod 提供一个网络访问的入口点，但在 DNS 的构成和解析上，它们有一些关键的区别。</p><p>对于一个常规的 Service（即非 Headless Service），Kubernetes 的 DNS 服务会为它分配一个对应的 DNS 名称，并将这个名称解析为 Service 的 Cluster IP。这样，当你访问这个 DNS 名称时，流量会被发送到 Service 的 Cluster IP，然后根据 Service 的负载均衡规则分发到后端的 Pod。Service 的 DNS 格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure><p>然而，对于一个 Headless Service（即 Service 的 <code>.spec.clusterIP</code> 被设置为 <code>None</code>），Kubernetes 的 DNS 服务会为这个 Service 的每一个后端 Pod 创建一个对应的 DNS 记录。每个 Pod 的 DNS 记录会解析为 Pod 的 IP。这样，当你访问这个 Service 的 DNS 名称时，你会得到所有后端 Pod 的 IP 列表。Headless Service 的 DNS 格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pod-name&gt;.&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure><p>Headless Service 的主要用途是为每个 Pod 提供一个唯一且稳定的网络标识，这对于一些需要集群感知或主从复制功能的应用，如数据库系统（MongoDB，Cassandra，MySQL等）非常有用。</p><h2 id="kube-proxy-和-网络插件">kube-proxy 和 网络插件</h2><p>kube-proxy 和 Kubernetes 网络插件实现的是两个不同的网络功能，它们都是 Kubernetes 网络模型的一部分，但各自负责不同的任务。</p><p>kube-proxy 负责在 Kubernetes 集群中<strong>实现服务发现和负载均衡</strong>。当你创建一个 Kubernetes Service 时，kube-proxy 会在每个节点上设置 iptables 规则或 IPVS 规则，将到达 Service IP 和端口的流量转发到 Service 后端的 Pod IP 和端口。这是实现 Service 抽象的关键部分。</p><p>然而，<strong>kube-proxy 并不负责 Pod 之间的网络通信，也不负责为 Pod 分配 IP 地址</strong>。这些任务是由 Kubernetes 网络插件来完成的。根据 Kubernetes 网络模型，每个 Pod 都应该有一个独一无二的 IP 地址，所有 Pod 应该能够直接通过 IP 地址互相通信，不需要 NAT。要实现这个模型，需要有一个网络插件来管理网络路由和 IP 地址分配。</p><p>所以，kube-proxy 和网络插件在 Kubernetes 网络中都有各自的角色和职责。虽然它们都参与到网络流量的转发中，但它们处理的上下文和目标是不同的。</p><h1>实战</h1><p>说明:  如果使用了动态创建pv的方式的话, 一定要记得自己创建好storageclass</p><h2 id="empty使用">empty使用</h2><p>使用configmap卷提供一段脚本,  一个容器执行这个脚本每隔一秒修改容器卷里面的index.html的数据, 另外一个nginx容器显示index.html</p><p><a href="https://github.com/djmnb/k8sResourceTest/blob/master/emptyTestPod.yaml">配置文件地址</a></p><h2 id="探针的使用">探针的使用</h2><p>对一个nginx使用了三个探针, 一个是存活探针,一个是就绪探针,一个是启动探针, 都是通过httpGet访问index.html页面, 看是不是返回200到300之前</p><p><a href="https://github.com/djmnb/k8sResourceTest/blob/master/pod/probeuserpod.yaml">配置文件地址</a></p><h2 id="蓝绿发布">蓝绿发布</h2><p>首先创建一个service, 两个deployment, 一个蓝版本,一个绿版本,   一开始先选择蓝版本, 然后修改标签再切换到绿版本</p><p><a href="https://github.com/djmnb/k8sResourceTest/blob/master/deployment/bluegreendeployment.yaml">配置文件地址</a></p><h2 id="主从数据库">主从数据库</h2><p><a href="https://www.jb51.net/article/271825.htm">参考链接</a></p><p>创建了一个configmap 写入了两个配置文件,  一个是开启主数据的log-bin  另外一个是开启从节点只读</p><p>使用了两个service:</p><ul><li>mysql 这个service是一个无头的service,  可以为pod提供一个dns解析,  这样我们就可以使用 域名的方式指定访问主数据库</li><li>mysql-read 这个service 是一个clusterip类型的service  可以做负载均衡,  读数据的时候访问这个service就行</li></ul><p>提供了两个初始化容器和两个主容器,他们的作用如下:</p><ul><li><code>init-mysql</code>初始化容器会根据Pod的序号（StatefulSet保证Pod的有序性）来生成MySQL的server-id，并且根据是否是主节点来选择使用master.cnf或slave.cnf。</li><li><code>clone-mysql</code>初始化容器会使用Xtrabackup工具，从序号小一位的Pod中复制数据。如果Pod是第一个（mysql-0），或者已经有数据了，就会跳过这一步。</li><li><code>mysql</code>主容器运行MySQL服务器，配置允许空密码，并且设置了就绪探针和活动探针。</li><li><code>xtrabackup</code>主容器使用Xtrabackup工具，提供数据备份的功能。如果是从节点，它还会尝试启动MySQL的复制功能。</li></ul><p><a href="https://github.com/djmnb/k8sResourceTest/blob/master/project/mysql-statefulset.yaml">资源文件地址</a></p><blockquote><p>这里要注意内存的分配量, 如果太多了,到时候会出现污点这些</p></blockquote><p>在主数据库里面创建一个数据库,看从数据库是否能够显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it mysql-0 -- bash</span><br><span class="line">mysql -uroot</span><br><span class="line">create database mydata;</span><br><span class="line"># 退出数据库,退出容器后</span><br><span class="line"></span><br><span class="line"># 查看从数据库</span><br><span class="line">kubectl exec -it mysql-1 -- mysql</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">kubectl exec -it mysql-2 -- mysql</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><p><img src="/2023/06/05/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s%E6%80%BB%E7%BB%93/../img/testassets/image-20230601110106864.png" alt="image-20230601110106864"></p><p>操作没问题</p><h2 id="部署一个springboot项目">部署一个springboot项目</h2><p>就用了一个简单的springboot项目,  读取mysql数据库里面的数据展示到前端页面,  使用初始化容器将项目jar包下载到pod里面,   使用就绪探针检测服务是否启动起来了,  使用存活探针检测容器是否正常工作,  使用configmap存放一些普通环境变量,  用secret存放mysql密码</p><p><a href="https://github.com/djmnb/k8sResourceTest/blob/master/project/springboot-project.yaml">配置文件地址</a></p><h1>错误</h1><h2 id="crashloopbackoff">CrashLoopBackOff</h2><p>“CrashLoopBackOff” 表示在 Kubernetes 中，Pod 在一段时间内<strong>重启次数过多</strong>，到达一定限制后就会进入这个状态，进入这个状态的 Pod 将会被<strong>暂时禁止启动</strong>。这种情况下，Kubelet 会使用指数型的退避策略（例如，5s、10s、20s、40s…），在每次失败重启后的一段时间再次尝试重启容器，从而避免过多消耗资源。</p><h2 id="镜像错误">镜像错误</h2><p>在 Kubernetes 中，<code>ErrImagePull</code> 和 <code>ImagePullBackOff</code> 两种错误状态都是与镜像拉取相关的。</p><ul><li><p><strong>ErrImagePull</strong>：这是一个状态，表示 Kubernetes 尝试拉取 Docker 镜像，但发生了错误。这可能是因为各种原因，如无法找到镜像、无法连接到 Docker registry、没有正确的凭证来访问私有的 Docker registry 等。</p></li><li><p><strong>ImagePullBackOff</strong>：这个状态表示 Kubernetes 尝试拉取镜像但失败了，并且现在正在退避，也就是说，它在一段时间内不会再尝试拉取这个镜像。这通常发生在连续多次尝试拉取镜像失败之后。这是 Kubernetes 的一个保护机制，防止由于频繁的失败尝试而耗尽资源。</p></li></ul><p>总的来说，<code>ErrImagePull</code> 是 Kubernetes 在尝试拉取镜像时遇到错误的立即反应，而 <code>ImagePullBackOff</code> 是在多次尝试失败之后的一种退避机制。这两种状态都表示镜像拉取失败，但 <code>ImagePullBackOff</code> 表示 Kubernetes 正在暂停一段时间，不再尝试拉取这个镜像。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令汇总</title>
      <link href="/2023/05/31/linux/linux%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2023/05/31/linux/linux%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tomcat的安装</title>
      <link href="/2023/05/19/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Tomcat/"/>
      <url>/2023/05/19/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Tomcat/</url>
      
        <content type="html"><![CDATA[<h1>下载Tomcat</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境搭建合集</title>
      <link href="/2023/05/19/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%90%88%E9%9B%86/"/>
      <url>/2023/05/19/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>这里总结了环境搭建,以及一些注意点和配置</p><h1>Tomcat</h1><h2 id="安装">安装</h2><p>windows</p><p>去<a href="https://tomcat.apache.org/">官网</a>下载压缩包解压就行 我这里用的<a href="https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.75/bin/apache-tomcat-9.0.75-windows-x64.zip">Tomcat9</a></p><p>linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/tomcat</span><br><span class="line">cd /usr/local/tomcat</span><br><span class="line">wget -c https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.75/bin/apache-tomcat-9.0.75.tar.gz  # 下载</span><br><span class="line">tar -zxvf apache-tomcat-9.0.75.tar.gz </span><br></pre></td></tr></table></figure><h2 id="目录解释">目录解释</h2><p>Tomcat 的安装目录结构中包含一些关键的子目录，每个目录都有特定的目的和用途：</p><ol><li><p><strong>bin</strong>：这个目录包含了用来启动和停止 Tomcat 服务的脚本文件。例如，在 Linux 系统上，你可以使用 <code>./startup.sh</code> 和 <code>./shutdown.sh</code> 来启动和停止服务。</p></li><li><p><strong>conf</strong>：这个目录包含了 Tomcat 服务的所有配置文件，例如 <code>server.xml</code>、<code>context.xml</code>、<code>tomcat-users.xml</code> 等。这些文件允许你定制 Tomcat 的行为，例如修改默认端口、配置虚拟主机等。</p></li><li><p><strong>lib</strong>：这个目录包含了 Tomcat 服务运行所需的所有 Java 库。这包括 Tomcat 的核心库，以及用于处理 JSP、servlet 等的库。如果你需要添加全局可用的库，可以将它们放在这个目录下。</p></li><li><p><strong>logs</strong>：这个目录包含了 Tomcat 服务的所有日志文件。你可以通过查看这些文件来了解 Tomcat 在运行过程中是否出现了任何问题。</p></li><li><p><strong>webapps</strong>：这个目录是 Tomcat 默认的 web 应用部署目录。你可以将你的 <code>.war</code> 文件或解压后的 web 应用目录放在这里，Tomcat 就会自动加载和运行它们。</p></li><li><p><strong>temp</strong>：这个目录被 Tomcat 用作临时文件的存放位置。在处理大型上传文件或编译 JSP 文件时，Tomcat 会在这个目录中创建临时文件。</p></li><li><p><strong>work</strong>：这个目录是 Tomcat 用来存放 JSP 文件编译后生成的 servlet 类的地方。这个目录的内容通常不需要手动管理，Tomcat 会自动处理。</p></li></ol><p>以上就是 Tomcat 安装目录下各个主要子目录的作用</p><h2 id="配置">配置</h2><p>Tomcat 的 <code>conf</code> 目录包含了多个配置文件，用于定制 Tomcat 的行为。以下是 <code>conf</code> 目录中主要的配置文件：</p><ol><li><p><strong>server.xml</strong>：这是 Tomcat 的主配置文件，定义了 Tomcat 服务的一般行为，包括监听的端口、安装的 web 应用、虚拟主机等。</p></li><li><p><strong>web.xml</strong>：这是全局的 Servlet 配置文件，提供了所有 web 应用的默认设置。这个文件中的设置可以被部署的 web 应用的 <code>WEB-INF/web.xml</code> 文件中的设置覆盖。</p></li><li><p><strong>context.xml</strong>：这个文件定义了 Tomcat 服务器中所有 web 应用的上下文（Context）设置。这个文件中的设置可以被部署的 web 应用的 <code>META-INF/context.xml</code> 文件中的设置覆盖。</p></li><li><p><strong>tomcat-users.xml</strong>：这个文件用于配置 Tomcat 的用户和角色，以便于进行基于角色的访问控制。</p></li><li><p><strong>catalina.properties</strong>：这个文件定义了一些系统属性，例如类加载器的配置、Tomcat 内部使用的一些目录等。</p></li><li><p><strong>logging.properties</strong>：这个文件定义了 Tomcat 的日志行为，例如日志级别、日志输出格式、日志文件的位置等。</p></li></ol><p>每个文件都有其特定的用途和格式，修改这些文件可以让你定制 Tomcat 的行为以满足你的需求。在修改这些文件时，需要遵循相应的 XML 或 properties 文件格式，否则可能导致 Tomcat 启动失败。在修改前，建议备份原始文件，以便于出现问题时能够迅速恢复。</p><h3 id="server-xml">server.xml</h3><p>Tomcat的<code>server.xml</code>文件是服务器的主配置文件，包含了与Tomcat服务器实例的行为有关的所有配置。以下是<code>server.xml</code>文件中一些主要的配置元素：</p><ol><li><p><strong>Server</strong>：这个元素代表着Tomcat实例本身，它是配置文件中最顶层的元素。其中的属性包括：</p><ul><li><code>port</code>：用于监听关闭命令的端口，默认值是8005。</li><li><code>shutdown</code>：用于关闭Tomcat的字符串命令，默认值是&quot;SHUTDOWN&quot;。</li></ul></li><li><p><strong>Service</strong>：这个元素包含了一个或多个Connector元素和一个Engine元素。它代表着能够接收请求并返回响应的Tomcat服务。</p></li><li><p><strong>Connector</strong>：这个元素代表着一个具体的连接器，用于处理特定协议的请求。例如，一个处理HTTP请求的连接器，一个处理AJP请求的连接器等。它的一些主要属性包括：</p><ul><li><code>port</code>：连接器监听请求的端口。</li><li><code>protocol</code>：连接器使用的协议，例如HTTP/1.1或AJP/1.3。</li><li><code>connectionTimeout</code>：连接超时时间，单位是毫秒。</li><li><code>redirectPort</code>：如果客户端请求一个需要HTTPS的页面，但是请求是使用HTTP协议发出的，那么请求将被重定向到这个端口。</li></ul></li><li><p><strong>Engine</strong>：这个元素代表了处理请求的引擎。每个Service元素都需要有一个Engine元素。其中的一些属性包括：</p><ul><li><code>name</code>：引擎的名字。</li><li><code>defaultHost</code>：如果请求的主机名没有匹配到任何Host元素，那么将使用这个属性指定的Host来处理请求。</li></ul></li><li><p><strong>Host</strong>：这个元素代表了一个虚拟主机。在一个Engine元素中可以有多个Host元素，每个Host元素都有自己的appBase属性，用于指定部署web应用的目录。其中的一些属性包括：</p><ul><li><code>name</code>：虚拟主机的名字，通常是一个完全限定的域名。</li><li><code>appBase</code>：部署web应用的目录。如果路径是相对路径，那么它是相对于<code>catalina.base</code>系统属性指定的目录。</li></ul></li><li><p><strong>Context</strong>：这个元素代表了一个web应用。它可以在Host元素中定义，也可以在单独的XML文件中定义。其中的一些属性包括：</p><ul><li><code>path</code>：web应用的访问路径。</li><li><code>docBase</code>：web应用的目录或war文件位置。如果路径是相对路径，那么它是相对于appBase指定的目录。</li></ul></li></ol><p>这些就是<code>server.xml</code>中的一些主要配置元素。</p><p>如果需要一个服务器有多个Tomcat,一定要修改几个地方, <strong>一个是 监听命令的端口, 一定不能冲突, 还有就是连接监听端口, 如果配置了HTTPS的话,一定还要修改被重定向端口和HTTPS处理端口</strong></p><h3 id="日志文件">日志文件</h3><p><code>logs</code> 目录通常包含以下的日志文件：</p><ol><li><strong>catalina.out</strong>: 这个文件记录了 Tomcat 的标准输出和标准错误信息。包含了所有写入到 <code>System.out</code> 和 <code>System.err</code> 的内容。通常包含有关 Tomcat 启动、运行和关闭过程中的信息。</li><li><strong>catalina.[date].log</strong>: 这个文件包含了 Catalina 容器的日志信息，包括启动和关闭的信息，以及运行过程中的错误和警告信息。</li><li><strong>localhost.[date].log</strong>: 这个文件包含了名为 “localhost” 的虚拟主机的日志信息，主要包含对应的 web 应用的错误和警告信息。</li><li><strong>manager.[date].log</strong> 和 <strong>host-manager.[date].log</strong>: 这两个文件分别包含了 “manager” 应用和 “host-manager” 应用的日志信息，主要包含应用运行过程中的错误和警告信息。</li><li><strong>localhost_access_log.[date].txt</strong>: 这个文件是 HTTP 访问日志，记录了所有到 “localhost” 虚拟主机的 HTTP 请求。包含请求的时间、源 IP 地址、请求的 HTTP 方法、请求的 URL、HTTP 版本、响应的状态码、响应的字节数和请求处理的耗时等信息。</li></ol><p>这些日志文件可以提供有关 Tomcat 运行状态和运行中出现的问题的重要信息，对于故障排查和系统监控都非常有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows常用命令</title>
      <link href="/2023/05/16/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/05/16/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>有时候需要用到windows命令,每次都要谷歌查一下,下一次还要继续查, 又不能保证每次都能查到,我索性总结一下</p><h1>查看信息命令</h1><h2 id="查看端口是否被占用">查看端口是否被占用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr port(端口)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springMVC 源码</title>
      <link href="/2023/05/08/java/springMVC%E6%BA%90%E7%A0%81/"/>
      <url>/2023/05/08/java/springMVC%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>maven + Tomcat + spring + springMVC 纯注解搭建web环境</h1><p>创建maven项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring MVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Servlet API --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JSP API --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InternalResourceViewResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternalResourceViewResolver</span>();</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/views/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建初始化类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.example.config.WebConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRegistration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebAppInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        applicationContext.register(AppConfig.class, WebConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(applicationContext);</span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addServlet(<span class="string">&quot;dispatcher&quot;</span>, dispatcherServlet);</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>EnableWebMVC的作用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line">public @interface EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到,他就导入了一个配置类,这个配置类干的事情可不少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.servlet.config.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.format.FormatterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.MessageCodesResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodReturnValueHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WebMvcConfigurerComposite</span> <span class="variable">configurers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurerComposite</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DelegatingWebMvcConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(</span></span><br><span class="line"><span class="meta">        required = false</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.configurePathMatch(configurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.configureContentNegotiation(configurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.configureAsyncSupport(configurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.configureDefaultServletHandling(configurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.addFormatters(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.addResourceHandlers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.addCorsMappings(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.addViewControllers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.configureViewResolvers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.addArgumentResolvers(argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.addReturnValueHandlers(returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.configureMessageConverters(converters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.extendMessageConverters(converters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.configureHandlerExceptionResolvers(exceptionResolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configurers.extendHandlerExceptionResolvers(exceptionResolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Validator <span class="title function_">getValidator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.configurers.getValidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> MessageCodesResolver <span class="title function_">getMessageCodesResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.configurers.getMessageCodesResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>我们会发现这里面貌似也没注入bean到容器中去啊,当然,它是没有注入,但是他的父类WebMvcConfigurationSupport可是注入了不少</strong></p><p><code>WebMvcConfigurationSupport</code> 类是 Spring MVC 的核心配置类，它负责向容器中注册默认的 Spring MVC 相关组件。下面列出了 <code>WebMvcConfigurationSupport</code> 类中注入的主要 Bean 及其作用：</p><ol><li><p><strong>RequestMappingHandlerMapping</strong>：处理 HTTP 请求与处理器（Controller）方法之间的映射关系。它是 Spring MVC 中最重要的 HandlerMapping 实现之一。</p></li><li><p><strong>HandlerMethodArgumentResolverComposite</strong>：负责解析处理器方法的参数。它包含许多默认的 <code>HandlerMethodArgumentResolver</code> 实现，例如：<code>RequestParamMethodArgumentResolver</code>、<code>ModelAttributeMethodArgumentResolver</code> 和 <code>RequestBodyAdviceAdapter</code> 等。</p></li><li><p><strong>HandlerMethodReturnValueHandlerComposite</strong>：负责处理处理器方法的返回值。它包含许多默认的 <code>HandlerMethodReturnValueHandler</code> 实现，例如：<code>ModelAndViewMethodReturnValueHandler</code>、<code>HttpEntityMethodProcessor</code> 和 <code>ResponseBodyAdviceAdapter</code> 等。</p></li><li><p><strong>RequestMappingHandlerAdapter</strong>：负责处理执行处理器方法的适配器。它使用 <code>HandlerMethodArgumentResolverComposite</code> 解析参数，并使用 <code>HandlerMethodReturnValueHandlerComposite</code> 处理返回值。</p></li><li><p><strong>ExceptionHandlerExceptionResolver</strong>：处理来自处理器方法的异常。它使用 <code>@ExceptionHandler</code> 标注的方法来处理异常。</p></li><li><p><strong>ContentNegotiationManager</strong>：负责协商内容类型（Content-Type），用于确定客户端请求的响应类型。它使用多种策略（例如：URL 扩展名、HTTP Accept 头、默认内容类型等）来确定合适的内容类型。</p></li><li><p><strong>FormattingConversionService</strong>：提供数据类型转换和格式化服务。它包含许多内置的类型转换器和格式化器，例如：日期、数字、枚举等。</p></li><li><p><strong>Validator</strong>：用于验证数据模型对象。默认实现是 Hibernate Validator，它使用 JSR-303/JSR-380 Bean Validation 规范。</p></li><li><p><strong>HttpMessageConverter</strong>：负责将请求体和响应体转换为特定的 Java 类型和反之。默认情况下，Spring MVC 提供了许多内置的消息转换器，例如：<code>StringHttpMessageConverter</code>、<code>MappingJackson2HttpMessageConverter</code> 和 <code>ByteArrayHttpMessageConverter</code> 等。</p></li></ol><p>这些 Bean 只是 <code>WebMvcConfigurationSupport</code> 类中的一部分，默认情况下还会注册许多其他组件，例如：资源处理器、视图解析器、拦截器、跨域配置等。这些组件共同构成了 Spring MVC 框架的核心功能，使得开发者可以方便地构建 Web 应用程序。</p><p>通过上面两个类我们可以发现, <strong>如果我们能够接管WebMvcConfigurationSupport, 我们就能够全面地接管springMVC</strong>, 但是吧,这样也不建议做**,但是我们可以通过向容器中注入WebMvcConfigurer类型的bean进行充, 注意这个玩意是可以叠加的,而不是冲突**</p><h1>容器启动</h1><p>这里的容器启动流程跟AnnotationConfigApplicationContext的启动流程是一样的,只不过springMVC的容器里面做了一些其他的事,这里我们就只去了解不同的地方</p><p>看一下refresh吧,流程一样,只不过有些地方实现不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.prepareRefresh();</span><br><span class="line">            <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainFreshBeanFactory();</span><br><span class="line">            <span class="built_in">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里是唯一跟AnnotationConfigApplicationContext不同的地方,里面进行了一些操作</span></span><br><span class="line">                <span class="built_in">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">                <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                <span class="built_in">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">                beanPostProcess.end();</span><br><span class="line">                <span class="built_in">this</span>.initMessageSource();</span><br><span class="line">                <span class="built_in">this</span>.initApplicationEventMulticaster();</span><br><span class="line">                <span class="built_in">this</span>.onRefresh();</span><br><span class="line">                <span class="built_in">this</span>.registerListeners();</span><br><span class="line">                <span class="built_in">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                <span class="built_in">this</span>.finishRefresh();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var10) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var10);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.destroyBeans();</span><br><span class="line">                <span class="built_in">this</span>.cancelRefresh(var10);</span><br><span class="line">                <span class="keyword">throw</span> var10;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.resetCommonCaches();</span><br><span class="line">                contextRefresh.end();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="this-postprocessbeanfactory-beanfactory">this.postProcessBeanFactory(beanFactory);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 向 BeanFactory 添加一个 ServletContextAwareProcessor 类型的 BeanPostProcessor，</span></span><br><span class="line">    <span class="comment">// 用于处理实现了 ServletContextAware 和 ServletConfigAware 接口的 Bean</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ServletContextAwareProcessor</span>(<span class="built_in">this</span>.servletContext, <span class="built_in">this</span>.servletConfig));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 BeanFactory 忽略 ServletContextAware 接口的依赖，由 ServletContextAwareProcessor 进行处理</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 BeanFactory 忽略 ServletConfigAware 接口的依赖，由 ServletContextAwareProcessor 进行处理</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册 Web 应用的作用域（如 request、session 等）</span></span><br><span class="line">    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="built_in">this</span>.servletContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册 Web 环境相关的 Bean，如 ServletContext、ServletConfig 等,会注入几个单实例bean</span></span><br><span class="line">    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="built_in">this</span>.servletContext, <span class="built_in">this</span>.servletConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法的主要作用是对 BeanFactory 进行后置处理，以支持 Web 应用程序上下文的特性。具体包括：</p><ol><li>添加一个处理 <code>ServletContextAware</code> 和 <code>ServletConfigAware</code> 的 BeanPostProcessor。</li><li>让 BeanFactory 忽略 <code>ServletContextAware</code> 和 <code>ServletConfigAware</code> 接口的依赖。</li><li>向 BeanFactory 注册 Web 应用的作用域。</li><li>向 BeanFactory 注册 Web 环境相关的 Bean。</li></ol><p><img src="/2023/05/08/java/springMVC%E6%BA%90%E7%A0%81/../img/springMVC%E6%BA%90%E7%A0%81assets/image-20230509144318016.png" alt="image-20230509144318016"></p><p>后四个单实例bean是增加进去的</p><h2 id="webapplicationcontextutils-registerwebapplicationscopes-beanfactory-this-servletcontext">WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);</h2><p>这段代码位于 <code>WebApplicationContextUtils</code> 类中的 <code>registerWebApplicationScopes()</code> 方法。以下是带有代码注释的版本，解释了每一行代码的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerWebApplicationScopes</span><span class="params">(ConfigurableListableBeanFactory beanFactory, <span class="meta">@Nullable</span> ServletContext sc)</span> &#123;</span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册请求作用域（request scope）</span></span><br><span class="line">    beanFactory.registerScope(<span class="string">&quot;request&quot;</span>, <span class="keyword">new</span> <span class="title class_">RequestScope</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册会话作用域（session scope）</span></span><br><span class="line">    beanFactory.registerScope(<span class="string">&quot;session&quot;</span>, <span class="keyword">new</span> <span class="title class_">SessionScope</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 向 BeanFactory 注册应用程序作用域（application scope）</span></span><br><span class="line">        <span class="type">ServletContextScope</span> <span class="variable">appScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextScope</span>(sc);</span><br><span class="line">        beanFactory.registerScope(<span class="string">&quot;application&quot;</span>, appScope);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 ServletContextScope 存储在 ServletContext 的属性中</span></span><br><span class="line">        sc.setAttribute(ServletContextScope.class.getName(), appScope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册 ServletRequest 的依赖解析</span></span><br><span class="line">    beanFactory.registerResolvableDependency(ServletRequest.class, <span class="keyword">new</span> <span class="title class_">WebApplicationContextUtils</span>.RequestObjectFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册 ServletResponse 的依赖解析</span></span><br><span class="line">    beanFactory.registerResolvableDependency(ServletResponse.class, <span class="keyword">new</span> <span class="title class_">WebApplicationContextUtils</span>.ResponseObjectFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册 HttpSession 的依赖解析</span></span><br><span class="line">    beanFactory.registerResolvableDependency(HttpSession.class, <span class="keyword">new</span> <span class="title class_">WebApplicationContextUtils</span>.SessionObjectFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 BeanFactory 注册 WebRequest 的依赖解析</span></span><br><span class="line">    beanFactory.registerResolvableDependency(WebRequest.class, <span class="keyword">new</span> <span class="title class_">WebApplicationContextUtils</span>.WebRequestObjectFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 JSF 存在，则向 BeanFactory 注册 JSF 相关依赖</span></span><br><span class="line">    <span class="keyword">if</span> (jsfPresent) &#123;</span><br><span class="line">        WebApplicationContextUtils.FacesDependencyRegistrar.registerFacesDependencies(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要作用是向 BeanFactory 注册 Web 应用程序中的作用域和依赖解析。具体包括：</p><ol><li>注册请求、会话和应用程序作用域。</li><li>注册 <code>ServletRequest</code>、<code>ServletResponse</code>、<code>HttpSession</code> 和 <code>WebRequest</code> 的依赖解析。</li><li>如果 JSF 存在，注册 JSF 相关的依赖。</li></ol><h1>方法分析</h1><h2 id="1-protected-final-void-processrequest-httpservletrequest-request-httpservletresponse-response">1. protected final void processRequest(HttpServletRequest request, HttpServletResponse response)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 记录请求处理开始的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个 Throwable 类型的变量，用于存储处理请求过程中的异常信息</span></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的 LocaleContext，稍后用于在请求处理完毕后恢复原始的 LocaleContext</span></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前请求构建一个新的 LocaleContext</span></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> <span class="built_in">this</span>.buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的 RequestAttributes，稍后用于在请求处理完毕后恢复原始的 RequestAttributes</span></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前请求和响应构建一个新的 ServletRequestAttributes</span></span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> <span class="built_in">this</span>.buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前请求的 WebAsyncManager，它负责管理异步请求的执行</span></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为当前请求的 WebAsyncManager 注册一个名为 FrameworkServlet.RequestBindingInterceptor 的拦截器</span></span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">FrameworkServlet</span>.RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化请求处理所需的上下文环境（LocaleContext 和 RequestAttributes）</span></span><br><span class="line">    <span class="built_in">this</span>.initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求并生成响应</span></span><br><span class="line">        <span class="built_in">this</span>.doService(request, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ServletException var16) &#123;</span><br><span class="line">        <span class="comment">// 捕获 IOException 和 ServletException 异常</span></span><br><span class="line">        failureCause = var16;</span><br><span class="line">        <span class="keyword">throw</span> var16;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">        <span class="comment">// 捕获其他类型的异常</span></span><br><span class="line">        failureCause = var17;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, var17);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 重置上下文环境（恢复原始的 LocaleContext 和 RequestAttributes）</span></span><br><span class="line">        <span class="built_in">this</span>.resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 requestAttributes 不为 null，则通知请求已完成</span></span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录请求处理结果</span></span><br><span class="line">        <span class="built_in">this</span>.logResult(request, response, (Throwable)failureCause, asyncManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布请求处理完毕的事件</span></span><br><span class="line">        <span class="built_in">this</span>.publishRequestHandledEvent(request, response, startTime, (Throwable)failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-this-doservice-request-response">2. this.doService(request, response);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 记录请求信息（例如：请求 URI、请求方法等）</span></span><br><span class="line">    <span class="built_in">this</span>.logRequest(request);</span><br><span class="line">    <span class="comment">// 定义一个属性快照，用于存储请求中的属性</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 检查请求是否是 include 请求</span></span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Enumeration</span> <span class="variable">attrNames</span> <span class="operator">=</span> request.getAttributeNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            String attrName;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有更多的属性，则跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (!attrNames.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                attrName = (String) attrNames.nextElement();</span><br><span class="line">            &#125; <span class="keyword">while</span> (!<span class="built_in">this</span>.cleanupAfterInclude &amp;&amp; !attrName.startsWith(<span class="string">&quot;org.springframework.web.servlet&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将属性添加到属性快照中</span></span><br><span class="line">            attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 WebApplicationContext、LocaleResolver、ThemeResolver 和 ThemeSource 设置为请求属性</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="built_in">this</span>.getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="built_in">this</span>.getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 FlashMapManager 不为空，则处理 FlashMap 相关逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从请求中检索并更新 FlashMap</span></span><br><span class="line">        <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将输入的 FlashMap 设置为请求属性</span></span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置输出 FlashMap 和 FlashMapManager 为请求属性</span></span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存之前的 RequestPath（如果 parseRequestPath 为 true）</span></span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">previousRequestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;</span><br><span class="line">        previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);</span><br><span class="line">        ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 doDispatch() 方法处理请求</span></span><br><span class="line">        <span class="built_in">this</span>.doDispatch(request, response);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果异步处理未开始，并且属性快照不为空，则恢复 include 请求后的属性</span></span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 parseRequestPath 为 true，则将 RequestPath 设置回之前的值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;</span><br><span class="line">            ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="this-dodispatch-request-response">this.doDispatch(request, response);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 定义处理过的请求和映射处理器</span></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 检查请求是否为多部分请求，如果是，则处理请求</span></span><br><span class="line">                processedRequest = <span class="built_in">this</span>.checkMultipart(request);</span><br><span class="line">                multipartRequestParsed = processedRequest != request;</span><br><span class="line">                <span class="comment">// 获取处理请求的映射处理器</span></span><br><span class="line">                mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有找到处理器，则返回 404</span></span><br><span class="line">                    <span class="built_in">this</span>.noHandlerFound(processedRequest, response); <span class="comment">// 这里直接返回的话,就轮不到我们来操作了,如果想要数据返回格式统一,我们还得做点事情,比如</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取处理器适配器</span></span><br><span class="line">                <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">                <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                    <span class="comment">// 获取资源的最后修改时间，并检查请求是否需要处理</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用拦截器前置处理方法</span></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理请求并获取 ModelAndView</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 应用默认视图名称（如果需要）</span></span><br><span class="line">                <span class="built_in">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                <span class="comment">// 调用拦截器后置处理方法</span></span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                dispatchException = var20;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, var21);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理请求分发结果,如果我们的mv是没有视图的话,数据早就已经被写会个客户端了, 这里还会统一处理异常</span></span><br><span class="line">            <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception) dispatchException);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            <span class="comment">// 触发完成处理方法</span></span><br><span class="line">            <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">            <span class="comment">// 触发完成处理方法</span></span><br><span class="line">            <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, var23));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果异步处理已开始，则应用异步处理完成方法</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            <span class="comment">// 如果请求是多部分请求，则进行清理</span></span><br><span class="line">            <span class="built_in">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我么可以看一下没有请求处理器的时候走的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">noHandlerFound</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (pageNotFoundLogger.isWarnEnabled()) &#123;</span><br><span class="line">           pageNotFoundLogger.warn(<span class="string">&quot;No mapping for &quot;</span> + request.getMethod() + <span class="string">&quot; &quot;</span> + getRequestUri(request));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.throwExceptionIfNoHandlerFound) &#123;  <span class="comment">// 如果允许抛出异常的话,就会抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoHandlerFoundException</span>(request.getMethod(), getRequestUri(request), (<span class="keyword">new</span> <span class="title class_">ServletServerHttpRequest</span>(request)).getHeaders());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           response.sendError(<span class="number">404</span>);  <span class="comment">// 如果不允许的话,就不会抛出</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关于视图解析器,参数解析器,返回值处理器这些,我就只去过了一遍源码,没有详细总结了</p><h1>跨域请求配置</h1><p>在Spring MVC中设置CORS全局配置和处理器CORS配置的方法如下：</p><ol><li><strong>全局CORS配置</strong>：要设置全局CORS配置，您需要在Spring MVC配置类中重写<code>addCorsMappings</code>方法并使用<code>CorsRegistry</code>对象进行配置。这里有一个例子：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;header2&quot;</span>, <span class="string">&quot;header3&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;header2&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置允许来自<code>http://example.com</code>的跨域请求访问所有URL（<code>/**</code>），并限制了允许的HTTP方法、请求头、响应头和凭证支持。</p><ol start="2"><li><strong>处理器CORS配置</strong>：要为特定处理器设置CORS配置，您可以使用<code>@CrossOrigin</code>注解。将此注解添加到控制器类或处理器方法上，以指定CORS策略。下面是一个例子：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="meta">@CrossOrigin(origins = &quot;http://example.com&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>getData</code>方法允许来自<code>http://example.com</code>的跨域请求。<code>@CrossOrigin</code>注解也可以接受其他参数，如<code>methods</code>, <code>allowedHeaders</code>, <code>exposedHeaders</code>, <code>allowCredentials</code>, 和 <code>maxAge</code>。</p><p>注意：如果同时设置了全局CORS配置和处理器CORS配置，处理器CORS配置将优先于全局CORS配置。</p><p>通过使用<code>CorsRegistry</code>和<code>@CrossOrigin</code>注解，您可以轻松地在Spring MVC中配置CORS策略，并根据需要为整个应用程序或特定处理器设置CORS设置。</p><h1>拦截器</h1><p>在 Spring MVC 中，<code>HandlerInterceptor</code> 接口定义了三个方法，用于在请求处理的不同阶段执行自定义操作。这些方法分别是：</p><ol><li><p><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code>：在处理器（即 Controller 方法）执行之前调用。如果该方法返回 <code>true</code>，则请求继续向下执行；如果返回 <code>false</code>，则请求处理停止，不会调用后续的拦截器和处理器。这个方法通常用于权限控制、身份验证和请求参数校验等。</p></li><li><p><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code>：在处理器执行之后、视图渲染之前调用。这个方法可以用来修改数据模型、处理异常等。注意，如果 <code>preHandle</code> 返回 <code>false</code>，则不会调用 <code>postHandle</code>。</p></li><li><p><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code>：在请求处理完成后调用，即在视图渲染之后。这个方法通常用于清理资源、记录日志、监控性能等。即使在请求处理过程中发生异常，这个方法也会被调用。注意，如果 <code>preHandle</code> 返回 <code>false</code>，则不会调用 <code>afterCompletion</code>。</p></li></ol><p>实现 <code>HandlerInterceptor</code> 接口时，你可以根据需要重写这些方法以实现自定义的请求拦截和处理逻辑。在实际应用中，你通常会继承 <code>HandlerInterceptorAdapter</code> 类，它提供了默认的空实现，这样你只需要重写需要的方法即可。</p><h1>大概流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">processRequest()&#123;</span><br><span class="line">doService()&#123;</span><br><span class="line">doDispatch()&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 通过请求处理映射器拿到请求处理器</span></span><br><span class="line">mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">                 <span class="comment">// 如果没有拿到的话就抛出一个异常</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 拿到适配器,适配器能够帮助我们统一处理不同的handler</span></span><br><span class="line">                 <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 执行拦截器第一部分,preHandler </span></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// 执行handler,得到视图模型</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果没有出异常的话,就会执行拦截器的第二步</span></span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 到这里就请求响应完了</span></span><br><span class="line">                </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception var20)&#123;</span><br><span class="line">                <span class="comment">//出现了异常,把异常存下来</span></span><br><span class="line">                dispatchException = var20;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">// 这里就是统一处理异常的地方,比如使用了controlleradvice这些,同时如果视图不为空,也会渲染视图,但是如果视图为空的话,数据早就已经写到response里面了</span></span><br><span class="line">            <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果统一处理异常也出现异常,也会被捕获,最终一定会执行这个方法,拦截器的最后一步,然后将这个异常往上面抛出去</span></span><br><span class="line">            <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring源码</title>
      <link href="/2023/05/07/java/spring%E6%BA%90%E7%A0%81/"/>
      <url>/2023/05/07/java/spring%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>ApplicationStartup</h1><p><code>ApplicationStartup</code> 接口是 Spring 框架提供的一个扩展点，允许开发者在 Spring 应用启动期间收集性能指标和监控数据。通过实现这个接口，你可以自定义收集和处理这些数据的方式，以便更好地理解和优化你的应用程序。</p><p>从 Spring Boot 2.4.0 和 Spring Framework 5.3.0 开始，<code>ApplicationStartup</code> 接口被引入。它允许开发者为 Spring 应用提供自定义的启动跟踪策略</p><p>我们可以自定义这个东西,然后检测整个过程干了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AnnotationConfigApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBeanFactory</span><span class="params">(Class&lt;?&gt;... componentClasses)</span>&#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (DefaultListableBeanFactory) <span class="built_in">this</span>.getBeanFactory();</span><br><span class="line">        beanFactory.setApplicationStartup(MyApplicationStartup.DEFAULT);</span><br><span class="line">        <span class="built_in">this</span>.register(componentClasses);</span><br><span class="line">        <span class="built_in">this</span>.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// super(componentClasses);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyApplicationStartup</span> <span class="keyword">implements</span> <span class="title class_">ApplicationStartup</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyStartupStep</span> <span class="keyword">implements</span> <span class="title class_">StartupStep</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span> <span class="type">MyStartupStep</span> <span class="variable">DEFAULE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStartupStep</span>();</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Long <span class="title function_">getParentId</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> StartupStep <span class="title function_">tag</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">                System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> StartupStep <span class="title function_">tag</span><span class="params">(String key, Supplier&lt;String&gt; value)</span> &#123;</span><br><span class="line">                System.out.println(key+<span class="string">&quot;:&quot;</span>+value.get());</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tags <span class="title function_">getTags</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">MyApplicationStartup</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyApplicationStartup</span>();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> StartupStep <span class="title function_">start</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始\n&quot;</span>+name);</span><br><span class="line">            <span class="keyword">return</span> MyStartupStep.DEFAULE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationStartup <span class="title function_">getApplicationStartup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MyApplicationStartup.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动一下看一下这个过程吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">spring.context.annotated-bean-reader.create  <span class="comment">// reader属性被创建</span></span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.component-classes.register  <span class="comment">// 开始配置类定义的注册</span></span><br><span class="line">classes:[<span class="keyword">class</span> <span class="title class_">com</span>.djm.Main]               <span class="comment">// Main定义被注册</span></span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate  <span class="comment">// 实例化spring 提供的一个bean</span></span><br><span class="line">beanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor </span><br><span class="line">beanType:<span class="keyword">interface</span> <span class="title class_">org</span>.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor <span class="comment">// 这是一个bean定义后置处理器</span></span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.beandef-registry.post-process  <span class="comment">// 上面这个bean定义后置处理器开始干活</span></span><br><span class="line">postProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@<span class="number">6950e31</span></span><br><span class="line">开始</span><br><span class="line">spring.context.config-classes.parse  <span class="comment">//  开始通过一开始的配置类拿到其他配置类, 然后通过其他配置类拿到bean定义信息</span></span><br><span class="line">classCount:<span class="number">11</span>  <span class="comment">// 这个过程总共拿到的bean定义信息</span></span><br><span class="line">结束</span><br><span class="line">结束</span><br><span class="line">开始 <span class="comment">// 开始实例化所有后置处理器,优先实列化所有的bean定义后置处理器,执行里面的的方法,然后就是beanfactory后置处理器,然后就是bean后置处理器</span></span><br><span class="line">spring.beans.instantiate   </span><br><span class="line">beanName:customBeanDefinitionRegistryPostProcessor</span><br><span class="line">beanType:<span class="keyword">interface</span> <span class="title class_">org</span>.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate  </span><br><span class="line">beanName:myBeanDefinitionRegistryPostProcessor</span><br><span class="line">beanType:<span class="keyword">interface</span> <span class="title class_">org</span>.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.beandef-registry.post-process  <span class="comment">// 由于我们刚刚实例化了一个bean定义后置处理器,所以这个后置处理器初始化会调用里面的方法往容器中注入bean</span></span><br><span class="line">postProcessor:com.djm.processor.CustomBeanDefinitionRegistryPostProcessor@7ff95560</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.beandef-registry.post-process</span><br><span class="line">postProcessor:com.djm.processor.MyBeanDefinitionRegistryPostProcessor<span class="meta">@add0edd</span> </span><br><span class="line">我的bean定义注册后置处理器被执行 </span><br><span class="line">结束</span><br><span class="line">开始  <span class="comment">// //刚刚是bean定义后置处理器,现在是beanfactory后置处理器</span></span><br><span class="line">spring.context.bean-factory.post-process</span><br><span class="line">postProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@<span class="number">6950e31</span></span><br><span class="line">开始</span><br><span class="line">spring.context.config-classes.enhance</span><br><span class="line">classCount:<span class="number">1</span></span><br><span class="line">结束</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.bean-factory.post-process </span><br><span class="line">postProcessor:com.djm.processor.CustomBeanDefinitionRegistryPostProcessor@7ff95560</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.bean-factory.post-process</span><br><span class="line">postProcessor:com.djm.processor.MyBeanDefinitionRegistryPostProcessor<span class="meta">@add0edd</span></span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">beanType:<span class="keyword">interface</span> <span class="title class_">org</span>.springframework.beans.factory.config.BeanFactoryPostProcessor</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:myBeanFactoryPostProcessor</span><br><span class="line">beanType:<span class="keyword">interface</span> <span class="title class_">org</span>.springframework.beans.factory.config.BeanFactoryPostProcessor</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.bean-factory.post-process</span><br><span class="line">postProcessor:org.springframework.context.event.EventListenerMethodProcessor@55b699ef</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">结束</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.context.bean-factory.post-process</span><br><span class="line">postProcessor:com.djm.processor.MyBeanFactoryPostProcessor@18078bef</span><br><span class="line">我的beanFactoryPostProcessor被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate <span class="comment">// 开始bean后置处理器的实例化, 这里实例化的时候并不会执行bean后置处理器的方法</span></span><br><span class="line">beanName:org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">beanType:<span class="keyword">interface</span> <span class="title class_">org</span>.springframework.beans.factory.config.BeanPostProcessor</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:myBeanPostProcessor</span><br><span class="line">beanType:<span class="keyword">interface</span> <span class="title class_">org</span>.springframework.beans.factory.config.BeanPostProcessor</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate <span class="comment">// 实例化所有的bean, 然后会执行bean后置处理器中的方法</span></span><br><span class="line">beanName:main</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:myListener</span><br><span class="line">我的bean后置处理器被执行  </span><br><span class="line">结束</span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:myConponent</span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:&amp;myfactory  <span class="comment">// 工厂类的名字</span></span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:myListener1</span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:com.djm.configuration.MyConfiguration</span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:setObject1</span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:setobject</span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.instantiate</span><br><span class="line">beanName:com.djm.configuration.MyConfiguration1</span><br><span class="line">我的bean后置处理器被执行</span><br><span class="line">结束</span><br><span class="line">开始</span><br><span class="line">spring.beans.smart-initialize</span><br><span class="line">beanName:org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">结束</span><br><span class="line">hello world</span><br><span class="line">MyListener1 run</span><br><span class="line">hello world</span><br><span class="line">MyListener1 run</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>执行流程</h1><h2 id="0-annotationconfigapplicationcontext-class-componentclasses-里面的重点执行函数">0. AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)里面的重点执行函数</h2><ol><li><p>this()  初始化beanfactory, 加入一些后置处理器的bean定义信息</p></li><li><p>this.register(componentClasses)   把给定的配置类定义信息加载到beanfactory中<br>3. this.reader.register(componentClasses);</p></li><li><p>this.refresh(); 更新容器,扫描bean定义信息,实例bean单例对象</p><ol start="5"><li><p>this.prepareBeanFactory(beanFactory)  设置启动时间,状态,初始化一些存放事件和监听器的集合</p></li><li><p>this.invokeBeanFactoryPostProcessors(beanFactory)  <strong>首先根据优先级执行所有的BeanDefinitionRegistryPostProcessor,然后再根据优先级执行所有的BeanFactoryPostProcessor, 至此所有的bean定义信息都会在factory中, 而且所有的BeanFactoryPostProcessor已经被注册了,生成了对应的单实例bean了</strong><br>7. PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors());   这个方法执行完毕后,所有定义好的bean定义信息都会被加载到beanfactory中<br>8. invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());  执行spring提供的configurationpostprocessor 后置处理器<br>9. postProcessor.postProcessBeanDefinitionRegistry(registry); 做一些验证<br>10. this.processConfigBeanDefinitions(registry); 处理现在beanfactory中已经有了的配置类,找到他们会往容器中注入的bean定义信息<br>11. ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) 这份方法会往配置类的定义信息上加一些东西,比如是否排序, 是完整配置类还是简单配置类<br>12. parser.parse(candidates); 找到所有的配置类的定义信息<br>13. this.reader.loadBeanDefinitions(configClasses); 加载所有配置类里面所有涉及到的bean定义信息</p></li><li><p>this.registerBeanPostProcessors(beanFactory); 注册所有的BeanPostProcessor到beanfactory中存起来,方便后面使用</p></li><li><p>this.finishBeanFactoryInitialization(beanFactory); 实例化所有的单实例bean,后置处理器相应的做事情</p></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">1. this() </span><br><span class="line"></span><br><span class="line">// 得到每个配置类的bean的定义信息</span><br><span class="line">2. this.register(componentClasses) </span><br><span class="line">  3. this.reader.register(componentClasses); </span><br><span class="line">  </span><br><span class="line">// 更新容器</span><br><span class="line">4.this.refresh();</span><br><span class="line">  // 放入一些</span><br><span class="line">  5. this.prepareBeanFactory(beanFactory)  </span><br><span class="line">  //</span><br><span class="line">  6. this.invokeBeanFactoryPostProcessors(beanFactory)  </span><br><span class="line">    7. PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</span><br><span class="line">     </span><br><span class="line">      8. invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); </span><br><span class="line">        9. postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">          10. this.processConfigBeanDefinitions(registry); </span><br><span class="line">            11. ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)</span><br><span class="line">            12. parser.parse(candidates);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-annotationconfigapplicationcontext">1. AnnotationConfigApplicationContext()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">StartupStep</span> <span class="variable">createAnnotatedBeanDefReader</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.annotated-bean-reader.create&quot;</span>); </span><br><span class="line">       <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">       createAnnotatedBeanDefReader.end(); </span><br><span class="line">       <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用了父类的所有无参构造函数,初始化两个属性</p><p>beanfactory工厂已经初始化完毕了,  并且定义了几个后置处理器的bean定义信息和一个监听器工厂类</p><p><img src="/2023/05/07/java/spring%E6%BA%90%E7%A0%81/../img/spring%E5%AD%A6%E4%B9%A0assets/image-20230507151848223.png" alt="image-20230507151848223"></p><h2 id="2-this-register-componentclasses">2. this.register(componentClasses)</h2><p>主要是为了获取每个配置类的bean定义信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">        Assert.notEmpty(componentClasses, <span class="string">&quot;At least one component class must be specified&quot;</span>);</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">registerComponentClass</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.component-classes.register&quot;</span>).tag(<span class="string">&quot;classes&quot;</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(componentClasses);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.reader.register(componentClasses); </span><br><span class="line">        registerComponentClass.end();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-this-reader-register-componentclasses">3. this.reader.register(componentClasses);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">        Class[] var2 = componentClasses;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> componentClasses.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;  <span class="comment">// 依次获取每个给定的配置类的bean定义信息</span></span><br><span class="line">            Class&lt;?&gt; componentClass = var2[var4];</span><br><span class="line">            <span class="built_in">this</span>.registerBean(componentClass);  <span class="comment">// 获取</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>把构造函数里面给定的类的定义信息注册进去了</p><p><img src="/2023/05/07/java/spring%E6%BA%90%E7%A0%81/../img/spring%E5%AD%A6%E4%B9%A0assets/image-20230507152134907.png" alt="image-20230507152134907"></p><h2 id="4-this-refresh">4. this.refresh();</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="comment">// 使用 startupShutdownMonitor 保证容器启动和关闭时的线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 记录应用启动过程中的性能数据</span></span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备刷新，设置容器的启动时间、激活状态等,初始化监听器和事件的容器</span></span><br><span class="line">        <span class="built_in">this</span>.prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个新的 BeanFactory，并将其设置为当前 ApplicationContext 的 BeanFactory</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 BeanFactory，如设置类加载器、添加 BeanPostProcessor,以及注入一些系统变量,环境变量相关的单例bean</span></span><br><span class="line">        <span class="built_in">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 留给子类的扩展点，可对 BeanFactory 进行进一步的处理</span></span><br><span class="line">            <span class="built_in">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录性能数据</span></span><br><span class="line">            <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用所有的 BeanFactoryPostProcessor，进行容器级别的处理，如解析配置文件、注册自定义作用域等</span></span><br><span class="line">            <span class="built_in">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册所有的 BeanPostProcessor，用于处理 Bean 的生命周期事件</span></span><br><span class="line">            <span class="built_in">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 MessageSource 组件，用于国际化</span></span><br><span class="line">            <span class="built_in">this</span>.initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 ApplicationEventMulticaster，用于事件广播</span></span><br><span class="line">            <span class="built_in">this</span>.initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 留给子类的扩展点，进行容器的自定义初始化</span></span><br><span class="line">            <span class="built_in">this</span>.onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 ApplicationListener，用于处理应用事件</span></span><br><span class="line">            <span class="built_in">this</span>.registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化容器中的所有单例 bean</span></span><br><span class="line">            <span class="built_in">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成刷新，通知所有的 LifecycleProcessor 刷新，并发布相关事件</span></span><br><span class="line">            <span class="built_in">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var10) &#123;</span><br><span class="line">            <span class="comment">// 如果在刷新过程中发生异常，记录日志并销毁已创建的 bean</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var10);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.destroyBeans();</span><br><span class="line">            <span class="built_in">this</span>.cancelRefresh(var10);</span><br><span class="line">            <span class="keyword">throw</span> var10;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 重置内部缓存</span></span><br><span class="line">            <span class="built_in">this</span>.resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.prepareRefresh();  <span class="comment">// 初始化监听器,事件容器</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainFreshBeanFactory();</span><br><span class="line">        <span class="built_in">this</span>.prepareBeanFactory(beanFactory);  <span class="comment">// 忽略一些bean的自动装入,设置类加载器,表达式解析器,一些BeanPostProcessor后置处理器,以及注入一些系统变量,环境变量相关的bean</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.postProcessBeanFactory(beanFactory); <span class="comment">// 预留点,让我们自定义一些事情</span></span><br><span class="line">            <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.invokeBeanFactoryPostProcessors(beanFactory); <span class="comment">// 调用已经存在的BeanFactoryPostProcessor,其实这里也是个扩展点,因为这个后置处理器压根就没有,我们可以定制化,this.addBeanFactoryPostProcessor方法</span></span><br><span class="line">            <span class="built_in">this</span>.registerBeanPostProcessors(beanFactory); </span><br><span class="line">            beanPostProcess.end();</span><br><span class="line">            <span class="built_in">this</span>.initMessageSource();</span><br><span class="line">            <span class="built_in">this</span>.initApplicationEventMulticaster();</span><br><span class="line">            <span class="built_in">this</span>.onRefresh();</span><br><span class="line">            <span class="built_in">this</span>.registerListeners();</span><br><span class="line">            <span class="built_in">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="built_in">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var10) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var10);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.destroyBeans();</span><br><span class="line">            <span class="built_in">this</span>.cancelRefresh(var10);</span><br><span class="line">            <span class="keyword">throw</span> var10;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-this-preparebeanfactory-beanfactory">5. this.prepareBeanFactory(beanFactory)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置 beanFactory 的类加载器为当前 ApplicationContext 的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(<span class="built_in">this</span>.getClassLoader());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 beanFactory 的表达式解析器为 StandardBeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 为 beanFactory 注册一个属性编辑器，用于处理 Resource 类型的属性</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，用于处理实现了 ApplicationContextAware 接口的 bean</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 让 beanFactory 忽略以下类型的自动装配</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册可解析的依赖关系，以便在需要时进行自动装配</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，用于检测实现了 ApplicationListener 接口的 bean</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不是在 native image 模式下运行，并且 beanFactory 中包含 loadTimeWeaver 的 bean</span></span><br><span class="line">   <span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(<span class="string">&quot;loadTimeWeaver&quot;</span>)) &#123;</span><br><span class="line">       <span class="comment">// 添加一个 BeanPostProcessor，用于处理实现了 LoadTimeWeaverAware 接口的 bean</span></span><br><span class="line">       beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置 beanFactory 的临时类加载器为 ContextTypeMatchClassLoader</span></span><br><span class="line">       beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里是直接注入了对象,而不是放入beandefinition</span></span><br><span class="line">   <span class="comment">// 如果 beanFactory 中不存在名为 &quot;environment&quot; 的 bean，将环境对象注册为单例 bean</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">&quot;environment&quot;</span>)) &#123;</span><br><span class="line">       beanFactory.registerSingleton(<span class="string">&quot;environment&quot;</span>, <span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果 beanFactory 中不存在名为 &quot;systemProperties&quot; 的 bean，将系统属性注册为单例 bean</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">&quot;systemProperties&quot;</span>)) &#123;</span><br><span class="line">       beanFactory.registerSingleton(<span class="string">&quot;systemProperties&quot;</span>, <span class="built_in">this</span>.getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果 beanFactory 中不存在名为 &quot;systemEnvironment&quot; 的 bean，将系统环境变量注册为单例 bean</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">&quot;systemEnvironment&quot;</span>)) &#123;</span><br><span class="line">       beanFactory.registerSingleton(<span class="string">&quot;systemEnvironment&quot;</span>, <span class="built_in">this</span>.getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果 beanFactory 中不存在名为 &quot;applicationStartup&quot; 的 bean，将 ApplicationStartup 对象注册为单例 bean</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">&quot;applicationStartup&quot;</span>)) &#123;</span><br><span class="line">       beanFactory.registerSingleton(<span class="string">&quot;applicationStartup&quot;</span>, <span class="built_in">this</span>.getApplicationStartup());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里完毕后会直接注册几个单实例对象,他们是没有bean定义信息的,还会放几个后置处理器,也没有定义信息</p><p>bean定义信息不变</p><p><img src="/2023/05/07/java/spring%E6%BA%90%E7%A0%81/../img/spring%E5%AD%A6%E4%B9%A0assets/image-20230507191945213.png" alt="image-20230507191945213"></p><p>多了几个单实例bean</p><p><img src="/2023/05/07/java/spring%E6%BA%90%E7%A0%81/../img/spring%E5%AD%A6%E4%B9%A0assets/image-20230507192212678.png" alt="image-20230507192212678"></p><p>多了两个后置处理器</p><p><img src="/2023/05/07/java/spring%E6%BA%90%E7%A0%81/../img/spring%E5%AD%A6%E4%B9%A0assets/image-20230507192136806.png" alt="image-20230507192136806"></p><h2 id="6-this-invokebeanfactorypostprocessors-beanfactory">6.this.invokeBeanFactoryPostProcessors(beanFactory)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, <span class="built_in">this</span>.getBeanFactoryPostProcessors()); <span class="comment">// 这里是留给开发者扩展的后置处理器,这里面是个空的容器,因为我们没有扩展,这里的扩展是指自定义容器</span></span><br><span class="line">        <span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(<span class="string">&quot;loadTimeWeaver&quot;</span>)) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">            beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-postprocessorregistrationdelegate-invokebeanfactorypostprocessors-beanfactory-this-getbeanfactorypostprocessors">7. PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors());</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123; </span><br><span class="line">        Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>();  <span class="comment">// 已经处理的beanfactory后置处理器名字</span></span><br><span class="line">        ArrayList regularPostProcessors;</span><br><span class="line">        ArrayList registryProcessors;</span><br><span class="line">        <span class="type">int</span> var9;</span><br><span class="line">        ArrayList currentRegistryProcessors; <span class="comment">// 当前注册的后置处理器</span></span><br><span class="line">        String[] postProcessorNames;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123; </span><br><span class="line">            <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry)beanFactory;</span><br><span class="line">            regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> beanFactoryPostProcessors.iterator(); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var6.hasNext()) &#123; </span><br><span class="line">                <span class="type">BeanFactoryPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> (BeanFactoryPostProcessor)var6.next();</span><br><span class="line">                <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123; <span class="comment">// 如果是bean定义后置处理器</span></span><br><span class="line">                    <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span> (BeanDefinitionRegistryPostProcessor)postProcessor;</span><br><span class="line">                    registryProcessor.postProcessBeanDefinitionRegistry(registry); <span class="comment">// 调用beandefinition后置处理器方法</span></span><br><span class="line">                    registryProcessors.add(registryProcessor);  <span class="comment">// 因为beandefinition这个后置处理器还是BeanFactory后置处理器的子类,所以还要加入这里面</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    regularPostProcessors.add(postProcessor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  <span class="comment">// 当前后置处理器</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);  <span class="comment">// 得到一个字符串数组,里面有spring注入的BeanDefinitionRegistryPostProcessor类型bean的名字</span></span><br><span class="line">            String[] var16 = postProcessorNames;</span><br><span class="line">            var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先处理有排序规则的</span></span><br><span class="line">            <span class="type">int</span> var10;</span><br><span class="line">            String ppName;</span><br><span class="line">            <span class="keyword">for</span>(var10 = <span class="number">0</span>; var10 &lt; var9; ++var10) &#123;  <span class="comment">// 循环得到这些单实例后置处理器bean</span></span><br><span class="line">                ppName = var16[var10];</span><br><span class="line">                <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; <span class="comment">// 必须是实现了这个接口</span></span><br><span class="line">                    currentRegistryProcessors.add((BeanDefinitionRegistryPostProcessor)beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); <span class="comment">// 注意这里会将这个后置处理器实例化了</span></span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors); <span class="comment">// 把当前的后置处理器加入到里面去</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); <span class="comment">// 执行当前bean定义的后置处理器,这里是处理configuration注解的后置处理器,这步执行完后所有的通过注解定义的bean的信息都会被加载到容器中</span></span><br><span class="line">            currentRegistryProcessors.clear();<span class="comment">// 清除</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>); <span class="comment">// 更新BeanDefinitionRegistryPostProcessor,因为刚刚加入的bean可能会有这个类型</span></span><br><span class="line">            var16 = postProcessorNames;</span><br><span class="line">            var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var10 = <span class="number">0</span>; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">                ppName = var16[var10];</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add((BeanDefinitionRegistryPostProcessor)beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); <span class="comment">// 如果实现了Ordered接口,加入到本次执行,否则就等下次</span></span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory); <span class="comment">//对新加入的bean定义后置处理器排序</span></span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors); <span class="comment">//将新的后置处理器加入到其中</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());  <span class="comment">// 执行新的后置处理的方法,这个就是我们自定义得了</span></span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(reiterate) &#123; <span class="comment">// 搁着套娃,因为你通过这个方法定义的bean可能又有bean定义后置处理器,不过这里的都是没有实现排序接口的bean定义后置处理器</span></span><br><span class="line">                reiterate = <span class="literal">false</span>;</span><br><span class="line">                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>); </span><br><span class="line">                String[] var19 = postProcessorNames;</span><br><span class="line">                var10 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var26</span> <span class="operator">=</span> <span class="number">0</span>; var26 &lt; var10; ++var26) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">ppName</span> <span class="operator">=</span> var19[var26];</span><br><span class="line">                    <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                        currentRegistryProcessors.add((BeanDefinitionRegistryPostProcessor)beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                        processedBeans.add(ppName);</span><br><span class="line">                        reiterate = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 我不知道这里为什么还要排序,但是里面的排序算法我是看的云里雾里的,貌似这里的排序算法是根据提供者等级来的</span></span><br><span class="line">                sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">                registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">                currentRegistryProcessors.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行所有的bean定义后置处理的关于beanfactory的后置处理器</span></span><br><span class="line">            invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory); </span><br><span class="line">            <span class="comment">// 执行扩展beanfactory后置处理器</span></span><br><span class="line">            invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        postProcessorNames = postProcessorNames;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var20</span> <span class="operator">=</span> postProcessorNames.length;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 拿到所有没有被执行过的beanfactory的后置处理器, 然后根据等级排序执行后置处理器,这就是后面干的事情</span></span><br><span class="line">        String ppName;</span><br><span class="line">        <span class="keyword">for</span>(var9 = <span class="number">0</span>; var9 &lt; var20; ++var9) &#123;</span><br><span class="line">            ppName = postProcessorNames[var9];</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                    regularPostProcessors.add((BeanFactoryPostProcessor)beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                    registryProcessors.add(ppName);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currentRegistryProcessors.add(ppName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(registryProcessors.size());</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var21</span> <span class="operator">=</span> registryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var21.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">postProcessorName</span> <span class="operator">=</span> (String)var21.next();</span><br><span class="line">            orderedPostProcessors.add((BeanFactoryPostProcessor)beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(currentRegistryProcessors.size());</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var24</span> <span class="operator">=</span> currentRegistryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var24.hasNext()) &#123;</span><br><span class="line">            ppName = (String)var24.next();</span><br><span class="line">            nonOrderedPostProcessors.add((BeanFactoryPostProcessor)beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">        beanFactory.clearMetadataCache();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="8-invokebeandefinitionregistrypostprocessors">8. invokeBeanDefinitionRegistryPostProcessors</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历提供的 BeanDefinitionRegistryPostProcessor 集合</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> postProcessors.iterator(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 获取当前遍历的 BeanDefinitionRegistryPostProcessor 实例</span></span><br><span class="line">        <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> (BeanDefinitionRegistryPostProcessor)var3.next();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动一个新的 StartupStep，并将 postProcessor 信息添加到步骤中</span></span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">var10000</span> <span class="operator">=</span> applicationStartup.start(<span class="string">&quot;spring.context.beandef-registry.post-process&quot;</span>);</span><br><span class="line">        Objects.requireNonNull(postProcessor);</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">postProcessBeanDefRegistry</span> <span class="operator">=</span> var10000.tag(<span class="string">&quot;postProcessor&quot;</span>, postProcessor::toString);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用当前 BeanDefinitionRegistryPostProcessor 实例的 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">        </span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束当前的 StartupStep</span></span><br><span class="line">        postProcessBeanDefRegistry.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-postprocessor-postprocessbeandefinitionregistry-registry">9.  postProcessor.postProcessBeanDefinitionRegistry(registry);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前 BeanDefinitionRegistry 的唯一标识</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查当前 registry 是否已经被 postProcessBeanDefinitionRegistry 处理过</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="comment">// 如果已经处理过，则抛出 IllegalStateException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 检查当前 registry 是否已经被 postProcessBeanFactory 处理过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="comment">// 如果已经处理过，则抛出 IllegalStateException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果当前 registry 没有被处理过</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前 registry 标识添加到 registriesPostProcessed 集合中</span></span><br><span class="line">        <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 processConfigBeanDefinitions 方法处理配置类 BeanDefinition</span></span><br><span class="line">        <span class="built_in">this</span>.processConfigBeanDefinitions(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-this-processconfigbeandefinitions-registry">10. this.processConfigBeanDefinitions(registry);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 候选配置类bean定义信息</span></span><br><span class="line">        String[] candidateNames = registry.getBeanDefinitionNames(); <span class="comment">// 候选类名字,从这里面拿到候选配置类bean定义信息</span></span><br><span class="line">        String[] var4 = candidateNames;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> candidateNames.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef); <span class="comment">// 如果已经处理过了的配置类就没有必要再处理了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123; <span class="comment">// 如果是配置类的话,会看他是完整配置类还是简单配置类,然后添加一个属性到bean定义中,还有就是如果有排序注解的话,也会加入一个排序属性到bean定义中</span></span><br><span class="line">                configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName)); <span class="comment">// 满足要求加添加进去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!configCandidates.isEmpty()) &#123; </span><br><span class="line">            configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">                <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">                sbr = (SingletonBeanRegistry)registry;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">                    <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator)sbr.getSingleton(<span class="string">&quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                        <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置类解析器,解析componentsan这些注解,还有import注解,就是为了得到其他的bean定义信息</span></span><br><span class="line">            <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(<span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(configCandidates);</span><br><span class="line">            <span class="type">HashSet</span> <span class="variable">alreadyParsed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(configCandidates.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">StartupStep</span> <span class="variable">processConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.config-classes.parse&quot;</span>);</span><br><span class="line">                parser.parse(candidates); <span class="comment">//得到所有通过@component注解类(还有controller这些)和@configuration声明组件</span></span><br><span class="line">                parser.validate();</span><br><span class="line">                Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(parser.getConfigurationClasses()); <span class="comment">// 得到所有的配置类,包括@import注解导入的</span></span><br><span class="line">                configClasses.removeAll(alreadyParsed);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);  <span class="comment">// 加载所有的@bean注解定义的bean信息</span></span><br><span class="line">                alreadyParsed.addAll(configClasses);</span><br><span class="line">                processConfig.tag(<span class="string">&quot;classCount&quot;</span>, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> String.valueOf(configClasses.size());</span><br><span class="line">                &#125;).end();</span><br><span class="line">                candidates.clear();</span><br><span class="line">                <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">                    String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">                    Set&lt;String&gt; oldCandidateNames = Set.of(candidateNames);</span><br><span class="line">                    Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">                    <span class="type">Iterator</span> <span class="variable">var13</span> <span class="operator">=</span> alreadyParsed.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var13.hasNext()) &#123;</span><br><span class="line">                        <span class="type">ConfigurationClass</span> <span class="variable">configurationClass</span> <span class="operator">=</span> (ConfigurationClass)var13.next();</span><br><span class="line">                        alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String[] var26 = newCandidateNames;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">var27</span> <span class="operator">=</span> newCandidateNames.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var15</span> <span class="operator">=</span> <span class="number">0</span>; var15 &lt; var27; ++var15) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">candidateName</span> <span class="operator">=</span> var26[var15];</span><br><span class="line">                        <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                            <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">                            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                                candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    candidateNames = newCandidateNames;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>(!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">                sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.propertySourceDescriptors = parser.getPropertySourceDescriptors();</span><br><span class="line">            <span class="type">MetadataReaderFactory</span> <span class="variable">var25</span> <span class="operator">=</span> <span class="built_in">this</span>.metadataReaderFactory;</span><br><span class="line">            <span class="keyword">if</span> (var25 <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">                <span class="type">CachingMetadataReaderFactory</span> <span class="variable">cachingMetadataReaderFactory</span> <span class="operator">=</span> (CachingMetadataReaderFactory)var25;</span><br><span class="line">                cachingMetadataReaderFactory.clearCache();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="11-configurationclassutils-checkconfigurationclasscandidate-beandef-this-metadatareaderfactory">11. ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkConfigurationClassCandidate</span><span class="params">(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanDef.getBeanClassName();</span><br><span class="line">        <span class="keyword">if</span> (className != <span class="literal">null</span> &amp;&amp; beanDef.getFactoryMethodName() == <span class="literal">null</span>) &#123;</span><br><span class="line">            AnnotationMetadata metadata;</span><br><span class="line">            <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AnnotatedBeanDefinition &amp;&amp; className.equals(((AnnotatedBeanDefinition)beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">                metadata = ((AnnotatedBeanDefinition)beanDef).getMetadata();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition)beanDef).hasBeanClass()) &#123;</span><br><span class="line">                Class&lt;?&gt; beanClass = ((AbstractBeanDefinition)beanDef).getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) || BeanPostProcessor.class.isAssignableFrom(beanClass) || AopInfrastructureBean.class.isAssignableFrom(beanClass) || EventListenerFactory.class.isAssignableFrom(beanClass)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                metadata = AnnotationMetadata.introspect(beanClass);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">                    metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Could not find class file for introspecting configuration annotations: &quot;</span> + className, var6);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line">            <span class="keyword">if</span> (config != <span class="literal">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">&quot;proxyBeanMethods&quot;</span>))) &#123;</span><br><span class="line">                beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, <span class="string">&quot;full&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (config == <span class="literal">null</span> &amp;&amp; !isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, <span class="string">&quot;lite&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">order</span> <span class="operator">=</span> getOrder(metadata);</span><br><span class="line">            <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">                beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="12-parser-parse-candidates">12.parser.parse(candidates);</h2><p>这里就不看源码了,知道他把所有的配置类全部找出来了就行</p><h2 id="13-this-reader-loadbeandefinitions-configclasses">13 this.reader.loadBeanDefinitions(configClasses);</h2><p>加载配置类中定义的所有bean</p><h1>小技巧</h1><p>如果父类重写了祖先的方法,那么子类点击这个方法进入的是父类这个方法,而不是祖先这个方法,  如果跳转到了祖先的方法,那说明父类没有重写</p><h1>配置类与简化配置类</h1><p>在阅读源码的过程中看到了这么两条语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, &quot;full&quot;);</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, &quot;lite&quot;);</span><br></pre></td></tr></table></figure><p>经过查询后得到 一个是完整配置类,一个是简化配置类,  完整配置类是使用了@Configuration注解的类  而简化配置类是使用了 哪些组件注解的 比如 :</p><ul><li><code>@Component</code></li><li><code>@Service</code></li><li><code>@Repository</code></li><li><code>@Controller</code></li></ul><p>完整配置类和简化配置类都可以在 Spring 中用于配置和创建 bean，但它们之间有一些关键区别：</p><ol><li><p>注解：完整配置类使用 <code>@Configuration</code> 注解，而简化配置类没有使用 <code>@Configuration</code> 注解。简化配置类通常使用 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 或 <code>@Controller</code> 注解。</p></li><li><p>Bean 方法调用：在完整配置类中，<code>@Bean</code> 方法之间的调用会遵循 Spring 容器的单例规则，即调用 <code>@Bean</code> 方法时，容器会返回已经创建的 bean 实例（如果存在的话）。在简化配置类中，<code>@Bean</code> 方法之间的调用不会遵循单例规则，而是直接创建新的实例。这意味着在简化配置类中，如果一个 <code>@Bean</code> 方法调用另一个 <code>@Bean</code> 方法，它将会创建一个新的实例，而不是返回容器中已经存在的 bean 实例。</p></li><li><p>CGLIB 代理：完整配置类会被 CGLIB 代理，以确保 <code>@Bean</code> 方法之间的调用遵循 Spring 容器的单例规则。简化配置类不会被 CGLIB 代理，因此它们的 <code>@Bean</code> 方法之间的调用行为与普通的 Java 方法调用相同。</p></li><li><p>适用场景：完整配置类主要用于集中管理和配置应用程序的 bean，通常会包含多个 <code>@Bean</code> 方法。简化配置类适用于将 bean 的定义散布在整个应用程序中，使其更接近使用 bean 的地方。这有助于保持代码的模块化和易于理解。</p></li></ol><p>总之，完整配置类和简化配置类的主要区别在于它们处理 <code>@Bean</code> 方法之间调用以及代理方式的不同。完整配置类提供了更严格的管理和控制，而简化配置类提供了更轻量级和灵活的方式来配置和定义 bean。在实际应用中，可以根据需求和场景选择使用哪种配置类。</p><h1>spring是如何判断bean是否有某个注解的</h1><p>它的底层是通过拿到bean定义中的AnnotationMetadata,然后调用它的isAnnotated方法判断是否有某个注解的,这个方法有个厉害的地方就是,无论是你的类上有这个注解,还是注解上有这个注解,他都能检测到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentA.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentB.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@ComponentA</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentC.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@ComponentB</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentC &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如这个样, 我们使用ComponentC注解也能将这个组件注入进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取所有的bean名称</span></span><br><span class="line">        String[] beanNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="comment">// 获取bean定义</span></span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span>(!(beanDefinition <span class="keyword">instanceof</span> AnnotatedBeanDefinition beanDefinition1))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">AnnotationMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> beanDefinition1.getMetadata();</span><br><span class="line">            <span class="keyword">if</span>(metadata.isAnnotated(ComponentC.class.getName()))&#123; </span><br><span class="line">                System.out.println(beanName+<span class="string">&quot;有这个注解&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 无需在此方法中执行任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>doGetBean</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.transformedBeanName(name);</span><br><span class="line">       <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> <span class="built_in">this</span>.getSingleton(beanName);</span><br><span class="line">       Object beanInstance;</span><br><span class="line">       <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;  <span class="comment">// 如果已经存在了而且参数为空</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                   <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 这里是shareedInstance可能会做一些别的操作,比如如果是个工厂类,可能执行他的方法得到bean</span></span><br><span class="line">           beanInstance = <span class="built_in">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)<span class="literal">null</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getParentBeanFactory();</span><br><span class="line">           <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> <span class="built_in">this</span>.originalBeanName(name);</span><br><span class="line">               <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                   <span class="type">AbstractBeanFactory</span> <span class="variable">abf</span> <span class="operator">=</span> (AbstractBeanFactory)parentBeanFactory;</span><br><span class="line">                   <span class="keyword">return</span> abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">               <span class="built_in">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">StartupStep</span> <span class="variable">beanCreation</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>).tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">                   Objects.requireNonNull(requiredType);</span><br><span class="line">                   beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> <span class="built_in">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">               <span class="built_in">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">               String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">               String[] var12;</span><br><span class="line">               <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">                   var12 = dependsOn;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">var13</span> <span class="operator">=</span> dependsOn.length;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var14</span> <span class="operator">=</span> <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">                       <span class="type">String</span> <span class="variable">dep</span> <span class="operator">=</span> var12[var14];</span><br><span class="line">                       <span class="keyword">if</span> (<span class="built_in">this</span>.isDependent(beanName, dep)) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="built_in">this</span>.registerDependentBean(dep, beanName);</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="built_in">this</span>.getBean(dep);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException var31) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, var31);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                   sharedInstance = <span class="built_in">this</span>.getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="built_in">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</span><br><span class="line">                           <span class="built_in">this</span>.destroySingleton(beanName);</span><br><span class="line">                           <span class="keyword">throw</span> var5;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">                   beanInstance = <span class="built_in">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                   var12 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                   Object prototypeInstance;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="built_in">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                       prototypeInstance = <span class="built_in">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="built_in">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   beanInstance = <span class="built_in">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">                   <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No scope name defined for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> (Scope)<span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">                   <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                           <span class="built_in">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line"></span><br><span class="line">                           Object var4;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               var4 = <span class="built_in">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               <span class="built_in">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">return</span> var4;</span><br><span class="line">                       &#125;);</span><br><span class="line">                       beanInstance = <span class="built_in">this</span>.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IllegalStateException var30) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, var30);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (BeansException var32) &#123;</span><br><span class="line">               beanCreation.tag(<span class="string">&quot;exception&quot;</span>, var32.getClass().toString());</span><br><span class="line">               beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(var32.getMessage()));</span><br><span class="line">               <span class="built_in">this</span>.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">               <span class="keyword">throw</span> var32;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               beanCreation.end();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// adaptBeanInstance方法会检查传入的beanInstance是否与requiredType兼容。如果不兼容，它会尝试进行类型转换，例如通过调用AOPProxyUtils.ultimateTargetClass方法来获取代理对象的最终目标类，然后将其与requiredType进行比较。如果最终仍然不兼容，adaptBeanInstance方法将抛出一个BeanNotOfRequiredTypeException异常。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> Object <span class="title function_">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="built_in">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">              Class&lt;?&gt; targetType = <span class="built_in">this</span>.determineTargetType(beanName, mbd);</span><br><span class="line">              <span class="keyword">if</span> (targetType != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//在bean实例化前做一些事情,有可能需要代理啊啥的</span></span><br><span class="line">                  bean = <span class="built_in">this</span>.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); </span><br><span class="line">                  <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="comment">// 如果被代理了直接执行实例化后的方法</span></span><br><span class="line">                      bean = <span class="built_in">this</span>.applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          mbd.beforeInstantiationResolved = bean != <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1>总结</h1><p>spring容器启动流程如下:</p><ul><li>初始化容器, <strong>往里面放入一个BeanDefinitionRegistryPostProcessor</strong>,(这个东西很厉害,就是靠他去扫描我们定义的bean的定义信息)  和 几个Beanfactroy</li><li>把我们给的配置类的信息放入到容器中, 然后开始设置一些初始状态,放入一些环境</li><li>首先执行BeanDefinitionRegistryPostProcessor和BeanPostProcessor里面的方法, 拿到所有的bean定义信息, 拿到bean定义信息的流程如下: 首先加载所有配置类,包括简化配置类, 比如configuration,component等,还有一个<strong>特别重要的import</strong>, 如果我们import进来的类不是ImportSelector和ImportBeanDefinitionRegistrar的话,就会把它的定义信息加载到容器中,如果是ImportSelector那就会执行接口里面的方法拿到bean定义信息到容器中, 如果是ImportBeanDefinitionRegistrar就会保留它的信息,<strong>最终加载配置类定义bean的时候就会执行这个方法</strong>， 不过他们的信息此时都是看不见的,也就是说debug去查看是看不到的. <strong>加载完配置类后开始把配置类里面的bean定义信息全部找出来放入容器</strong></li><li>拿到了所有的bean定义信息, 开始把里面所有的<strong>后置处理器实例化</strong>,  如果是BeanDefinitionRegistryPostProcessor和BeanPostProcessor就会执行里面的方法再次拿到bean定义信息放入容器. 一直循环,直到所有的后置处理器被实例化</li><li>接下来就是一些国际化,监听器的处理</li><li>然后就是spring的重头戏,开始bean的实例化,看bean是不是factorybean, 如果是就获取它里面的bean实例化,如果不是就直接实例化,实例化的过程大概是<strong>执行实例化后置处理器的前置方法开始执行,这里就能实现对对象的代理了,如果有返回值就不执行接下来的实例化后置处理器</strong>,  接下来就是普通的后置处理器了,初始化前后做一些操作,比如一些自动化注入的注解,属性注解等等</li><li>接下来就是一些其他的事情了,发布完成刷新的事件啊,清除缓存啊等等</li></ul><p>补充一点就是,如果有@Conditional这类的注解的话, 如果不满足是不会加载bean的定义信息的</p>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven 学习</title>
      <link href="/2023/05/05/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/maven/"/>
      <url>/2023/05/05/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/maven/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>在java开发中,maven的重要性不言而喻,但是我对于它的使用还只停留在导入配置文件这样,所以现在得好好学习一下</p><blockquote><p>借鉴文档 <a href="http://www.mvnbook.com/maven-dependency-conflict.html">http://www.mvnbook.com/maven-dependency-conflict.html</a></p></blockquote><h1>介绍</h1><p>Maven是一个流行的<strong>Java项目构建和管理工具，主要用于自动化构建过程</strong>。它有助于项目的<strong>编译、测试、打包、发布和部署</strong>。Maven是基于Project Object Model (POM)的，<strong>使用一个名为pom.xml的配置文件来描述项目的结构、依赖、插件和其他相关信息</strong>。</p><p>Maven具有以下特点：</p><ol><li><p>约定优于配置：Maven遵循一套标准的目录结构和默认设置，使得开发人员无需过多的配置即可完成大部分任务。这有助于提高开发效率，简化项目结构，同时使得项目在团队间具有一致性。</p></li><li><p>依赖管理：Maven能够自动处理项目所需的依赖库，避免了手动下载和管理jar文件的麻烦。它还能解决依赖冲突和版本控制问题。</p></li><li><p>插件和扩展性：Maven拥有大量插件，这些插件可以帮助开发者完成各种任务，如编译、测试、打包、生成文档等。此外，Maven还支持自定义插件，从而使项目更具扩展性。</p></li><li><p>生命周期管理：Maven定义了一组预设的生命周期阶段，如编译、测试、打包、安装等。这些阶段按顺序执行，使项目的构建过程更加规范和可控。</p></li><li><p>多模块项目支持：Maven支持将大型项目分割成多个模块，每个模块可以独立构建和管理。这有助于模块化开发和团队协作。</p></li><li><p>集成持续集成工具：Maven可以轻松地与持续集成工具（如Jenkins、GitLab CI/CD等）集成，从而实现项目的自动构建、测试和部署。</p></li></ol><h1>maven项目标准目录</h1><p>目录结构图</p><p><img src="/2023/05/05/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/maven/../img/mavenassets/maven-standard-project-directory.png" alt="img"></p><p>详细介绍</p><table><thead><tr><th><code>$&#123;basedir&#125;</code></th><th>存放 <code>pom.xml</code> 和所有子目录</th></tr></thead><tbody><tr><td><code>$&#123;basedir&#125;/src/main/java</code></td><td>项目的 <code>java</code> 源代码所在的目录</td></tr><tr><td><code>$&#123;basedir&#125;/src/main/resources</code></td><td>项目的资源文件所在的目录，例如：<code>propert</code>文件</td></tr><tr><td><code>$&#123;basedir&#125;/src/test/java</code></td><td>测试代码所在的目录，例如：<code>JUnit</code> 代码</td></tr><tr><td><code>$&#123;basedir&#125;/src/test/resources</code></td><td>测试相关的资源文件所在的目录</td></tr><tr><td><code>$&#123;basedir&#125;/src/main/webapp/WEB-INF</code></td><td><code>web</code> 应用文件目录，<code>web</code> 项目的信息，比如存放 <code>web.xml</code>、本地图片、<code>jsp</code> 视图页面</td></tr><tr><td><code>$&#123;basedir&#125;/target</code></td><td>打包输出目录</td></tr><tr><td><code>$&#123;basedir&#125;/target/classes</code></td><td>编译输出目录</td></tr><tr><td><code>$&#123;basedir&#125;/target/test-classes</code></td><td>测试编译输出目录</td></tr></tbody></table><h1>构件坐标</h1><p>对于maven来说每一个项目的输出都可以看成一个构件,每个构件都有自己的唯一标识，由 groupId，artifactId 和 version 等信息构成,Maven可以对构件进行版本控制，管理。</p><h2 id="构件标识">构件标识</h2><p>每个构件都有自己的唯一标识（Maven 行话称之为 <strong>“唯一坐标”</strong> ），由 groupId，artifactId 和 version 等信息构成。  groupId通常反域名,artifactId 是项目标识,一般是项目名字,version是版本, 在仓库中, 一个坐标只对应一个jar包</p><h2 id="maven构件特性">Maven构件特性</h2><p>（1）构件具有依赖传递。例如：项目依赖构件A，而构件A又依赖B，Maven会将A和B都视为项目的依赖。</p><p>（2）构件之间存在版本冲突时，Maven会依据 “短路优先” 原则加载构件。此外，我们也可以在 pom.xml 中，使用 <exclusions></exclusions>显式排除某个版本的依赖，以确保项目能够运行。</p><ul><li>（a）项目依赖构件A和B，构件A → C → D(version:1.0.0)，构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.1.0)。</li><li>（b）项目依赖构件A和B，构件A → D(version:1.0.0)， 构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.0.0)。</li></ul><p>（3）构件的依赖范围。Maven在项目的构建过程中，会编译三套 ClassPath，分别对应：编译期，运行期，测试期。而依赖范围就是为构件指定它可以作用于哪套 ClassPath。</p><h1>依赖范围</h1><p>因为 Maven 执行一系列操作，主要包括编译、测试、运行等操作，在不同的操作下依赖的 Jar 不同，依赖范围就是用来控制 Jar 包的可见性。例如，JUnit 的依赖范围是test，只用于编译测试代码和运行测试代码的时候才可见，而在编译和运行主项目时无法使用此依赖。<strong>有些依赖编译用不到，只有运行的时候才能用到，比如 MySQL 的驱动包在编译期就用不到（编译期用的是JDBC接口）</strong>，而是在运行时用到的。还有些依赖，编译期要用到，而运行期不需要提供，因为有些容器已经提供了，比如 servlet-api.jar 在 Tomcat 中已经提供了，我们只需要的是编译期提供而已。</p><table><thead><tr><th style="text-align:left">-</th><th style="text-align:left">编译期</th><th style="text-align:left">测试期</th><th style="text-align:left">运行期</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">compile</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">默认范围</td></tr><tr><td style="text-align:left">provided</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left"></td><td style="text-align:left">如 servlet-api.jar，运行期由web容器提供。</td></tr><tr><td style="text-align:left">runtime</td><td style="text-align:left"></td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">编译期无需直接引用。</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left"></td><td style="text-align:left">√</td><td style="text-align:left"></td><td style="text-align:left">如junit.jar。</td></tr><tr><td style="text-align:left">system</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left"></td><td style="text-align:left">必须通过 <systemPath></systemPath> 元素，显示指定依赖文件的路径， 与本地系统相关联，可移植性差。</td></tr><tr><td style="text-align:left">import</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">表示继承父POM.XML中的依赖范围设置</td></tr></tbody></table><blockquote><p>jar包是真实存在的, 依赖范围只是看我们什么时候需要使用这个jar包</p></blockquote><h1>依赖搜索顺序</h1><p><code>maven</code>按照以下顺序查找依赖库：</p><ul><li>步骤 1：在本地仓库搜索，如果找不到，执行步骤 2，找到了则执行其他操作</li><li>步骤 2：在中央仓库搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中引用。</li><li>步骤 3：如果远程仓库没有被设置,  将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li>步骤 4：在一个或多个远程仓库中搜索依赖的文件, 如果找到则下载到本地仓库引用, 否则将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><h1>依赖冲突</h1><p>在 Maven 中，依赖分为直接依赖和传递依赖（即间接依赖）,传递性依赖机制，能大大简化依赖管理，因为大部分情况下我们只需要关心项目的直接依赖是什么，而不用考虑这些直接依赖会引入什么传递性依赖, 但是这样也会有问题, 就是会有间接依赖冲突的问题, <strong>对于同一个groupid 和 artifactId  下  只能有同一个version</strong>,(版本决定不了包名字)对于间接依赖这种就很容易会产生冲突</p><h2 id="直接依赖冲突">直接依赖冲突</h2><p>对于直接依赖冲突, 引入的依赖是最后出现的一个版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如这样就是3.5.0的版本</p><h2 id="传递依赖冲突">传递依赖冲突</h2><p>依赖传递的发生有两种情况：一种是存在模块之间的继承关系，在继承父模块后同时引入了父模块中的依赖，可通过可选依赖机制放弃依赖传递到子模块；<strong>另一种是引包时附带引入该包所依赖的包，该方式是引起依赖冲突的主因</strong></p><p>比如一个项目同时引入了 A 和 B  A引用了 C 1.0版本  B引用了 C 2.0的版本  那这样肯定会产生冲突  如果使用的时候C 2.0 的话,可能不会有问题, 但是如果使用的是 C 1.0的话,那可能就有大问题了, 1.0的版本一般是无法调用2.0的东西的, 而2.0一般是兼容1.0的,这个时候我们是不是就要去解决冲突了,尽量让2.0优先</p><h2 id="冲突解决策略">冲突解决策略</h2><h3 id="路径最先的优先">路径最先的优先</h3><p>这个是maven自动解决的, 谁的路径最短,优先使用谁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A --&gt; B --&gt; X(1.1)         // dist(A-&gt;X) = 2</span><br><span class="line"></span><br><span class="line">A --&gt; C --&gt; D --&gt; X(1.0)   // dist(A-&gt;X) = 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里优先使用x(1.1)版本</p><h3 id="第一声明优先">第一声明优先</h3><p>如果路径最先解决不了的话,就谁先声明谁使用 (<strong>这个是针对间接依赖</strong>),直接依赖的话就谁后声明谁优先</p><h3 id="依赖排除">依赖排除</h3><p>我们可以直接排除一些依赖留下一个或者没有</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jersey.containers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-container-grizzly2-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 剔除依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.hk2.external<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>快照</h1><p>在Maven中，快照（Snapshot）是一种特殊类型的版本，表示项目的一个正在开发中的版本。<strong>快照版本通常用于在团队内共享尚未发布的项目版本，以便在不同的模块或项目之间进行协作开发。与正式发布的稳定版本相比，快照版本可能会频繁更新，因此它们不能保证稳定性和一致性。</strong></p><p><strong>快照版本的主要优点是它们可以自动更新。当你的项目依赖于一个快照版本的库时，Maven会定期检查远程仓库中是否有新的快照版本。如果有更新，Maven会自动下载并使用新版本。这有助于确保项目始终使用最新的开发版本。</strong></p><p>要定义一个Maven项目的快照版本，你需要在项目的<code>pom.xml</code>文件中将<code>&lt;version&gt;</code>标签的值设置为以<code>-SNAPSHOT</code>结尾的版本号。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，项目的版本被定义为<code>1.0.0-SNAPSHOT</code>，表示这是一个正在开发中的1.0.0版本。当项目稳定并准备发布时，可以将版本号更新为不包含<code>-SNAPSHOT</code>的正式版本号，如<code>1.0.0</code>。</p><p>要使用其他项目的快照版本，只需在<code>pom.xml</code>文件的<code>&lt;dependencies&gt;</code>部分添加相应的依赖，并确保远程仓库包含该快照版本。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>another-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：为了使用快照版本，你需要配置Maven仓库（如<code>settings.xml</code>文件中的<code>&lt;repositories&gt;</code>和<code>&lt;pluginRepositories&gt;</code>部分），以便它们可以从包含快照版本的远程仓库获取。<strong>这通常包括配置一个称为“快照仓库”的特殊仓库。</strong></p><h2 id="更新策略">更新策略</h2><p>在settings.xml中profiles标签中我们可以配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">    &lt;id&gt;myRepository&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;...&lt;/url&gt;</span><br><span class="line">    &lt;snapshots&gt;</span><br><span class="line">        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">        &lt;updatePolicy&gt;更新策略&lt;/updatePolicy&gt;</span><br><span class="line">    &lt;/snapshots&gt;</span><br><span class="line">&lt;/repository&gt;</span><br></pre></td></tr></table></figure><p>更新策略有一下几种：</p><ul><li>always 每次构建都检查远程仓库中该依赖jar包是否有更新</li><li>daily 每天检查一次 (默认策略)</li><li>interval:XXX 指定检查时间间隔，单位是分钟。</li><li>never 从不检查。该策略就和正式版本的处理规则一样了。</li></ul><h2 id="命令强制更新">命令强制更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -U</span><br></pre></td></tr></table></figure><h1>生命周期</h1><p>在Maven中，生命周期是指一系列有序的阶段，用于构建、测试、部署和发布项目。Maven的核心原则是约定优于配置，因此它为各种类型的项目提供了一些预定义的项目周期。这些预定义的周期涵盖了项目从源代码到可部署产物的整个过程。</p><blockquote><p>生命周期只是一个概念,真正做事情的是插件</p></blockquote><p>Maven 有以下三个标准的生命周期:</p><ol><li>clean：项目清理。主要用于清理上一次构建产生的文件，可以理解为删除 target 目录,它包含以下阶段:<ul><li>pre-clean：在实际清理之前执行必要的操作。</li><li>clean：删除构建产物（例如，删除 target 目录）。</li><li>post-clean：完成清理后，进行后续操作。</li></ul></li><li>default(或 build)：项目构建。主要阶段包含：<ul><li>validate：验证项目是否正确，所有必需的信息是否可用。</li><li>initialize：初始化构建状态，例如设置属性或创建目录。</li><li>generate-sources：生成项目所需的任何源代码。</li><li>process-sources：处理源代码，例如过滤文件。</li><li>generate-resources：生成项目所需的任何资源。</li><li>process-resources：将资源复制到目标目录，以便在打包时包含它们。</li><li>compile：编译项目的源代码。</li><li>process-classes：处理编译后的文件，例如优化字节码。</li><li>generate-test-sources：生成项目的测试源代码。</li><li>process-test-sources：处理测试源代码，例如过滤文件。</li><li>generate-test-resources：生成项目的测试资源。</li><li>process-test-resources：将测试资源复制到目标目录，以便在测试时使用。</li><li>test-compile：编译项目的测试源代码。</li><li>process-test-classes：处理编译后的测试文件。</li><li>test：使用合适的测试框架运行测试。</li><li>prepare-package：执行任何在打包之前需要完成的操作。</li><li><strong>package</strong>：将编译后的代码和资源打包成指定格式的文件，如 JAR、WAR 或 EAR。</li><li>pre-integration-test：在集成测试之前执行必要的操作。</li><li>integration-test：处理和部署项目以便进行集成测试。</li><li>post-integration-test：完成集成测试后，进行后续操作。</li><li>verify：检查包是否有效，满足质量标准。</li><li>install：将包安装到本地仓库，以便在其他项目中使用。</li><li>deploy：将最终的包复制到远程仓库，以便与其他开发人员和项目共享。</li></ul></li></ol><p><img src="/2023/05/05/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/maven/../img/mavenassets/maven-build.png" alt="img"></p><ol start="3"><li>site：项目站点文档创建。</li></ol><p><strong>如果我们执行了某个生命周期的命令,那么它之前的生命周期对应的插件都会被执行</strong>,比如我们使用了 mvn compile 那么validate就会执行</p><h1>插件</h1><p>Maven本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成。</p><p>使用插件的命令格式如下:</p><h3 id="方式一">方式一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn pluginGroupId:pluginArtifactId:pluginVersion:goal(goal 也可以理解成方法)</span><br><span class="line">mvn compiler:compile</span><br></pre></td></tr></table></figure><h3 id="方式二">方式二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn 生命周期</span><br><span class="line">mvn compile</span><br></pre></td></tr></table></figure><p>方式一执行的是一个插件, 而方式二一般是执行一堆插件</p><h2 id="插件与生命周期的绑定">插件与生命周期的绑定</h2><p>Maven生命周期与插件的绑定是指将插件的目标（goal）与生命周期的某个阶段关联起来。当Maven执行生命周期的某个阶段时，与该阶段绑定的插件目标也会被执行。这种绑定机制允许开发人员在构建过程中使用插件完成特定任务，从而扩展和自定义Maven的构建过程。</p><p>插件通常会有一个或多个目标，每个目标对应一个具体的任务。例如，<code>maven-compiler-plugin</code> 插件有两个主要目标：<code>compile</code>和<code>testCompile</code>。这两个目标分别负责编译主代码和测试代码。在默认情况下，<code>compile</code> 目标绑定到生命周期的 <code>compile</code> 阶段，<code>testCompile</code> 目标绑定到生命周期的 <code>test</code> 阶段。</p><p>要将插件目标与生命周期阶段绑定，需要在项目的<code>pom.xml</code>文件中的<code>&lt;build&gt;</code>元素内定义插件。以下是一个简单的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-compile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-testCompile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述示例中，<code>maven-compiler-plugin</code>的<code>compile</code>目标被绑定到了<code>compile</code>阶段，而<code>testCompile</code>目标被绑定到了<code>test</code>阶段。当Maven执行生命周期阶段时，相应的插件目标也会被触发执行。</p><p>通过这种绑定关系，开发人员可以为Maven项目自定义构建过程，使用插件完成各种任务，如编译、测试、打包等。</p><h2 id="开发插件">开发插件</h2><p>Maven 作为一个优秀的项目管理工具，其插件机制提供了很多功能扩展。Maven 自带的插件足够满足我们的项目开发要求，不排除在某些特殊情况下，需要我们自己开发一个自己的插件来协助我们完成某些工作</p><h3 id="命名规范">命名规范</h3><p>Maven 命名有要求，插件命名为 <myplugin>-maven-plugin ，而不推荐使用 maven-<myplugin>-plugin，因为后者是 Maven 团队维护官方插件的保留命名方式。</myplugin></myplugin></p><h3 id="创建mojo工程">创建MOJO工程</h3><p>MOJO 就是 Maven Ordinary Java Object。每一个 MOJO 就是 Maven 中的一个执行目标（executable goal），而插件则是对单个或多个相关的 MOJO做统一分发。一个 MOJO 包含一个简单的 Java 类。插件中多个类似 MOJO 的通用之处可以使用抽象父类来封装。</p><p>创建 Maven 插件工程与正常工程相似，但是，记得要选用 maven-archetype-mojo 模板。</p><blockquote><p>新建 Maven 项目时，需要选择 archetype。那么，什么是archetype？ archetype 的意思就是模板原型的意思，原型是一个 Maven 项目模板工具包。一个原型被定义为从其中相同类型的所有其它事情是由一个原始图案或模型。原型将帮助作者为用户创建 Maven 项目模板，并为用户提供了手段，产生的这些项目模板参数化的版本。maven-archetype-mojo 是一个 Maven 的 Java 插件开发项目原型。</p></blockquote><h3 id="编写pom-xml文件">编写pom.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.djm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>maven-plugin<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-maven-plugin Maven Mojo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugin-tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编写mojo类">编写MOJO类</h3><p>编写的类继承AbstractMojo然后重写它的执行方法, 最后还需要在类上加入@Mojo 注解声明执行目标</p><p>无参MOJO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Mojo(name = &quot;hello&quot;)</span><br><span class="line">public class MyMojo</span><br><span class="line">    extends AbstractMojo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void execute()</span><br><span class="line">        throws MojoExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">        getLog().info(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要参数的MOJO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Mojo(name = &quot;parameter&quot;)</span><br><span class="line">public class ParamterMojo extends AbstractMojo &#123;</span><br><span class="line"></span><br><span class="line">    @Parameter(property = &quot;someParameter&quot;, defaultValue = &quot;default-value&quot;)</span><br><span class="line">    private String someParameter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() throws MojoExecutionException, MojoFailureException &#123;</span><br><span class="line">        System.out.println(someParameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行mvn install</p><h3 id="引入插件">引入插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;com.djm&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hello-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;someParameter&gt;hello world!!!!&lt;/someParameter&gt;  &lt;!--传递参数--&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;phase&gt;compile&lt;/phase&gt;  &lt;!--与生命周期绑定--&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;parameter&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line"></span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h2 id="plugin的子标签">plugin的子标签</h2><p>在 Maven 的 <code>pom.xml</code> 文件中，<code>&lt;plugin&gt;</code> 标签用于定义插件及其配置。插件用于扩展或定制 Maven 构建过程中的某些任务。<code>&lt;plugin&gt;</code> 标签可以包含以下子标签：</p><ol><li><p><code>&lt;groupId&gt;</code>：插件的 groupId，它用于唯一标识插件所属的项目或组织。例如：<code>org.apache.maven.plugins</code>。</p></li><li><p><code>&lt;artifactId&gt;</code>：插件的 artifactId，它用于唯一标识插件。例如：<code>maven-compiler-plugin</code>。</p></li><li><p><code>&lt;version&gt;</code>：插件的版本号。例如：<code>3.8.0</code>。</p></li><li><p><code>&lt;extensions&gt;</code>：布尔值，用于指示插件是否提供扩展点。扩展点允许插件修改 Maven 的核心行为。大多数插件不需要使用扩展点，因此此标签通常为 <code>false</code> 或省略。</p></li><li><p><code>&lt;executions&gt;</code>：定义插件在构建过程中的多个执行。<code>&lt;executions&gt;</code> 标签可以包含多个 <code>&lt;execution&gt;</code> 标签。每个 <code>&lt;execution&gt;</code> 标签可以包含以下子标签：</p><ul><li><code>&lt;id&gt;</code>：执行的唯一标识符，用于区分不同的执行。</li><li><code>&lt;phase&gt;</code>：与此执行关联的生命周期阶段。在指定的阶段，将执行这个插件。</li><li><code>&lt;goals&gt;</code>：定义与此执行关联的插件目标（任务）。<code>&lt;goals&gt;</code> 标签可以包含多个 <code>&lt;goal&gt;</code> 标签，每个 <code>&lt;goal&gt;</code> 标签表示一个要执行的插件目标。</li></ul></li><li><p><code>&lt;configuration&gt;</code>：插件的配置信息。<strong>这些配置参数用于定制插件的行为</strong>。<code>&lt;configuration&gt;</code> 标签中的子标签取决于插件本身，因为每个插件可能有不同的配置参数。例如，对于 <code>maven-compiler-plugin</code>，<code>&lt;configuration&gt;</code> 可能包含 <code>&lt;source&gt;</code> 和 <code>&lt;target&gt;</code> 标签，用于指定 Java 源代码和目标字节码的版本。</p></li></ol><p>下面是一个配置示例，它使用 <code>maven-compiler-plugin</code> 设置 Java 源代码和目标字节码的版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个示例中，我们定义了一个插件（<code>maven-compiler-plugin</code>），并通过 <code>&lt;configuration&gt;</code> 标签设置了 Java 源代码和目标字节码的版本为 1.8。</p><h1>POM常用配置项</h1><p><code>pom.xml</code> 是 Maven 项目的核心配置文件，它定义了项目的基本信息、依赖关系、插件、构建配置等。以下是 <code>pom.xml</code> 中的一些主要配置项及其用途：</p><ol><li><p><code>&lt;modelVersion&gt;</code>：POM 文件的模型版本，通常是 “4.0.0”。<strong>这是一个必需的元素</strong>。</p></li><li><p><code>&lt;groupId&gt;</code>：项目的组织或公司名称，通常是一个反向的域名，例如 “org.example”。它是 Maven 项目坐标的一部分。</p></li><li><p><code>&lt;artifactId&gt;</code>：项目的唯一标识符，例如 “my-project”。它是 Maven 项目坐标的一部分。</p></li><li><p><code>&lt;version&gt;</code>：项目的版本号，例如 “1.0.0”。它是 Maven 项目坐标的一部分。</p></li><li><p><code>&lt;packaging&gt;</code>：项目的打包类型，例如 “jar”、“war” 等。默认值是 “jar”。</p></li><li><p><code>&lt;name&gt;</code>：项目的人类可读名称，例如 “My Project”。</p></li><li><p><code>&lt;description&gt;</code>：项目的简要描述。</p></li><li><p><code>&lt;url&gt;</code>：项目的主页 URL。</p></li><li><p><code>&lt;dependencies&gt;</code>：项目的依赖关系列表。在此元素中，可以使用 <code>&lt;dependency&gt;</code> 标签声明项目所需的库文件。例如：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>example-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="10"><li><p><strong><code>&lt;dependencyManagement&gt;</code>：用于在多模块项目中管理依赖关系的版本</strong>。在此元素中，可以使用 <code>&lt;dependencies&gt;</code> 标签声明依赖关系，**但这些依赖关系不会直接添加到项目中，而是作为版本管理的参考。子模块可以继承这些依赖关系，并在需要时覆盖版本。**子项目只需要引入就行而不用指定版本,当然也可以指定版本进行覆盖</p><p>父模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;aop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这么做的的好处是,可以让一套项目中可能用到的版本都适配,  因为使用者并不知道哪些包需要使用哪些版本,但是他知道要这个包</strong></p></li><li><p><code>&lt;build&gt;</code>：项目的构建配置。在此元素中，可以配置构建输出目录、源代码目录、资源文件目录等。还可以配置插件及其执行阶段、目标和参数。例如：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="12"><li><p><code>&lt;pluginManagement&gt;</code>：与 <code>&lt;dependencyManagement&gt;</code> 类似，用于在多模块项目中管理插件的版本和配置。子模块可以继承这些插件，并在需要时覆盖配置。</p></li><li><p><code>&lt;properties&gt;</code>：项目的自定义属性。可以在此元素中定义属性，然后在 POM 文件的其他地方引用它们。例如：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="14"><li><code>&lt;profiles&gt;</code>：项目的配置文件。在 <code>&lt;profiles&gt;</code> 中，可以定义一组构建配置文件（profiles），每个配置文件对应一种特定的构建场景。<strong>配置文件可以包含特定的依赖关系、插件配置和属性</strong>。通过激活不同的配置文件，可以在不同的环境或条件下使用不同的构建配置。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">    &lt;!-- ... 其他配置 ... --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;development&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;property&gt;</span><br><span class="line">                    &lt;name&gt;activeProfile&lt;/name&gt;</span><br><span class="line">                    &lt;value&gt;development&lt;/value&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- 默认激活该profile --&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;db.url&gt;jdbc:mysql://localhost:3306/dev_db&lt;/db.url&gt;</span><br><span class="line">                &lt;db.username&gt;dev_user&lt;/db.username&gt;</span><br><span class="line">                &lt;db.password&gt;dev_password&lt;/db.password&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;production&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;property&gt;</span><br><span class="line">                    &lt;name&gt;activeProfile&lt;/name&gt;</span><br><span class="line">                    &lt;value&gt;production&lt;/value&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;db.url&gt;jdbc:mysql://localhost:3306/prod_db&lt;/db.url&gt;</span><br><span class="line">                &lt;db.username&gt;prod_user&lt;/db.username&gt;</span><br><span class="line">                &lt;db.password&gt;prod_password&lt;/db.password&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>多模块</h1><p>子模块会继承父模块的插件和依赖</p><h1>maven配置</h1><p><code>settings.xml</code> 文件是 Maven 的核心配置文件。它允许你定制 Maven 的行为，包括存储库设置、代理设置、构建配置等。下面是一些常见的配置项及其用途：</p><ol><li><p><code>&lt;localRepository&gt;</code>：指定本地存储库的路径。默认情况下，Maven 将所有依赖项和插件存储在用户主目录下的 <code>.m2/repository</code> 文件夹中。</p></li><li><p><code>&lt;mirrors&gt;</code>：用于配置镜像存储库。当 Maven 无法从默认的中央存储库中检索某个组件时，可以配置镜像存储库作为替代源。</p></li><li><p><code>&lt;proxies&gt;</code>：配置 Maven 通过代理服务器访问外部网络的设置。这对于需要使用代理服务器来访问外部资源的用户非常有用。</p></li><li><p><code>&lt;servers&gt;</code>：配置 Maven 用于身份验证的服务器设置。当需要访问受保护的远程存储库或部署到远程存储库时，这是必需的。</p></li><li><p><code>&lt;profiles&gt;</code>：包含用于定制构建环境的一组配置。通过使用不同的配置文件，可以轻松地在多个环境中切换构建设置，例如开发、测试和生产环境。</p></li><li><p><code>&lt;activeProfiles&gt;</code>：列出在 Maven 运行时默认激活的配置文件。这允许你根据需要激活或禁用某些配置文件。</p></li><li><p><code>&lt;pluginGroups&gt;</code>：定义可在命令行中简化命令的插件组。例如，你可以通过添加插件组来将完整的插件坐标缩短为更简洁的前缀。</p></li></ol><p>这些配置项通过 XML 标签组织在 <code>settings.xml</code> 文件中。可以根据项目需求自定义这些配置，以便更好地控制 Maven 的行为。</p><h2 id="优先级">优先级</h2><p>Maven 配置文件的优先级如下：</p><ol><li>项目的 <code>pom.xml</code></li><li>用户级的 <code>settings.xml</code>（通常位于 <code>~/.m2/settings.xml</code>）</li><li>全局的 <code>settings.xml</code>（通常位于 <code>$&#123;maven.home&#125;/conf/settings.xml</code>）</li></ol><p><strong>当存在相同的配置项时，优先级较高的配置会覆盖优先级较低的配置。</strong></p><p>在合并过程中，如果有冲突，高优先级的配置会覆盖低优先级的配置。这种覆盖是在具体配置项的层次上进行的，而不是整个标签。也就是说，如果高优先级的配置文件只更改了一个特定的配置项，那么它只会覆盖低优先级配置文件中的该配置项，而不会影响其他配置项。</p><p>例如，如果用户级 <code>settings.xml</code> 中的 <code>&lt;mirrors&gt;</code> 配置与全局 <code>settings.xml</code> 中的 <code>&lt;mirrors&gt;</code> 配置冲突，那么用户级 <code>settings.xml</code> 中的 <code>&lt;mirrors&gt;</code> 配置将优先使用。然后，仅具有冲突的 <code>&lt;mirror&gt;</code> 标签将被用户级设置中的对应标签替换，而其他不冲突的 <code>&lt;mirror&gt;</code> 标签将保持原样。</p><h2 id="注意点">注意点</h2><p>如果我们有多个镜像,  maven会根据顺序 和 规则 去 连接这些镜像对应的仓库, <strong>如果连接成功了, 就不会再去连接其他仓库, 即使其他仓库里面有我们需要的依赖,而这个仓库没有</strong> ,这样的话就会报出依赖找不到的错误,因此我们要注意这些镜像能够匹配哪些仓库</p><h1>多环境配置</h1><p>在开发的时候,我们通常需要多套环境切换,  比如springboot 中,  如果我们通过spring.profiles.active 去切换的话,这样有点太麻烦了, 每次都要修改,  我觉得使用maven自带的这个多环境配置会更方便,  接下来讲一下springboot中如何使用maven配置多环境</p><p>在springboot 中的 配置文件中引入maven变量</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">@activatedProperties@</span></span><br></pre></td></tr></table></figure><p>然后在pom.xml中配置, 这个千万不能少,不然的话,maven不会替换掉springboot中的变量值的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ROOT<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>  <span class="comment">&lt;!-- 打包后的名称 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  <span class="comment">&lt;!-- 启用过滤 即该资源中的变量将会被过滤器中的值替换 --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  <span class="comment">&lt;!-- 指定需要过滤的文件,不要全部指定,比如如果有些静态资源里面也有@@或者$&#123;&#125;这样的变量,会出现问题的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  <span class="comment">&lt;!-- 关闭资源文件过滤 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>  <span class="comment">&lt;!-- 指定不需要关闭过滤的文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在pom.xml创建多个配置环境激活变量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>devlop<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activatedProperties</span>&gt;</span>devlop,devlopallow<span class="tag">&lt;/<span class="name">activatedProperties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>devlop-not-allow<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activatedProperties</span>&gt;</span>devlop<span class="tag">&lt;/<span class="name">activatedProperties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>local<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activatedProperties</span>&gt;</span>local<span class="tag">&lt;/<span class="name">activatedProperties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span> <span class="comment">&lt;!-- 默认激活该profile --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样之后我们就只需要在maven中选择哪个配置文件就行了,不用修改代码</p><p><img src="/2023/05/05/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/maven/../img/mavenassets/image-20230519094122926.png" alt="image-20230519094122926"></p><p>默认情况下, 在 Maven 的 pom.xml 文件中定义的变量只在 Maven 构建过程中有效。<strong>并不会影响我们的配置文件和环境变量</strong>,  然而，可以使用 Maven 的资源过滤功能来将 <strong>Maven 变量的值插入到 Java 属性文件</strong>（如 .properties 或 .yml 文件）中, <strong>但是要注意哪些需要替换,哪些不需要替换</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kk音标</title>
      <link href="/2023/05/04/English/kk%E9%9F%B3%E6%A0%87/"/>
      <url>/2023/05/04/English/kk%E9%9F%B3%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此篇文章是我还没学会音标之前摸索学的一套kk音标, 现在学的是dj音标, 感觉学起来轻松很多, 比下面这种学起来正常很多</p></blockquote><h1>正常字母对应</h1><p>a a  矮矮</p><p>b b  波波</p><p>c c  咳咳</p><p>d d 的的</p><p>e e 哎哎</p><p>f f 符符</p><p>g g 个个</p><p>h h 呵呵</p><p>i i 依依</p><p>j j 聚聚</p><p>k k 咳咳</p><p>l l</p><ul><li>前面  了了</li><li>后面 哦哦</li></ul><p>m m</p><ul><li>前面 么么</li><li>后面 嗯嗯 (闭嘴)</li></ul><p>n n</p><ul><li>前面 讷讷</li><li>后面  嗯嗯 (开嘴)</li></ul><p>o o 啊啊 (重音)</p><p>p p 颇颇</p><p>q q 扩扩</p><p>r r</p><ul><li>前面  若若</li><li>后面  尔尔</li></ul><p>s s 死死</p><p>t t 特特</p><p>u u 啊啊(轻)</p><p>v v 五五(牙齿咬下嘴唇)</p><p>w w 呜呜 (张开嘴唇)</p><p>x x 渴死渴死</p><p>y y 依依</p><p>z z 滋滋(重)</p><p>a e i o u 是 元音  其他是辅音</p><h1>元音的特殊</h1><ol><li><p>每个元音(a,e,i,o.u)还有字符本身的发音  比如  a 就发a  e 就是 e</p></li><li><p>一般第一个元音前面的辅音是重音节,  如果后面还有元音字符的话  就发 额  比如  doctor   的啊可特额而</p></li><li><p>字尾有e的话  不发音, 前面的元音发字符本身的音   name  ride  came take</p></li><li><p>如果元音与r紧挨着  如果不是在单词末尾  就发 哦     work   bird   如果是在末尾 那就是  而尔    her  doctor     worker 包含了这两种</p></li><li><p>两个 o一起就是 唔   book  look  good  foot food</p></li><li><p>ou ow  au aw  奥   hour  house  how</p></li><li><p>th 有两个 四 think  Z that this    ch 吃  chat  sh 使 she  ph 符  photo</p></li><li><p>ng 在尾巴发  嗯 (重)   嗯个    nk  嗯可</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>公司框架学习</title>
      <link href="/2023/05/04/java/%E5%85%AC%E5%8F%B8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/05/04/java/%E5%85%AC%E5%8F%B8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>c2-runtimex</h1><h2 id="启动类配置">启动类配置</h2><p>如果不需要使用数据库的话,exclude其实也可以不用配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123;DynamicDataSourceAutoConfiguration.class&#125;)</span><br><span class="line">@EnableC2Runtime</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication springBootApplication = new SpringApplication(Main.class);</span><br><span class="line">        springBootApplication.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt的api使用</title>
      <link href="/2023/05/01/chatGPT/Api%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/01/chatGPT/Api%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>最近在完成我的毕设,有一个使用ChatGPT提问的功能,所以就来玩玩咯</p><p>使用的是python和openai这个库 开发工具是vscode  然后用的jupyter这个交互式笔记本,这个东西很有用,可以保留历史输出记录,这样就能节省我们不少token</p><h1>介绍</h1><p>第一列代表一个类型,比如有聊天,创作,音频处理等等, 第二列是对应有哪些模型</p><p><img src="/2023/05/01/chatGPT/Api%E7%9A%84%E4%BD%BF%E7%94%A8/../img/Api%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230501221456900.png" alt="image-20230501221456900"></p><h1>环境搭建</h1><h2 id="安装openai库">安装openai库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openai</span><br></pre></td></tr></table></figure><h1>完成类模型</h1><p>这类模型只能进行一次问答,就是你提问它回答,或者说你让他做一件事情,他完成好回复你,代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">openai.api_key = sys.argv[<span class="number">1</span>]</span><br><span class="line">response = openai.Completion.create(</span><br><span class="line">    engine=<span class="string">&quot;text-davinci-003&quot;</span>,</span><br><span class="line">    prompt=<span class="string">&quot;中国的首都是?&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.9</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(response1,ensure_ascii=<span class="literal">False</span>,indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>它的回复格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmpl-7BOcWIGMa8dam4xtHwbQKy8kYqSat&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">1682950604</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text-davinci-003&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\n\n北京。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logprobs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;finish_reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prompt_tokens&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completion_tokens&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;total_tokens&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1>聊天类模型</h1><p>聊天类模型就是可以连续对话,但是每次对话你必须把前面的问题与回答都要传上去,这样是非常消耗token的</p><h2 id="单独一次对话">单独一次对话</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">openai.api_key = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 聊天模型的使用方法</span></span><br><span class="line">messages=[&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;中国的首都是?&quot;</span>&#125;]</span><br><span class="line">    </span><br><span class="line">response2 = openai.ChatCompletion.create(</span><br><span class="line">        model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">        messages=messages</span><br><span class="line">  )</span><br><span class="line"><span class="built_in">print</span>(json.dumps(response2,ensure_ascii=<span class="literal">False</span>,indent=<span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出格式如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chatcmpl-7BOw1ixdrVHz6i5nX6sK89JgbonSr&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chat.completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">1682951813</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-3.5-turbo-0301&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prompt_tokens&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completion_tokens&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;total_tokens&quot;</span><span class="punctuation">:</span> <span class="number">32</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国的首都是北京。&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;finish_reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="连续对话">连续对话</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">openai.api_key = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">messages=[&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a helpful assistant.&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chatGPT</span>(<span class="params">messages</span>):</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">        messages=messages)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> response[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;message&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    answer = <span class="built_in">input</span>(<span class="string">&quot;输入你的问题:\n&quot;</span>)</span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: answer&#125;)</span><br><span class="line">    response = chatGPT(messages)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;回答如下:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response[<span class="string">&quot;content&quot;</span>])</span><br><span class="line">    messages.append(response)</span><br></pre></td></tr></table></figure><h1>图片模型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1>请求参数</h1><h2 id="通用参数">通用参数</h2><ul><li>model  这个是选择的模型参数  必须</li><li></li></ul><h1>回复格式</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>websocket基本使用</title>
      <link href="/2023/04/30/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/WebSocket/"/>
      <url>/2023/04/30/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/WebSocket/</url>
      
        <content type="html"><![CDATA[<h1>导入依赖</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1>原生</h1><h2 id="前端">前端</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Type your message here...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn&quot;</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> messageInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> sendBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sendBtn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080/chat-websocket&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 连接打开时触发</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="title function_">addEventListener</span>(<span class="string">&quot;open&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            output.<span class="property">innerHTML</span> += <span class="string">&quot;WebSocket connection opened.&lt;br&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 接收到服务器消息时触发</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            output.<span class="property">innerHTML</span> += <span class="string">&quot;Server: &quot;</span> + event.<span class="property">data</span> + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 连接关闭时触发</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="title function_">addEventListener</span>(<span class="string">&quot;close&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            output.<span class="property">innerHTML</span> += <span class="string">&quot;WebSocket connection closed.&lt;br&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送消息到服务器</span></span></span><br><span class="line"><span class="language-javascript">        sendBtn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> message = messageInput.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (message !== <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                socket.<span class="title function_">send</span>(message);</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="后端">后端</h2><h3 id="配置类">配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通信类">通信类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@ServerEndpoint(value = &quot;/chat-websocket&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class ChatController &#123;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;ChatController created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void preDestroy() &#123;</span><br><span class="line">        System.out.println(&quot;ChatController preDestroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/onlineCount&quot;)</span><br><span class="line">    public String onlineCount() &#123;</span><br><span class="line">        return &quot;onlineCount&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @OnOpen</span><br><span class="line">    public void onOpen(Session session) &#123;</span><br><span class="line">        System.out.println(&quot;New connection: &quot; + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnMessage</span><br><span class="line">    public void onMessage(String message, Session session) &#123;</span><br><span class="line">        System.out.println(&quot;Received message: &quot; + message + &quot; from: &quot; + session.getId());</span><br><span class="line">        try &#123;</span><br><span class="line">            session.getBasicRemote().sendText(&quot;Received message: &quot; + message);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnError</span><br><span class="line">    public void onError(Throwable error, Session session) &#123;</span><br><span class="line">        System.out.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnClose</span><br><span class="line">    public void onClose(Session session) &#123;</span><br><span class="line">        System.out.println(&quot;Connection closed: &quot; + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>STOMP 协议</h1><h2 id="订阅与发布">订阅与发布</h2><h3 id="前端">前端</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Chat Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.2/sockjs.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;from&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Your name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;to&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Recipient&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Message&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMessage()&quot;</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;chat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 连接WebSocket服务器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&quot;http://localhost:8080/chat-websocket&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> stompClient = <span class="title class_">Stomp</span>.<span class="title function_">over</span>(socket);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    stompClient.<span class="title function_">connect</span>(&#123;&#125;, <span class="keyword">function</span> (<span class="params">frame</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connected: &quot;</span> + frame);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 订阅/topic/messages以接收聊天消息</span></span></span><br><span class="line"><span class="language-javascript">        stompClient.<span class="title function_">subscribe</span>(<span class="string">&quot;/topic/messages&quot;</span>, <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response.<span class="property">body</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">showMessage</span>(message);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="keyword">from</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;from&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> to = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;to&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送聊天消息到/app/sendMessage</span></span></span><br><span class="line"><span class="language-javascript">        stompClient.<span class="title function_">send</span>(<span class="string">&quot;/app/sendMessage&quot;</span>, &#123;&#125;, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">from</span>: <span class="keyword">from</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">to</span>: to,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">content</span>: content</span></span><br><span class="line"><span class="language-javascript">        &#125;));</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> chat = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;chat&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        li.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(message.<span class="property">from</span> + <span class="string">&quot; to &quot;</span> + message.<span class="property">to</span> + <span class="string">&quot;: &quot;</span> + message.<span class="property">content</span>));</span></span><br><span class="line"><span class="language-javascript">        chat.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="后端">后端</h3><h4 id="配置类">配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry config)</span> &#123;</span><br><span class="line">        config.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>);</span><br><span class="line">        config.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/chat-websocket&quot;</span>).setAllowedOriginPatterns(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>WebSocketMessageBrokerConfigurer</code>中的<code>configureMessageBroker</code>方法用于配置消息代理相关选项。<code>MessageBrokerRegistry</code>对象提供了一些方法，用于自定义消息代理的行为。下面是关于这两个方法的详细解释：</p><ol><li><p><code>config.enableSimpleBroker(&quot;/topic&quot;)</code>：<strong>启用简单消息代理，并指定代理应该处理的目标前缀</strong>。在这个例子中，我们指定了前缀<code>/topic</code>。简单消息代理是一个内置的、轻量级的消息代理，适用于简单的用例。当<strong>客户端订阅以<code>/topic</code>开头的目标时</strong>，它们会收到发送到这些目标的消息。例如，<strong>如果客户端订阅了<code>/topic/chat</code>，那么它们将接收到发送到<code>/topic/chat</code>的所有消息。</strong></p></li><li><p><code>config.setApplicationDestinationPrefixes(&quot;/app&quot;)</code>：设置应用程序的目标前缀。这个前缀用于定义应用程序特定的消息处理方法。在这个例子中，<strong>我们使用了前缀<code>/app</code>。当客户端向以<code>/app</code>开头的目标发送消息时</strong>，这些消息将被路由到Spring应用程序中相应的<code>@MessageMapping</code>注解的方法。例如，<strong>如果客户端发送了一个目标为<code>/app/sendMessage</code>的消息，Spring将查找一个<code>@MessageMapping(&quot;/sendMessage&quot;)</code>注解的方法来处理该消息。</strong></p></li></ol><p>除了上述方法，<code>MessageBrokerRegistry</code>还提供了其他一些方法，用于配置消息代理。这里有一些常用的方法：</p><ul><li><p><code>config.setUserDestinationPrefix(String userDestinationPrefix)</code>：设置用户目标前缀。这个前缀用于定义用户特定的消息目标。当客户端订阅以该前缀开头的目标时，它们将只收到发送到这些目标的针对特定用户的消息。例如，如果客户端订阅了<code>/user/queue/notifications</code>，那么它们将只接收到发送给当前用户的通知消息。</p></li><li><p><code>config.enableStompBrokerRelay(String... destinationPrefixes)</code>：启用STOMP代理中继，以便将消息代理的职责委托给外部STOMP代理（如RabbitMQ或ActiveMQ）。这个方法接受一个或多个目标前缀，指定外部代理应处理哪些目标。这对于更复杂的用例和更高的可扩展性非常有用。</p></li></ul><p>这些配置方法用于控制WebSocket消息的路由和处理。您可以根据应用程序的需求选择合适的方法来自定义消息代理行为。</p><p><code>registerStompEndpoints</code>方法用于注册WebSocket端点，客户端将通过这些端点与服务器建立WebSocket连接。<code>StompEndpointRegistry</code>对象提供了一些方法，用于自定义端点的行为。以下是关于这个方法的详细解释：</p><ul><li><code>registry.addEndpoint(&quot;/chat-websocket&quot;)</code>：向注册表添加一个新的WebSocket端点，并设置端点的URL路径。在这个例子中，我们使用了路径<code>/chat-websocket</code>。客户端将使用此路径与服务器建立WebSocket连接。</li></ul><p>在添加端点后，可以使用链式调用来配置端点的其他选项：</p><ul><li><code>setAllowedOriginPatterns(&quot;*&quot;)</code>：设置允许连接到WebSocket端点的源（即客户端的域）。在这个例子中，我们使用了<code>&quot;*&quot;</code>，意味着允许任何域连接到这个端点。您可以通过指定一个或多个特定的域来限制允许连接的来源，以提高安全性。</li><li><code>withSockJS()</code>：启用SockJS支持。SockJS是一个JavaScript库，<strong>用于在不支持原生WebSocket的浏览器中提供类似于WebSocket的功能。通过在服务器端配置中启用SockJS，您可以确保即使在不支持WebSocket的浏览器中，您的应用程序也能够正常工作。</strong></li></ul><blockquote><p>如果启用了了sockjs,那么前端就需要使用sockjs库,如果没有启用就用原生的websocket就可以了</p></blockquote><p>这些方法和选项允许您自定义WebSocket端点的行为，以满足应用程序的需求。您可以根据需要添加和配置多个端点，以支持不同的客户端连接和使用场景。</p><p>虽然SockJS和STOMP通常一起使用，以确保在不支持原生WebSocket的浏览器中仍能正常工作，但并非所有情况下都需要同时使用它们。在某些情况下，您可能只需要STOMP，而不需要SockJS，或者只需要原生的WebSocket。</p><p>将<code>withSockJS()</code>作为一个可选配置项，而不是内置到STOMP配置中，可以为开发人员提供更大的灵活性。这样，您可以根据实际需求和目标浏览器的支持来选择是否启用SockJS。此外，这也有助于确保在不需要SockJS时，应用程序不会因为不必要的额外开销而受到影响。</p><p>在实际开发中，如果您打算使用STOMP协议，而且希望确保在各种浏览器环境中都能正常工作，那么开启<code>withSockJS()</code>是一个很好的做法。但是，这个决策仍然取决于您的实际需求和场景。</p><h4 id="控制层">控制层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demo.bean.TestBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.MessageMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.SendTo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.SimpMessagingTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestBean testBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="meta">@SendTo(&quot;/topic/messages&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点对点">点对点</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring系列学习</title>
      <link href="/2023/04/28/java/spring%E7%B3%BB%E5%88%97/"/>
      <url>/2023/04/28/java/spring%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><blockquote><p>源码看了又看,忘了又忘,还不如多学学怎么用吧</p></blockquote><h2 id="全家桶">全家桶</h2><p>Spring 全家桶（Spring Ecosystem）包括许多项目和模块，以支持各种应用程序开发需求。以下是 Spring 全家桶中的一些主要项目：</p><ol><li><p>Spring Framework：核心框架，提供了依赖注入（DI）、面向切面编程（AOP）、事件处理等基本功能。</p></li><li><p>Spring Boot：简化 Spring 应用程序开发的框架，提供了自动配置、内嵌容器、快速创建微服务等特性。</p></li><li><p>Spring Cloud：基于 Spring Boot 的微服务框架，提供了服务发现、配置中心、断路器等分布式系统开发组件。</p></li><li><p>Spring Data：提供了统一的数据访问层解决方案，包括对关系型数据库、NoSQL 数据库和其他数据存储技术的支持。</p></li><li><p>Spring Security：提供了强大的安全解决方案，支持认证、授权、攻击防护等功能。</p></li><li><p>Spring Integration：提供了企业集成模式的实现，用于集成不同系统和服务。</p></li><li><p>Spring Batch：用于创建高性能批处理应用程序，支持任务调度、分块处理等功能。</p></li><li><p>Spring Web MVC：用于构建基于 Servlet API 的 Web 应用程序，支持 RESTful API、表单处理、文件上传等功能。</p></li><li><p>Spring WebFlux：用于构建响应式 Web 应用程序，支持非阻塞 I/O、异步处理等功能。</p></li><li><p>Spring WebSocket：提供了 WebSocket 通信支持，用于构建实时 Web 应用程序。</p></li><li><p>Spring AMQP：提供了对高级消息队列协议（AMQP）的支持，用于实现消息队列通信。</p></li><li><p>Spring Cloud Stream：基于 Spring Boot 的消息队列框架，提供了对多种消息中间件的抽象和统一接口。</p></li><li><p>Spring Cloud Data Flow：用于构建数据集成和实时数据处理管道的微服务框架。</p></li><li><p>Spring Cloud Gateway：基于 Spring Boot 的 API 网关，提供了路由、过滤、限流等功能。</p></li><li><p>Spring Cloud Function：提供了将 Spring Boot 应用程序作为函数进行部署的支持，用于无服务器计算场景。</p></li></ol><p>以上只是 Spring 全家桶中的部分项目。随着社区的不断发展，Spring 生态系统不断扩展，为开发者提供了丰富的工具和组件。更多关于 Spring 项目的详细信息，可以访问 Spring 官方网站：<a href="https://spring.io/projects">https://spring.io/projects</a></p><blockquote><p>后面的代码都是基于springboot, 但是很多东西都是spring框架的核心概念</p></blockquote><h1>spring</h1><h2 id="什么是spring">什么是spring</h2><p>Spring Framework 是一个开源的 Java 应用框架，由 Rod Johnson 创立于 2003 年。它旨在简化企业级 Java 开发，提供了一套完整的解决方案，用于创建各种类型的 Java 应用程序，包括 Web、桌面和分布式应用。Spring Framework 的主要特性如下：</p><ol><li>Inversion of Control（IoC，控制反转）：Spring Framework 提供了一个 IoC 容器，<strong>负责管理对象之间的依赖关系。通过使用控制反转，开发者可以将关注点集中在业务逻辑上，而不是依赖关系的管理和实例化过程</strong>。</li><li>Dependency Injection（DI，依赖注入）：依赖注入是实现 IoC 的一种方法。Spring Framework <strong>支持构造器注入和属性注入，使得对象之间的依赖关系可以在配置文件或注解中声明</strong>，从而提高代码的可测试性和可维护性。</li><li>Aspect-Oriented Programming（AOP，面向切面编程）：Spring Framework 提供了 AOP 支持，允许开发者将横切关注点（如日志记录、事务管理等）<strong>从核心业务逻辑中分离出来。这有助于提高代码的模块化程度和可读性。</strong></li></ol><h2 id="注册bean">注册bean</h2><p>在Spring Boot中，有多种方式注册Bean（组件），每种方式都有其使用方法、注意事项、优缺点。以下是主要的注册方式：</p><h3 id="1-使用-component-service-repository和-controller注解：">1. 使用@Component、@Service、@Repository和@Controller注解：</h3><p>使用方法：将这些注解添加到类上，以便让Spring将其作为组件（Bean）自动注册到上下文中。每个注解都具有特定的用途和语义，但它们都是@Component注解的特殊化版本。</p><p>注意事项：确保这些类在组件扫描的路径下，否则Spring将无法自动检测和注册这些组件。</p><p>优点：简单易用，易于理解。</p><p>缺点：使用注解，与Spring框架产生了耦合。</p><h3 id="2-使用-configuration和-bean注解：">2. 使用@Configuration和@Bean注解：</h3><p>使用方法：使用@Configuration注解标记配置类，而@Bean注解用于在配置类中定义Bean。在配置类中，每个带有@Bean注解的方法将生成一个Bean，方法的返回值类型决定了Bean的类型，方法名默认为Bean的名称。</p><blockquote><p>这种方式只会注入这个bean进去,而不会去扫描它内部的其他一些注入bean的注解</p></blockquote><p>注意事项：确保配置类在组件扫描的路径下。</p><p>优点：易于管理，可在一个配置类中集中定义多个Bean，提高代码的可维护性。</p><p>缺点：与Spring框架产生了耦合。</p><h3 id="3-使用java配置类和-beanfactorypostprocessor：">3. 使用Java配置类和@BeanFactoryPostProcessor：</h3><p>使用方法：在Java配置类中实现BeanFactoryPostProcessor接口，然后在<code>postProcessBeanFactory</code>方法中手动注册Bean。这种方式适用于更高级的用例，例如动态注册Bean。</p><p>注意事项：要确保实现了BeanFactoryPostProcessor接口的类被Spring扫描到。</p><p>优点：灵活，适用于高级用例和动态注册Bean。</p><p>缺点：相对复杂，需要更多的代码。</p><h3 id="4-使用xml配置文件：">4. 使用XML配置文件：</h3><p>使用方法：在XML文件中使用<code>&lt;bean&gt;</code>标签定义Bean，然后在启动类或配置类上使用@ImportResource注解导入XML配置文件。</p><p>注意事项：确保XML配置文件位于类路径下，且@ImportResource注解正确指向文件。</p><p>优点：与Spring框架的耦合相对较低，易于在不同项目中复用。</p><p>缺点：与Java配置相比，XML配置可读性较差，且需要额外维护一个配置文件。</p><p>总结：根据具体需求和场景选择合适的方式来定义和注册Bean。在大多数情况下，使用注解（如@Component、@Service等）和@Configuration类是最简单且推荐的方式，因为它们易于理解和维护。当有高级需求或需要动态注册Bean时，可以使用BeanFactoryPostProcessor。如果希望降低与Spring框架的耦合，可以考虑使用XML配置文件。</p><h2 id="作用域">作用域</h2><h2 id="注入方式">注入方式</h2><p>在Spring Boot中，有几种常见的注入Bean的方式。每种方式都有其适用场景、优缺点以及注意事项。以下是主要的注入方式：</p><h3 id="autowired">@Autowired</h3><p>可以使用@Autowired注解在<strong>字段、构造函数或方法上进行依赖注入</strong>。Spring会自动寻找与目标类型匹配的Bean并注入。</p><p>优点：</p><ul><li>易于使用，代码简洁。</li><li>能在字段、构造函数和方法上使用。</li></ul><p>缺点：</p><ul><li>依赖于Spring特定的注解，降低了代码的可移植性。</li></ul><p>注意事项：</p><ul><li>如果没有找到与目标类型匹配的Bean，<strong>Spring将抛出一个异常。为了避免这种情况，可以将@Autowired注解的required属性设置为false。</strong></li><li>当存在多个匹配的Bean时，**可以使用@Qualifier注解指定Bean的名称来消除歧义。**又或者说如果Bean有@Primary注解也可以优先被使用</li></ul><h3 id="resource">@Resource</h3><p>@Resource注解是JavaEE提供的注解，可用于字段和方法上。它根据名称或类型查找匹配的Bean。</p><p>优点：</p><ul><li>不依赖于Spring特定的注解，更具可移植性。</li><li>默认按名称查找Bean，当名称匹配失败时，再按类型查找。</li></ul><p>缺点：</p><ul><li><strong>不能用于构造函数上。</strong></li><li>功能相对较少。</li></ul><p>注意事项：</p><ul><li>当存在多个匹配的Bean时，可以设置@Resource注解的name属性来消除歧义。</li></ul><h3 id="inject">@Inject</h3><p>@Inject注解来自于Java的依赖注入规范（JSR-330），可用于字段、构造函数和方法上。它根据类型查找匹配的Bean。</p><p>优点：</p><ul><li>不依赖于Spring特定的注解，具有更好的可移植性。</li><li>能在字段、构造函数和方法上使用。</li></ul><p>缺点：</p><ul><li><strong>需要额外引入javax.inject依赖。</strong></li></ul><p>注意事项：</p><ul><li>如果没有找到与目标类型匹配的Bean，Spring将抛出一个异常。</li><li>当存在多个匹配的Bean时，可以使用@Named注解指定Bean的名称来消除歧义。</li></ul><h3 id="使用构造函数注入">使用构造函数注入</h3><p>通过在类的构造函数上添加@Autowired或@Inject注解，可以实现依赖注入。这是推荐的注入方式，因为它可以确保对象在创建时就已经注入了依赖，使得对象处于有效状态。</p><p>优点：</p><ul><li>可以确保对象在创建时就已经注入了依赖，使得对象处于有效状态。</li><li>有助于实现不可变对象，提高代码的健壮性。</li></ul><p>缺点：</p><ul><li>当注入大量依赖时，构造函数可能变得复杂。</li></ul><p>注意事项：</p><ul><li><strong>当使用构造函数注入时，如果只有一个构造函数，可以省略@Autowired或@Inject注解。</strong></li></ul><h2 id="import注解">@Import注解</h2><p>在Spring框架中，<code>@Import</code>注解用于导入其他的配置类。这个注解提供了一种方式来导入另一个或多个<code>@Configuration</code>类。以下是一些使用<code>@Import</code>注解的例子：</p><ol><li><strong>导入配置类</strong>：如果你有一些定义在其他配置类中的bean，你可以使用<code>@Import</code>注解来导入这些配置类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并返回数据源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(DatabaseConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 这个类现在可以使用DatabaseConfig类中定义的bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>导入ImportSelector接口的实现</strong>：<code>ImportSelector</code>是一个接口，它返回要导入的配置类的全类名。这个特性主要用于基于条件的配置。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">// 返回要导入的类的全类名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;com.example.DatabaseConfig&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 依据MyImportSelector的selectImports方法返回的类被导入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>导入ImportBeanDefinitionRegistrar接口的实现</strong>：如果你想编程地注册bean，你可以实现<code>ImportBeanDefinitionRegistrar</code>接口，并使用<code>@Import</code>注解来导入它。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里编程地注册bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// MyBeanDefinitionRegistrar将会被调用，以便在运行时注册bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，<code>@Import</code>注解在Spring中提供了一个强大的机制，可以用来导入配置类、普通类，或者基于<code>ImportSelector</code>和<code>ImportBeanDefinitionRegistrar</code>的更复杂的配置。</p><blockquote><p>如果 @Import导入的是一个普通类的话,就仅仅是加载它的bean定义信息,还有他本身,如果是其他两种情况的话, 会加载它指定的配置类信息或者bean信息,但是本身都不会被注册为bean</p></blockquote><h2 id="conditional注解">@Conditional注解</h2><p><code>@Conditional</code> 是 Spring Framework 4.0 引入的一个核心注解，用于基于满足某个特定条件来决定一个配置类、配置方法或者 Bean 是否需要被注册到 Spring 容器。</p><p><code>@Conditional</code> 注解的主要作用是条件化地注册 Bean。在实际开发中，我们可能会遇到这样的需求：只有在满足特定条件（比如某个类在类路径上、某个系统属性存在等）的情况下，才需要注册某个 Bean。<code>@Conditional</code> 就是解决这种问题的。</p><p>使用 <code>@Conditional</code> 注解需要提供一个实现了 <code>Condition</code> 接口的类，这个类定义了条件逻辑。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，只有当 <code>MyCondition</code> 的 <code>matches</code> 方法返回 <code>true</code> 时，<code>MyConfiguration</code> 配置类才会被加载，<code>myBean</code> Bean 才会被创建。</p><p>下面是 <code>Condition</code> 接口的一个简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以定义复杂的条件逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果返回 true，那么带有 @Conditional 注解的配置或 Bean 就会被加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot 还提供了一系列的 <code>Condition</code> 实现，比如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code> 等，这些都可以用于实现复杂的条件逻辑。</p><h2 id="aop">AOP</h2><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，用于将通用功能（如日志记录、安全检查等）从业务逻辑代码中分离出来，以提高代码的模块化程度。在 Spring Boot 中，可以使用 Spring AOP 框架实现 AOP 功能。以下是一些 AOP 相关的概念：</p><ol><li><p>Aspect（切面）：封装横切关注点（如日志记录、事务管理等）的模块。切面可以包含多个通知（Advice）。</p></li><li><p>Advice（通知）：在特定连接点（Join Point）执行的动作。根据执行时机的不同，通知可以分为前置通知、后置通知、环绕通知、异常通知和最终通知。</p></li><li><p>Pointcut（切点）：定义在哪些连接点应用通知的表达式。切点确定了通知应该在何时、何地执行。</p></li><li><p>Join Point（连接点）：程序执行过程中的某个特定点，如方法调用、异常抛出等。连接点是通知实际应用的地方。</p></li><li><p>Target（目标对象）：被通知的对象，即包含业务逻辑的对象。</p></li><li><p>Proxy（代理）：由 AOP 框架创建的目标对象的代理，用于在调用目标方法前后插入通知的逻辑。</p></li></ol><p>在 Spring Boot 中使用 AOP，通常需要进行以下步骤：</p><ol><li>引入依赖：首先，在 <code>pom.xml</code> 文件中引入 Spring AOP 相关依赖。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义切面：创建一个类，并使用 <code>@Aspect</code> 注解标注该类为切面。在切面类中，定义通知方法，并使用相应的通知注解（如 <code>@Before</code>、<code>@After</code>、<code>@Around</code> 等）标注这些方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.demo.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method called: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为 <code>LoggingAspect</code> 的切面，它包含一个前置通知方法 <code>logBefore</code>，用于在 <code>com.example.demo.service</code> 包下的所有方法执行前记录日志。</p><ol start="3"><li>配置 AOP：在 Spring Boot 中，AOP 通常是自动配置的。但是，在某些情况下，你可能需要自定义 AOP 的配置。在这种情况下，可以创建一个配置类，并使用 <code>@EnableAspectJAutoProxy</code> 注解开启 AOP 自动代理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopConfig</span> &#123;</span><br><span class="line"><span class="comment">// 可以在此处自定义 AOP 相关的 Bean 或配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通知">通知</h3><p>在通知方法中，可以使用一些特定的参数来获取关于目标方法和执行上下文的信息。以下是一些常用的通知方法参数：</p><ol><li><p>JoinPoint：表示连接点的对象，提供了许多与目标方法相关的信息。一般在前置通知（<code>@Before</code>）、后置通知（<code>@After</code>）、异常通知（<code>@AfterThrowing</code>）和最终通知（<code>@AfterReturning</code>）中使用。<code>JoinPoint</code> 接口提供了以下一些常用方法：</p><ul><li><code>Signature getSignature()</code>：获取目标方法的签名信息。</li><li><code>Object[] getArgs()</code>：获取目标方法的参数列表。</li><li><code>Object getTarget()</code>：获取目标对象，即包含业务逻辑的对象。</li><li><code>Object getThis()</code>：获取代理对象，即 AOP 框架创建的代理。</li><li><code>SourceLocation getSourceLocation()</code>：获取源代码位置信息。</li></ul></li><li><p>ProceedingJoinPoint：扩展自 <code>JoinPoint</code> 接口，表示可继续执行的连接点。一般在环绕通知（<code>@Around</code>）中使用。<code>ProceedingJoinPoint</code> 提供了一个额外的方法：</p><ul><li><code>Object proceed() throws Throwable</code>：执行目标方法。在环绕通知中，可以通过调用此方法来控制何时执行目标方法。</li></ul></li><li><p>MethodInvocation：表示方法调用连接点的对象。它扩展自 <code>JoinPoint</code> 接口，并提供了一些额外的方法，如 <code>Method getMethod()</code>（获取目标方法的 <code>java.lang.reflect.Method</code> 对象）。在 Spring AOP 中，<code>MethodInvocation</code> 接口的实例通常作为 <code>JoinPoint</code> 或 <code>ProceedingJoinPoint</code> 的实现。</p></li></ol><p>除了这些参数，还可以在通知方法中使用 <code>@annotation</code>、<code>@args</code>、<code>@target</code> 和 <code>@within</code> 等注解来绑定特定的目标方法参数、注解、目标对象类型等信息。例如，可以使用 <code>@annotation</code> 注解来获取目标方法上的自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.example.demo.service.*.*(..)) &amp;&amp; @annotation(myAnnotation)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint, MyAnnotation myAnnotation)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>logBefore</code> 方法有两个参数：<code>JoinPoint</code> 和 <code>MyAnnotation</code>。<code>MyAnnotation</code> 参数使用 <code>@annotation</code> 注解绑定目标方法上的 <code>MyAnnotation</code> 注解。这样，在通知方法中，可以访问目标方法上的 <code>MyAnnotation</code> 注解及其属性值。</p><p>了解这些参数及其用法可以帮助你在通知方法中获取关于目标方法和执行上下文的详细信息，从而实现更复杂的横切关注点逻辑。</p><h2 id="后置处理器">后置处理器</h2><h3 id="定义">定义</h3><p>Spring中有一些后置处理器，它们可以在Bean的生命周期中的不同阶段进行拦截，从而扩展或自定义Bean的行为。按照<strong>Bean在Spring容器中被加载的顺序</strong>，下面是一些常见的后置处理器及其用途和作用时机：</p><ol><li>BeanDefinitionRegistryPostProcessor：<br>用途：它允许在<strong>Bean定义被加载到容器之前，修改或添加Bean定义</strong>。可以用于动态注册Bean或修改Bean的元数据。<br>作用时机：在所有Bean定义被加载到容器之前，调用postProcessBeanDefinitionRegistry()方法。举个例子</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 GenericBeanDefinition 实例</span></span><br><span class="line">        <span class="type">GenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 bean 定义的属性</span></span><br><span class="line">        beanDefinition.setBeanClassName(<span class="string">&quot;com.example.MyService&quot;</span>);</span><br><span class="line">        beanDefinition.setScope(BeanDefinition.SCOPE_SINGLETON);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 bean 定义注册到 BeanDefinitionRegistry</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="string">&quot;myService&quot;</span>;</span><br><span class="line">        registry.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 不需要在这里做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>BeanFactoryPostProcessor：<br>用途：<strong>它允许在Bean定义被加载且尚未实例化Bean之前修改Bean的定义</strong>。主要用于修改Bean的配置元数据。<br>作用时机：在所有Bean定义都已加载到容器且还未实例化Bean时，调用postProcessBeanFactory()方法。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的beanFactoryPostProcessor被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>InstantiationAwareBeanPostProcessor：<br>用途：<strong>它允许在Bean实例化之前和之后进行自定义处理</strong>，例如替换Bean的实例、改变属性值等。<br>作用时机：在Bean实例化之前调用postProcessBeforeInstantiation()方法，实例化之后调用postProcessAfterInstantiation()方法，然后在设置属性前调用postProcessProperties()方法。</p></li><li><p>BeanPostProcessor：<br>用途：它允许在Bean初始化的时候执行一些自定义逻辑，例如修改Bean的属性或执行其他配置。对所有的Bean都生效。<br>作用时机：<strong>在Bean的初始化方法（如afterPropertiesSet()或自定义的init-method）之前和之后</strong>，分别调用postProcessBeforeInitialization()和postProcessAfterInitialization()方法。</p></li><li><p>DestructionAwareBeanPostProcessor：<br>用途：<strong>它允许在Bean销毁之前执行一些自定义逻辑，例如释放资源、清理缓存等</strong>。<br>作用时机：在Bean销毁之前调用postProcessBeforeDestruction()方法。</p></li></ol><p>按照Bean的加载顺序，这些后置处理器都在Bean的生命周期中的不同阶段起作用。通过实现相应的接口并注册到Spring容器，可以灵活地扩展Bean的行为。</p><h3 id="spring默认提供的后置处理器">spring默认提供的后置处理器</h3><p>Spring框架默认提供了一些内置的后置处理器，这些后置处理器负责处理各种功能和任务。以下是一些常见的内置后置处理器及其用途：</p><ol><li><p>ApplicationContextAwareProcessor：<br>用途：负责处理实现了ApplicationContextAware、ResourceLoaderAware、ApplicationEventPublisherAware和MessageSourceAware接口的Bean，为它们注入相应的依赖。</p></li><li><p>InitDestroyAnnotationBeanPostProcessor：<br>用途：<strong>处理带有@PostConstruct和@PreDestroy注解的Bean，分别在Bean初始化后和销毁前执行相应的方法。</strong></p></li><li><p>AutowiredAnnotationBeanPostProcessor：<br>用途：<strong>处理带有@Autowired、@Value和@Inject注解的Bean，负责自动装配Bean的属性、方法和构造函数。</strong></p></li><li><p>RequiredAnnotationBeanPostProcessor：<br>用途：处理带有@Required注解的Bean，确保标注了@Required注解的属性已经被设置，否则抛出异常。</p></li><li><p>CommonAnnotationBeanPostProcessor：<br>用途：<strong>处理带有@Resource、@PostConstruct和@PreDestroy注解的Bean，分别负责依赖注入和在Bean初始化后、销毁前执行相应的方法。</strong></p></li><li><p>EventListenerMethodProcessor：<br>用途：处理带有@EventListener注解的方法，将它们注册为事件监听器。</p></li><li><p>DefaultEventListenerFactory：<br>用途：为@EventListener注解的方法提供默认的事件监听器实例。</p></li><li><p>ConfigurationClassPostProcessor (<strong>BeanDefinitionRegistryPostProcessor</strong>)：<br>用途：<strong>处理带有@Configuration、@Bean、@ComponentScan、@Import和@PropertySource注解的配置类，负责解析和注册Bean定义。</strong></p></li><li><p>ScheduledAnnotationBeanPostProcessor：<br>用途：处理带有@Scheduled注解的方法，将它们注册为计划任务。</p></li></ol><p>这些内置后置处理器由Spring框架自动注册，并在不同的生命周期阶段处理各种功能和任务。它们使得开发人员能够更加便捷地使用Spring框架的功能。</p><h2 id="配置类与简化配置类">配置类与简化配置类</h2><p>在阅读源码的过程中看到了这么两条语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, &quot;full&quot;);</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, &quot;lite&quot;);</span><br></pre></td></tr></table></figure><p>经过查询后得到 一个是完整配置类,一个是简化配置类,  完整配置类是使用了@Configuration注解的类  而简化配置类是使用了 哪些组件注解的 比如 :</p><ul><li><code>@Component</code></li><li><code>@Service</code></li><li><code>@Repository</code></li><li><code>@Controller</code></li><li>还有@import导入的类</li></ul><p>完整配置类和简化配置类都可以在 Spring 中用于配置和创建 bean，但它们之间有一些关键区别：</p><ol><li><p>注解：完整配置类使用 <code>@Configuration</code> 注解，而简化配置类没有使用 <code>@Configuration</code> 注解。简化配置类通常使用 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 或 <code>@Controller</code> 注解。</p></li><li><p>Bean 方法调用：在完整配置类中，<code>@Bean</code> 方法之间的调用会遵循 Spring 容器的单例规则，即调用 <code>@Bean</code> 方法时，容器会返回已经创建的 bean 实例（如果存在的话）。在简化配置类中，<code>@Bean</code> 方法之间的调用不会遵循单例规则，而是直接创建新的实例。这意味着在简化配置类中，如果一个 <code>@Bean</code> 方法调用另一个 <code>@Bean</code> 方法，它将会创建一个新的实例，而不是返回容器中已经存在的 bean 实例。</p></li><li><p>CGLIB 代理：<strong>完整配置类会被 CGLIB 代理，以确保 <code>@Bean</code> 方法之间的调用遵循 Spring 容器的单例规则</strong>。简化配置类不会被 CGLIB 代理，因此它们的 <code>@Bean</code> 方法之间的调用行为与普通的 Java 方法调用相同。</p></li><li><p>适用场景：完整配置类主要用于集中管理和配置应用程序的 bean，通常会包含多个 <code>@Bean</code> 方法。简化配置类适用于将 bean 的定义散布在整个应用程序中，使其更接近使用 bean 的地方。这有助于保持代码的模块化和易于理解。</p></li></ol><p>总之，完整配置类和简化配置类的主要区别在于它们处理 <code>@Bean</code> 方法之间调用以及代理方式的不同。完整配置类提供了更严格的管理和控制，而简化配置类提供了更轻量级和灵活的方式来配置和定义 bean。在实际应用中，可以根据需求和场景选择使用哪种配置类。</p><p>完整配置类可以转换成简单配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false   //这样就不会生成代理类,也不会维护里面方法的相互依赖关系,每次调用方法都是生成一个新的对象</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><h1>spring boot</h1><h2 id="多余文件介绍">多余文件介绍</h2><p>从官网下过来的项目中会多处一部分跟maven相关的东西,我们来看看吧</p><p>Spring Boot项目中的<code>.mvn</code>文件夹以及<code>mvnw</code>和<code>mvnw.cmd</code>文件是Maven Wrapper的一部分。Maven Wrapper是一个方便的工具，让开发者可以在没有预先安装Maven的情况下运行Maven项目。</p><p>以下是这些文件的具体用途：</p><ol><li><p><code>.mvn</code>：这是一个文件夹，通常包含<code>wrapper</code>子文件夹以及一个<code>maven-wrapper.properties</code>文件，这个文件包含了Maven分发包的URL，Maven Wrapper会从这个URL下载对应版本的Maven。</p></li><li><p><code>mvnw</code>：这是一个Unix shell脚本，用于在Linux或Mac操作系统上运行Maven命令。使用这个脚本，你可以不必在你的机器上预先安装Maven，而是直接运行Maven项目。</p></li><li><p><code>mvnw.cmd</code>：这是一个Windows批处理文件，用于在Windows操作系统上运行Maven命令。与<code>mvnw</code>脚本类似，使用这个批处理文件，你可以不必在你的机器上预先安装Maven，而是直接运行Maven项目。</p></li></ol><p>这些文件的主要优点是它们使项目能够自我包含，并且不需要开发者预先安装特定版本的Maven。而且，由于这些文件将Maven的版本和分发包的URL存储在源代码中，因此它们还确保了项目的构建过程的一致性，无论是在不同的开发环境还是在持续集成服务器上。</p><h2 id="自动配置原理">自动配置原理</h2><p>Spring Boot 的自动配置是它的一个核心功能，它通过预先定义的默认配置和约定优于配置（Convention over Configuration）的原则，简化了应用程序的配置。自动配置的原理主要依赖以下几个关键技术：</p><ol><li><p>条件注解：Spring Boot 使用条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnBean</code>、<code>@ConditionalOnMissingBean</code> 等）来根据当前应用程序上下文和类路径的情况来决定是否应用某个配置。这些注解使得 Spring Boot 能够在满足特定条件时自动配置所需的组件。</p></li><li><p>自动配置类：Spring Boot 提供了许多自动配置类，它们是带有 <code>@Configuration</code> 注解的 Java 配置类，包含了一系列预定义的默认配置。这些自动配置类通常以 <code>AutoConfiguration</code> 结尾，例如 <code>DataSourceAutoConfiguration</code>、<code>WebMvcAutoConfiguration</code> 等。这些自动配置类会在应用程序启动时被加载，并根据条件注解决定是否应用这些默认配置。</p></li><li><p><code>spring.factories</code> 文件：<code>spring.factories</code> 文件是 Spring Boot 的一个关键配置文件，它位于 <code>META-INF</code> 目录下。该文件定义了许多自动配置类和启用器，它们在应用程序启动时被 Spring Boot 自动发现和加载。自动配置类和启用器都是通过 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 键列出的。</p></li><li><p><code>@EnableAutoConfiguration</code> 注解：这个注解通常在 Spring Boot 的主配置类或启动类上使用（通过 <code>@SpringBootApplication</code> 注解间接启用，因为 <code>@SpringBootApplication</code> 包含了 <code>@EnableAutoConfiguration</code>）。该注解负责激活自动配置功能，并从 <code>spring.factories</code> 文件中加载自动配置类。</p></li></ol><p>整个自动配置过程如下：</p><ol><li>当您的应用程序启动时，Spring Boot 会加载带有 <code>@SpringBootApplication</code> 注解的主类。</li><li><code>@SpringBootApplication</code> 注解包含了 <code>@EnableAutoConfiguration</code> 注解，这个注解会激活自动配置功能。</li><li>Spring Boot 读取 <code>spring.factories</code> 文件，<strong>加载并实例化其中定义的自动配置类</strong>。</li><li>对于每个自动配置类，Spring Boot 根据条件注解的结果决定是否应用它们。</li><li>在满足条件的情况下，自动配置类会将默认配置和相关组件注册到应用程序上下文中。</li></ol><p>通过这个自动配置原理，Spring Boot 能够在适当的时机为应用程序提供合适的默认配置，从而简化开发过程。当然，也可以覆盖这些默认配置，以满足特定的需求。</p><h2 id="配置文件">配置文件</h2><p>Spring Boot中的配置文件是用于配置应用程序的属性和参数的文件。Spring Boot支持多种类型的配置文件，包括属性文件、<strong>YAML文件</strong>、JSON文件等. 配置文件可以包含应用程序的所有配置参数，例如数据库连接信息、日志配置、服务器端口等。这些参数可以通过@ConfigurationProperties注解和@Value注解在应用程序中访问。</p><p>Spring Boot 提供了许多有用的特性，以简化配置文件的使用。以下是一些配置文件中的特殊用法：</p><h3 id="配置文件的多环境支持：">配置文件的多环境支持：</h3><p>Spring Boot <strong>支持使用不同的配置文件来区分不同的环境</strong>（如开发、测试和生产环境）。您可以在 <code>application.yml</code> 或 <code>application.properties</code> 文件中使用 <code>spring.profiles.active</code> 属性来激活特定的环境配置文件。例如，在 <code>application.yml</code> 文件中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p>这将激活名为 <code>application-dev.yml</code> 的配置文件。您还可以通过命令行参数或环境变量来覆盖此属性。</p><h3 id="配置文件中的占位符">配置文件中的占位符</h3><p>您可以在配置文件中使用 <code>$&#123;...&#125;</code> 占位符引用其他属性。例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app.message</span>=<span class="string">Hello, Spring Boot!</span></span><br><span class="line"><span class="attr">app.greeting</span>=<span class="string">$&#123;app.message&#125; Welcome to our application!</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>app.greeting</code> 的值将包含 <code>app.message</code> 的值。</p><h3 id="配置文件的优先级">配置文件的优先级</h3><p>Spring Boot 允许您将配置文件放在不同的位置，如项目的根目录、<code>config/</code> 目录、类路径等。不同位置的配置文件具有不同的优先级。例如，项目根目录下的 <code>application.properties</code> 文件的优先级高于类路径下的 <code>application.properties</code> 文件。这意味着在多个位置定义相同的属性时，具有较高优先级的配置文件中的值将覆盖较低优先级的配置文件中的值。</p><h3 id="使用-yaml-配置文件中的锚点和别名">使用 YAML 配置文件中的锚点和别名</h3><p>在 YAML 格式的配置文件中，您可以使用锚点（<code>&amp;</code>）和别名（<code>*</code>）来避免重复。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">dataSource:</span></span><br><span class="line">    <span class="attr">default:</span> <span class="meta">&amp;default</span></span><br><span class="line">      <span class="attr">driverClassName:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:h2:mem:testdb</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">primary:</span> <span class="meta">*default</span></span><br><span class="line">    <span class="attr">secondary:</span></span><br><span class="line">      <span class="string">&lt;&lt;:</span> <span class="meta">*default</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:h2:mem:anotherdb</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了锚点和别名来避免重复定义 <code>default</code> 数据源的属性。</p><h3 id="获取pom-xml的环境变量">获取pom.xml的环境变量</h3><p>在配置文件中使用&quot;@@&quot;通常是指使用<strong>Maven资源过滤器</strong>，用于将Maven构建过程中的<strong>项目属性值替换到配置文件中</strong>。</p><p>在Maven中，可以使用&quot;@变量名@“的形式来引用项目属性，例如”@artifactId@“引用项目的artifactId值，”@version@“引用项目的版本号等等。除了这些内置的变量之外，还可以在pom.xml文件中定义自己的属性，并在配置文件中使用”@@自定义变量名@@&quot;的形式来引用它们。</p><p>例如，在pom.xml文件中定义了一个自定义属性my-property：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-property</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">my-property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在配置文件中使用&quot;@@&quot;引用它：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.property.value</span>=<span class="string">@my-property@</span></span><br></pre></td></tr></table></figure><p>在Maven构建过程中，Maven会自动将&quot;@@&quot;语法替换成对应的属性值，因此上面的配置文件将被替换成：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.property.value</span>=<span class="string">hello world</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在配置文件中使用&quot;@@&quot;时，变量名需要与pom.xml文件中定义的属性名保持一致，否则无法正确地替换属性值。</p><blockquote><p>需要注意的是,配置文件里面的变量不区分大小写,环境变量也是</p></blockquote><h2 id="配置文件读取">配置文件读取</h2><p>在 Spring Boot 中，常用的配置文件格式有两种：<code>.properties</code> 和 <code>.yml</code>（或 <code>.yaml</code>）。Spring Boot 自动加载项目根目录下的 <code>application.properties</code> 或 <code>application.yml</code> 文件作为默认的配置文件。您可以使用以下方式来读取配置文件中的值：</p><h3 id="使用-value-注解">使用 <code>@Value</code> 注解</h3><p>在需要注入配置值的地方，使用 <code>@Value</code> 注解并指定配置的键。例如，假设 <code>application.properties</code> 文件中有一个属性 <code>app.message</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app.message</span>=<span class="string">Hello, Spring Boot!</span></span><br></pre></td></tr></table></figure><p>您可以使用 <code>@Value</code> 注解将该属性值注入到一个变量中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-configurationproperties-注解">使用 <code>@ConfigurationProperties</code> 注解</h3><p>为了更方便地管理和验证配置，您可以使用 <code>@ConfigurationProperties</code> 注解将配置文件中的属性值绑定到一个 Java 对象上。首先，创建一个带有 <code>@ConfigurationProperties</code> 注解的类，并为该类的字段添加 getter 和 setter 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>prefix = &quot;app&quot;</code> 表示将配置文件中以 <code>app</code> 为前缀的属性绑定到 <code>AppConfig</code> 类的字段上。</p><h3 id="使用-environment-对象">使用 <code>Environment</code> 对象</h3><p>在 Spring 中，您还可以使用 <code>Environment</code> 对象来访问配置文件中的属性值。首先，将 <code>Environment</code> 注入到您的组件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppConfig</span><span class="params">(Environment env)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.env = env;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(<span class="string">&quot;app.message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法适用于在运行时动态访问配置值的情况。</p><p>这些方法可以应用于不同的配置文件格式（<code>.properties</code> 或 <code>.yml</code>）。您可以根据实际需求和偏好选择合适的方式来读取配置文件中的值。</p><h2 id="配置文件优先级">配置文件优先级</h2><p>Spring Boot 允许将配置文件放在多个位置，它们具有不同的优先级。配置文件可以是 <code>application.properties</code> 或 <code>application.yml</code> 格式。以下是 Spring Boot 在寻找配置文件时的默认搜索顺序：</p><ol><li>当前目录下的 <code>/config</code> 子目录。</li><li>当前目录。</li><li>类路径下的 <code>/config</code> 包。</li><li>类路径的根目录。</li></ol><p>在这个顺序中，位于靠前位置的配置文件会优先加载，并且可能会覆盖后续位置的相同配置。例如，如果当前目录下的 <code>application.properties</code> 文件中有一个 <code>server.port</code> 配置，而类路径下的 <code>application.properties</code> 文件中也有一个 <code>server.port</code> 配置，那么当前目录下的配置会生效。</p><p>在这些位置中，类路径下的配置文件通常是打包在 JAR 文件中的。在运行 JAR 文件时，Spring Boot 会自动加载 JAR 包内的配置文件。你可以将配置文件放在 <code>src/main/resources</code> 或 <code>src/main/resources/config</code> 目录下，Maven 或 Gradle 会在构建过程中将它们打包到 JAR 文件中。</p><p>总之，是的，Spring Boot 会在运行时加载 JAR 包中的配置文件。</p><h2 id="配置源的优先级">配置源的优先级</h2><p>在Spring Boot中，配置文件的优先级是有明确规定的。Spring Boot将从多个位置读取配置，并根据特定的优先级对它们进行排序，高优先级的配置将覆盖低优先级的配置。</p><p>以下是一些主要的配置源及其优先级，从高到低：</p><ol><li>命令行参数</li><li><code>SPRING_APPLICATION_JSON</code>属性中的属性</li><li><code>ServletConfig</code>初始化参数</li><li><code>ServletContext</code>初始化参数</li><li>来自<code>java:comp/env</code>的JNDI属性</li><li>Java系统属性（<code>System.getProperties()</code>）</li><li>操作系统环境变量</li><li>只包含随机属性的<code>random.*</code>属性文件</li><li>位于当前目录的<code>.env</code>文件</li><li>如果不是<code>jar</code>包运行，位于应用程序目录的<code>application-&#123;profile&#125;.properties</code>或<code>application-&#123;profile&#125;.yml</code>以及<code>application.properties</code>或<code>application.yml</code></li><li>如果是<code>jar</code>包运行，位于应用程序<code>jar</code>包内部的<code>application-&#123;profile&#125;.properties</code>或<code>application-&#123;profile&#125;.yml</code>以及<code>application.properties</code>或<code>application.yml</code></li><li>在<code>@Configuration</code>类中通过<code>@PropertySource</code>注解指定的属性源</li><li>默认属性（使用<code>SpringApplication.setDefaultProperties</code>指定）</li></ol><p>以上是一些主要的配置源，实际上Spring Boot还支持更多的配置源，包括云服务的配置等。</p><h2 id="自定义starter">自定义starter</h2><h3 id="创建一个空maven项目">创建一个空maven项目</h3><p>修改配置文件如下:  分别配置坐标 和 引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.djm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>socket-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建自动配置类">创建自动配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyServerSocket.class)</span>  <span class="comment">// 导入要配置的东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要往容器中自动放入的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerSocket</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后续做准备</span></span><br><span class="line">    String hello;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建meta-inf-spring-factories文件">创建META-INF/spring.factories文件</h3><p>springboot项目在启动的时候,有个注解导入了一个自动扫描所有jar包下面的 META-INF/spring.factories文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.djm.SocketAutoConfiguration</span><br></pre></td></tr></table></figure><p>这里是一对键值组合, 键通常是一个接口或者一个注解，值则是一组实现了该接口或被该注解标记的类，用逗号分隔。不同的键值对做不同的事情, 以下是一些常见的键：</p><ol><li><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>：这是最常见的键，它用于指定应该由 Spring Boot 自动配置的类。当 Spring Boot 应用启动时，这些类将会被实例化，并且它们中定义的任何 bean 都会被添加到 Spring 应用上下文中。</li><li><code>org.springframework.context.ApplicationContextInitializer</code>：这个键用于指定应该在 Spring 应用上下文初始化期间执行的类。这些类可以用来进行一些自定义的初始化操作。</li><li><code>org.springframework.context.ApplicationListener</code>：这个键用于指定应该在 Spring 应用上下文中注册的 ApplicationListener 类，这些类可以用来监听和处理 Spring 发布的各种事件。</li><li><code>org.springframework.boot.SpringApplicationRunListener</code>：这个键用于指定在 Spring Boot 应用启动期间应该调用的监听器类。这些监听器可以用来自定义 Spring Boot 的启动过程。</li></ol><h3 id="打包-安装-发布-如果有需要的话">打包,安装,发布(如果有需要的话)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br><span class="line">mvn install</span><br><span class="line">mvn deploy</span><br></pre></td></tr></table></figure><h3 id="使用这个starter">使用这个starter</h3><p>新建一个springboot项目导入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.djm&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;socket-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我们可以查看是否自动注册了这个bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SocketAutoConfiguration1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(SocketAutoConfiguration.class);</span><br><span class="line">        MyServerSocket bean = run.getBean(MyServerSocket.class);</span><br><span class="line">        bean.sayHello();  // 输出  null 和 hello world  代表配置成功</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是,如果我们项目里面有了application.properties文件的话,jar包里面的application.properties是不会生效的,  比如我们在starter里面想要使用starter里面定义的配置文件的话这样是不行的, 而且也不推荐啊,我们可以使用一个资源类,然后给默认值不就行了?</strong>,比如:</p><p>修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my&quot;)</span>   <span class="comment">//定义好资源类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;我是jar包里面的hello&quot;</span>; <span class="comment">// 定义好默认值, 如果用户配置文件里面有 my.hello 自然可以覆盖  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHello</span><span class="params">(String hello)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyServerSocket <span class="title function_">myServerSocket</span><span class="params">(MyProperties properties)</span> &#123;</span><br><span class="line">        <span class="type">MyServerSocket</span> <span class="variable">myServerSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServerSocket</span>();</span><br><span class="line">        myServerSocket.setHello(properties.hello);</span><br><span class="line">        <span class="keyword">return</span> myServerSocket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="监听器">监听器</h2><h3 id="常用监听器与事件">常用监听器与事件</h3><p>Spring Boot中的监听器和事件是基于Spring框架的事件驱动模型。下面列出了一些常见的监听器和事件：</p><p>监听器（Listener）：</p><ol><li><p>ApplicationListener：这是一个通用的监听器接口，用于监听各种类型的事件。你可以实现此接口并根据需要定义自己的监听器。</p></li><li><p>ServletContextListener：这是Java Servlet规范中的监听器，用于在Web应用程序的生命周期中监听ServletContext的创建和销毁事件。</p></li><li><p>HttpSessionListener：这是Java Servlet规范中的监听器，用于在Web应用程序的生命周期中监听HttpSession的创建和销毁事件。</p></li><li><p>ServletRequestListener：这是Java Servlet规范中的监听器，用于在Web应用程序的生命周期中监听ServletRequest的创建和销毁事件。</p></li></ol><p>事件（Event）：</p><ol><li><p>ContextRefreshedEvent：当ApplicationContext初始化或刷新时触发此事件。</p></li><li><p>ContextStartedEvent：当ApplicationContext启动时触发此事件。</p></li><li><p>ContextStoppedEvent：当ApplicationContext停止时触发此事件。</p></li><li><p>ContextClosedEvent：当ApplicationContext关闭时触发此事件。</p></li><li><p>ServletContextInitializedEvent：当ServletContext初始化时触发此事件。</p></li><li><p>ServletContextDestroyedEvent：当ServletContext销毁时触发此事件。</p></li><li><p>HttpSessionCreatedEvent：当HttpSession创建时触发此事件。</p></li><li><p>HttpSessionDestroyedEvent：当HttpSession销毁时触发此事件。</p></li><li><p>ServletRequestInitializedEvent：当ServletRequest创建时触发此事件。</p></li><li><p>ServletRequestDestroyedEvent：当ServletRequest销毁时触发此事件。</p></li><li><p>ApplicationEnvironmentPreparedEvent：在应用环境准备完成且ApplicationContext创建之前触发此事件。</p></li><li><p>ApplicationPreparedEvent：在ApplicationContext创建完成但尚未刷新时触发此事件。</p></li><li><p>ApplicationReadyEvent：在ApplicationContext刷新并启动后触发此事件，此时应用已经准备好接受请求。</p></li><li><p>ApplicationFailedEvent：当应用启动失败时触发此事件。</p></li><li><p>SpringApplicationEvent：<strong>这是所有Spring Boot事件的基类，可以用于监听所有Spring Boot相关事件</strong>。</p></li></ol><p>通过实现监听器并监听相应的事件，你可以在应用程序的生命周期中的特定时刻执行特定操作。此外，你还可以创建自定义事件和监听器，以满足特定的业务需求。</p><h3 id="springboot启动过程中发出的事件">springboot启动过程中发出的事件</h3><p>Spring Boot在启动过程中会主动触发一系列事件，这些事件通常用于在应用程序生命周期的不同阶段执行特定的操作。以下是Spring Boot启动过程中的一些关键事件：</p><ol><li><p>ApplicationStartingEvent：在Spring Boot应用程序开始运行，但任何处理开始之前触发。这是启动过程中触发的第一个事件。</p></li><li><p>ApplicationEnvironmentPreparedEvent：在应用环境准备完成且ApplicationContext创建之前触发。此时，应用已经加载了配置文件并准备好了环境。</p></li><li><p>ApplicationContextInitializedEvent：在ApplicationContext准备好后触发，但在它被刷新前。此时，已经注册了bean定义，但bean实例还没有被创建。</p></li><li><p>ApplicationPreparedEvent：在ApplicationContext创建完成但尚未刷新时触发。此时，所有bean定义已经加载到容器中，但bean实例尚未创建。</p></li><li><p>ContextRefreshedEvent：当ApplicationContext初始化或刷新时触发。此时，所有bean已经被创建并初始化。 <strong>从这一步开始,我们通过注解定义的事件监听器才会响应事件</strong></p></li><li><p>ServletWebServerInitializedEvent：在嵌入式Servlet容器（如Tomcat、Jetty等）初始化完成时触发。此时，应用程序已经准备好处理HTTP请求。</p></li><li><p>ApplicationStartedEvent：在ApplicationContext刷新并启动后触发，但在任何应用程序和命令行运行器（ApplicationRunner和CommandLineRunner）开始之前。此时，应用程序已经准备好处理业务逻辑。</p></li><li><p>ApplicationReadyEvent：在所有应用程序和命令行运行器（ApplicationRunner和CommandLineRunner）执行完成后触发。此时，应用已经准备好接受请求，此事件表明应用已完全启动并处于运行状态。</p></li><li><p>ApplicationFailedEvent：当应用启动失败时触发。这个事件只有在启动过程中出现异常时才会触发。</p></li></ol><p>通过监听这些事件，你可以在应用程序的生命周期中的特定时刻执行特定操作。例如，在<code>ApplicationReadyEvent</code>触发时执行一些初始化任务，或者在<code>ApplicationFailedEvent</code>触发时执行错误处理操作。</p><h3 id="创建监听器">创建监听器</h3><h4 id="基于-eventlistener">基于@EventListener</h4><p>Spring Boot中的事件监听器允许您对应用程序中发生的事件进行响应。这些事件包括应用程序生命周期事件、自定义事件等。要使用事件监听器，请遵循以下步骤：</p><ol><li>创建事件：<br>如果您要监听的是自定义事件，首先需要创建一个事件类。自定义事件类需要继承<code>org.springframework.context.ApplicationEvent</code>。</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建事件监听器：<br>在需要监听事件的类中创建一个方法，该方法将在事件发生时被调用。然后使用<code>@EventListener</code>注解标记此方法，并指定要监听的事件类型。</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCustomEvent</span><span class="params">(CustomEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received custom event: &quot;</span> + event.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>发布事件：<br>要触发事件，需要将事件发布到应用程序上下文中。您可以通过注入<code>org.springframework.context.ApplicationEventPublisher</code>并调用其<code>publishEvent()</code>方法来实现。</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomEventPublisher</span><span class="params">(ApplicationEventPublisher eventPublisher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventPublisher = eventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishCustomEvent</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">CustomEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="built_in">this</span>, message);</span><br><span class="line">        eventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用事件监听器：<br>现在您已经准备好使用事件监听器。当您需要触发事件时，只需调用<code>CustomEventPublisher</code>中的<code>publishCustomEvent()</code>方法，事件监听器将自动响应事件。</li></ol><p>例如，在Controller类中使用<code>CustomEventPublisher</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEventController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomEventPublisher customEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomEventController</span><span class="params">(CustomEventPublisher customEventPublisher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customEventPublisher = customEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/triggerEvent&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">triggerEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        customEventPublisher.publishCustomEvent(<span class="string">&quot;Hello, this is a custom event!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Event triggered&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述步骤，您可以在Spring Boot应用程序中使用事件监听器来监听和响应特定事件。</p><h4 id="基于接口">基于接口</h4><p>有些事件并不支持上面那种方法,当然支持上面那种方法的,一定可以基于接口使用, 我们来定义一个session创建与销毁的监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHttpSessionEventListener</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;session创建: &quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;session销毁: &quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="actuator">actuator</h2><p>用来检测项目运行状况</p><p>搭配spring-boot-admin <strong>来可视化的监控</strong> spring-boot 程序的运行状态</p><h1>springMVC</h1><h2 id="异常类">异常类</h2><h3 id="httpmessagenotreadableexception">HttpMessageNotReadableException</h3><p>在 Spring Boot 应用程序中，HttpMessageNotReadableException 异常通常代表请求的消息无法读取或解析。这个异常通常是由于以下原因之一导致的：</p><ol><li>请求的 Content-Type 不正确：如果请求的 Content-Type 不正确，例如请求头中的 Content-Type 是 application/json，但请求体中的数据格式不是 JSON 格式，则会导致 HttpMessageNotReadableException 异常。</li><li>请求体中的数据格式不正确：如果请求体中的数据格式不正确，例如请求体中的 JSON 数据格式不符合要求，或者请求体中缺少必要的属性等，也会导致 HttpMessageNotReadableException 异常。</li><li>请求体中的数据长度不正确：如果请求体中的数据长度超出了服务器预期的范围，也可能导致 HttpMessageNotReadableException 异常。</li></ol><p>当发生 HttpMessageNotReadableException 异常时，Spring Boot 会自动返回一个 HTTP 400 Bad Request 响应，提示客户端请求的消息无法读取或解析。</p><h2 id="异常处理">异常处理</h2><p>通常使用controlleradvice来捕获异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler</span><span class="params">(Exception exception)</span>&#123; </span><br><span class="line">       <span class="keyword">return</span> exception.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下在<code>@ExceptionHandler</code>方法中可以使用的参数：</p><ol><li><p>异常参数：您可以将处理的异常类或其基类（如<code>Exception</code>、<code>RuntimeException</code>等）作为参数传递。这是必须的，用于捕获异常信息。</p></li><li><p><code>HttpServletRequest</code>：您可以将<code>HttpServletRequest</code>对象作为参数，以便访问与请求相关的信息，例如获取请求参数、请求头等。</p></li><li><p><code>HttpServletResponse</code>：您可以将<code>HttpServletResponse</code>对象作为参数，以便操作响应对象，例如设置响应状态码、响应头等。</p></li><li><p><code>WebRequest</code>或<code>NativeWebRequest</code>：您可以使用这些对象以一种与底层技术无关的方式访问请求和响应的属性。</p></li><li><p><code>Locale</code>：可以使用<code>Locale</code>对象获取客户端的区域设置信息。</p></li><li><p><code>Model</code>：可以将<code>Model</code>对象作为参数，以便向视图添加属性。在返回<code>ModelAndView</code>对象时，这可能会派上用场。</p></li><li><p><code>@ModelAttribute</code>：虽然在异常处理器中使用<code>@ModelAttribute</code>的情况较少，但您可以在需要时将带有<code>@ModelAttribute</code>注解的参数添加到方法中。</p></li></ol><p>请注意，一些常见的参数，如<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@RequestHeader</code>等，在异常处理器方法中是不支持的。需要使用<code>HttpServletRequest</code>对象来获取这些值。</p><p><strong>如果有多个异常处理器,最终只有一个异常处理器会生效</strong>,根据优先级来.</p><h2 id="过滤器">过滤器</h2><p>下面是定义过滤器的几种方式</p><h3 id="filterregistrationbean">FilterRegistrationBean</h3><p>在 Spring Boot 中，你可以通过实现 <code>javax.servlet.Filter</code> 接口并注册一个 <code>Filter</code> Bean 来创建一个过滤器。下面是创建一个简单过滤器的步骤：</p><ol><li>首先，创建一个 Java 类，实现 <code>javax.servlet.Filter</code> 接口。在这个类中，你需要实现 <code>init</code>、<code>doFilter</code> 和 <code>destroy</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化操作，例如加载配置、设置参数等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 在此处执行过滤逻辑，例如请求头检查、权限验证等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果符合过滤条件，继续执行后续过滤器和请求处理</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 清理操作，例如释放资源、清理缓存等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后，将创建的过滤器类注册为 Spring Bean 并配置过滤器顺序。你可以通过创建一个 <code>FilterRegistrationBean</code> Bean 来实现这一点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;MyFilter&gt; <span class="title function_">myFilterRegistration</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyFilter&gt; registration = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        registration.setFilter(<span class="keyword">new</span> <span class="title class_">MyFilter</span>());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>); <span class="comment">// 设置过滤器拦截的 URL 模式</span></span><br><span class="line">        registration.setOrder(<span class="number">1</span>); <span class="comment">// 设置过滤器的执行顺序</span></span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为 <code>MyFilter</code> 的过滤器，并通过 <code>FilterConfig</code> 类将其注册为一个 Spring Bean。<code>MyFilter</code> 会拦截所有的 URL（通过 <code>addUrlPatterns(&quot;/*&quot;)</code> 配置），并设置其执行顺序为 1（通过 <code>setOrder(1)</code> 配置）。</p><p>现在，每当有请求到达应用时，<code>MyFilter</code> 都会在请求进入控制器之前执行。你可以在 <code>doFilter</code> 方法中实现你的过滤逻辑，例如权限检查、日志记录等。</p><h3 id="component和-order-注解">@Component<code>和</code>@Order 注解</h3><p>在过滤器类上添加 <code>@Component</code> 和 <code>@Order</code> 注解，将过滤器作为 Spring Bean 进行注册，同时指定执行顺序。这种方式适用于需要 Spring 执行自动扫描的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化操作，例如加载配置、设置参数等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 在此处执行过滤逻辑，例如请求头检查、权限验证等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果符合过滤条件，继续执行后续过滤器和请求处理</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里是是请求处理结束了的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 清理操作，例如释放资源、清理缓存等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的方式适用于传统的springMVC,下面这两种可以用于springboot</p></blockquote><h3 id="使用-webfilter-注解：">使用 <code>@WebFilter</code> 注解：</h3><p>在过滤器类上添加 <code>@WebFilter</code> 注解，指定要拦截的 URL 模式。同时，需要在启动类上添加 <code>@ServletComponentScan</code> 注解以启用自动扫描。这种方式主要用于 Servlet 容器的过滤器，而不是 Spring 的过滤器，因此在过滤器中无法自动注入其他 Spring Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;myFilter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化操作，例如加载配置、设置参数等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 在此处执行过滤逻辑，例如请求头检查、权限验证等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果符合过滤条件，继续执行后续过滤器和请求处理</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 清理操作，例如释放资源、清理缓存等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类添加 <code>@ServletComponentScan</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器">拦截器</h2><h3 id="定义">定义</h3><p>在 Spring MVC 中，<code>HandlerInterceptor</code> 接口定义了三个方法，用于在请求处理的不同阶段执行自定义操作。这些方法分别是：</p><ol><li><p><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code>：在处理器（即 Controller 方法）执行之前调用。如果该方法返回 <code>true</code>，则请求继续向下执行；如果返回 <code>false</code>，则请求处理停止，不会调用后续的拦截器和处理器。这个方法通常用于权限控制、身份验证和请求参数校验等。</p></li><li><p><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code>：在处理器执行之后、视图渲染之前调用。这个方法可以用来修改数据模型、处理异常等。注意，如果 <code>preHandle</code> 返回 <code>false</code>，则不会调用 <code>postHandle</code>。</p></li><li><p><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code>：在请求处理完成后调用，即在视图渲染之后。这个方法通常用于清理资源、记录日志、监控性能等。<strong>即使在请求处理过程中发生异常，这个方法也会被调用。注意，如果 <code>preHandle</code> 返回 <code>false</code>，则不会调用 <code>afterCompletion</code>。</strong></p></li></ol><p>实现 <code>HandlerInterceptor</code> 接口时，你可以根据需要重写这些方法以实现自定义的请求拦截和处理逻辑。在实际应用中，你通常会继承 <code>HandlerInterceptorAdapter</code> 类，它提供了默认的空实现，这样你只需要重写需要的方法即可。</p><h3 id="使用">使用</h3><p>创建拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器与拦截器的区别">过滤器与拦截器的区别</h2><p>过滤器（Filter）和拦截器（Interceptor）都是用于处理Web应用程序中的请求和响应的。它们之间的主要区别在于作用范围、处理时机和功能。</p><ol><li><p>作用范围：</p><ul><li>过滤器（Filter）是基于Java Servlet规范的，适用于所有Java Web应用程序。它可以拦截所有进入Servlet容器的HTTP请求和响应，对它们进行预处理和后处理。</li><li>拦截器（Interceptor）是Spring MVC特有的，仅适用于使用Spring MVC框架的Web应用程序。它在Spring MVC处理请求的过程中起作用，主要拦截Controller方法的调用。</li></ul></li><li><p>处理时机：</p><ul><li>过滤器（Filter）在Servlet容器层面处理请求，所以它在请求进入Web应用程序之前和离开Web应用程序之后都起作用。因此，过滤器可以在请求被处理之前和响应被发送之前进行一些操作。</li><li>拦截器（Interceptor）在Spring MVC处理请求的过程中起作用，它在请求到达Controller方法之前、Controller方法处理完成后、视图渲染完成之后都可以执行相应的操作。</li></ul></li><li><p>功能：</p><ul><li>过滤器（Filter）可以用于对请求和响应进行通用处理，例如字符编码转换、安全检查、压缩响应等。</li><li>拦截器（Interceptor）更适用于处理与应用程序业务逻辑相关的操作，例如登录验证、权限控制、性能监控等。由于拦截器是Spring MVC特有的，所以它可以方便地访问Spring的依赖注入（DI）功能，以及其他Spring MVC组件。</li></ul></li></ol><p>总之，过滤器（Filter）和拦截器（Interceptor）都可以实现类似的功能，但由于它们在不同的处理阶段和层次起作用，所以它们的使用场景和优缺点也有所不同。根据具体的需求和应用程序架构，可以选择使用过滤器、拦截器或者它们的组合来实现所需的功能。</p><h2 id="权限校验的几种方式">权限校验的几种方式</h2><h3 id="过滤器">过滤器</h3><h3 id="拦截器">拦截器</h3><h3 id="aop-restcontrolleradvice">AOP + RestControllerAdvice</h3><p>AOP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.project.AOP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.project.excption.LoginError;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查用户是否登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.example.project.annotation.LoginCheckAnnotation)&quot;)</span>  <span class="comment">// 只对需要校验的方法进行检查</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">checkLogin</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();  <span class="comment">// 拿到request对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">userinfo</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;userinfo&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(userinfo == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginError</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RestControllerAdvice里面去检测这个异常就可以了</p><h2 id="请求响应流程">请求响应流程</h2><ol><li>接收请求：客户端（如浏览器或其他应用）向服务器发起 HTTP 请求。请求首先到达服务器上的 Web 服务器，例如 Tomcat、Jetty 或 Undertow。</li><li>过滤器（Filter）链：在请求到达 Spring Boot 应用之前，它会经过一系列的过滤器。这些过滤器可以用于处理跨域请求、安全性、编码等问题。过滤器按照定义的顺序依次执行。</li><li>请求进入 Spring DispatcherServlet：在过滤器链处理完成后，请求进入 Spring 的核心 Servlet，即 DispatcherServlet。DispatcherServlet 负责将请求路由到合适的控制器（Controller）方法。</li><li>解析请求映射：DispatcherServlet 查找与请求 URL 匹配的控制器方法。这是通过处理器映射（HandlerMapping）完成的，它会根据请求的 URL、HTTP 方法和其他条件找到匹配的控制器方法。</li><li>参数解析与数据绑定：在找到匹配的控制器方法后，Spring 会解析请求参数并将其绑定到方法参数上。这是通过参数解析器（ArgumentResolver）完成的。参数解析器可以处理各种类型的参数，例如路径参数、查询参数、请求体等。</li><li>参数校验：根据需要，Spring 可以对请求参数进行校验。例如，可以使用 JSR-303/JSR-380 校验注解（如 <code>@NotNull</code>、<code>@Size</code> 等）对请求参数进行校验。</li><li>执行控制器方法：参数解析和校验完成后，Spring 会调用匹配的控制器方法并传入解析后的参数。在控制器方法中，可以处理业务逻辑并返回响应数据。</li><li>AOP 切面：在执行控制器方法时，可以使用 AOP 为目标方法添加切面。切面可以包含前置通知（Before Advice）、后置通知（After Advice）、环绕通知（Around Advice）等，用于实现日志记录、权限控制等功能。</li><li>返回值处理：控制器方法执行完成后，Spring 会处理其返回值。返回值处理器（ReturnValueHandler）负责将返回值转换为最终的 HTTP 响应。例如，可以使用 <code>@ResponseBody</code> 注解将返回值序列化为 JSON，或者返回一个视图名称（如 “index”）以渲染 HTML 页面。</li><li>异常处理：在请求处理过程中，可能会抛出异常。这时，可以使用 <code>@ControllerAdvice</code> 或 AOP 的 <code>@Around</code> 通知来捕获和处理异常。异常处理方法可以根据异常类型返回不同的错误响应。</li><li>视图解析与渲染：如果控制器方法返回的是一个视图名称（例如 “index”），Spring 会使用视图解析器（ViewResolver）来找到与视图名称匹配的视图模板（如 Thymeleaf、Freemarker、JSP 等）。然后，视图模板将使用控制器方法返回的数据渲染 HTML 页面。</li><li>生成 HTTP 响应：经过视图渲染或返回值处理后，Spring 会将结果封装成一个 HTTP 响应。响应包括 HTTP 状态码、响应头和响应体。响应体可能包含 JSON 数据、HTML 页面等。</li><li>响应过滤器链：在发送响应给客户端之前，响应会经过一系列的过滤器。这些过滤器可以用于处理响应头、响应体等。与请求过滤器链类似，响应过滤器链中的过滤器按照定义的顺序依次执行。</li><li>发送响应：最后，Web 服务器将 HTTP 响应发送回客户端。客户端收到响应后可以解析响应数据并采取相应的操作。</li></ol><p>上面这个步骤其实还少了拦截器</p><h2 id="自定义资源处理">自定义资源处理</h2><p>springboot默认帮我们配置了不少的资源路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">staticPathPattern</span> <span class="operator">=</span> <span class="string">&quot;/**&quot;</span>; </span><br></pre></td></tr></table></figure><p>当然如果不想使用就直接禁用掉,这样就省去了一个资源处理器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后自定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>); <span class="comment">// 这样的话,所有的/static请求都会去使用资源路径,也不一定,如果有controller的路径跟我们对上了,那肯定那个处理器优先,里面有一套排序规则的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有个高级的用法就是addResourceLocations里面可以使用文件系统的路径,这就方便很多了啊,我们可以使用配置文件的方法很灵活的放置和取资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;filePath&#125;&quot;)</span></span><br><span class="line">    String path;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="string">&quot;file:&quot;</span>+path+<span class="string">&quot;/&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点">注意点</h3><ul><li><p>如果有多个资源处理器能够处理这个路径, 那么会选择最符合的资源处理器去处理这个请求, 但是如果两个资源处理器的优先级一样,那就是谁先定义谁被使用,  而且在springboot中,永远有一个/**的默认处理器为我们兜底,前提是你没关闭它</p></li><li><p><strong>如果一个资源处理器被选择了, 即使它不能处理这个路径的资源,那么它就会抛出404,而不是交给下一个能处理这个资源的处理器</strong>,比如你定义了两个/** 和 /static 路径的资源处理器,  当你处理/static路径的时候  会选择 /static路径的资源处理器, 如果它不能处理,也不会去选择/**处理器了,而是响应404回去</p></li></ul><h2 id="自定义404异常处理">自定义404异常处理</h2><p>404在springMVC中分为两种, 第一种是没有处理器对应, 第二种是资源处理器里面没有对应资源, 如果看过源码的话,就知道springboot默认给我们提供一个兜底的资源处理器,它能够处理任何路径, <strong>因此就算开启找不到处理器抛出异常这个选项, ControllerAdvice也没有机会去捕获异常,因为无论如何都有资源处理器去处理,</strong> 除非你放弃使用资源处理器,然后开启没有异常处理抛出异常</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样的话,能够使用ControllerAdvice去处理404异常</p><p>但是我们一般要使用静态资源,所有我们<strong>一般是重写一个ErrorController 去处理404异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyErrorController</span> <span class="keyword">implements</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/error&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">notFound</span><span class="params">(HttpServletRequest httpServletRequest)</span>&#123;</span><br><span class="line">        <span class="comment">// 这里要注意,如果是springboot3.0的话 就是jakarta开头了</span></span><br><span class="line">      <span class="keyword">if</span>(httpServletRequest.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>).equals(HttpStatus.NOT_FOUND.value()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;404 not found&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;500 error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义数据转换">自定义数据转换</h2><h3 id="converter和formatter">Converter和Formatter</h3><p>Converter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToPersonConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Person&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(source);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>formatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.Formatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span>&lt;LocalDate&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalDate <span class="title function_">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(text, formatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(LocalDate object, Locale locale)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formatter.format(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册他们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        registry.addFormatter(<span class="keyword">new</span> <span class="title class_">LocalDateFormatter</span>());</span><br><span class="line">        registry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToPersonConverter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="httpmessageconverter">HttpMessageConverter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHttpMessageConvert</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpMessageConverter</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHttpMessageConvert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(MediaType.APPLICATION_JSON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class == clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">readInternal</span><span class="params">(Class&lt;? extends User&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的httpMessage被执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().readValue(inputMessage.getBody(),clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeInternal</span><span class="params">(User user, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的httpMessage被执行&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValue(outputMessage.getBody(),user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span></span><br><span class="line"><span class="comment">        converters.add(new MyHttpMessageConvert());</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;  <span class="comment">// 注意这里要使用这个,如果使用上面这个,那么就只会留下我们自己的</span></span><br><span class="line">        converters.add(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">MyHttpMessageConvert</span>());  <span class="comment">// 这里我们把它放在最前面,增加优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别">区别</h3><p><code>Converter</code>：</p><ol><li>它是Spring的一个核心接口，用于在类型之间进行转换，例如在<strong>表单数据绑定到Java对象</strong>时，或者在@PathVariable注解的参数转换时。</li><li>它主要用于将一种数据类型转换为另一种数据类型。例如，将一个字符串转换为一个日期对象或自定义类型。</li><li><code>Converter</code>通常在数据绑定或类型转换过程中使用。</li><li><strong>它不关心HTTP请求或响应的内容，仅关注类型之间的转换。</strong></li></ol><p><code>HttpMessageConverter</code>：</p><ol><li>它是Spring MVC中的一个接口，<strong>用于处理HTTP请求和响应中的内容</strong>。</li><li>它主要用于将请求体中的数据转换为Java对象（反序列化），或者将Java对象转换为响应体中的数据（序列化）。</li><li><code>HttpMessageConverter</code>通常与<code>@RequestBody</code>和<code>@ResponseBody</code>注解一起使用，<strong>以将请求和响应中的数据与Java对象进行转换。</strong></li><li>它关注HTTP请求和响应的内容，以及将数据与Java对象之间进行序列化和反序列化。</li></ol><p>总结一下：</p><ul><li><code>Converter</code>主要用于在类型之间进行转换，例如将字符串转换为自定义对象。它通常在数据绑定过程中使用，与HTTP请求和响应的内容无关。</li><li><code>HttpMessageConverter</code>主要用于处理HTTP请求和响应中的数据。它负责将请求体中的数据转换为Java对象，以及将Java对象转换为响应体中的数据。它与<code>@RequestBody</code>和<code>@ResponseBody</code>注解一起使用。</li></ul><h2 id="跨域问题">跨域问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> @Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">        registry.addMapping(&quot;/file/**&quot;).allowedOrigins(&quot;*&quot;).allowedMethods(&quot;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点">注意点</h2><ol><li>springMVC中有很多的一次性注解,它会将输入流里面东西读出来,因此在使用的时候要特别注意,不要多次使用,比如@RequestBody这种</li><li>使用HttpMessageConverter 放入自己的转换器的时候,要注意extendMessageConverters() 和 configureMessageConverters() 的区别</li></ol><h1>Mybatis-Plus</h1><h2 id="导入依赖">导入依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.3.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置数据源">配置数据源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><h2 id="命名规则">命名规则</h2><p>在 MyBatis-Plus 中，数据库表名、字段名和 Java 对象名（实体类名）及其属性名之间的映射关系通常遵循以下规则：</p><ol><li>数据库表名与实体类名：<ul><li>数据库表名通常使用下划线命名法，例如 <code>user_info</code>。</li><li>Java 实体类名应使用驼峰命名法（Pascal Case），例如 <code>UserInfo</code>。</li><li>如果数据库表名与实体类名不匹配，可以使用 <code>@TableName</code> 注解指定实体类对应的数据库表名，例如 <code>@TableName(&quot;user_info&quot;)</code>。</li></ul></li><li>数据库字段名与实体类属性名：<ul><li>数据库字段名通常使用下划线命名法，例如 <code>first_name</code>。</li><li>Java 实体类属性名应使用小驼峰命名法（Camel Case），例如 <code>firstName</code>。</li><li>如果数据库字段名与实体类属性名不匹配，可以使用 <code>@TableField</code> 注解指定属性对应的数据库字段名，例如 <code>@TableField(&quot;first_name&quot;)</code>。</li></ul></li></ol><p>在 MyBatis-Plus 的默认配置下，框架会自动将下划线命名法的数据库表名和字段名映射到驼峰命名法的实体类名和属性名。因此，只要遵循这些命名规则，通常不需要额外的注解来指定映射关系。</p><p>当然，如果您的项目有特殊的命名规则，您可以根据实际需求调整这些映射关系。使用 <code>@TableName</code> 和 <code>@TableField</code> 注解可以灵活地定制实体类与数据库表之间的映射关系。</p><blockquote><p>一定要注意Mybatis-Plus和springboot版本的关系,切记切记</p></blockquote><h2 id="属性名字或者类名与关键字冲突">属性名字或者类名与关键字冲突</h2><p>使用TableName 和 TableField</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;message&quot;)</span>  <span class="comment">// 指定表名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span>  <span class="comment">// 自增</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="meta">@TableField(&quot;`like`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> like;  <span class="comment">// 这里与关键字冲突,用双引号加反引号</span></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> carId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>尽量不要跟关键字冲突</p></blockquote><h2 id="代码生成">代码生成</h2><p>导入依赖,这两个搭配才能生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 AutoGenerator 对象</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 配置数据源</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dataSourceConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dataSourceConfig.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSourceConfig.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSourceConfig.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSourceConfig.setPassword(<span class="string">&quot;mysql666.&quot;</span>);</span><br><span class="line">        generator.setDataSource(dataSourceConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 配置全局策略</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        globalConfig.setOutputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        globalConfig.setAuthor(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">        globalConfig.setOpen(<span class="literal">false</span>);</span><br><span class="line">        generator.setGlobalConfig(globalConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 配置包信息</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">packageConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        packageConfig.setParent(<span class="string">&quot;com.example&quot;</span>);</span><br><span class="line">        packageConfig.setModuleName(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        generator.setPackageInfo(packageConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 配置生成策略</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategyConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategyConfig.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategyConfig.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">        strategyConfig.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        strategyConfig.setInclude(<span class="string">&quot;car_info&quot;</span>,<span class="string">&quot;message&quot;</span>,<span class="string">&quot;order&quot;</span>,<span class="string">&quot;user&quot;</span>); <span class="comment">// 要生成的表名</span></span><br><span class="line">        generator.setStrategy(strategyConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 执行生成</span></span><br><span class="line">        generator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行一遍即可</p><p><strong>他就会帮我们生成好实体类与mapper还有service,还有controller</strong></p><blockquote><p>推荐使用插件而不是这种方式</p></blockquote><h2 id="映射文件编写">映射文件编写</h2><p>映射文件是MyBatis框架中用于描述数据库操作和Java对象之间映射关系的XML文件。它包含了执行SQL操作所需的各种信息，如SQL语句、输入参数、返回结果等。映射文件可以将SQL语句和Java代码分离，使得代码更易于维护和阅读。映射文件通常以<code>.xml</code>为扩展名，并位于项目的资源文件夹（如<code>src/main/resources</code>）中。</p><p>映射文件的基本结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.YourMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SQL操作映射，例如select、insert、update、delete等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;!DOCTYPE ...&gt;</code>：这是DTD（Document Type Definition）声明，用于指定XML文档的验证规则。对于MyBatis映射文件，它需要指定MyBatis 3映射文件的DTD。</li><li><code>&lt;mapper&gt;</code>：映射文件的根元素，包含一个<code>namespace</code>属性，用于指定映射接口的完全限定类名。映射文件中的所有SQL操作映射都应位于此元素中。</li></ol><h3 id="sql标签">sql标签</h3><p><strong>这个元素可以用来定义可重用的 SQL 代码片段</strong>，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t1&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="sql映射标签">SQL映射标签</h3><p><code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>和<code>&lt;delete&gt;</code>这四个标签用于定义不同类型的SQL操作。它们有一些共同的属性，也有各自独有的属性。下面分别列出这些标签的属性及其用途。</p><p><strong>共同属性</strong>：</p><ol><li><p><code>id</code>（必需）：指定映射语句的唯一标识符，对应Java接口中的方法名。在<code>&lt;mapper&gt;</code>元素内，<code>id</code>属性的值必须唯一。</p></li><li><p><code>parameterType</code>（可选）：指定输入参数的Java类型。可以是完全限定类名或类型别名。如果方法参数是单个基本类型或者简单的Java对象，可以省略此属性。</p></li><li><p><code>flushCache</code>（可选）：指定是否在执行此映射语句后清空一级缓存。默认值为<code>false</code>对于<code>&lt;select&gt;</code>，<code>true</code>对于<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>和<code>&lt;delete&gt;</code>。</p></li><li><p><code>timeout</code>（可选）：指定此映射语句的超时时间（以秒为单位）。如果未指定，则使用全局默认超时时间。</p></li></ol><p><strong><code>&lt;select&gt;</code>独有属性</strong>：</p><ol><li><p><code>resultType</code>（可选）：指定返回结果的Java类型。可以是完全限定类名或类型别名。对于简单类型和单个Java对象，可以使用此属性。如果返回结果需要自定义映射规则，应该使用<code>resultMap</code>属性。</p></li><li><p><code>resultMap</code>（可选）：指定一个自定义<code>&lt;resultMap&gt;</code>来处理返回结果。如果返回结果需要自定义映射规则，应该使用此属性，而不是<code>resultType</code>。</p></li><li><p><code>fetchSize</code>（可选）：指定JDBC驱动程序每次获取的记录数。此属性对于处理大量数据时非常有用，因为它可以降低内存占用。不过，此属性的实际行为取决于JDBC驱动程序的实现。</p></li><li><p><code>resultSetType</code>（可选）：指定<code>ResultSet</code>的类型。可选值有<code>FORWARD_ONLY</code>（只向前滚动）、<code>SCROLL_SENSITIVE</code>（可滚动，但对数据库更改敏感）和<code>SCROLL_INSENSITIVE</code>（可滚动，对数据库更改不敏感）。默认值为<code>undefined</code>，即使用JDBC驱动程序的默认设置。</p></li><li><p><code>useCache</code>（可选）：指定是否启用二级缓存。默认值为<code>true</code>。</p></li></ol><p><strong><code>&lt;insert&gt;</code>独有属性</strong>：</p><ol><li><p><code>keyProperty</code>（可选）：指定用于保存自动生成主键的Java对象属性。仅在使用自动生成主键的数据库时有效。</p></li><li><p><code>keyColumn</code>（可选）：指定用于保存自动生成主键的数据库列。仅在使用自动生成主键的数据库时有效。</p></li><li><p><code>useGeneratedKeys</code>（可选）：<strong>指定是否使用数据库自动生成的主键。默认值为<code>false</code>。如果设置为<code>true</code>，MyBatis会尝试获取数据库生成的主键，并将其赋值给<code>keyProperty</code>指定的Java对象属性。</strong></p></li><li><p><code>statementType</code>（可选）：指定SQL语句的类型。可选值有<code>PREPARED</code>（预编译SQL语句，默认值）、<code>CALLABLE</code>（调用存储过程）和<code>STATEMENT</code>（普通SQL语句）。</p></li></ol><p><strong><code>&lt;update&gt;</code>和<code>&lt;delete&gt;</code>独有属性</strong>：</p><ol><li><code>statementType</code>（可选）：与<code>&lt;insert&gt;</code>标签的<code>statementType</code>属性相同，指定SQL语句的类型。可选值有<code>PREPARED</code>（预编译SQL语句，默认值）、<code>CALLABLE</code>（调用存储过程）和<code>STATEMENT</code>（普通SQL语句）。</li></ol><p>这些属性使得MyBatis在处理各种SQL操作时具有很高的灵活性。通过为这些标签提供不同的属性值，可以调整SQL操作的行为以满足特定的需求。</p><h3 id="结果映射">结果映射</h3><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。<strong>它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来</strong>，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p><p>对于映射类型 <strong>如果没有指定别名的话,一般需要全路径类名</strong>,我们可以配置type-aliases-package来指定别名,就能直接使用类名</p><p>对于这么一个对象,我们来举例resultType的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    Long id;</span><br><span class="line">    String name;</span><br><span class="line">    Long age;</span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式配置">隐式配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;com.djm.pojo.User&quot;&gt;</span><br><span class="line">    select * from user where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>这里需要User里面属性名字 与 字段名字相同(<strong>规则映射相同,不是名字完全相同,比如字段名字是下划线分割,属性名是小驼峰</strong>),  如果不同的话我们也可以通过设置字段别名,但是对于字段很多的话,使用又频繁的话,建议使用显示配置,我们举个设置字段别名的例子, 我们把user改成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    Long id;</span><br><span class="line">    String myName;</span><br><span class="line">    Long age;</span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select *,name my_name from user where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h4 id="显示配置">显示配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;</span><br><span class="line">       &lt;result property=&quot;myName&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">   &lt;/resultMap&gt;</span><br><span class="line">   &lt;select id=&quot;getUser&quot; resultMap =&quot;userResultMap&quot;&gt;</span><br><span class="line">       select * from user where id=#&#123;id&#125;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure><p><strong>其实我们也只需要配置不同的地方就行了,但是为了能够多处使用,建议写全</strong></p><p>resultMap里面的子配置项:</p><p>在MyBatis的<code>&lt;resultMap&gt;</code>元素中，可以使用以下子配置项来定义映射关系和处理复杂关系。以下是常见的子配置项及其意义：</p><ol><li><p><code>&lt;id&gt;</code>：用于指定实体类的主键属性与数据库表中的主键列之间的映射关系。<code>property</code>属性指定实体类中的属性名，<code>column</code>属性指定数据库表中的列名。</p></li><li><p><code>&lt;result&gt;</code>：用于指定普通实体类属性与数据库表列之间的映射关系。与<code>&lt;id&gt;</code>类似，<code>property</code>属性指定实体类中的属性名，<code>column</code>属性指定数据库表中的列名。</p></li><li><p><code>&lt;association&gt;</code>：用于定义一对一关系。<code>property</code>属性指定实体类中的属性名，<code>javaType</code>属性指定关联实体类的完全限定类名。<code>&lt;association&gt;</code>元素内部可以包含<code>&lt;id&gt;</code>、<code>&lt;result&gt;</code>、<code>&lt;constructor&gt;</code>等子元素来描述关联实体类的映射关系。</p></li><li><p><code>&lt;collection&gt;</code>：用于定义一对多关系。<code>property</code>属性指定实体类中的属性名，<code>ofType</code>属性指定集合元素类型的完全限定类名。<code>&lt;collection&gt;</code>元素内部可以包含<code>&lt;id&gt;</code>、<code>&lt;result&gt;</code>、<code>&lt;constructor&gt;</code>等子元素来描述集合元素的映射关系。</p></li><li><p><code>&lt;constructor&gt;</code>：用于指定实体类的构造方法参数与数据库表列之间的映射关系。<code>&lt;constructor&gt;</code>元素内部可以包含<code>&lt;idArg&gt;</code>和<code>&lt;arg&gt;</code>子元素。</p><ul><li><code>&lt;idArg&gt;</code>：用于指定作为构造方法参数的主键属性与数据库表中的主键列之间的映射关系。其用法类似于<code>&lt;id&gt;</code>。</li><li><code>&lt;arg&gt;</code>：用于指定作为构造方法参数的普通属性与数据库表列之间的映射关系。其用法类似于<code>&lt;result&gt;</code>。</li></ul></li><li><p><code>&lt;discriminator&gt;</code>：用于实现基于数据库表列值的映射结果类型判断。<code>column</code>属性指定用于判断的数据库表列名，<code>javaType</code>属性指定该列对应的Java类型。<code>&lt;discriminator&gt;</code>元素内部可以包含<code>&lt;case&gt;</code>子元素来定义不同列值对应的映射关系。</p><ul><li><code>&lt;case&gt;</code>：用于定义<code>&lt;discriminator&gt;</code>中特定列值对应的映射关系。<code>value</code>属性指定列值，<code>resultType</code>属性指定映射结果的完全限定类名。<code>&lt;case&gt;</code>元素内部可以包含<code>&lt;id&gt;</code>、<code>&lt;result&gt;</code>、<code>&lt;constructor&gt;</code>等子元素来描述映射关系。</li></ul></li></ol><p>举个列子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.example.entity.User&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;user_id&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt;</span><br><span class="line">    &lt;association property=&quot;profile&quot; javaType=&quot;com.example.entity.Profile&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;profile_id&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;phone&quot; property=&quot;phone&quot; /&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">    &lt;collection property=&quot;orders&quot; ofType=&quot;com.example.entity.Order&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;order_id&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;order_number&quot; property=&quot;orderNumber&quot; /&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态sql">动态SQL</h3><p>动态SQL是MyBatis中的一种功能，它使你能够根据参数、条件等动态地构建和修改SQL语句。动态SQL提高了代码的可读性和灵活性，尤其在处理复杂查询、条件过滤和分页等场景时非常有用。</p><p>以下是MyBatis中常用的动态SQL元素及其用途：</p><ol><li><p><code>&lt;if&gt;</code>：条件判断，只有当条件成立时，才会包含<code>&lt;if&gt;</code>元素内的SQL片段。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUsers&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">      AND username = #&#123;username&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;email != null&quot;&gt;</span><br><span class="line">      AND email = #&#123;email&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>当<code>username</code>和<code>email</code>参数不为<code>null</code>时，相应的条件将被包含在查询语句中。</p></li><li><p><code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>和<code>&lt;otherwise&gt;</code>：类似于Java的<code>switch</code>语句，用于根据条件选择不同的SQL片段。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUsers&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;choose&gt;</span><br><span class="line">      &lt;when test=&quot;username != null&quot;&gt;</span><br><span class="line">        username = #&#123;username&#125;</span><br><span class="line">      &lt;/when&gt;</span><br><span class="line">      &lt;when test=&quot;email != null&quot;&gt;</span><br><span class="line">        email = #&#123;email&#125;</span><br><span class="line">      &lt;/when&gt;</span><br><span class="line">      &lt;otherwise&gt;</span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">      &lt;/otherwise&gt;</span><br><span class="line">    &lt;/choose&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>当<code>username</code>不为<code>null</code>时，查询将根据<code>username</code>进行；当<code>username</code>为<code>null</code>且<code>email</code>不为<code>null</code>时，查询将根据<code>email</code>进行；否则，查询将根据<code>id</code>进行。</p></li><li><p><code>&lt;where&gt;</code>：用于生成<code>WHERE</code>子句，可以包含动态元素。它会自动处理开头的<code>AND</code>或<code>OR</code>关键字。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUsers&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">      username = #&#123;username&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;email != null&quot;&gt;</span><br><span class="line">      AND email = #&#123;email&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;where&gt;</code>元素会自动处理开头的<code>AND</code>关键字，生成有效的SQL语句。</p></li><li><p><code>&lt;set&gt;</code>：用于生成<code>SET</code>子句，常用于<code>UPDATE</code>语句。它会自动处理结尾的逗号。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">  UPDATE users</span><br><span class="line">  &lt;set&gt;</span><br><span class="line">    &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">      username = #&#123;username&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;email != null&quot;&gt;</span><br><span class="line">      email = #&#123;email&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/set&gt;</span><br><span class="line">  WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;set&gt;</code>元素会自动处理结尾的逗号，生成有效的SQL语句。</p></li><li><p><code>&lt;foreach&gt;</code>：用于遍历集合或数组，并对每个元素执行相同的SQL片段。<code>&lt;foreach&gt;</code>元素可以生成<code>IN</code>子句，或用于批量插入、更新、删除操作。示例：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUsersByIds&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  WHERE id IN</span><br><span class="line">  &lt;foreach item=&quot;id&quot; index=&quot;index&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">    #&#123;id&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>当<code>ids</code>参数为一个包含多个<code>id</code>值的集合时，<code>&lt;foreach&gt;</code>元素会生成一个<code>IN</code>子句，查询所有匹配的用户。</p></li><li><p><code>&lt;trim&gt;</code>：用于自定义SQL片段的前缀、后缀、前缀覆盖和后缀覆盖。<code>&lt;trim&gt;</code>元素内可以包含动态元素，如<code>&lt;if&gt;</code>。<code>&lt;trim&gt;</code>元素提供了比<code>&lt;where&gt;</code>和<code>&lt;set&gt;</code>更高的灵活性。 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">  UPDATE users</span><br><span class="line">  &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">      username = #&#123;username&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;email != null&quot;&gt;</span><br><span class="line">      email = #&#123;email&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/trim&gt;</span><br><span class="line">  WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;trim&gt;</code>元素会根据指定的前缀和后缀覆盖规则生成SQL片段，使得SQL语句更加灵活。</p></li><li><p><code>&lt;bind&gt;</code>：用于创建一个变量，并将其绑定到指定的表达式。<code>&lt;bind&gt;</code>元素可以用于计算中间结果，或在多个地方重复使用相同的表达式。 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code&lt;select id=&quot;findUsers&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;/&gt;</span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">      username LIKE #&#123;pattern&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;bind&gt;</code>元素创建了一个名为<code>pattern</code>的变量，将其绑定到一个包含通配符的表达式，用于模糊查询。</p></li></ol><p>通过组合使用这些动态SQL元素，你可以根据不同的条件和参数值生成灵活、可维护的SQL语句。动态SQL在处理复杂查询、条件过滤和分页等场景时非常有用。</p><h3 id="与">$ 与#</h3><p>在MyBatis中，<code>$</code>和<code>#</code>都用于在SQL语句中插入参数值，但它们的用途和行为有所不同。</p><ol><li><p><code>#&#123;&#125;</code>：使用<code>#</code>括起来的参数表示预编译参数。MyBatis会将这些参数值作为预编译语句的参数进行传递，这样可以避免SQL注入的风险。此外，MyBatis会根据参数类型自动进行类型处理，例如将Java中的<code>Date</code>类型转换为数据库中的<code>TIMESTAMP</code>类型。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = #&#123;username&#125;</span><br></pre></td></tr></table></figure><p>当<code>username</code>参数为<code>'admin'</code>时，生成的SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = ?</span><br></pre></td></tr></table></figure><p>在执行SQL语句时，MyBatis会将<code>'admin'</code>作为预编译参数传递给数据库。</p></li><li><p><code>$&#123;&#125;</code>：使用<code>$</code>括起来的参数表示直接插入参数值。MyBatis会将这些参数值直接替换到SQL语句中，而不会进行预编译。这样做可能会导致SQL注入的风险。因此，你应该谨慎使用<code>$</code>，尽量避免在可控制的参数上使用它。<code>$</code>通常用于动态表名、列名等无法通过预编译参数实现的场景。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users ORDER BY $&#123;columnName&#125; $&#123;order&#125;</span><br></pre></td></tr></table></figure><p>当<code>columnName</code>参数为<code>'username'</code>，<code>order</code>参数为<code>'ASC'</code>时，生成的SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users ORDER BY username ASC</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>#&#123;&#125;</code>：用于预编译参数，安全且支持类型处理。</li><li><code>$&#123;&#125;</code>：用于直接插入参数值，可能导致SQL注入，谨慎使用。</li></ul><p>在大多数情况下，你应该优先使用<code>#&#123;&#125;</code>作为参数占位符，以保证安全和正确的类型处理。只有在必要的时候，如动态表名、列名等，才考虑使用<code>$&#123;&#125;</code>。</p><h2 id="mapper位置扫描">Mapper位置扫描</h2><p>在Spring Boot应用中，<code>@MapperScan</code>注解和配置文件中的<code>mybatis.mapper-locations</code>配置都可以用于指定MyBatis的mapper接口和XML映射文件的位置。<strong>这两者是互补的，它们会合并而不是替换</strong>。这意味着，如果您在<code>@MapperScan</code>注解中指定了一个包路径，并且在配置文件中也指定了一个或多个文件路径，那么MyBatis将会扫描这些路径，加载所有符合条件的mapper接口和XML映射文件。</p><h2 id="配置项">配置项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String configLocation;  <span class="comment">//MyBatis 配置文件（如：mybatis-config.xml）的位置,一般不用</span></span><br><span class="line"><span class="keyword">private</span> String[] mapperLocations = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span>&#125;; <span class="comment">//XML 映射文件的位置，可以使用通配符来指定多个文件</span></span><br><span class="line"><span class="keyword">private</span> String typeAliasesPackage; <span class="comment">// 别名包，用于为实体类自动创建别名</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; typeAliasesSuperType; <span class="comment">//为继承自某个类的子类创建别名</span></span><br><span class="line"><span class="keyword">private</span> String typeHandlersPackage;  <span class="comment">// 类型处理器包，用于指定自定义类型处理器所在的包</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">checkConfigLocation</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否检查配置文件的存在。如果设置为 true，则会在找不到配置文件时抛出异常。</span></span><br><span class="line"><span class="keyword">private</span> ExecutorType executorType;  <span class="comment">// MyBatis 的执行器类型（如：SIMPLE、REUSE、BATCH）</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">LanguageDriver</span>&gt; defaultScriptingLanguageDriver;  <span class="comment">// 默认的脚本语言驱动</span></span><br><span class="line"><span class="keyword">private</span> Properties configurationProperties; <span class="comment">// 自定义配置项。</span></span><br><span class="line"><span class="meta">@NestedConfigurationProperty</span></span><br><span class="line"><span class="keyword">private</span> MybatisConfiguration configuration;  <span class="comment">//MyBatis 的配置，可以用来配置一些 MyBatis 原生的特性。</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> MybatisMapperRegistry mybatisMapperRegistry; <span class="comment">// MyBatis 映射器注册表</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Cache&gt; caches; <span class="comment">//MyBatis 缓存对象的映射</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps; <span class="comment">// 结果映射的映射</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps; </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, XNode&gt; sqlFragments;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements; <span class="comment">//映射语句的映射</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> useGeneratedShortKey; <span class="comment">//是否使用自动生成的短键名</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">private</span> String typeEnumsPackage; <span class="comment">// 枚举类型的包名（已弃用）</span></span><br><span class="line"><span class="meta">@NestedConfigurationProperty</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> GlobalConfigUtils.defaults()</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">banner</span> <span class="operator">=</span> <span class="literal">true</span>;  <span class="comment">//是否在启动时显示 MyBatis-Plus 的 Banner 信息，默认为 true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enableSqlRunner</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否启用 SQL 运行器，它允许在项目启动后直接运行 SQL，而无需编写映射器和服务类，默认为 false</span></span><br><span class="line">    <span class="keyword">private</span> GlobalConfig.DbConfig dbConfig;  <span class="comment">//MyBatis-Plus 的数据库配置，用于配置数据库相关的参数</span></span><br><span class="line">  <span class="keyword">private</span> IdType idType; <span class="comment">//主键类型，用于配置实体类的主键生成策略（如：AUTO、INPUT、UUID 等）。</span></span><br><span class="line">            <span class="keyword">private</span> String tablePrefix; <span class="comment">// 表前缀，用于自动映射实体类和数据库表之间的关系</span></span><br><span class="line">            <span class="keyword">private</span> String schema; <span class="comment">// 数据库 schema，用于指定查询时的默认 schema</span></span><br><span class="line">            <span class="keyword">private</span> String columnFormat; <span class="comment">//列名格式化，用于自定义数据库列名的格式</span></span><br><span class="line">            <span class="keyword">private</span> String propertyFormat; <span class="comment">// 属性名格式化，用于自定义实体类属性名的格式</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> replacePlaceholder; <span class="comment">// 是否替换占位符，默认为 false。</span></span><br><span class="line">            <span class="keyword">private</span> String escapeSymbol; <span class="comment">// 转义符，用于在 SQL 中转义特殊字符。</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> tableUnderline; <span class="comment">//是否使用表名下划线分隔，默认为 true。</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> capitalMode;  <span class="comment">// 是否使用大写命名，默认为 false。</span></span><br><span class="line">            <span class="keyword">private</span> List&lt;IKeyGenerator&gt; keyGenerators; </span><br><span class="line">            <span class="keyword">private</span> String logicDeleteField;</span><br><span class="line">            <span class="keyword">private</span> String logicDeleteValue;</span><br><span class="line">            <span class="keyword">private</span> String logicNotDeleteValue;</span><br><span class="line">            <span class="keyword">private</span> FieldStrategy insertStrategy;</span><br><span class="line">            <span class="keyword">private</span> FieldStrategy updateStrategy;</span><br><span class="line">            <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">            <span class="meta">@Deprecated</span></span><br><span class="line">            <span class="keyword">private</span> FieldStrategy selectStrategy;</span><br><span class="line">            <span class="keyword">private</span> FieldStrategy whereStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ISqlInjector</span> <span class="variable">sqlInjector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlInjector</span>(); <span class="comment">//SQL 注入器，用于向 MyBatis-Plus 添加自定义的 SQL 方法，默认为 DefaultSqlInjector</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; superMapperClass = Mapper.class; <span class="comment">// Mapper 接口的超类，所有的 Mapper 接口都应继承这个超类，默认为 Mapper.class。</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory; <span class="comment">//MyBatis 的 SqlSessionFactory 实例，用于创建 SqlSession。</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mapperRegistryCache = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListSet</span>(); <span class="comment">//映射器注册缓存，存储已注册的 Mapper 接口。</span></span><br><span class="line">    <span class="keyword">private</span> MetaObjectHandler metaObjectHandler; <span class="comment">// 元对象处理器，用于自动填充实体类中的字段。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">PostInitTableInfoHandler</span> <span class="variable">postInitTableInfoHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PostInitTableInfoHandler</span>() &#123;</span><br><span class="line">    &#125;; <span class="comment">//表信息初始化后的处理器，允许您在表信息初始化后自定义一些操作。</span></span><br><span class="line">    <span class="keyword">private</span> IdentifierGenerator identifierGenerator; <span class="comment">//标识符生成器，用于自定义实体类的主键生成策略</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1>Spring Security</h1><h2 id="基础的安全概念">基础的安全概念</h2><p>在计算机安全中，主要涉及到两个基本概念：身份验证(Authentication)和授权(Authorization)。</p><ol><li><p><strong>身份验证(Authentication)</strong>：身份验证是确认用户身份的过程，通常涉及用户名和密码，但也可能包括更复杂的过程，如两步验证和数字证书。当用户首次访问系统时，他们会被要求提供凭证，如用户名和密码，系统将根据这些凭证确认用户的身份。在 Spring Security 中，身份验证过程由 AuthenticationManager 接口管理。</p></li><li><p><strong>授权(Authorization)</strong>：一旦用户的身份得到确认，下一步就是确定他们可以访问系统的哪些资源，以及他们可以执行哪些操作，这就是授权过程。例如，一个用户可能被授权读取一个文件，但不能删除它。另一个用户可能被授权修改该文件，但不能查看它。在 Spring Security 中，授权过程由 AccessDecisionManager 接口管理。</p></li></ol><p>理解这两个概念是学习 Spring Security 的基础。在应用程序中，我们需要根据用户的角色和权限对资源进行保护，只有经过正确的身份验证和授权的用户才能访问这些资源。在接下来的学习中，我们将更深入地探讨这两个概念，并学习如何在 Spring Security 中实现身份验证和授权。</p><h2 id="基本定义">基本定义</h2><p>Spring Security 是一个用于为 Java 应用程序提供身份验证和授权功能的安全框架。在 Spring Boot 中，Spring Security 可以轻松集成，提供自动配置和默认安全设置。以下是 Spring Security 在 Spring Boot 应用中的工作机制和工作流程：</p><ol><li><p>配置和启动：当 Spring Boot 检测到 Spring Security 在 classpath 中时，它会自动启用 Spring Security，并提供基本的安全配置。你可以通过在配置文件中添加自定义配置或创建自定义的 <code>WebSecurityConfigurerAdapter</code> 类来覆盖默认配置。</p></li><li><p>过滤器链：Spring Security 在应用中使用 Servlet 过滤器链来处理 HTTP 请求。过滤器链中包含多个过滤器，负责处理不同的安全功能，如身份验证、授权、跨站请求伪造保护（CSRF）等。当一个请求到达应用时，它首先经过过滤器链的处理。</p></li><li><p>身份验证：在过滤器链中，<code>UsernamePasswordAuthenticationFilter</code> 负责处理基于表单的登录请求。<strong>这个过滤器会尝试从请求中提取用户名和密码</strong>，然后将它们封装成一个 <code>Authentication</code> 对象。接着，<code>AuthenticationManager</code> 负责处理这个 <code>Authentication</code> 对象，将其传递给相应的 <code>AuthenticationProvider</code>，如 <code>DaoAuthenticationProvider</code>。<code>AuthenticationProvider</code> 会调用 <code>UserDetailsService</code> 来加载用户的详细信息（如密码、角色等），并将其与请求中提供的凭据进行比较。如果凭据匹配，<code>AuthenticationProvider</code> 会返回一个已认证的 <code>Authentication</code> 对象，包含用户的详细信息和授权。</p></li><li><p>授权：Spring Security 使用 <code>AccessDecisionManager</code> 来处理授权决策。当一个已认证的请求尝试访问受保护的资源时，<code>AccessDecisionManager</code> 会检查用户的授权（如角色、权限等）是否允许访问该资源。如果用户具有相应的授权，请求将被允许访问资源；否则，将返回一个 HTTP 403（Forbidden）响应。</p></li><li><p>异常处理：Spring Security 使用 <code>AuthenticationEntryPoint</code> 和 <code>AccessDeniedHandler</code> 来处理身份验证和授权异常。例如，当未认证的用户尝试访问受保护资源时，<code>AuthenticationEntryPoint</code> 会返回一个 HTTP 401（Unauthorized）响应，通常会引导用户登录。当已认证的用户尝试访问不具有权限的资源时，<code>AccessDeniedHandler</code> 会返回一个 HTTP 403（Forbidden）响应。</p></li><li><p>会话管理：Spring Security 提供了会话管理功能，包括创建新会话、超时设置和并发控制等。此外，Spring Security 支持持久化会话数据，以便在应用重启后还能保持会话状态。</p></li><li><p>注销：Spring Security 提供了注销功能，允许用户安全地结束会话并清除相关的认证信息。默认情况下，用户可以通过访问 <code>/logout</code> URL 发起注销请求。<code>LogoutFilter</code> 负责处理这些请求，并调用配置的 <code>LogoutHandler</code> 实现来执行注销操作，如清除安全上下文、使当前会话失效、删除持久化的会话数据等。注销完成后，可以将用户重定向到指定的 URL，通常是登录页面或主页。</p></li><li><p>记住我：Spring Security 支持“记住我”功能，允许用户在关闭浏览器或会话过期后仍然保持登录状态。该功能通过在用户浏览器中设置一个特殊的 cookie 来实现。在接收到请求时，<code>RememberMeAuthenticationFilter</code> 会检查这个 cookie，如果存在并有效，它会自动为用户创建一个已认证的安全上下文，无需重新登录。你可以在配置中启用和自定义“记住我”功能，例如设置 cookie 的有效期、加密密钥等。</p></li><li><p>跨站请求伪造（CSRF）保护：Spring Security 提供了 CSRF 保护功能，可以防止恶意网站伪造用户的请求。默认情况下，Spring Security 会为所有的 POST、PUT、DELETE 等非幂等请求启用 CSRF 保护。要实现这个功能，<code>CsrfFilter</code> 会在每个请求中查找一个名为 <code>_csrf</code> 的 token（通常以参数或 HTTP 头的形式传递），并将其与服务器端存储的 token 进行比较。如果 token 不存在或不匹配，请求将被拒绝。开发者需要在表单提交和 AJAX 请求中正确携带 CSRF token，以确保请求能够通过验证。</p></li><li><p>跨域资源共享（CORS）配置：Spring Security 支持 CORS 配置，允许在不同域名之间进行安全的资源共享。你可以通过 <code>WebSecurityConfigurerAdapter</code> 定义全局或特定的 CORS 策略，例如允许的源、请求方法、头部等。</p></li><li><p>自定义扩展：Spring Security 提供了许多扩展点，允许开发者根据需求定制安全功能。例如，你可以实现自定义的 <code>UserDetailsService</code>、<code>AuthenticationProvider</code>、<code>AccessDecisionVoter</code> 等，以支持特定的认证和授权策略。此外，Spring Security 支持 OAuth2、OpenID Connect、SAML 等多种身份验证和单点登录（SSO）协议，可以通过添加相应的依赖和配置来集成这些协议。</p></li></ol><h2 id="核心组件">核心组件</h2><p>Spring Security 是一个功能强大且可高度自定义的身份验证和访问控制框架。以下是其主要的核心接口和组件：</p><ol><li><p><code>Authentication</code>：这是一个接口，保存了主体的详细信息。当用户成功登录后，所有的详细信息都会被存储在这个对象中。</p></li><li><p><code>AuthenticationManager</code>：这是一个接口，它定义了一个方法 <code>authenticate()</code>，该方法可以从任何位置调用以进行身份验证。</p></li><li><p><code>ProviderManager</code>：这是 AuthenticationManager 的一个实现。它迭代通过 ProviderManager 配置的 AuthenticationProvider 列表。</p></li><li><p><code>AuthenticationProvider</code>：这是一个接口，它的实现提供了一个方式来获取用户详细信息。</p></li><li><p><code>UserDetailsService</code>：这是一个接口，它定义了一个方法 <code>loadUserByUsername()</code>。这个方法在任何位置都可以调用，以获取用户详细信息。</p></li><li><p><code>GrantedAuthority</code>：这是一个接口，代表应用程序的认证对象的授权，即角色和权限。</p></li><li><p><code>SecurityContextHolder</code>：这是一个类，它用于存储当前线程的安全上下文，包括当前用户的详细信息。</p></li><li><p><code>SecurityContext</code>：这是一个接口，用于保存 Authentication 和可能的任何其他需要的信息。</p></li><li><p><code>AccessDecisionManager</code>：这是一个接口，用于做访问控制决策。</p></li><li><p><code>FilterSecurityInterceptor</code>：这是一个类，它处理所有 HTTP 请求并检查安全性。它是 Spring Security Web 安全的核心组件。</p></li></ol><p>以上就是 Spring Security 中的一些主要接口和组件。要注意的是，Spring Security 的设计是可插拔的，这意味着这些接口和组件可以根据需要进行自定义和替换。</p><h2 id="核心过滤器">核心过滤器</h2><p>在Spring Security 5中，有16个主要的过滤器，它们按照执行顺序如下：</p><ol><li><p><code>ChannelProcessingFilter</code>：处理请求的安全通道，例如http与https。</p></li><li><p><code>SecurityContextPersistenceFilter</code>：在<code>HttpSession</code>中存储并提取<code>SecurityContext</code>，在每个请求上下文中保持用户身份。</p></li><li><p><code>ConcurrentSessionFilter</code>：在用户登录时检查并限制同时登录的会话数量。</p></li><li><p><code>HeaderWriterFilter</code>：向HTTP响应中添加安全头，如X-XSS-Protection，X-Content-Type-Options。</p></li><li><p><code>CsrfFilter</code>：<strong>提供跨站请求伪造（CSRF）保护，验证请求中的CSRF token</strong>。</p></li><li><p><code>LogoutFilter</code>：处理用户的注销，清除用户的认证信息和会话。</p></li><li><p><code>UsernamePasswordAuthenticationFilter</code>：处理基于表单的认证请求，即用户名和密码的认证。</p></li><li><p><code>DefaultLoginPageGeneratingFilter</code>：如果应用没有定义登录页面，这个过滤器将生成一个默认的登录页面。</p></li><li><p><code>DefaultLogoutPageGeneratingFilter</code>：如果应用没有定义注销页面，这个过滤器将生成一个默认的注销页面。</p></li><li><p><code>BasicAuthenticationFilter</code>：处理HTTP Basic认证请求。</p></li><li><p><code>RequestCacheAwareFilter</code>：检查并使用缓存的请求，例如在登录前访问的受保护资源。</p></li><li><p><code>SecurityContextHolderAwareRequestFilter</code>：向请求中添加安全上下文凭据，如用户身份。</p></li><li><p><code>AnonymousAuthenticationFilter</code>：为未认证的用户创建一个匿名的<code>Authentication</code>，使你能够对未认证的用户进行授权决策。</p></li><li><p><code>SessionManagementFilter</code>：处理会话管理，包括固定会话保护和并发会话控制。</p></li><li><p><code>ExceptionTranslationFilter</code>：捕获Spring Security引发的异常并启动认证流程或发送HTTP 403状态码。</p></li><li><p><code>FilterSecurityInterceptor</code>：最后的过滤器，它根据用户的认证信息和访问的URL，决定用户是否有权限访问该资源。</p></li></ol><p>这是Spring Security的默认过滤器链，但你可以根据你的需求对其进行定制和扩展。</p><p>这样过滤器最终都会被执行他们就像函数递归一样, 先自己做一点事情  然后开始递归下去, 等到递归完毕后  自己再做一点事情, 这些过滤器最主要的就是做三件事,  认证, 授权, 保护</p><h2 id="鉴权">鉴权</h2><p>spring sercurity给我们提供了权限校验的功能, 对于那些需要权限的接口, 它会去检测用户的凭证信息, 查看它是否具有这个权限访问这个接口, 鉴权可以在配置类中声明,也可以在方法上声明</p><p>配置类中声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests()</span><br><span class="line">               .antMatchers(&quot;/hello&quot;).hasAuthority(&quot;admin&quot;) // 这个接口需要admin权限</span><br><span class="line">               .antMatchers(&quot;/test1&quot;).hasAuthority(&quot;p1&quot;) // 这个接口需要p1权限</span><br></pre></td></tr></table></figure><p>方法上声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 开启方法注解支持</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">@EnableMethodSecurity</span><br><span class="line">public class SecurityConfig </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line"> @PreAuthorize(&quot;hasAuthority(&#x27;admin&#x27;)&quot;)</span><br><span class="line"> public String login() &#123;</span><br><span class="line">     return &quot;hello world&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="失败处理">失败处理</h2><h3 id="认证失败处理">认证失败处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUnauthorizedHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置类里面修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.exceptionHandling().authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">MyUnauthorizedHandler</span>()); <span class="comment">// 添加自定义的未认证处理</span></span><br></pre></td></tr></table></figure><h3 id="鉴权失败处理">鉴权失败处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;没有权限访问&quot;</span>);</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类里面修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.exceptionHandling().accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">MyAccessDeniedHandler</span>()); <span class="comment">// 添加自定义的未授权处理器</span></span><br></pre></td></tr></table></figure><h2 id="自定义认证">自定义认证</h2><p>spring Security 的自定义实际上涵盖了三个主要的部分：</p><ol><li><p><strong>用户信息的获取</strong>：这个部分是关于如何从请求中提取用户的身份信息。例如，这可能包含从请求头中提取一个token，或者从请求参数或体中提取用户名和密码。你需要自定义一个部分来告诉 Spring Security 如何获取这些信息。这一部分需要自定义过滤器去处理</p></li><li><p><strong>认证过程</strong>：这个部分描述了验证用户身份的过程。你需要自定义一个认证处理器，告诉 Spring Security 如何根据提供的信息判断用户的身份是否有效。这可能涉及到与数据库的交互，或者与第三方身份验证服务的交互。这一部分可以用AuthenticationProvider去处理,也可以在过滤器中处理</p></li><li><p><strong>用户信息的加载与比对</strong>：这个部分是指定如何从你的数据源（例如数据库或者其他服务）加载用户的详细信息，并与获取到的用户信息进行比对。你需要自定义一个“用户详情服务”，来告诉 Spring Security 如何加载用户数据并进行比对。可以用UserDetailsService,也可以自己用其他方法拿到用户存好的信息</p></li></ol><p>这三个步骤构成了自定义 Spring Security 的基础框架。通过这样的设计，Spring Security 能够在一个统一的框架内处理各种各样的身份验证方法，同时还能够保持很高的灵活性，适应各种复杂的需求场景。</p><h2 id="自定义token认证">自定义token认证</h2><h3 id="创建身份信息">创建身份信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class JwtAuthenticationToken extends AbstractAuthenticationToken &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String token;</span><br><span class="line"></span><br><span class="line">    public JwtAuthenticationToken(String token) &#123;</span><br><span class="line">        super(null);</span><br><span class="line">        this.token = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JwtAuthenticationToken(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123;</span><br><span class="line">        super(authorities);</span><br><span class="line">        setAuthenticated(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getCredentials() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getPrincipal() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getToken() &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建验证器">创建验证器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class JwtAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        JwtAuthenticationToken jwtAuthenticationToken = (JwtAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">        if(!TokenUtil.isOk(jwtAuthenticationToken.getToken()))&#123;</span><br><span class="line">            return jwtAuthenticationToken; // 验证失败,直接返回未验证的信息,如果后面还有过滤器的话,交给他们看他们能不能处理</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 验证成功,设置为已验证</span><br><span class="line">        jwtAuthenticationToken.setAuthenticated(true);</span><br><span class="line">        JSONObject map =  TokenUtil.parseToken(jwtAuthenticationToken.getToken());</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; stringList = map.getBeanList(&quot;authorities&quot;, String.class);</span><br><span class="line"></span><br><span class="line">        stringList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = new LinkedList&lt;&gt;();</span><br><span class="line">        stringList.forEach(s -&gt; authorities.add(new SimpleGrantedAuthority(s)));</span><br><span class="line">        // 生成一个已验证的JwtAuthenticationToken,并把authorities和map设置进去</span><br><span class="line">        JwtAuthenticationToken jwtAuthenticationToken1 = new JwtAuthenticationToken(authorities);</span><br><span class="line">        jwtAuthenticationToken1.setDetails(map);</span><br><span class="line">        return jwtAuthenticationToken1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">        // 判断传进来的authentication是不是JwtAuthenticationToken的子类,如果是就返回true,表示支持</span><br><span class="line">        return authentication.isAssignableFrom(JwtAuthenticationToken.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建过滤器">创建过滤器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">    public static String HEADER = &quot;Authorization&quot;;</span><br><span class="line">    public static String TYPE = &quot;Bearer &quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        String header = request.getHeader(HEADER);</span><br><span class="line">        if(header != null &amp;&amp; header.startsWith(TYPE))&#123;</span><br><span class="line">            String token = header.substring(TYPE.length());</span><br><span class="line"></span><br><span class="line">            JwtAuthenticationToken jwtAuthenticationToken = new JwtAuthenticationToken(token);</span><br><span class="line">            Authentication authenticate = authenticationManager.authenticate(jwtAuthenticationToken);</span><br><span class="line">            if(authenticate != null &amp;&amp; authenticate.isAuthenticated())&#123;</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authenticate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自定义登录请求">自定义登录请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public Map&lt;String,Object&gt; login(@RequestBody Map&lt;String,Object&gt; map)&#123;</span><br><span class="line">        String username = (String) map.get(&quot;username&quot;);</span><br><span class="line">        String password = (String) map.get(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        User user = userService.getUserByUsername(username);</span><br><span class="line"></span><br><span class="line">        if(user == null) &#123;</span><br><span class="line">            return Map.of(&quot;code&quot;,200,&quot;msg&quot;,&quot;用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(!user.getPassword().equals(password)) &#123;</span><br><span class="line">            return Map.of(&quot;code&quot;,200,&quot;msg&quot;,&quot;密码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String, Object&gt; data = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        data.put(&quot;id&quot;, user.getId());</span><br><span class="line">        data.put(&quot;username&quot;, user.getUsername());</span><br><span class="line"></span><br><span class="line">        data.put(&quot;authorities&quot;, user.getRoles());</span><br><span class="line"></span><br><span class="line">        String token = &quot;Bearer &quot; + TokenUtil.getToken(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return Map.of(&quot;code&quot;,200,&quot;msg&quot;,&quot;登录成功&quot;,&quot;token&quot;,token);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/logout&quot;)</span><br><span class="line">    public Map&lt;String,Object&gt; logout() &#123;</span><br><span class="line"></span><br><span class="line">        // 拿到当前的SecurityContext</span><br><span class="line">        SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line"></span><br><span class="line">        // 拿到当前的Authentication</span><br><span class="line">        Authentication authentication = context.getAuthentication();</span><br><span class="line"></span><br><span class="line">        // 如果是匿名用户，就直接返回没有登录</span><br><span class="line">        if(authentication.getClass().isAssignableFrom(AnonymousAuthenticationToken.class)) &#123;</span><br><span class="line">           return Map.of(&quot;code&quot;,200,&quot;msg&quot;,&quot;用户未登录&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果是已经登录的用户，就清空SecurityContextHolder中的信息</span><br><span class="line">        SecurityContextHolder.clearContext();</span><br><span class="line">        return Map.of(&quot;code&quot;,200,&quot;msg&quot;,&quot;登出成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置类">配置类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AuthenticationConfiguration authenticationConfiguration;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationProvider jwtAuthenticationProvider()&#123;</span><br><span class="line">        return new JwtAuthenticationProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationManager authenticationManager() throws Exception &#123;</span><br><span class="line">        return authenticationConfiguration.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter() throws Exception &#123;</span><br><span class="line">        return new JwtAuthenticationTokenFilter();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        httpSecurity.authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;/hello&quot;).hasAuthority(&quot;admin&quot;) // 这个接口需要p1权限</span><br><span class="line">                .antMatchers(&quot;/login&quot;,&quot;/logout&quot;).permitAll() // 这两个接口不需要认证</span><br><span class="line">                .antMatchers(&quot;/test1&quot;).hasAuthority(&quot;p1&quot;) // 这个接口不需要认证，但是不能是已经认证的用户</span><br><span class="line">                .anyRequest().authenticated() // 其他接口都需要认证</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().disable()  // 禁用默认表单登录</span><br><span class="line">                .logout().disable() // 禁用默认退出登录</span><br><span class="line">                .csrf().disable() // 禁用csrf</span><br><span class="line">                .sessionManagement().disable(); // 禁用session</span><br><span class="line">        // 添加自定义的jwt认证器</span><br><span class="line">        httpSecurity.authenticationProvider(jwtAuthenticationProvider());</span><br><span class="line"></span><br><span class="line">        // 添加自定义的jwt过滤器</span><br><span class="line">        httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        httpSecurity.authenticationManager(authenticationConfiguration.getAuthenticationManager());</span><br><span class="line">        return httpSecurity.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是按照标准的三步走, 但是我感觉有点麻烦, 我其实可以在filter里面全部弄完,不需要验证器, 这样多方便</p><h2 id="补充">补充</h2><h3 id="过滤链">过滤链</h3><p>在Spring Security的过滤器链中，每个过滤器会依次处理请求。<strong>一旦一个过滤器完成了身份验证，它会填充Security Context，后续的过滤器通常就会跳过身份验证步骤</strong>。<strong>如果一个过滤器没有完成身份验证，那么请求就会继续传递给后续的过滤器进行处理</strong>。前提是这个过程没有抛出异常</p><p>所以，如果 <code>UsernamePasswordAuthenticationFilter</code> 没有完成身份验证（例如，请求中没有包含用户名和密码），那么你的自定义过滤器就有机会处理这个请求。</p><p>这就是为什么过滤器的顺序很重要。如果你希望自定义的过滤器能处理特定类型的身份验证，那么你需要确保它位于能处理这种类型身份验证的内置过滤器之前。这样，当内置过滤器不能处理请求时，你的自定义过滤器就可以接手处理。</p><p>这种设计让Spring Security能够支持多种类型的身份验证，并且可以通过添加自定义过滤器来扩展其功能。</p><h3 id="authenticationprovider优先级">AuthenticationProvider优先级</h3><p>Spring Security 的 <code>ProviderManager</code>（<code>AuthenticationManager</code> 的一个实现）会遍历所有的 <code>AuthenticationProvider</code> 实例，按照它们在配置中的顺序，依次尝试对提供的 <code>Authentication</code> 对象进行认证。</p><p>当 <code>ProviderManager</code> 找到一个能够处理当前 <code>Authentication</code> 对象的 <code>AuthenticationProvider</code> 时，它会调用这个 <code>AuthenticationProvider</code> 的 <code>authenticate</code> 方法。如果该 <code>AuthenticationProvider</code> <strong>认证成功，则认证过程结束</strong>，否则，<code>ProviderManager</code> 会继续尝试下一个 <code>AuthenticationProvider</code>。</p><p>如果所有的 <code>AuthenticationProvider</code> 都无法认证成功，<code>ProviderManager</code> 会抛出一个 <code>AuthenticationException</code>。</p><p>因此，你可以根据你的需求配置多个 <code>AuthenticationProvider</code>，Spring Security 会按照它们在配置中的顺序，依次尝试每个 <code>AuthenticationProvider</code>。并且，你可以为每种 <code>Authentication</code> 类型（如用户名密码、OAuth 2.0 token、LDAP 等）配置不同的 <code>AuthenticationProvider</code>。</p><h3 id="hasrole-和-hasauthority的区别">hasRole 和 hasAuthority的区别</h3><p>在 Spring Security 中，<code>hasAuthority()</code> 和 <code>hasRole()</code> 都是方法级别的安全性注解，用于决定某个用户是否拥有访问特定方法的权限。但是它们之间存在一些细微的差别：</p><ol><li><p><strong>hasAuthority()</strong>: 这个方法会检查 <code>Authentication</code> 对象中的 <code>GrantedAuthority</code> 列表，看用户是否具有指定的权限。你可以使用任意的字符串来作为权限，例如 <code>hasAuthority('READ')</code>。</p></li><li><p><strong>hasRole()</strong>: 这个方法也会检查 <code>Authentication</code> 对象中的 <code>GrantedAuthority</code> 列表，但它假定你的权限是以 <code>ROLE_</code> 前缀开头的。所以，如果你有一个名为 <code>ROLE_ADMIN</code> 的权限，你可以使用 <code>hasRole('ADMIN')</code> 来检查用户是否拥有这个权限。也就是说，<code>hasRole()</code> 会自动在你给定的角色名前加上 <code>ROLE_</code> 前缀。</p></li></ol><p>总的来说，<code>hasAuthority()</code> 和 <code>hasRole()</code> 的功能基本相同，但是 <code>hasRole()</code> 更适用于检查以 <code>ROLE_</code> 前缀命名的权限，而 <code>hasAuthority()</code> 可以用来检查任何名称的权限。你可以根据你的实际需求来选择使用哪个方法。</p><h3 id="jwt认证">jwt认证</h3><p>JWT是指JSON Web Token（JSON网络令牌），是一种用于在网络应用之间传递信息的开放标准（RFC 7519）。它可以作为一种轻量级的安全性传输方式，用于在发送方和接收方之间传递声明。这些声明可以被验证和信任，因此可以用来实现单点登录、用户认证等功能。</p><p>JWT由三部分组成，分别是头部（Header）、载荷（Payload）和签名（Signature）。头部包含关于JWT的元数据，如加密算法和类型。载荷包含声明，即要传输的信息，例如用户的ID、过期时间等。签名则是用于验证消息的完整性和认证信息发送方的值。</p><p>JWT具有无状态、可扩展、易于传输等特点，因此广泛应用于Web应用程序、移动应用程序和IoT设备等场景。</p><p>下面是生成 JWT 的详细流程：</p><ol><li><p>创建 header（头部）：JWT 的 header 包含两部分：token 类型（typ）和使用的哈希算法（alg）。通常，header 是一个 JSON 对象，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，alg 指定了用于签名的算法，常见的有 HS256、HS384、HS512、RS256 等。typ 用于声明数据结构类型，这里是 JWT。</p></li><li><p>创建 payload（负载）：payload 包含实际需要传递的数据。它通常是一个 JSON 对象，可以包含多个键值对。这些键值对被称为 claims（声明）。有三种类型的 claims：registered（注册）、public（公共）和 private（私有）声明。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;iat&quot;: 1516239022</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，sub 是主题，name 是用户名称，iat 是 token 发布时间。</p></li><li><p><strong>对 header 和 payload 进行 Base64Url 编码</strong>：将 header 和 payload 分别进行 Base64Url 编码。Base64Url 是一种对 URL 安全的编码方式。编码后的 header 和 payload 称为 JWT 的第一部分和第二部分。</p><blockquote><p>这个Base64Url 编码只是对数据进行了格式化,并没有加密,所以客户端是可以通过这两个东西拿到数据的</p></blockquote></li><li><p>连接编码后的 header 和 payload：将编码后的 header 和 payload 用英文句号（.）连接起来，形成一个字符串，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64UrlEncodedHeader.base64UrlEncodedPayload</span><br></pre></td></tr></table></figure></li><li><p>生成签名：使用指定的哈希算法（如 HS256）对连接后的字符串进行哈希计算，同时用一个密钥（secret）对哈希值进行签名。这将生成一个签名，确保 JWT 在传输过程中没有被篡改。</p><blockquote><p>这里才是加密过程</p></blockquote></li><li><p>连接签名：将签名进行 Base64Url 编码后，再与前面生成的字符串用英文句号（.）连接，得到完整的 JWT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64UrlEncodedHeader.base64UrlEncodedPayload.base64UrlEncodedSignature</span><br></pre></td></tr></table></figure><p>这个 JWT 可以在需要的场景下传递给其他服务进行认证和授权。</p></li></ol><p>在生成 JWT 后，接收方可以对其进行解码和验证。验证的过程包括解码 header 和 payload，然后使用相同的哈希算法和密钥重新生成签名，如果新生成的签名与接收到的 JWT 中的签名相同，则说明该 JWT 是有效且未被篡改的。</p><blockquote><p>在认证的过程中,我们只需要进行同样的前五步,得到前面然后和token的前面进行对比,如果相同就认证成功,不同就说明比篡改了</p></blockquote><h1>日志</h1><h2 id="日志门面和日志实现">日志门面和日志实现</h2><p><img src="/2023/04/28/java/spring%E7%B3%BB%E5%88%97/../img/spring%E7%B3%BB%E5%88%97assets/image-20230430143718193.png" alt="image-20230430143718193"></p><p>JUL是jdk自带，在java.util.logging包下的Logger类</p><p>Log4j是Apache下的一款开源的日志框架</p><p><strong>Logback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好</strong></p><p>Log4j 2是对Log4j的升级版，参考了logback的一些优秀的设计</p><p>Log4j2主要有以下特色:</p><p>性能提升：Log4j 2包含基于LMAX Disruptor库的下一代<strong>异步记录器</strong>。在多线程方案中，与Log4j 1.x和Logback相比，异步Logger的吞吐量高18倍，延迟降低了几个数量级</p><p>自动重载配置：与Logback一样，Log4j 2可以在修改后自动重新加载其配置。与Logback不同，它在进行重新配置时不会丢失日志事件</p><p>无垃圾机制：在稳态日志记录期间，Log4j 2 在独立应用程序中是无垃圾的，而在Web应用程序中是低垃圾的。这样可以减少垃圾收集器上的压力，并可以提供更好的响应时间性能</p><h2 id="使用日志框架">使用日志框架</h2><p>Spring Boot内置了对日志的支持，它为开发者提供了一个统一、易于配置的日志框架。默认情况下，<strong>Spring Boot使用Logback作为其日志实现</strong>。然而，它也提供了对其他日志框架（如Log4j2）的支持，可以通过简单的配置进行切换。</p><p>日志级别：<br>Spring Boot支持以下日志级别，按照日志输出的详细程度递减排列：</p><ol><li>ERROR：错误级别，仅记录错误信息。</li><li>WARN：警告级别，记录警告和错误信息。</li><li>INFO：信息级别，记录信息、警告和错误信息。<strong>这是Spring Boot的默认日志级别</strong>。</li><li>DEBUG：调试级别，记录调试、信息、警告和错误信息。比INFO级别的日志更详细。</li><li>TRACE：追踪级别，记录所有日志信息，包括追踪、调试、信息、警告和错误信息。这是最详细的日志级别。</li></ol><h3 id="方式一">方式一</h3><p>为了在你的应用程序中使用日志，你需要导入适当的日志API。对于Spring Boot，默认情况下，<strong>你应该使用SLF4J（Simple Logging Facade for Java）API</strong>。首先，在你的Java类中导入以下包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br></pre></td></tr></table></figure><p>然后，创建一个<code>Logger</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(YourClassName.class);</span><br></pre></td></tr></table></figure><p>现在，你可以使用<code>logger</code>实例记录不同级别的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger.error(<span class="string">&quot;这是一条错误日志&quot;</span>);</span><br><span class="line">logger.warn(<span class="string">&quot;这是一条警告日志&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;这是一条信息日志&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;这是一条调试日志&quot;</span>);</span><br><span class="line">logger.trace(<span class="string">&quot;这是一条追踪日志&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="方式二">方式二</h3><p>使用lombok注解,自动帮我们生成一个log对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHttpSessionEventListener</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;session创建: &quot;</span> + se.getSession().getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;session创建: &quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;session销毁: &quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="日志配置">日志配置</h2><p>Spring Boot允许你通过<code>application.properties</code>或<code>application.yml</code>文件轻松地配置日志。以下是一些常见的日志配置选项：</p><ul><li><p>日志级别配置：通过<code>logging.level</code>属性设置包或类的日志级别。例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.root</span>=<span class="string">WARN</span></span><br><span class="line"><span class="attr">logging.level.com.example.demo</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure></li><li><p>日志文件配置：通过<code>logging.file.name</code>或<code>logging.file.path</code>属性设置日志输出文件。例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.file.name</span>=<span class="string">myapp.log</span></span><br><span class="line"><span class="attr">logging.file.path</span>=<span class="string">logs</span></span><br></pre></td></tr></table></figure></li><li><p>日志文件的滚动策略、最大文件大小等配置：在Logback或Log4j2的配置文件中设置。例如，在<code>src/main/resources</code>目录下创建一个名为<code>logback-spring.xml</code>的文件，然后自定义相关配置。</p></li></ul><h3 id="配置文件">配置文件</h3><p>Spring Boot 在启动时会自动检测项目 <code>src/main/resources</code> 目录下的一些特定命名的配置文件，并根据这些文件的名称来确定它们的用途。对于日志配置，Spring Boot 会检查以下文件名：</p><ul><li>Logback：<code>logback-spring.xml</code>、<code>logback.xml</code></li><li>Log4j2：<code>log4j2-spring.xml</code>、<code>log4j2.xml</code></li></ul><p>当 Spring Boot 找到这些文件中的一个时，它会自动将其用作日志系统的配置。在这些文件中，你可以使用相应日志框架的语法和配置元素来定制日志系统的行为。</p><p>请注意，对于 Logback，推荐使用 <code>logback-spring.xml</code> 而不是 <code>logback.xml</code>。使用 <code>logback-spring.xml</code> 文件名，你可以利用 Spring Boot 提供的一些额外特性，例如使用 Spring Profile 进行条件化配置。而使用 <code>logback.xml</code>，这些特性将不可用。</p><p>总之，Spring Boot 通过检测特定的文件名来识别日志配置文件，并在启动过程中自动应用这些配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.demo&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制台日志输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 文件日志输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logs/app-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将输出引用到控制台和文件日志,这个是兜底的,如果前面设置了其他的级别,会使用那个级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滚动策略是用于管理日志文件的生成和清理的一种策略。当日志文件的大小或时间达到一定阈值时，滚动策略会自动将当前日志文件“滚动”为一个新的日志文件。这样可以避免日志文件无限增长，同时使得日志易于查找和管理。</p><p>以下是一些常见的滚动策略：</p><ol><li><p>基于大小的滚动策略（Size-Based Rolling Policy）：当日志文件大小达到指定值时，创建一个新的日志文件。例如，在 Logback 中，可以使用 <code>ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy</code> 来实现这种策略。</p></li><li><p>基于时间的滚动策略（Time-Based Rolling Policy）：根据时间间隔（如每天、每小时等）创建新的日志文件。例如，在 Logback 中，可以使用 <code>ch.qos.logback.core.rolling.TimeBasedRollingPolicy</code> 来实现这种策略。</p></li><li><p>混合滚动策略：结合基于大小和基于时间的滚动策略，当满足其中任一条件时，创建新的日志文件。例如，在 Logback 中，可以将 <code>SizeBasedTriggeringPolicy</code> 和 <code>TimeBasedRollingPolicy</code> 一起使用。</p></li></ol><p>此外，滚动策略还可以包含日志文件的清理策略，如最大日志文件数量、最长日志保留期限等。在达到这些限制时，最早的日志文件将被自动删除。</p><p>以 Logback 的 <code>TimeBasedRollingPolicy</code> 为例，以下是一个配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每天滚动日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logs/app-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 保留最近30天的日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，滚动策略被设置为每天创建一个新的日志文件，同时保留最近 30 天的日志。当超过 30 天时，最早的日志文件将被自动删除。</p><p>滚动策略在日志管理中起着重要作用，有助于防止日志文件过大，提高日志文件的可读性和可维护性。要了解更多关于滚动策略的详细信息，请参阅相应日志框架的官方文档。</p><h1>好用的工具类</h1><h2 id="jackson">jackson</h2><p>Jackson是一个Java语言的JSON库，用于在Java对象和JSON数据之间进行转换。它可以将Java对象序列化为JSON字符串，也可以将JSON字符串反序列化为Java对象。Jackson可以处理任意复杂度的Java对象，包括对象的继承关系、嵌套关系、集合和映射等。同时，Jackson还支持各种常见的JSON数据格式，包括JSON对象、JSON数组、JSON字符串、JSON数值、JSON布尔值和JSON null值等。</p><p>Jackson是一个功能强大、高效稳定的JSON库，在Java开发中被广泛使用。Jackson的主要优点包括：</p><ol><li>速度快：Jackson采用了高效的JSON处理算法，可以快速地将Java对象序列化为JSON字符串或者将JSON字符串反序列化为Java对象。</li><li>易于使用：Jackson提供了简单易用的API，开发者可以快速地上手并进行相关操作。</li><li>可扩展性强：Jackson提供了丰富的注解和接口，可以方便地扩展和定制自己的序列化和反序列化处理逻辑。</li><li>配置灵活：Jackson支持各种配置选项，可以控制序列化和反序列化的行为，满足不同应用场景的需求。</li><li>开源免费：Jackson是一款开源的JSON库，可以免费使用，并且有一个活跃的社区在维护和更新它的功能。</li></ol><h3 id="导入依赖">导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果导入了springboot web模块的话,这个包已经帮我们导入好了</p></blockquote><h3 id="常用方法">常用方法</h3><p>Jackson提供了很多实用的方法，以下是一些常用的方法：</p><h4 id="objectmapper-writevalueasstring-object-obj">ObjectMapper.writeValueAsString(Object obj)</h4><p>该方法将Java对象序列化为JSON字符串，并返回字符串表示。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(person);</span><br><span class="line">System.out.println(json); <span class="comment">// 输出：&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:25&#125;</span></span><br></pre></td></tr></table></figure><h4 id="objectmapper-writevalue-file-file-object-obj">ObjectMapper.writeValue(File file, Object obj)</h4><p>该方法将Java对象序列化为JSON字符串，并将结果写入指定的文件。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;person.json&quot;</span>);</span><br><span class="line">objectMapper.writeValue(file, person);</span><br></pre></td></tr></table></figure><h4 id="objectmapper-readvalue-string-json-class-t-valuetype"><code>ObjectMapper.readValue(String json, Class&lt;T&gt; valueType)</code></h4><p>该方法将JSON字符串反序列化为Java对象，并返回Java对象的实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:25&#125;&quot;</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> objectMapper.readValue(json, Person.class);</span><br><span class="line">System.out.println(person.getName()); <span class="comment">// 输出：张三</span></span><br></pre></td></tr></table></figure><h4 id="objectmapper-readvalue-file-file-class-t-valuetype"><code>ObjectMapper.readValue(File file, Class&lt;T&gt; valueType)</code></h4><p>该方法将JSON文件反序列化为Java对象，并返回Java对象的实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;person.json&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> objectMapper.readValue(file, Person.class);</span><br></pre></td></tr></table></figure><h4 id="jsonnode-get-string-fieldname"><code>JsonNode.get(String fieldName)</code></h4><p>该方法获取JSON节点中指定字段名对应的节点。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:25&#125;&quot;</span>;</span><br><span class="line"><span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> objectMapper.readTree(json);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;name&quot;</span>).asText();</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> jsonNode.get(<span class="string">&quot;age&quot;</span>).asInt();</span><br></pre></td></tr></table></figure><h4 id="jsonnode-iterator"><code>JsonNode.iterator()</code></h4><p>该方法返回JSON节点的所有子节点的迭代器。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;friends\&quot;:[&#123;\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;age\&quot;:28&#125;,&#123;\&quot;name\&quot;:\&quot;王五\&quot;,\&quot;age\&quot;:30&#125;]&#125;&quot;</span>;</span><br><span class="line"><span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> objectMapper.readTree(json);</span><br><span class="line">Iterator&lt;JsonNode&gt; iterator = jsonNode.get(<span class="string">&quot;friends&quot;</span>).iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">JsonNode</span> <span class="variable">friend</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> friend.get(<span class="string">&quot;name&quot;</span>).asText();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> friend.get(<span class="string">&quot;age&quot;</span>).asInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonnode-isarray"><code>JsonNode.isArray()</code></h4><p>该方法判断JSON节点是否为数组类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;friends\&quot;:[&#123;\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;age\&quot;:28&#125;,&#123;\&quot;name\&quot;:\&quot;王五\&quot;,\&quot;age\&quot;:30&#125;]&#125;&quot;</span>;</span><br><span class="line"><span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> objectMapper.readTree(json);</span><br><span class="line"><span class="keyword">if</span> (jsonNode.get(<span class="string">&quot;friends&quot;</span>).isArray()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonnode-isobject"><code>JsonNode.isObject()</code></h4><p>该方法判断JSON节点是否为对象类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;friends\&quot;:[&#123;\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;age\&quot;:28&#125;,&#123;\&quot;name\&quot;:\&quot;王五\&quot;,\&quot;age\&quot;:30&#125;]&#125;&quot;</span>;</span><br><span class="line"><span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> objectMapper.readTree(json);</span><br><span class="line"><span class="keyword">if</span> (jsonNode.isObject()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="objectnode-put-string-fieldname-jsonnode-value"><code>ObjectNode.put(String fieldName, JsonNode value)</code></h4><p>该方法向JSON对象节点中添加一个字段，并设置字段值。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">ObjectNode</span> <span class="variable">objectNode</span> <span class="operator">=</span> objectMapper.createObjectNode();</span><br><span class="line">objectNode.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">objectNode.put(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="type">JsonNode</span> <span class="variable">friendsNode</span> <span class="operator">=</span> objectMapper.createArrayNode()</span><br><span class="line">        .add(objectMapper.createObjectNode().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>).put(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>))</span><br><span class="line">        .add(objectMapper.createObjectNode().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王五&quot;</span>).put(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>));</span><br><span class="line">objectNode.set(<span class="string">&quot;friends&quot;</span>, friendsNode);</span><br></pre></td></tr></table></figure><h4 id="arraynode-add-jsonnode-value"><code>ArrayNode.add(JsonNode value)</code></h4><p>该方法向JSON数组节点中添加一个子节点。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">ArrayNode</span> <span class="variable">arrayNode</span> <span class="operator">=</span> objectMapper.createArrayNode();</span><br><span class="line">arrayNode.add(objectMapper.createObjectNode().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>).put(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>));</span><br><span class="line">arrayNode.add(objectMapper.createObjectNode().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王五&quot;</span>).put(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><p>以上是Jackson库中一些常用的方法，可以满足大部分的需求。当然，Jackson还提供了很多其他的方法，开发者可以根据自己的需要进行查阅和使用。</p><h3 id="常用注解">常用注解</h3><p>Jackson提供了许多注解，用于控制Java对象和JSON数据之间的转换。以下是一些常用的Jackson注解：</p><h4 id="jsonanygetter和-jsonanysetter"><code>@JsonAnyGetter</code>和<code>@JsonAnySetter</code></h4><p><strong><code>@JsonAnyGetter</code>和<code>@JsonAnySetter</code>注解可以用于处理一些未知的属性</strong>。<code>@JsonAnyGetter</code>注解标注在任意属性的获取方法上，<code>@JsonAnySetter</code>注解标注在任意属性的设置方法上。使用这两个注解可以让Jackson在序列化和反序列化时忽略一些不确定的属性。举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAnyGetter;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAnySetter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnyGetter</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnySetter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperty</span><span class="params">(String key, Object value)</span> &#123;  <span class="comment">// 要注意这里的区别啊,不是直接设置整个对象</span></span><br><span class="line">        properties.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个 <code>Person</code> 类中，我们有 <code>name</code> 和 <code>age</code> 两个属性，以及一个名为 <code>properties</code> 的 <code>Map</code>。我们使用 <code>@JsonAnyGetter</code> 注解 <code>getProperties()</code> 方法，使得在序列化时，<code>properties</code> 中的<strong>键值对会被平铺到最外层 JSON 对象</strong>。我们使用 <code>@JsonAnySetter</code> 注解 <code>setProperty()</code> 方法，使得在反序列化时，<strong>JSON 对象中未知的属性</strong>可以被添加到 <code>properties</code> 中。</p><h4 id="jsonproperty"><code>@JsonProperty</code></h4><p><code>@JsonProperty</code><strong>注解可以用于指定Java对象字段和JSON属性之间的映射关系</strong>。可以在Java对象字段上使用<code>@JsonProperty</code>注解指定JSON属性的名称，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;fullName&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>@JsonProperty(&quot;fullName&quot;)</code>注解将Java对象字段<code>name</code>与JSON属性<code>fullName</code>建立了映射关系。在将Java对象序列化为JSON字符串或者将JSON字符串反序列化为Java对象时，Jackson都会使用这个映射关系来确定Java对象字段和JSON属性之间的对应关系。</p><h4 id="jsonignore"><code>@JsonIgnore</code></h4><p><code>@JsonIgnore</code>注解可以用于标注Java对象字段，<strong>指定在序列化和反序列化时忽略该字段</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>@JsonIgnore</code>注解标注在Java对象字段<code>age</code>上，表示在将Java对象序列化为JSON字符串或者将JSON字符串反序列化为Java对象时，忽略<code>age</code>字段。</p><h4 id="jsonformat"><code>@JsonFormat</code></h4><p><code>@JsonFormat</code><strong>注解可以用于指定Java对象字段的日期格式和时区</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>@JsonFormat</code>注解指定了Java对象字段<code>birthDate</code>的日期格式为<code>yyyy-MM-dd HH:mm:ss</code>，时区为<code>GMT+8</code>。在将Java对象序列化为JSON字符串或者将JSON字符串反序列化为Java对象时，Jackson会根据这个注解来进行日期格式和时区的转换。</p><h4 id="jsoninclude"><code>@JsonInclude</code></h4><p><code>@JsonInclude</code><strong>注解可以用于指定在序列化时忽略为空的Java对象字段</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>@JsonInclude</code>注解指定了Java对象字段<code>age</code>在序列化时不包括空值。也就是说，如果<code>age</code>字段为<code>null</code>，在将Java对象序列化为JSON字符串时，Jackson会忽略这个字段。</p><h3 id="补充说明">补充说明</h3><ol><li>jackson 底层 通过反射拿到所有字段, 然后查看该字段的一些注解信息,然后查看该字段是否具有get,set方法,如果有,就调用,并根据规则序列化和反序列化数据,  如果没有, 就看是否有特定的注解,比如JsonProperty,如果有,也可以根据规则序列化和反序列化数据,如果没有,则查看它是public还是其他修饰符,如果是public就进行序列化与反序列化,如果没有的话就不对这个字段进行操作</li><li>Jackson在序列化的过程中, 如果没有一个可以序列化的字段,那就会抛出异常, 反序列化的过程中, 如果字符串对应的数据,没有被解析到对象中,就会抛出异常</li></ol><p>当然,这个只是默认规则, 我们可以通过配置ObjectMapper 来指定这些规则</p><p><code>ObjectMapper</code>提供了一系列的配置选项，允许您自定义序列化和反序列化的行为。以下是一些常用的配置规则及其用途：</p><ol><li><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>：控制反序列化时是否在遇到未知属性（不存在于目标Java对象中的属性）时抛出异常。默认为<code>true</code>。设置为<code>false</code>时，遇到未知属性将不会抛出异常，而是忽略它们。</li><li><code>DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES</code>：控制反序列化时是否在将JSON属性值设置为null时抛出异常。默认为<code>false</code>。设置为<code>true</code>时，如果尝试将原始类型字段设置为null，则会抛出异常。</li><li><code>DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY</code>：控制反序列化时是否允许将单个值作为数组处理。默认为<code>false</code>。设置为<code>true</code>时，允许将单个值作为数组处理，例如将<code>&#123;&quot;value&quot;: 1&#125;</code>解析为<code>&#123;&quot;value&quot;: [1]&#125;</code>。</li><li><code>SerializationFeature.WRAP_ROOT_VALUE</code>：控制序列化时是否在根元素外添加包装元素。默认为<code>false</code>。设置为<code>true</code>时，将在根元素外添加包装元素，例如将<code>&#123;&quot;name&quot;: &quot;John&quot;&#125;</code>序列化为<code>&#123;&quot;Person&quot;: &#123;&quot;name&quot;: &quot;John&quot;&#125;&#125;</code>。</li><li><code>SerializationFeature.INDENT_OUTPUT</code>：控制序列化时是否对输出的JSON字符串进行缩进（格式化）。默认为<code>false</code>。设置为<code>true</code>时，输出的JSON字符串将被格式化，使其具有更好的可读性。</li><li><code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>：控制序列化时是否将日期类型（如<code>java.util.Date</code>）转换为时间戳。默认为<code>true</code>。设置为<code>false</code>时，日期将被格式化为字符串，例如<code>&quot;2023-05-09T10:00:00.000+0000&quot;</code>。</li><li><code>SerializationFeature.FAIL_ON_EMPTY_BEANS</code>：控制序列化时是否在尝试序列化空对象（没有任何属性的对象）时抛出异常。默认为<code>true</code>。设置为<code>false</code>时，不会对空对象抛出异常，而是序列化为空JSON对象<code>&#123;&#125;</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 序列化的时候,如果没有数据,也不报错</span><br><span class="line">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS,false);</span><br><span class="line"></span><br><span class="line">// 如果反序列化的时候,遇到一个数据放不进去,也不报错</span><br><span class="line">objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);</span><br></pre></td></tr></table></figure><h2 id="hutool">Hutool</h2><p>一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：</p><table><thead><tr><th>模块</th><th>介绍</th></tr></thead><tbody><tr><td>hutool-aop</td><td>JDK动态代理封装，提供非IOC下的切面支持</td></tr><tr><td>hutool-bloomFilter</td><td>布隆过滤，提供一些Hash算法的布隆过滤</td></tr><tr><td>hutool-cache</td><td>简单缓存实现</td></tr><tr><td>hutool-core</td><td>核心，包括Bean操作、日期、各种Util等</td></tr><tr><td>hutool-cron</td><td>定时任务模块，提供类Crontab表达式的定时任务</td></tr><tr><td>hutool-crypto</td><td>加密解密模块，提供对称、非对称和摘要算法封装</td></tr><tr><td>hutool-db</td><td>JDBC封装后的数据操作，基于ActiveRecord思想</td></tr><tr><td>hutool-dfa</td><td>基于DFA模型的多关键字查找</td></tr><tr><td>hutool-extra</td><td>扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）</td></tr><tr><td>hutool-http</td><td>基于HttpUrlConnection的Http客户端封装</td></tr><tr><td>hutool-log</td><td>自动识别日志实现的日志门面</td></tr><tr><td>hutool-script</td><td>脚本执行封装，例如Javascript</td></tr><tr><td>hutool-setting</td><td>功能更强大的Setting配置文件和Properties封装</td></tr><tr><td>hutool-system</td><td>系统参数调用封装（JVM信息等）</td></tr><tr><td>hutool-json</td><td>JSON实现</td></tr><tr><td>hutool-captcha</td><td>图片验证码实现</td></tr><tr><td>hutool-poi</td><td>针对POI中Excel和Word的封装</td></tr><tr><td>hutool-socket</td><td>基于Java的NIO和AIO的Socket封装</td></tr><tr><td>hutool-jwt</td><td>JSON Web Token (JWT)封装实现</td></tr></tbody></table><p>可以根据需求对每个模块单独引入，也可以通过引入<code>hutool-all</code>方式引入所有模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.18&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>按需引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.18&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1>常用方法</h1><h2 id="base64图片互转">base64图片互转</h2><p>base64转图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String data)</span>&#123;</span><br><span class="line">    String[] parts = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">base64Image</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> parts[<span class="number">0</span>].split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> mimeType.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] decodedBytes = Base64.getDecoder().decode(base64Image);</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(decodedBytes);</span><br><span class="line">        BufferedImage image;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            image = ImageIO.read(bais);</span><br><span class="line">            <span class="keyword">if</span>(image == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;image为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无法将字节数组转换为 BufferedImage&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Objects.equals(fileExtension, <span class="string">&quot;jpeg&quot;</span>))&#123;  <span class="comment">// 对于jpeg的话,这个库貌似不够转化,我们直接变成png</span></span><br><span class="line">            fileExtension = <span class="string">&quot;png&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\img\\&quot;</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FIle</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(!ft.exists())ft.mkdirs();</span><br><span class="line">    </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID() +<span class="string">&quot;.&quot;</span> +fileExtension;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">png</span> <span class="operator">=</span> ImageIO.write(image, fileExtension, <span class="keyword">new</span> <span class="title class_">File</span>(path + name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反过来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ImgToBase64</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\img\\0a6dae19-7924-41c3-9edd-95aa659af5d1.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(fileInputStream.readAllBytes());</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="string">&quot;data:image/jpeg;base64,&quot;</span> + s).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1>补充</h1><h2 id="beanfactory-和-factorybean">BeanFactory 和 FactoryBean</h2><p><code>BeanFactory</code> 和 <code>FactoryBean</code> 是 Spring 框架中两个重要的概念，它们在功能和用途上有一些区别。</p><ol><li><code>BeanFactory</code>：</li></ol><p><code>BeanFactory</code> 是 Spring 框架中最基本的容器，它负责管理和创建 Bean。<code>BeanFactory</code> 是一个接口，包含了 Bean 的创建、配置和管理的基本功能。在实际应用中，我们通常使用它的扩展接口 <code>ApplicationContext</code>，后者提供了更多的高级特性，如事件发布、国际化支持等。</p><p>主要功能：</p><ul><li>负责创建和管理 Bean。</li><li>提供对 Bean 的依赖注入的支持。</li><li>实现了基本的 IoC（控制反转）容器功能。</li></ul><ol start="2"><li><code>FactoryBean</code>：</li></ol><p><code>FactoryBean</code> 是一个接口，通常用于封装复杂对象的创建过程。当一个 Bean 的创建过程比较复杂，或者需要进行一些特殊的初始化操作时，可以考虑实现 <code>FactoryBean</code> 接口。这样，容器在获取 Bean 时，会调用 <code>FactoryBean</code> 的 <code>getObject()</code> 方法来创建 Bean 实例。</p><p>主要功能：</p><ul><li>封装复杂对象的创建过程。</li><li>提供一种自定义 Bean 创建和初始化的机制。</li></ul><p>总结：</p><ul><li><code>BeanFactory</code> 是 Spring 容器的基础接口，负责创建和管理 Bean。实际应用中，通常使用 <code>ApplicationContext</code>。</li><li><code>FactoryBean</code> 是一个接口，用于封装复杂对象的创建过程。通过实现 <code>FactoryBean</code>，可以自定义 Bean 的创建和初始化逻辑。</li></ul><p>以下是一个简单的 <code>FactoryBean</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;MyObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyObject <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建和初始化 MyObject 实例</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        myObject.initialize();</span><br><span class="line">        <span class="keyword">return</span> myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyObject.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyFactoryBean</code> 实现了 <code>FactoryBean</code> 接口，并负责创建和初始化 <code>MyObject</code> 类的实例。当 Spring 容器需要获取 <code>MyObject</code> 类的实例时，会调用 <code>MyFactoryBean</code> 的 <code>getObject()</code> 方法。</p><h2 id="classpath">classpath</h2><p>在 Spring Boot 中，<code>classpath</code> 是一个特殊的前缀，用于表示类路径。以下是关于 Spring Boot 中 <code>classpath</code> 路径的用法和注意点的总结：</p><ol><li><p>用法：</p><ul><li>在配置文件中，您可以使用 <code>classpath</code> 前缀来指定资源文件的路径。例如，<code>classpath:/templates/</code> 用于表示类路径下的 <code>/templates/</code> 目录。</li><li>在 Java 代码中，您可以使用 <code>ResourceUtils.CLASSPATH_URL_PREFIX</code> 或直接使用字符串 “classpath:” 来加载类路径下的资源。</li></ul></li><li><p>注意点：</p><ul><li>当使用 <code>classpath</code> 前缀时，需要确保资源文件被正确打包到 JAR 或 WAR 文件中，以便在运行时可以被找到。</li><li><code>classpath</code> 可以和通配符 <code>*</code> 一起使用，例如 <code>classpath*:/mapper/**/*.xml</code>，表示加载类路径下 <code>/mapper/</code> 目录及其子目录中所有的 <code>.xml</code> 文件。注意，<code>classpath*</code> 和 <code>classpath</code> 的行为略有不同：<strong>classpath*会扫描所有类路径，而 classpath 只会扫描第一个匹配的类路径。</strong></li><li>当使用 <code>classpath</code> 加载资源时，需要注意文件名的大小写，因为在某些操作系统（如 Linux）上，文件名是大小写敏感的。</li><li>使用 <code>classpath</code> 加载资源时，还需要注意文件编码问题。如果资源文件包含特殊字符，需要确保文件的编码与读取时的编码一致。</li></ul></li></ol><p>了解这些用法和注意点有助于您在 Spring Boot 项目中更加高效地使用 <code>classpath</code> 路径。</p><h2 id="资源路径问题">资源路径问题</h2><ol><li><p>静态资源路径：</p><ul><li><p>加载静态资源，如HTML、CSS、JavaScript等，Spring Boot默认从以下路径加载：</p><ul><li><code>/META-INF/resources/</code></li><li><code>/resources/</code></li><li><code>/static/</code></li><li><code>/public/</code></li></ul></li><li><p>注意：这些路径是相对于类路径（classpath）的。它们通常位于项目的<code>src/main/resources</code>目录下。</p></li><li><p>读取：使用相对路径访问静态资源。例如，<code>&lt;img src=&quot;/images/logo.png&quot;&gt;</code>。</p></li><li><p>写入：通常不建议在静态资源目录下写入内容，因为它们可能会被覆盖。对于需要写入的文件，建议使用文件系统路径（见下文）。</p></li></ul></li><li><p>类路径（classpath）资源：</p><ul><li><p>类路径资源通常位于<code>src/main/resources</code>目录或<code>WEB-INF/classes</code>、<code>WEB-INF/lib</code>目录下。</p></li><li><p>读取：使用<code>ClassLoader</code>的<code>getResourceAsStream()</code>方法或Spring的<code>ResourceLoader</code>获取资源。</p><ul><li>示例：<code>resourceLoader.getResource(&quot;classpath:config.properties&quot;)</code></li></ul></li><li><p>写入：类路径资源通常是只读的。如果需要写入配置文件或其他资源文件，建议使用文件系统路径（见下文）。</p></li></ul></li><li><p>Web应用上下文资源：</p><ul><li><p>Web应用上下文资源位于Web应用的部署目录下。</p></li><li><p>读取：使用<code>ServletContext</code>的<code>getResourceAsStream()</code>方法获取资源。</p><ul><li>示例：<code>servletContext.getResourceAsStream(&quot;/WEB-INF/config/config.xml&quot;)</code></li></ul></li><li><p>写入：通常不建议在Web应用上下文目录下写入内容。对于需要写入的文件，建议使用文件系统路径（见下文）。</p></li></ul></li><li><p>文件系统资源：</p><ul><li><p>文件系统资源位于服务器的文件系统中。</p></li><li><p>读取：使用Java的<code>File</code>类或<code>java.nio.file</code>包中的类来读取文件，或者使用Spring的<code>ResourceLoader</code>获取<code>file:</code>前缀的资源。</p><ul><li>示例：<code>resourceLoader.getResource(&quot;file:/path/to/file.txt&quot;)</code></li></ul></li><li><p>写入：使用Java的<code>File</code>类或<code>java.nio.file</code>包中的类来写入文件。</p><ul><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./path/to/file.txt&quot;</span>);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">fileWriter.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">fileWriter.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>外部配置文件路径：</p><ul><li><p>外部配置文件通常位于服务器文件系统中。</p></li><li><p>读取：在<code>application.properties</code>或<code>application.yml</code>中指定配置文件路径，然后使用<code>@Value</code>注解或<code>@ConfigurationProperties</code>注解将配置文件的内容绑定到Java对象。</p><ul><li>示例：<code>@Value(&quot;$&#123;myapp.config.file-path&#125;&quot;) private String configFilePath;</code></li></ul></li><li><p>写入：使用Java的<code>File</code>类或<code>java.nio.file</code>包中的类来写入文件。</p><ul><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(configFilePath);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">fileWriter.write(<span class="string">&quot;key=value&quot;</span>);</span><br><span class="line">fileWriter.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><p>总结：</p><ul><li>在Spring Boot项目中，资源路径可能是类路径资源、Web应用上下文资源、文件系统资源或外部配置文件路径。</li><li>这些路径的读写方式取决于它们的类型和位置。</li><li>类路径资源和Web应用上下文资源通常只用于读取。如果需要写入资源文件，推荐使用文件系统路径或外部配置文件路径。</li><li>当处理资源路径时，注意区分绝对路径和相对路径。绝对路径通常是相对于服务器文件系统的根目录，而相对路径是相对于类路径、Web应用根目录或其他基准路径。</li></ul><h2 id="springboot打war包部署项目">springboot打war包部署项目</h2><h3 id="新增配置类">新增配置类</h3><p>继承SpringBootServletInitializer,然后重写configure方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Demo5Application extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Demo5Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(Demo5Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更改pom-xml">更改pom.xml</h3><p>更改打包方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><p>更改依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="执行插件">执行插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>将war包放入webapps目录下</p><p>注意点:</p><ul><li><strong>配置文件里面的上下文路径是无效的,文件名字才是上下文路径</strong></li><li>一定要注意Tomcat和springboot的版本, 对应springboot3.0的话, 是改了servlet的包名的</li></ul><h2 id="新版本">新版本</h2><p>现在已经有了springboot 3.0 和 spring6.0 了,但是啊, Java EE 已经变更为 Jakarta EE，包名以 javax开头的需要相应地变更为jakarta</p>]]></content>
      
      
      <categories>
          
          <category> 框架学习 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp学习</title>
      <link href="/2023/04/05/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/uniapp/"/>
      <url>/2023/04/05/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/uniapp/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue学习总结</title>
      <link href="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>感觉vue好像有好多很好用的组件,我就来看看</p><h1>Vue2</h1><h2 id="引用vue">引用vue</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="模板语法">模板语法</h2><p>vue采用一种简洁的<strong>模板语法来绑定数据到 DOM</strong>。在 Vue 中，你可以在 HTML 模板中使用双大括号来插入文本，以及使用特殊的属性（称为指令）来实现数据绑定和其他功能。以下是 Vue 的一些主要模板语法特性：</p><ol><li><p>插值 (Interpolation)</p><p>使用双大括号 将数据绑定到文本节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性绑定 (Attribute Binding)</p><p>使用 v-bind 指令绑定 HTML 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-bind:src=&quot;imageSource&quot; alt=&quot;Vue logo&quot;&gt;</span><br><span class="line">&lt;img :src=&quot;imageSource&quot; alt=&quot;Vue logo&quot;&gt;  简写方式</span><br></pre></td></tr></table></figure></li><li><p>条件渲染 (Conditional Rendering)</p><p>使用 v-if、v-else-if 和 v-else 指令进行条件渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;isVisible&quot;&gt;显示内容&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;isError&quot;&gt;错误信息&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;隐藏内容&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>循环渲染 (List Rendering)</p><p>使用 v-for 指令渲染列表数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">    &#123;&#123; item.text &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li><li><p>事件监听 (Event Handling)</p><p>使用 v-on 指令监听 DOM 事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;handleClick&quot;&gt;点击我&lt;/button&gt; 简写</span><br></pre></td></tr></table></figure></li><li><p>文本渲染</p><ul><li>v-text：用于更新元素的textContent</li><li>v-html：用于输出HTML字符串。(小心使用这个,可能会出现xss攻击)</li></ul></li><li><p>v-cloak：解决在页面加载时出现的闪烁问题，可以在vue实例编译结束时，自动移除v-cloak属性。我们可以通过css和js对其进行一些操作,等到vue接管后移除这个属性</p></li><li><p>v-once：<strong>只渲染元素和组件一次。随后的重新渲染, 元素/组件及其所有的子节点将被视为静态内容并跳过</strong>。</p></li><li><p>v-pre  跳过模板编译,直接显示原始页面,可以减少一些渲染,比如我们一个容器里面不需要使用的指令的结点就可以不需要编译</p></li><li><p>表单输入绑定 (Form Input Bindings)</p></li></ol><p>使用 v-model 指令实现双向数据绑定：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model:value=&quot;message&quot; placeholder=&quot;请输入内容&quot;&gt;</span><br><span class="line">&lt;input v-model=&quot;message&quot; placeholder=&quot;请输入内容&quot;&gt; 简写</span><br></pre></td></tr></table></figure><p>​v-model 只能用于可以输入标签上</p><p>在表单字段,v-bind 是单向绑定, 只有当js数据发生变化的时候才会影响页面数据变化, 但是页面数据发生变化的时候,js变量数据不会发生变化,v-model是双向的</p><p><strong>模板中必须是在Vue对象身上有的变量才能使用</strong></p><p><strong>插值和指令里面要写js表达式</strong></p><h2 id="vue对象常用配置项">vue对象常用配置项</h2><p>在创建一个 Vue 对象时，你需要向构造函数传递一个配置对象，其中包含一些属性和方法。以下是一些常用的配置项及其含义：</p><ol><li><p>el: 指定 Vue 实例挂载到 DOM 的元素。可以是一个 CSS 选择器字符串，也可以是一个 HTML 元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el: &#x27;#app&#x27;</span><br></pre></td></tr></table></figure></li><li><p>data: 定义 Vue 实例的数据对象。这些数据会被 Vue 进行响应式处理，以便在数据变化时自动更新视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 对象式</span><br><span class="line">data: &#123;</span><br><span class="line">  message: &#x27;Hello Vue!&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用脚手架的时候必须使用这个方式,因为如果不使用这个方式的话,无法共享组件,数据会混乱</span><br><span class="line">// 函数式</span><br><span class="line">// 这里千万不能使用箭头函数</span><br><span class="line">data:function()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">message:&quot;Hello Vue!&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>methods: 定义 Vue 实例的方法。这些方法可以在模板中通过事件绑定或其他方式调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  handleClick: function () &#123;</span><br><span class="line">    alert(&#x27;Button clicked!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>computed: 定义 Vue 实例的计算属性。计算属性是基于其他响应式数据进行计算的属性，会根据依赖数据的变化自动更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>watch: 定义 Vue 实例的监听器。监听器用于观察和响应数据的变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  message: function (newValue, oldValue) &#123;</span><br><span class="line">    console.log(&#x27;新值:&#x27;, newValue, &#x27;旧值:&#x27;, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>components: 定义 Vue 实例的局部组件。这些组件只能在当前 Vue 实例的模板中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  &#x27;my-component&#x27;: &#123;</span><br><span class="line">    template: &#x27;&lt;div&gt;自定义组件&lt;/div&gt;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>props: 定义接收的属性，仅适用于 Vue 组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [&#x27;title&#x27;, &#x27;content&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>template: 定义组件的模板。可以是一个字符串模板，也可以是一个 HTML 元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template: &#x27;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#x27;</span><br></pre></td></tr></table></figure></li><li><p>mounted: 生命周期钩子，在 Vue 实例挂载到 DOM 之后调用。可以在这个钩子中执行一些初始化操作，如获取数据、添加事件监听器等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">  console.log(&#x27;Vue 实例已挂载&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>created: 生命周期钩子，在 Vue 实例创建完成后立即调用。此时，实例已完成以下配置：数据观测（data observer）、计算属性（computed properties）以及方法（methods）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">created: function () &#123;</span><br><span class="line">  console.log(&#x27;Vue 实例已创建&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>vue 在实例化过程中，会对这些配置项进行处理和初始化。以下是 Vue 对主要配置项所做的处理：</p><ol><li><code>data</code>：Vue 会将 <code>data</code> 中的属性添加到 Vue 实例上，并使这些属性变得响应式。这意味着当这些属性值发生变化时，Vue 会自动更新相关视图。Vue 还会将 <code>data</code> 属性代理到 Vue 实例本身，以便可以直接通过 <code>this.propertyName</code> 访问这些属性。</li><li><code>computed</code>：Vue 会处理 <code>computed</code> 对象中定义的计算属性。计算属性是基于其他属性值（如 <code>data</code> 中的属性）计算得到的属性，它们会被缓存，只有当依赖的属性发生变化时，计算属性的值才会重新计算。</li><li><code>watch</code>：Vue 会设置 <code>watch</code> 对象中定义的侦听器。侦听器允许你对 Vue 实例中的某个属性进行观察，当该属性的值发生变化时，侦听器会触发指定的回调函数。</li><li><code>methods</code>：Vue 会将 <code>methods</code> 对象中定义的方法添加到 Vue 实例上，以便可以在 Vue 实例（如模板或其他方法）中使用这些方法。这些方法会自动绑定到 Vue 实例，因此可以在方法内部通过 <code>this</code> 访问 Vue 实例。</li><li><code>el</code>：Vue 会将 <code>el</code> 选项作为挂载点，将 Vue 实例挂载到 DOM 元素上。你可以传递一个选择器字符串或一个 DOM 元素。Vue 会将编译好的模板替换这个元素。</li><li><code>template</code>：Vue 会将 <code>template</code> 选项作为模板，用于渲染 Vue 实例。模板可以是一个字符串或一个 DOM 元素。在编译过程中，模板会被转换为虚拟 DOM，然后 Vue 会将虚拟 DOM 渲染为真实 DOM 并插入到页面中。</li><li><code>components</code>：Vue 会注册 <code>components</code> 对象中定义的子组件。这些子组件可以在 Vue 实例的模板中使用，以便构建组件化的应用程序。</li><li><code>props</code>：对于组件实例，Vue 会处理 <code>props</code> 对象中定义的属性。这些属性允许你从父组件向子组件传递数据。</li><li><code>mixins</code>：Vue 会将 <code>mixins</code> 数组中的 mixin 对象合并到 Vue 实例的配置对象中。mixin 对象可以包含任意的 Vue 配置选项（如 <code>data</code>、<code>methods</code>、<code>computed</code> 等），这些选项将被合并到 Vue 实例中，实现代码复用</li></ol><h2 id="mvvm模型">MVVM模型</h2><p>MVVM（Model-View-ViewModel）是一种软件架构设计模式，它将应用程序的逻辑、数据和界面分离。Vue.js 是一个基于 MVVM 模式的前端框架，它通过双向数据绑定在 Model（数据模型）和 View（视图）之间建立联系，而 ViewModel（视图模型）充当这两者之间的桥梁。</p><p>在 Vue 中，MVVM 的组成部分如下：</p><ol><li>Model（数据模型）：在 Vue 中，Model 通常是一个 JavaScript 对象，它包含应用程序的数据和业务逻辑。Model 位于 Vue 实例的 data 属性中，是响应式的，即当数据发生变化时，Vue 会自动更新与之相关的视图。</li><li>View（视图）：视图是指用户界面，即 HTML 模板。在 Vue 中，视图使用模板语法与 Model 进行绑定，包括插值、属性绑定、事件监听等。当 Model 中的数据发生变化时，视图会自动更新。</li><li>ViewModel（视图模型）：ViewModel 是 Vue 实例本身，它充当 Model 和 View 之间的桥梁。ViewModel 监听 Model 中数据的变化，并通过双向数据绑定自动更新视图。同时，它还处理用户在视图中触发的事件，如按钮点击、表单提交等，并根据需要更新 Model。</li></ol><p>Vue.js 的 MVVM 模式实现了 Model 和 View 之间的解耦，使得开发者可以专注于业务逻辑，而无需关心 DOM 操作和事件处理。这样可以提高代码的可维护性、可复用性和可测试性。</p><h2 id="数据代理">数据代理</h2><p>在 Vue.js 中，<strong>数据代理指的是 Vue 实例可以直接访问其 data 对象中的属性，而无需通过 data 对象本身</strong>。这意味着你可以使用 <code>this.propertyName</code> 访问和操作 data 中的属性，而不是 <code>this.data.propertyName</code>。<strong>数据代理简化了代码并提高了可读性</strong>。</p><p>数据代理的原理是基于 JavaScript 的访问器属性（getter 和 setter）和 <code>Object.defineProperty</code> 方法实现的。Vue 在创建实例时，会遍历 data 对象的属性，并通过 <code>Object.defineProperty</code> 为每个属性定义 getter 和 setter。这样，当你访问或修改 Vue 实例上的属性时，实际上是通过代理访问或修改 data 对象中的对应属性。</p><p>以下是一个简化的数据代理实现示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Vue(options) &#123;</span><br><span class="line">  this.data = options.data;</span><br><span class="line">  this.proxyData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype.proxyData = function () &#123;</span><br><span class="line">  for (const key in this.data) &#123;</span><br><span class="line">    if (this.data.hasOwnProperty(key)) &#123;</span><br><span class="line">      Object.defineProperty(this, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get: () =&gt; &#123;</span><br><span class="line">          return this.data[key];</span><br><span class="line">        &#125;,</span><br><span class="line">        set: (newValue) =&gt; &#123;</span><br><span class="line">          this.data[key] = newValue;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据劫持">数据劫持</h2><p>vue.js 中的数据劫持是指框架通过劫持对象属性的 getter 和 setter 方法，以实现对数据的监听和响应式更新。当数据发生变化时，Vue.js 能够自动检测到这些变化，<strong>并更新相关的视图</strong>。数据劫持是 Vue.js 实现双向数据绑定和响应式更新的核心技术。</p><p>Vue.js 中的数据劫持主要是通过 <code>Object.defineProperty</code> 方法实现的。具体实现过程如下：</p><ol><li>遍历 data 对象的属性：在创建 Vue 实例时，框架会遍历 data 对象的所有属性。</li><li>为每个属性定义 getter 和 setter：使用 <code>Object.defineProperty</code> 方法为每个属性定义访问器属性，即 getter 和 setter 方法。</li><li>在 getter 中收集依赖：当访问某个属性时，getter 方法会被触发。在 getter 中，Vue.js 会收集当前属性的依赖（如计算属性、模板等）。</li><li>在 setter 中触发更新：当修改某个属性时，setter 方法会被触发。在 setter 中，Vue.js 会通知与该属性相关的依赖进行更新，从而实现响应式更新。</li></ol><p>以下是一个简化的数据劫持实现示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function observe(data) &#123;</span><br><span class="line">  if (!data || typeof data !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const key in data) &#123;</span><br><span class="line">    if (data.hasOwnProperty(key)) &#123;</span><br><span class="line">      let value = data[key];</span><br><span class="line">      observe(value); // 递归处理嵌套对象</span><br><span class="line"></span><br><span class="line">      Object.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get: () =&gt; &#123;</span><br><span class="line">          console.log(&#x27;访问:&#x27;, key, value);</span><br><span class="line">          return value;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: (newValue) =&gt; &#123;</span><br><span class="line">          console.log(&#x27;修改:&#x27;, key, newValue);</span><br><span class="line">          if (newValue !== value) &#123;</span><br><span class="line">            value = newValue;</span><br><span class="line">            observe(newValue); // 如果设置了新的对象，则继续劫持新对象的属性</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里利用了闭包能够保存临时变量的特点</strong></p><h3 id="劫持数据类型的区别">劫持数据类型的区别</h3><ol><li><strong>对象</strong>：对于对象，Vue 会遍历对象的所有属性，使用 Object.defineProperty对每个属性进行劫持。当属性值发生变化时，Vue 会被通知并触发视图更新。这种方法适用于对象，因为它可以精确地监视每个属性的变化。</li><li><strong>数组</strong>：对于数组，Vue 会使用不同的策略进行数据劫持。使用 Object.defineProperty数组的索引进行劫持并不是一个好主意，因为这样会导致性能问题。相反，Vue 使用一种基于原型链的方法来监视数组变化。Vue 会覆盖数组的一些原生方法，如 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code> 和 <code>reverse</code>。当这些方法被调用时，Vue 会执行原生操作，并同时通知视图更新。这样可以避免对数组索引进行劫持，从而提高性能。</li></ol><p>如果我们的数组里面包含了对象比如这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persons: [&#123; id: 1, age: 25, name: &#x27;张三&#x27; &#125;]</span><br></pre></td></tr></table></figure><p>persons[0].age = 30   这种方式可以检测到</p><p>persons[0] = { id: 1, age: 30, name: ‘张三’ }  这种方式检测不到,因此不会更新视图</p><h3 id="后期添加数据劫持">后期添加数据劫持</h3><p>在 Vue 中，如果要在实例创建之后添加新的响应式属性，你不能直接将新属性添加到对象或数组中，因为 Vue 默认情况下无法检测到这种变化。相反，你需要使用 Vue 提供的特殊方法：<code>Vue.set()</code>（或 <code>this.$set()</code>）和 <code>Vue.delete()</code>（或 <code>this.$delete()</code>）。</p><p>以下是如何使用这些方法在 Vue 实例中添加和删除响应式属性的示例：</p><ol><li><strong>为对象添加响应式属性</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在 Vue 实例中添加一个新的响应式属性 `newProperty`</span><br><span class="line">this.$set(this.someObject, &#x27;newProperty&#x27;, &#x27;New Value&#x27;);</span><br></pre></td></tr></table></figure><ol><li><strong>为数组添加响应式元素</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 向 Vue 实例中的数组添加一个新的响应式元素</span><br><span class="line">this.$set(this.someArray, index, newValue);</span><br></pre></td></tr></table></figure><p>需要注意的是，如果你要添加的属性本身是一个对象或数组，这个对象或数组中的值也将变成响应式的。</p><p>总之，在 Vue 实例创建之后，如果需要添加新的响应式属性，请使用 <code>Vue.set()</code>（或 <code>this.$set()</code>）方法。这将确保新属性是响应式的，并且在属性值发生变化时能够触发视图更新。</p><blockquote><p>这个不能应用到vue._data 和 vue身上</p></blockquote><h2 id="收集表单数据">收集表单数据</h2><p><code>v-model</code> 在表单输入框中绑定的值对应于 Vue 实例中的数据属性。当你在输入框中输入内容时，<code>v-model</code> 会自动将输入的值与 Vue 实例中的相应数据属性保持同步。这样，你可以轻松地访问和处理用户输入的数据。</p><p>手动连接值绑定和更改事件监听器可能会很麻烦：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  :value=&quot;text&quot;</span><br><span class="line">  @input=&quot;event =&gt; text = event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>v-model</code> 指令帮我们简化了这一步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure><p>以下是使用 <code>v-model</code> 在不同类型的表单元素中绑定的数据含义：</p><ol><li><strong>文本输入框（<code>&lt;input type=&quot;text&quot;&gt;</code>）</strong>：<code>v-model</code> 会绑定输入框中的文本值。当用户输入内容时，<strong>输入框的值</strong>将实时同步到 Vue 实例的相应数据属性。</li><li><strong>数值输入框（<code>&lt;input type=&quot;number&quot;&gt;</code>）</strong>：<code>v-model</code> 会绑定输入框中的数值。与文本输入框类似，输入的数值会实时同步到 Vue 实例的相应数据属性。</li><li><strong>单选框（<code>&lt;input type=&quot;radio&quot;&gt;</code>）</strong>：<code>v-model</code> 会绑定被选中的单选框的值。当用户选择一个单选框时，选中的值将同步到 Vue 实例的相应数据属性。</li><li><strong>复选框（<code>&lt;input type=&quot;checkbox&quot;&gt;</code>）</strong>：<strong>初始值会影响,如果是一个数据,代表是多个复选框,其他就是单个复选框</strong><ul><li>单个复选框：<code>v-model</code> 会绑定一个布尔值，表示复选框是否被选中。当用户选中或取消选中复选框时，布尔值将同步到 Vue 实例的相应数据属性。</li><li>多个复选框：<strong><code>v-model</code> 会绑定一个数组</strong>，其中包含所有被选中复选框的值。当用户选中或取消选中复选框时，数组将实时更新以反映当前选中的值。</li></ul></li><li><strong>下拉列表（<code>&lt;select&gt;</code>）</strong>：<ul><li>单选下拉列表：<code>v-model</code> 会绑定选中的选项的值。当用户选择一个选项时，选中的值将同步到 Vue 实例的相应数据属性。</li><li>多选下拉列表：<code>v-model</code> 会绑定一个数组，其中包含所有被选中选项的值。当用户选中或取消选中选项时，数组将实时更新以反映当前选中的值。</li></ul></li></ol><p>这就是使用 <code>v-model</code> 在各种类型的表单输入框中绑定的数据含义。这些数据将实时同步到 Vue 实例中的相应数据属性，使得处理和验证用户输入变得更加简单。</p><h3 id="v-model的修饰符">v-model的修饰符</h3><ol><li><p><strong><code>.lazy</code></strong>：默认情况下，<code>v-model</code> 在输入框的 <code>input</code> 事件上进行同步。使用 <code>.lazy</code> 修饰符会将同步行为更改为在输入框的 <code>change</code> 事件上进行。这样，输入框的值只有在失去焦点时才会同步到 Vue 实例的数据属性。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.lazy=&quot;message&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>.number</code></strong>：使用 <code>.number</code> 修饰符会将用户输入的值自动转换为 Number 类型。如果输入值无法被转换为有效的数字，结果将为 NaN。这在需要确保输入值为数字类型时非常有用。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;text&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>.trim</code></strong>：<code>.trim</code> 修饰符用于自动去除用户输入的首尾空白字符。当输入框的值同步到 Vue 实例的数据属性时，首尾空白字符将被删除。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;message&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="事件绑定">事件绑定</h2><p>在 Vue.js 中，使用 <code>v-on</code> 指令来绑定事件监听器。通过 <code>v-on</code>，你可以在 DOM 元素上绑定事件，例如点击、双击、键盘事件等，并调用 Vue 实例中的方法来处理这些事件。你还可以设置一些修饰符和传递参数来定制事件处理</p><p>以下是 <code>v-on</code> 的一些使用方法和设置:</p><h3 id="绑定事件">绑定事件</h3><p>使用 <code>v-on:eventName</code> 语法来绑定事件。将 <code>eventName</code> 替换为要监听的事件名称，例如 <code>click</code>、<code>dblclick</code>、<code>keydown</code> 等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="调用方法">调用方法</h3><p>在 Vue 实例的 <code>methods</code> 属性中定义事件处理方法，然后在 <code>v-on</code> 指令中指定该方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick: function() &#123;</span><br><span class="line">        alert(&#x27;按钮被点击了！&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用简写语法：<code>v-on</code> 支持简写语法 <code>@</code>。例如，可以使用 <code>@click</code> 代替 <code>v-on:click</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="传递参数"><strong>传递参数</strong></h3><p>在事件处理方法中，可以接收事件对象作为参数。还可以在绑定事件时传递自定义参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick($event, &#x27;自定义参数&#x27;)&quot;&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick: function(event, customParam) &#123;</span><br><span class="line">        console.log(event, customParam);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><strong>事件修饰符</strong></h3><p>Vue.js 提供了一些事件修饰符，用于处理事件细节。事件修饰符以点 <code>.</code> 开头，跟在事件名称后面。</p><ul><li><code>.stop</code>：阻止事件冒泡。(常用)</li><li><code>.prevent</code>：阻止事件的默认行为。(常用)</li><li><code>.once</code>：只触发一次事件处理函数。(常用)</li><li><code>.capture</code>：使用事件捕获模式而不是冒泡模式。</li><li><code>.self</code>：只在事件在当前元素（而非子元素）上触发时调用处理函数。</li><li><code>.passive</code>：以被动模式添加事件监听器。比如滚轮事件, 滚动之后我们需要去远程下载一张图片,如果不使用这个修饰符,滚动条得等到图片下载完毕才能滚动, 如果使用这个修饰符,不用等图片下载完毕就能滚动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止事件冒泡 --&gt;</span><br><span class="line">&lt;button @click.stop=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 阻止事件默认行为 --&gt;</span><br><span class="line">&lt;a @click.prevent=&quot;handleClick&quot; href=&quot;https://example.com&quot;&gt;点击我&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用事件捕获模式 --&gt;</span><br><span class="line">&lt;button @click.capture=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只在当前元素触发事件 --&gt;</span><br><span class="line">&lt;button @click.self=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只触发一次事件处理函数 --&gt;</span><br><span class="line">&lt;button @click.once=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 以被动模式添加事件监听器 --&gt;</span><br><span class="line">&lt;button @click.passive=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="按键修饰符"><strong>按键修饰符</strong></h3><p>对于对于键盘事件，Vue.js 提供了按键修饰符来监听特定按键的事件。按键修饰符同样以点 <code>.</code> 开头，跟在事件名称后面。</p><p>以下是一些常见的按键修饰符：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获 “删除” 和 “退格” 键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>例如，你可以在 <code>keydown</code> 事件中使用按键修饰符来监听 Enter 键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keydown.enter=&quot;handleEnter&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleEnter: function() &#123;</span><br><span class="line">        console.log(&#x27;按下了 Enter 键&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>你还可以自定义按键别名。在 Vue 实例的全局配置中，使用 <code>Vue.config.keyCodes</code> 对象添加自定义按键别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.customKey = 123; // 将按键码 123 映射为 &quot;customKey&quot;</span><br><span class="line"></span><br><span class="line">// 然后在模板中使用自定义按键修饰符</span><br><span class="line">// &lt;input @keydown.customKey=&quot;handleCustomKey&quot; /&gt;</span><br></pre></td></tr></table></figure><p>总结一下，Vue.js 中的事件绑定可以通过 <code>v-on</code> 指令实现，支持多种设置选项，如传递参数、使用事件修饰符和按键修饰符等。这些设置选项可以帮助你方便地处理不同场景下的事件监听和处理。</p><h2 id="计算属性">计算属性</h2><p>Vue.js 中的计算属性（Computed properties）是一种特殊类型的属性，它们的值是通过其他属性（通常是 <code>data</code> 中的属性）进行计算得到的。计算属性在 Vue 实例的 <code>computed</code> 选项中定义。与普通属性不同，计算属性会被缓存，<strong>只有当依赖的属性(Vue劫持了的数据)发生变化时</strong>，计算属性的值才会重新计算。这有助于提高性能，特别是当计算过程复杂或计算代价较高时</p><p>计算属性主要包含两个配置项：<code>get</code> 和 <code>set</code>。</p><p><code>get</code>：用于计算属性的计算函数。当访问计算属性时，<code>get</code> 函数将被调用，用于计算属性的值。通常，<code>get</code> 函数会根据其他属性（如 <code>data</code> 中的属性）的值来计算结果。默认情况下，如果你直接在 <code>computed</code> 对象中定义一个函数，那么它就是 <code>get</code> 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy codecomputed: &#123;</span><br><span class="line">  fullName: function() &#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set<code>：用于设置计算属性的函数。当尝试修改计算属性的值时，</code>set<code> 函数将被调用。通常，</code>set<code>函数会根据传入的新值来更新其他相关属性（如</code>data` 中的属性）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy codecomputed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newValue) &#123;</span><br><span class="line">      var names = newValue.split(&quot; &quot;);</span><br><span class="line">      this.firstName = names[0];</span><br><span class="line">      this.lastName = names[1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为 <code>fullName</code> 的计算属性，它具有 <code>get</code> 和 <code>set</code> 函数。当访问 <code>fullName</code> 时，<code>get</code> 函数将根据 <code>firstName</code> 和 <code>lastName</code> 属性计算结果。当尝试修改 <code>fullName</code> 的值时，<code>set</code> 函数将被调用，并根据新值更新 <code>firstName</code> 和 <code>lastName</code> 属性。</p><p>总之，计算属性的主要配置项包括 <code>get</code> 和 <code>set</code> 函数。<code>get</code> 函数用于计算属性的值，而 <code>set</code> 函数用于设置计算属性的值。通过这两个函数，你可以方便地处理基于其他属性的计算和更新逻辑。</p><h3 id="计算属性的优势">计算属性的优势</h3><ol><li><strong>缓存</strong>：计算属性会缓存计算结果。只有当依赖的属性发生变化时，计算属性才会重新计算。这有助于提高性能，特别是当计算过程复杂或计算代价较高时。</li><li><strong>响应式</strong>：计算属性依赖于其他响应式属性。当依赖的属性发生变化时，计算属性会自动更新。这使得计算属性在处理复杂逻辑和依赖关系时非常方便。</li><li><strong>可读性</strong>：计算属性可以将复杂的逻辑封装在一个属性中，提高代码的可读性和可维护性。</li></ol><h3 id="计算属性与方法的区别">计算属性与方法的区别</h3><p>尽管你也可以在 Vue 实例的 <code>methods</code> 选项中定义方法来实现类似的功能，但计算属性具有缓存的优势。当多次访问同一个计算属性时，计算属性会返回缓存的结果，而不是重新计算。相反，使用方法时，<strong>每次调用方法</strong>都会重新计算结果。因此，在性能和依赖处理方面，计算属性更具优势。</p><h2 id="监视属性">监视属性</h2><p>监视属性（Watch properties）是 Vue 中用于观察和响应 Vue 实例上属性值变化的一种机制。<strong>它允许你为某个属性指定一个回调函数</strong>，当该属性的值发生变化时，回调函数将被调用。你可以在 Vue 实例的 <code>watch</code> 选项中定义监视属性。</p><p>以下是 <code>watch</code> 选项的一些配置：</p><p><strong>普通监视函数</strong>：为要监视的属性提供一个回调函数。回调函数接收两个参数：新值（<code>newVal</code>）和旧值（<code>oldVal</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  propertyName: function(newVal, oldVal) &#123;</span><br><span class="line">    // 在这里执行属性值变化时的操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>立即执行的监视函数</strong>：如果你希望监视函数在 Vue 实例初始化时立即执行，可以使用 <code>handler</code> 属性定义回调函数，并将 <code>immediate</code> 属性设置为 <code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  propertyName: &#123;</span><br><span class="line">    handler: function(newVal, oldVal) &#123;</span><br><span class="line">      // 在这里执行属性值变化时的操作</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带延迟的监视函数</strong>：如果你希望在属性值发生变化后延迟一段时间再执行回调函数，可以使用 <code>handler</code> 属性定义回调函数，并设置 <code>delay</code> 属性为一个毫秒值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  propertyName: &#123;</span><br><span class="line">    handler: function(newVal, oldVal) &#123;</span><br><span class="line">      // 在这里执行属性值变化时的操作</span><br><span class="line">    &#125;,</span><br><span class="line">    delay: 500 // 延迟 500 毫秒后执行回调函数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深度监视</strong>：默认情况下，Vue 只监视属性的一级变化。如果你需要监视一个对象的嵌套属性，可以将 <code>deep</code> 属性设置为 <code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  objectProperty: &#123;</span><br><span class="line">    handler: function(newVal, oldVal) &#123;</span><br><span class="line">      // 在这里执行属性值变化时的操作</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true // 深度监视嵌套属性变化</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了使用new Vue的时候传入监视配置,也可以在后面使用 Vue的$watch方法</p><p>如果是多层结构的话  监视名字得这样  “a.b.c”</p></blockquote><p>监视属性的主要用途是在属性值发生变化时执行某些操作，例如数据验证、数据获取、状态更新等。监视属性特别适用于处理异步或昂贵操作的情况。</p><p><strong>监视属性能够监视 vue自己通过Object.defineProperty方法往自己身上加的属性 比如 data里面的数据  计算属性</strong></p><p>值得注意的是，监视属性并非适用于所有情况。在很多情况下，计算属性可能是更好的选择，特别是当你需要根据其他属性计算一个值时。然而，监视属性在处理异步操作和昂贵操作时非常有用，因为它们允许你在属性值发生变化时执行特定操作。</p><h2 id="class-与-style-绑定">Class 与 Style 绑定</h2><h3 id="class-绑定">class 绑定</h3><p>在 Vue 中，你可以使用 <code>v-bind:class</code>（简写为 <code>:class</code>）动态地绑定 class。以下是一些常见的 class 绑定规则以及它们的使用方法：</p><p><strong>字符串语法</strong>：直接将字符串作为 class 名传递给 <code>v-bind:class</code>。字符串中的类名将被添加到元素上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;className&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>className</code> 可以是一个字符串，也可以是返回字符串的计算属性。</p><p><strong>对象语法</strong>：使用对象语法，你可以根据对象的属性值（布尔值）动态地切换类。对象的属性名表示要绑定的类名，属性值为布尔值，决定是否应用该类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive, error: hasError &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>active</code> 类将只在 <code>isActive</code> 为 <code>true</code> 时应用；<code>error</code> 类将只在 <code>hasError</code> 为 <code>true</code> 时应用。</p><p><strong>数组语法</strong>：使用数组语法，你可以将一个包含类名的数组传递给 <code>v-bind:class</code>。数组中的所有类名将被添加到元素上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>classA</code> 和 <code>classB</code> 都会被添加到元素上。它们可以是字符串或计算属性。</p><p><strong>数组语法中的对象</strong>：在数组语法中，你还可以使用对象来根据条件切换类名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, classB]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>active</code> 类将只在 <code>isActive</code> 为 <code>true</code> 时应用；<code>classB</code> 总是会被添加到元素上。</p><p><strong>绑定组件的 class</strong>：在自定义组件中，你可以使用 <code>v-bind:class</code> 来绑定类。这些类将被添加到组件的根元素上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>isActive</code> 为 <code>true</code>，则 <code>active</code> 类将被添加到 <code>my-component</code> 的根元素上。</p><h3 id="style绑定">style绑定</h3><p>在 Vue 中，你可以使用 <code>v-bind:style</code>（简写为 <code>:style</code>）动态地绑定 style。以下是一些常见的 style 绑定规则以及它们的使用方法：</p><p><strong>对象语法</strong>：使用对象语法，你可以将一个包含 CSS 属性及其值的对象传递给 <code>v-bind:style</code>。对象的属性名应为驼峰式（camelCase）或短横线分隔（kebab-case，需要加引号）的 CSS 属性名，属性值为相应的样式值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>activeColor</code> 和 <code>fontSize</code> 可以是 data 属性、计算属性或方法的返回值。</p><p><strong>数组语法</strong>：使用数组语法，你可以将一个包含多个样式对象的数组传递给 <code>v-bind:style</code>。数组中的所有样式对象将被合并，并应用到元素上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>styleObjectA</code> 和 <code>styleObjectB</code> 都应该是包含样式属性及其值的对象。它们可以是 data 属性、计算属性或方法的返回值。</p><p><strong>自动添加前缀</strong>：Vue 会自动为某些需要浏览器前缀的 CSS 属性添加前缀，如 <code>transform</code>。你只需要写标准的 CSS 属性名，Vue 会自动处理浏览器兼容性问题。<strong>绑定组件的 style</strong>：在自定义组件中，你可以使用 <code>v-bind:style</code> 来绑定样式。这些样式将被添加到组件的根元素上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:style=&quot;&#123; color: activeColor &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>activeColor</code> 的值将被应用到 <code>my-component</code> 的根元素上。</p><blockquote><p>我们绑定的class和style都是追加到标签的属性中的, 也就是说我们固定的属性并不会被删掉</p></blockquote><h2 id="条件渲染">条件渲染</h2><p>ue 提供了一些指令来实现条件渲染。这些指令可以根据表达式的值动态地添加或删除元素。以下是 Vue 中常见的条件渲染指令：</p><p><strong>v-if</strong>：<code>v-if</code> 指令用于根据一个表达式的真假值来决定是否渲染一个元素。如果表达式的值为真（truthy），则该元素将被渲染；否则，该元素将不会被渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;show&quot;&gt;这个元素将根据 show 的值进行条件渲染。&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>show</code> 的值为真（truthy），则该元素将被渲染；否则，不会被渲染。</p><p><strong>v-else</strong>：<code>v-else</code> 指令用于表示一个与 <code>v-if</code> 配套使用的“否则”分支。<code>v-else</code> 必须紧跟在一个带有 <code>v-if</code> 的元素之后，它们共同表示一个条件渲染的 if-else 结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;show&quot;&gt;这个元素将在 show 为真时渲染。&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;这个元素将在 show 为假时渲染。&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，当 <code>show</code> 的值为真时，第一个元素将被渲染；否则，第二个元素将被渲染。</p><p><strong>v-else-if</strong>：<code>v-else-if</code> 指令用于表示一个与 <code>v-if</code> 配套使用的“否则如果”分支。<code>v-else-if</code> 必须紧跟在一个带有 <code>v-if</code> 或 <code>v-else-if</code> 的元素之后，它们共同表示一个条件渲染的 if-elseif-else 结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;这个元素将在 type 为 &#x27;A&#x27; 时渲染。&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;这个元素将在 type 为 &#x27;B&#x27; 时渲染。&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;这个元素将在 type 不是 &#x27;A&#x27; 或 &#x27;B&#x27; 时渲染。&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，根据 <code>type</code> 的值，将渲染不同的元素。</p><p><strong>v-show</strong>：<code>v-show</code> 指令与 <code>v-if</code> 类似，也用于根据一个表达式的真假值来决定是否显示一个元素。但与 <code>v-if</code> 不同的是，<code>v-show</code> 不会实际移除或添加元素，而是通过 CSS 的 <code>display</code> 属性来控制元素的显示和隐藏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;div v-show=&quot;show&quot;&gt;这个元素将根据 show 的值进行显示或隐藏。&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>show</code> 的值为真,则该元素将被显示；否则，该元素将被隐藏。请注意，<code>v-show</code> 只是简单地切换元素的 CSS <code>display</code> 属性，而不是像 <code>v-if</code> 那样实际移除或添加元素。</p><p><strong>v-if 与 v-show 的区别</strong></p><p>尽管 <code>v-if</code> 和 <code>v-show</code> 都可以实现条件渲染，但它们在某些方面有所不同：</p><ul><li><code>v-if</code> 是真正的条件渲染，它会在条件满足时将元素添加到 DOM，条件不满足时将元素从 DOM 移除。这意味着切换 <code>v-if</code> 的条件会触发组件的销毁与重建，以及过渡效果。</li><li><code>v-show</code> 只是简单地切换元素的 CSS <code>display</code> 属性。无论条件是否满足，元素始终存在于 DOM 中，只是显示或隐藏。这意味着 <code>v-show</code> 的切换不会触发组件的销毁与重建，以及过渡效果。</li></ul><p>在选择 <code>v-if</code> 和 <code>v-show</code> 时，可以根据以下原则来决定：</p><ul><li>如果需要频繁切换显示和隐藏的元素，使用 <code>v-show</code> 可能更合适，因为它不会导致组件的销毁与重建，性能较好。</li><li>如果元素可能永远不会被显示，或者条件改变较少的情况下，使用 <code>v-if</code> 更合适，因为它可以减少初始渲染的开销。</li></ul><h2 id="列表渲染">列表渲染</h2><p>在 Vue 中，列表渲染是一种常见的需求。为了方便地渲染列表数据，Vue 提供了 <code>v-for</code> 指令。<code>v-for</code> 可以遍历数组或对象，并为每个元素生成一个模板实例。</p><p>以下是关于 Vue 中列表渲染的一些用法：</p><p><strong>遍历数组</strong>：使用 <code>v-for</code> 遍历数组时，需要提供一个表达式，表示“元素 in 数组”。遍历过程中，每个元素都将被绑定到当前模板实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>items</code> 是一个数组，<code>item</code> 是数组中的每个元素。<code>v-for</code> 将为 <code>items</code> 中的每个元素生成一个 <code>&lt;li&gt;</code> 标签。</p><p><strong>遍历对象</strong>：使用 <code>v-for</code> 遍历对象时，需要提供一个表达式，表示“(值, 键) in 对象”。遍历过程中，对象的每个属性都将被绑定到当前模板实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;(value, key) in object&quot;&gt;&#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>object</code> 是一个对象，<code>key</code> 是对象中的每个属性名，<code>value</code> 是对象中每个属性的值。<code>v-for</code> 将为 <code>object</code> 中的每个属性生成一个 <code>&lt;li&gt;</code> 标签。</p><p><strong>遍历指定次数</strong>: 我们可以指定次数遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(n,i) in 5&quot;&gt;&#123;&#123;i&#125;&#125;-&#123;&#123;n&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>索引从0开始,数字从1开始</p><p><strong>遍历数组或对象时获取索引</strong>：在遍历数组或对象时，你可以使用第三个参数获取当前元素的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 遍历数组时获取索引 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item, index) in items&quot;&gt;&#123;&#123; index &#125;&#125;: &#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 遍历对象时获取索引 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;(value, key, index) in object&quot;&gt;&#123;&#123; index &#125;&#125; - &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><strong>在组件上使用 <code>v-for</code></strong>：在自定义组件中，你可以使用 <code>v-for</code> 来遍历数据。遍历过程中，每个元素都将作为 prop 传递给组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-for=&quot;item in items&quot; v-bind:item=&quot;item&quot; v-bind:key=&quot;item.id&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>items</code> 是一个数组，<code>item</code> 是数组中的每个元素。<code>v-for</code> 将为 <code>items</code> 中的每个元素生成一个 <code>my-component</code> 组件实例。请注意，为了提高性能和避免重复渲染，你应该使用 <code>v-bind:key</code> 为每个组件实例绑定一个唯一的键值（通常是数据的 ID）。</p><p>在 Vue 中的列表渲染中，<code>key</code> 属性是一个特殊的属性，用于跟踪每个节点的唯一性。<strong>当 Vue 更新 DOM 时，它会尽可能地复用和重排现有的元素，而不是从头开始渲染。通过为每个列表项提供一个唯一的 <code>key</code>，可以帮助 Vue 更高效地识别和管理这些节点</strong>。</p><p>以下是关于 <code>key</code> 属性的一些特点和好处：</p><ol><li><strong>提高性能</strong>：<code>key</code> 的主要作用是提高列表渲染的性能。当列表发生变化时（例如，添加、删除、重新排序等操作），Vue 会根据每个节点的 <code>key</code> 来判断是否可以复用现有的 DOM 元素。这可以避免不必要的渲染，从而提高性能。</li><li><strong>维护组件状态</strong>：当你在列表中使用组件时，使用 <code>key</code> 可以帮助 Vue 维护组件的状态。在某些情况下，如果没有使用 <code>key</code>，当列表发生变化时，Vue 可能会复用组件实例，这可能导致组件状态出现问题。通过为每个组件实例提供一个唯一的 <code>key</code>，可以确保 Vue 正确地追踪和管理组件状态。</li><li><strong>唯一且稳定</strong>：<code>key</code> 的值应该是唯一且稳定的，这样 Vue 才能正确地追踪节点。通常情况下，你可以使用数据项的唯一 ID 作为 <code>key</code>。在某些特殊情况下，你也可以使用其他唯一且稳定的值，例如索引（但这可能会导致性能和状态管理问题，因此不推荐）。</li></ol><p>以下是一个使用 <code>key</code> 的列表渲染示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>items</code> 是一个数组，每个元素都包含一个唯一的 <code>id</code>。<code>v-for</code> 为 <code>items</code> 中的每个元素生成一个 <code>&lt;li&gt;</code> 标签，并使用 <code>v-bind:key</code> 为每个标签绑定一个唯一的 <code>key</code>。</p><p><code>key</code> 属性如何帮助 Vue 复用现有的 DOM 元素主要是通过 Vue 的 diff 算法实现的。当列表数据发生变化时，Vue 会通过这个算法比较<strong>新旧虚拟 DOM 树</strong>，以确定是否可以复用现有的 DOM 元素。<code>key</code> 在这个过程中起到了关键作用，它可以帮助 Vue 更准确地识别哪些节点可以被复用。</p><p>以下是关于 <code>key</code> 如何帮助复用 DOM 元素的简要说明：</p><ol><li><strong>创建虚拟 DOM 树</strong>：当 Vue 组件渲染时，它会创建一个虚拟 DOM 树来表示真实的 DOM 结构。虚拟 DOM 树是一个轻量级的 JavaScript 对象，它包含了节点的类型、属性、事件等信息。<code>key</code> 属性也会被包含在虚拟 DOM 节点中。</li><li><strong>比较新旧虚拟 DOM 树</strong>：当组件状态发生变化时，Vue 会创建一个新的虚拟 DOM 树，并将其与旧的虚拟 DOM 树进行比较。这个比较过程称为 diff 算法。</li><li><strong>识别可复用节点</strong>：在 diff 算法过程中，Vue 会尝试找到可以复用的节点。为了找到这些节点，Vue 需要确定新旧虚拟 DOM 树中的节点是否相同。<strong><code>key</code> 在这个过程中起到了重要作用。当两个节点具有相同的 <code>key</code> 时，Vue 认为它们是相同的</strong>，因此可以尝试<strong>复用现有的相同的 DOM</strong> 元素。如果没有 <code>key</code> 或 <code>key</code> 不同，Vue 将创建一个新的 DOM 元素。</li><li><strong>更新 DOM</strong>：根据 diff 算法的结果，Vue 会对真实的 DOM 进行更新。对于可以复用的节点，Vue 会更新其属性、事件等，而不是重新创建。这样可以避免不必要的渲染开销，提高性能。</li></ol><p>总之，<code>key</code> 在 Vue 的列表渲染中扮演着重要的角色，它可以提高性能、确保正确的组件状态管理，以及帮助 Vue 更高效地追踪和管理节点。因此，在使用 <code>v-for</code> 进行列表渲染时，建议总是为每个节点提供一个唯一的 <code>key</code>。</p><h2 id="过滤器">过滤器</h2><p>Vue.js 中的过滤器（filters）是一种特殊的函数，用于对数据进行格式化或转换。过滤器通常与插值表达式和 <code>v-bind</code> 指令一起使用，使得在模板中对数据进行格式化变得简单。</p><p>过滤器的主要用途是处理一些简单的文本格式化，如大小写转换、货币格式化、日期格式化等。它们不会改变原始数据，只是对数据进行转换后显示。</p><p>要在 Vue.js 中使用过滤器，需要遵循以下步骤：</p><ol><li><p><strong>定义过滤器</strong>：在 Vue 实例的 <code>filters</code> 选项中定义过滤器函数。<strong>过滤器函数始终接收原始值作为第一个参数</strong>，可以接受额外的参数,在使用的的时候直接函数式传参就行  。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  repeatString(value, count, separator) &#123;</span><br><span class="line">    if (!value) return &#x27;&#x27;;</span><br><span class="line">    value = value.toString();</span><br><span class="line">    return Array(count).fill(value).join(separator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>使用过滤器</strong>：在插值表达式或 <code>v-bind</code> 指令中，使用管道符（<code>|</code>）将原始值传递给过滤器函数。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在插值表达式中使用过滤器 --&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; message | repeatString(3, &#x27;, &#x27;) &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 在 v-bind 指令中使用过滤器 --&gt;</span><br><span class="line">&lt;p v-bind:title=&quot;message | repeatString(3, &#x27;, &#x27;)&quot;&gt;Hover to see  title&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol><p>你还可以将多个过滤器链式使用，将一个过滤器的输出作为另一个过滤器的输入。只需用管道符（<code>|</code>）分隔过滤器名称即可。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code&lt;!-- 链式使用过滤器 --&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; message | repeatString(3, &#x27;, &#x27;) | reverse &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，Vue.js 过滤器的主要目的是处理简单的文本格式化，而不是用于处理复杂数值计算或逻辑。对于复杂数值计算或逻辑，建议使用计算属性或方法。</p><h3 id="全局过滤器">全局过滤器</h3><p>在配置项里面写好的是局部过滤器,只能在局部使用,全局过滤器可以在任何 Vue 实例或组件中使用，而无需在每个实例中单独定义</p><p>以下是一个创建全局过滤器的示例：</p><ol><li><strong>定义全局过滤器</strong>：在创建 Vue 实例之前，使用 <code>Vue.filter()</code> 方法定义全局过滤器。该方法接受两个参数：过滤器名称（字符串）和过滤器函数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(&#x27;capitalize&#x27;, function (value) &#123;</span><br><span class="line">  if (!value) return &#x27;&#x27;;</span><br><span class="line">  value = value.toString();</span><br><span class="line">  return value.charAt(0).toUpperCase() + value.slice(1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用全局过滤器</strong>：在任何 Vue 实例或组件的插值表达式或 <code>v-bind</code> 指令中，使用管道符（<code>|</code>）将原始值传递给全局过滤器。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在插值表达式中使用全局过滤器 --&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 v-bind 指令中使用全局过滤器 --&gt;</span><br><span class="line">&lt;p v-bind:title=&quot;message | capitalize&quot;&gt;Hover to see capitalized title&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>全局过滤器在整个应用程序中都可以使用，这意味着你只需要在一个地方定义过滤器，就可以在多个 Vue 实例或组件中使用它。但请注意，<strong>如果全局过滤器与局部过滤器同名，局部过滤器将优先使用</strong>。</p><blockquote><p>过滤器只支持插值语法跟 v-bind</p></blockquote><h2 id="自定义指令">自定义指令</h2><p>在Vue中，自定义指令允许你为元素添加特定的行为，有时候这比组件更加方便。自定义指令可以帮助你封装和重用一些DOM操作逻辑，使代码更易于阅读和维护。</p><p>以下是如何创建和使用自定义指令的详细步骤：</p><p><strong>注册全局自定义指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&#x27;focus&#x27;, &#123;</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注册局部自定义指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    focus: &#123;  // 这个就是指令名字,但是使用的时候得用v-开头</span><br><span class="line">      inserted: function (el) &#123;</span><br><span class="line">        el.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>在模板中使用自定义指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;  // 注意使用 v-  +  指令名字</span><br></pre></td></tr></table></figure><p>自定义指令的配置项：</p><ul><li>bind：指令第一次绑定到元素时调用，可以进行一次性的初始化设置。</li><li>inserted：被绑定元素插入父节点时调用（仅需父节点存在，不必存在于document中）。</li><li>update：所在组件的 VNode 更新时调用，可能在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。</li><li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li>unbind：指令与元素解绑时调用，可以进行一些清理工作。</li></ul><blockquote><p>如果是函数式的话,在bind和update会执行这个函数</p></blockquote><p>钩子函数的参数：</p><ul><li>el：指令所绑定的元素，可用于直接操作DOM。</li><li>binding：包含以下属性的对象：<ul><li><strong>name</strong>：指令名，不包括v-前缀。</li><li><strong>value</strong>：指令的绑定值。例如：<code>v-focus=&quot;1 + 1&quot;</code>中，绑定值为<code>2</code>。</li><li>oldValue：指令绑定的前一个值，仅在update和component Updated钩子中可用。</li><li>expression：字符串形式的指令表达式。例如：<code>v-focus=&quot;1 + 1&quot;</code>中，表达式为<code>&quot;1 + 1&quot;</code>。</li><li>arg：传给指令的参数。例如：<code>v-focus:arg</code>中，arg为参数。</li><li><strong>modifiers</strong>：<strong>一个包含修饰符的对象</strong>。例如：<code>v-focus.foo.bar</code>中，修饰符对象为<code>&#123; foo: true, bar: true &#125;</code>。</li></ul></li><li>vnode：Vue编译生成的虚拟节点。</li><li>oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中可用。</li></ul><p>使用自定义指令时需要注意：</p><ol><li>不要在自定义指令中修改数据，尽量仅用于操作DOM。因为它并不具备响应式机制，可能导致数据和视图不一致。</li><li>在编写自定义指令时，遵循Vue的单向数据流原则，尽量避免双向绑定。如果需要实现类似于双向绑定的功能，可以考虑使用组件或通过事件通信实现。</li><li>避免在自定义指令中执行耗时操作，因为这可能导致界面卡顿或性能下降。对于复杂的操作，可以考虑使用计算属性、侦听器或生命周期钩子。</li><li>注意指令的作用域。全局指令在整个应用中都可以使用，而局部指令仅在指定的Vue实例或组件中可用。如果指令具有通用性，可以注册为全局指令；如果仅在特定组件中使用，可以注册为局部指令。</li><li>使用修饰符来扩展指令的功能。修饰符是以<code>.</code>分隔的特殊后缀，可以用于指示指令应以某种特定方式绑定。例如，你可以使用修饰符来表示在更新DOM时是否使用动画效果。</li><li>注意自定义指令与Vue内置指令的命名冲突。避免使用与内置指令相同或相似的名称，以免发生意外的行为。</li><li>在使用自定义指令时，确保对其参数、值和修饰符的处理正确。在钩子函数中，可以通过<code>binding</code>对象获取这些信息。</li></ol><h3 id="自己实现一个简单v-model">自己实现一个简单v-model</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">    &quot;my-model&quot;: &#123;</span><br><span class="line">        bind(el, bindding,vnode) &#123;</span><br><span class="line">            el.addEventListener(&#x27;input&#x27;, function(event)&#123;</span><br><span class="line">                vnode.context[bindding.expression] = event.target.value</span><br><span class="line">            &#125;);</span><br><span class="line">            // 这里面的this是Window,而不是vm</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给输入框的输入绑定了事件,只要输入了数据,就通过VNode拿到vm修改对应的数据</p><h2 id="生命周期">生命周期</h2><p>ue的生命周期是指Vue实例或组件在其整个生命周期内经历的各个阶段。在这些阶段中，<strong>Vue会触发一系列生命周期钩子函数</strong>，这些函数可以让你在特定时机执行自定义的逻辑。了解生命周期及其钩子函数可以帮助你更好地管理组件的状态和资源。</p><p>Vue的生命周期主要包括以下几个阶段：</p><ol><li><p>创建阶段（Creation）：在这个阶段，Vue实例或组件开始创建，初始化数据和事件监听器。</p><p>生命周期钩子函数：</p><ul><li><code>beforeCreate</code>: <strong>在实例初始化之后、数据观测（data observer）和事件配置之前被调用</strong>。</li><li><code>created</code>: 在实例创建完成后被立即调用。此时，数据观测已经设置，<strong>但DOM还没有生成</strong>，<code>$el</code>属性还不可用。</li></ul></li><li><p>挂载阶段（Mounting）：在这个阶段，Vue实例或组件的模板将被<strong>编译成虚拟DOM并挂载到真实DOM上</strong>。</p><p>生命周期钩子函数：</p><ul><li><code>beforeMount</code>: 在挂载开始之前被调用。<strong>此时，模板已编译成渲染函数，但还没有挂载到真实DOM上</strong>。</li><li><code>mounted</code>: <strong>在实例被挂载到真实DOM上后调用</strong>。此时，你可以访问到DOM元素，但需要注意的是，<strong>不保证子组件也都一起被挂载</strong>。</li></ul></li><li><p>更新阶段（Updating）：在这个阶段，Vue实例或组件的数据发生变化，导致虚拟DOM重新渲染并更新真实DOM。</p><p>生命周期钩子函数：</p><ul><li><code>beforeUpdate</code>: 在数据变化导致的虚拟DOM重新渲染和打补丁之前被调用。此时，<strong>你可以在这个钩子函数中进一步改变数据，避免不必要的更新</strong>。</li><li><code>updated</code>: 在数据变化导致的虚拟DOM重新渲染和打补丁之后被调用。此时，<strong>组件DOM已经更新</strong>，<strong>但不保证子组件也都已经更新</strong>。<strong>此时不要改数据</strong></li></ul></li><li><p>销毁阶段（Destruction）：在这个阶段，Vue实例或组件将被销毁，<strong>移除所有的事件监听器和子组件</strong>。</p><p>生命周期钩子函数：</p><ul><li><code>beforeDestroy</code>: 在实例销毁之前被调用。此时，实例仍然完全可用，<strong>你可以在这个钩子函数中执行清理操作</strong>，如取消定时器或事件监听器。</li><li><code>destroyed</code>: 在实例销毁之后被调用。此时，所有的事件监听器和子组件都已经被移除，<strong>Vue实例的所有属性和方法都不再可用</strong>。</li></ul></li></ol><p>通过在这些生命周期钩子函数中添加自定义逻辑，你可以在特定时机处理特定的任务，例如获取数据、操作DOM元素、监听或取消事件等</p><blockquote><p>一定要使用普通方法而不是lambda方法,不然this就是window了</p></blockquote><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p><h2 id="组件">组件</h2><p>Vue 组件（Component）是一种可复用的、独立的代码单元，它封装了 HTML、CSS 和 JavaScript 代码。组件的目的是将应用的各个部分划分成小的、独立的、可维护的单元，从而提高代码的复用性和可维护性。</p><p>组件有以下作用：</p><ol><li><strong>模块化</strong>：组件可以将复杂的 UI 划分成小的、独立的模块，使代码结构更加清晰，便于理解和维护。</li><li><strong>复用性</strong>：组件可以在多个地方重复使用，避免重复编写相同的代码，提高开发效率。</li><li><strong>封装</strong>：组件可以将其内部的实现细节隐藏起来，只暴露必要的接口，降低组件之间的耦合度，使组件更容易替换和升级。</li></ol><h3 id="非单文件组件">非单文件组件</h3><p>在 Vue 中，你可以使用以下几种方法来注册非单文件组件</p><p><strong>全局注册</strong>：通过 <code>Vue.component()</code> 方法注册的组件可以在应用中的任何地方使用。这种方法将组件注册为全局可用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;div&gt;这是一个全局注册的组件！&lt;/div&gt;&#x27;,</span><br><span class="line">  // 其他组件选项（如 data、methods 等）可在此定义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在模板中使用全局注册的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>局部注册</strong>：局部注册的组件只能在注册它的 Vue 实例和其子组件中使用。这种方法将组件注册为局部可用。</p><p>首先，定义一个组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const MyComponent = &#123;</span><br><span class="line">  template: &#x27;&lt;div&gt;这是一个局部注册的组件！&lt;/div&gt;&#x27;,</span><br><span class="line">  // 其他组件选项（如 data、methods 等）可在此定义</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，在 Vue 实例中局部注册这个组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &#x27;my-component&#x27;: MyComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在模板中使用局部注册的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>Vue.extend()</code></strong>：<code>Vue.extend()</code> 函数可以创建一个组件构造器，然后你可以根据需要在不同的地方使用这个构造器来创建组件实例。</p><p>首先，使用 <code>Vue.extend()</code> 创建一个组件构造器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const MyComponent = Vue.extend(&#123;</span><br><span class="line">  template: &#x27;&lt;div&gt;这是使用 Vue.extend() 创建的组件！&lt;/div&gt;&#x27;,</span><br><span class="line">  // 其他组件选项（如 data、methods 等）可在此定义</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来，在 Vue 实例中使用这个组件构造器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &#x27;my-component&#x27;: MyComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在模板中使用通过 <code>Vue.extend()</code> 创建的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这些方法都可以用来注册非单文件组件。全局注册的组件可以在整个应用范围内使用，而局部注册的组件仅在特定的 Vue 实例和其子组件中可用。<strong><code>Vue.extend()</code> 方法创建的组件构造器可以在多个地方重复使用</strong>。根据实际需求选择合适的注册方式。</p><p><code>Vue.extend()</code> 方法和直接使用字符串注册组件的区别在<strong>于注册到全局组件的时候</strong>, Vue.extend()得到的是一个构造函数,每次都是新的组件,而字符串的格式就相当于一个组件,每次使用都是一个组件,会共享状态</p><h2 id="vue脚手架">vue脚手架</h2><p>Vue 脚手架（Vue CLI，全称 Vue Command Line Interface）是一个基于 Vue.js 的官方命令行工具，旨在帮助开发者快速创建、开发和构建 Vue 项目。Vue 脚手架提供了一套完整的工具和预设选项，让你能专注于编写应用程序代码，而无需关注底层的构建配置和优化过程。</p><p>Vue 脚手架的主要功能和用途包括：</p><ol><li><strong>快速创建 Vue 项目</strong>：Vue 脚手架提供了一个简单的命令行界面，使得创建新的 Vue 项目变得非常容易。只需几个简单的命令，你就可以创建一个具有预先配置的 Vue 项目，包括目录结构、开发工具配置和基本的 Vue 模板。</li><li><strong>项目预设</strong>：Vue 脚手架提供了一些预设选项，允许你根据项目需求选择不同的配置。例如，你可以选择是否需要 Vue Router、Vuex 或者其他第三方库。这可以减轻配置项目的负担，同时确保项目结构的一致性。</li><li><strong>开发服务器</strong>：Vue CLI 集成了一个开发服务器（基于 webpack-dev-server），支持热模块替换（HMR）和其他开发功能，使得开发过程更为流畅。</li><li><strong>构建和优化</strong>：Vue CLI 提供了一套用于构建和优化 Vue 项目的工具，包括压缩、代码分割、按需加载等功能。这些工具可以帮助你生成高性能的生产环境代码。</li><li><strong>可扩展性和插件系统</strong>：Vue CLI 具有强大的可扩展性，允许你根据项目需求自定义构建配置。此外，Vue CLI 还提供了一个插件系统，使得开发者可以方便地为项目添加额外的功能。</li></ol><p>总之，Vue 脚手架是一个强大且易于使用的工具，旨在帮助开发者快速创建、开发和构建 Vue 项目。它提供了一套预先配置的工具和选项，使得开发者可以专注于编写应用程序代码，而无需关注底层的构建和优化过程。</p><blockquote><p>其实我们所见的功能就是将.vue文件变成html css js这些那</p></blockquote><h3 id="如何使用">如何使用</h3><p>安装vue/cli</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>创建项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create projectname</span><br></pre></td></tr></table></figure><p>启动项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>写好代码后,构建项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>这将构建并优化项目代码，生成的文件将存放在 <code>dist</code> 目录下。</p><h3 id="项目结构介绍">项目结构介绍</h3><p>使用 Vue 脚手架（Vue CLI）创建的项目具有以下目录结构。请注意，根据你在创建项目时选择的预设选项，某些目录和文件可能略有不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">my-project</span><br><span class="line">├── node_modules/         # 项目依赖模块存放目录</span><br><span class="line">├── public/               # 公共资源文件夹，不会被 webpack 处理，会直接复制到构建后的输出目录</span><br><span class="line">│   ├── favicon.ico       # 网站图标</span><br><span class="line">│   └── index.html        # 应用的入口 HTML 文件，可在此文件中添加全局资源引用</span><br><span class="line">├── src/                  # 项目源代码目录</span><br><span class="line">│   ├── assets/           # 资源目录，存放如图片、样式等静态资源，会被 webpack 处理</span><br><span class="line">│   ├── components/       # Vue 组件目录</span><br><span class="line">│   ├── views/            # 页面组件目录，通常用于存放路由组件（当使用 Vue Router 时）</span><br><span class="line">│   ├── App.vue           # 根组件</span><br><span class="line">│   ├── main.js           # 项目的入口文件，包括 Vue 实例化、引入全局资源等</span><br><span class="line">│   └── router.js         # 路由配置文件（当使用 Vue Router 时）</span><br><span class="line">├── tests/                # 测试文件目录</span><br><span class="line">├── .browserslistrc       # 浏览器兼容性配置，用于配置目标浏览器版本</span><br><span class="line">├── .eslintrc.js          # ESLint 配置文件，用于配置代码风格检查规则</span><br><span class="line">├── .gitignore            # Git 忽略文件配置</span><br><span class="line">├── babel.config.js       # Babel 配置文件，用于配置 JavaScript 编译选项</span><br><span class="line">├── package.json          # 项目描述文件，包括项目信息、依赖管理、脚本等</span><br><span class="line">└── vue.config.js         # Vue CLI 配置文件，用于自定义项目的构建配置（如果需要的话）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="做些配置">做些配置</h3><p>在vue.config.js中这么配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">lintOnSave</span>: <span class="literal">false</span>, <span class="comment">// 关闭代码检查</span></span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">        <span class="attr">port</span>:<span class="number">8081</span>, <span class="comment">// 更改端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="项目分析">项目分析</h3><p>我们来看一下main.js这个入口文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">// 关闭生产提示</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // 渲染页面</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)   //挂在到id为app的容器中</span><br></pre></td></tr></table></figure><p>这里使用了一个新的渲染函数,因为我们现在是.vue的格式文件了,而且这里引入的vue是一个残缺版的vue</p><p>在开发过程中，<strong>Vue 单文件组件（<code>.vue</code> 文件）的模板会被 Vue Loader 预编译为渲染函数</strong>。因此，运行时版本的 Vue（不包含模板编译器）已经可以正常工作。这意味着，项目中的模板在构建时就已经被编译成 JavaScript，<strong>不需要在浏览器中再进行模板编译</strong>。这有助于提高性能和减小输出文件的体积。</p><h2 id="ref属性">ref属性</h2><p>在 Vue 中，<code>ref</code> 是一个特殊的属性，用于获取对 DOM 元素或 Vue 组件实例的引用。<code>ref</code> 属性的主要作用是允许你在 Vue 实例的方法或计算属性中访问 <strong>DOM 元素</strong>或<strong>子组件实例(VC)</strong>，从而可以对它们进行操作或获取信息。</p><p>使用 <code>ref</code> 属性的步骤如下：</p><ol><li><p>在需要引用的 DOM 元素或组件上添加 <code>ref</code> 属性，并为其分配一个唯一的标识符（字符串）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&quot;myInput&quot; /&gt;</span><br><span class="line">&lt;my-component ref=&quot;myComponent&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 Vue 实例中通过 <code>this.$refs</code> 对象访问指定的 <code>ref</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    doSomething() &#123;</span><br><span class="line">      // 访问 DOM 元素</span><br><span class="line">      const myInputElement = this.$refs.myInput;</span><br><span class="line">      console.log(myInputElement.value);</span><br><span class="line"></span><br><span class="line">      // 访问组件实例</span><br><span class="line">      const myComponentInstance = this.$refs.myComponent;</span><br><span class="line">      myComponentInstance.someMethod();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，<code>ref</code> 属性不是响应式的，因此在引用发生变化时不会触发 Vue 实例的更新。另外，<code>ref</code> 属性仅在 Vue 实例渲染完成后可用。在实例创建期间（如 <code>created</code> 生命周期钩子中）访问 <code>this.$refs</code> 可能会得到 <code>undefined</code>。因此，在需要使用 <code>ref</code> 的场景中，通常会在 <code>mounted</code> 或 <code>updated</code> 生命周期钩子中进行操作。</p><p>总之，<code>ref</code> 属性使你能够在 Vue 实例中访问和操作 DOM 元素或子组件实例，从而实现更复杂的交互和功能。</p><h2 id="props属性">props属性</h2><p><code>props</code> 是 Vue 组件中的一个概念，表示属性。它允许父组件向子组件传递数据。<code>props</code> 的主要用途是实现组件之间的数据流动和通信，使组件更加灵活和可复用。组件可以根据接收到的 <code>props</code> 数据来调整其行为和显示内容，这样组件就可以在不同的场景下重复使用。</p><p>关于 <code>props</code>，有一些注意事项：</p><ol><li><strong>单向数据流</strong>：<code>props</code> 数据流动是单向的，从父组件流向子组件。为了保持数据的一致性和可预测性，不建议子组件直接修改 <code>props</code>。如果需要在子组件中改变 <code>props</code> 的值，可以创建一个局部变量或使用计算属性。</li><li><strong>类型检查</strong>：为了避免潜在的错误和数据不一致，建议在子组件中为 <code>props</code> 定义类型。Vue 提供了一个 <code>PropType</code> 工具，用于定义 <code>props</code> 的类型。这样，在传递非预期类型的数据时，Vue 将发出警告。</li><li><strong>默认值</strong>：为了让组件在未接收到特定 <code>props</code> 数据时仍能正常工作，可以为 <code>props</code> 提供默认值。在定义 <code>props</code> 时，可以使用 <code>default</code> 选项来设置默认值。</li><li><strong>必需属性</strong>：在某些场景下，子组件可能需要父组件传递某个 <code>props</code> 才能正常工作。为了确保组件的正确使用，可以将这些 <code>props</code> 标记为必需。在定义 <code>props</code> 时，可以使用 <code>required</code> 选项设置为 <code>true</code>。</li><li><strong>避免修改复杂数据类型</strong>：虽然不建议直接修改 <code>props</code>，但在处理复杂数据类型（如对象和数组）时，Vue 无法阻止你修改 <code>props</code>。修改复杂数据类型可能导致父组件和子组件的数据不一致。为了避免这种情况，可以使用计算属性或方法创建数据副本，然后在子组件中操作副本。</li></ol><p>props的数据是优先被代理到vc上面去的,  在beforecreate之前就有了,<strong>因此我们可以在data属性中使用</strong></p><blockquote><p>如果我们没有在组件中接收,那么会出现在vc的$attrs中</p></blockquote><h2 id="混入">混入</h2><p>在 Vue 中，混入（mixin）是一种代码重用机制，允许在多个组件间共享相同的功能、数据、生命周期钩子等。通过混入，你可以将组件的共同特性抽象成一个独立的对象，然后在需要的组件中引入该对象。这样可以避免重复代码，提高代码的可维护性和可读性。</p><p>混入的用途主要有以下几点：</p><ol><li><strong>共享数据</strong>：可以在混入对象中定义数据（data），然后在引入混入的组件中共享这些数据。</li><li><strong>共享方法</strong>：可以在混入对象中定义方法，这些方法可以在引入混入的组件中使用。这对于多个组件中都需要的通用功能尤为有用。</li><li><strong>共享生命周期钩子</strong>：混入对象中的生命周期钩子将在引入混入的组件的对应生命周期钩子之前调用。这可以用于在多个组件中执行相同的操作，例如获取数据、添加事件监听器等。</li><li><strong>共享计算属性和侦听器</strong>：混入对象也可以包含计算属性和侦听器。这使得可以在多个组件中重用相同的逻辑。</li></ol><p>需要注意的是，在使用混入时，<strong>如果混入对象和组件本身具有相同的选项（例如同名的方法或数据），组件本身的选项将优先级更高</strong>。<strong>对于生命周期钩子，它们将首先调用混入对象中的钩子，然后调用组件本身的钩子</strong>。</p><p>总之，混入是 Vue 中一种强大的代码重用机制，可以帮助你在多个组件间共享相同的功能、数据和逻辑，提高代码的可维护性和可读性。</p><h3 id="局部混合">局部混合</h3><p>在mixin.js中写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onst myMixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      mixinData: &quot;I&#x27;m from mixin&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    mixinMethod() &#123;</span><br><span class="line">      console.log(&quot;Mixin method called!&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&quot;Mixin created hook!&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在组件中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import myMixin from &#x27;./mixin.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [myMixin],</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&quot;Component created hook!&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.mixinMethod();</span><br><span class="line">    console.log(this.mixinData);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全局混入">全局混入</h3><p>全局混入需要谨慎使用，因为它会影响到每个组件。在大型项目中，过度使用全局混入可能导致代码难以维护和理解。通常，只有在需要向所有组件添加某些功能或钩子时才应使用全局混入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const globalMixin = &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#x27;Global mixin created hook!&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    globalMethod() &#123;</span><br><span class="line">      console.log(&#x27;Global mixin method called!&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.mixin(globalMixin);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="插件">插件</h2><p>在 Vue 中，插件是一种可重用的代码块，可以为 Vue 应用程序添加全局功能、自定义指令、过滤器等。插件的主要目的是扩展 Vue 的核心功能，使其能够满足特定场景和需求。插件通常封装在模块中，可以在多个 Vue 项目中使用。</p><p>插件的工作原理：插件应该暴露一个 <code>install</code> 方法，当 Vue 使用该插件时，将自动调用此方法。<code>install</code> 方法接收两个参数：第一个是 Vue 构造函数本身，第二个是一个可选的选项对象，可以用于配置插件的行为。</p><p>以下是一个简单的 Vue 插件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const MyPlugin = &#123;</span><br><span class="line">  install(Vue, options) &#123;</span><br><span class="line">    // 添加全局方法或属性</span><br><span class="line">    Vue.myGlobalMethod = function () &#123;</span><br><span class="line">      console.log(&#x27;MyPlugin global method called&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 添加全局自定义指令</span><br><span class="line">    Vue.directive(&#x27;my-directive&#x27;, &#123;</span><br><span class="line">      bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">        // 逻辑...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 添加全局过滤器</span><br><span class="line">    Vue.filter(&#x27;myFilter&#x27;, function (value) &#123;</span><br><span class="line">      // 返回处理后的值</span><br><span class="line">      return value.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 注入组件选项</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      created() &#123;</span><br><span class="line">        // 逻辑...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 添加实例方法</span><br><span class="line">    Vue.prototype.$myMethod = function () &#123;</span><br><span class="line">      console.log(&#x27;MyPlugin instance method called&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用插件</span><br><span class="line">Vue.use(MyPlugin);</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为 <code>MyPlugin</code> 的插件。该插件添加了一个全局方法、一个全局自定义指令、一个全局过滤器、一个混入以及一个实例方法。要在 Vue 应用程序中使用此插件，需要调用 <code>Vue.use()</code> 方法并将插件作为参数传递。</p><p>插件是 Vue 的一种强大扩展机制，<strong>可以帮助你为 Vue 添加全局功能、自定义指令、过滤器等，提高代码的可维护性和可读性。</strong></p><blockquote><p>我们只需要从别人那下载一个插件,我们只需要use一下就行,能够添加很多功能</p></blockquote><h2 id="scoped">scoped</h2><p>在 Vue 中，<code>scoped</code> 是一个特殊的属性，可以应用于单文件组件（SFC）的 <code>&lt;style&gt;</code> 标签。当你在 <code>&lt;style&gt;</code> 标签中添加 <code>scoped</code> 属性时，样式将只作用于当前组件。这意味着这些样式不会影响到其他组件，避免了全局 CSS 样式的污染和样式冲突。(css的层叠性是由我们引入的顺序来决定的)</p><p><code>scoped</code> 的工作原理：当 Vue 编译组件时，<strong>它会为每个组件的 DOM 元素添加一个唯一的属性（例如：<code>data-v-123456</code>）。然后，Vue 会根据这个属性调整样式规则，使它们只作用于具有相同属性值的元素。</strong>,通过属性选择器和我们定义的选择器一起选择</p><h2 id="组件自定义事件">组件自定义事件</h2><p>在 Vue 中，组件可以通过自定义事件与其他组件进行通信。自定义事件允许子组件向父组件发送消息，实现组件之间的解耦和数据流的单向传递。自定义事件的使用主要包括以下两个步骤：</p><ol><li><p>子组件触发自定义事件： 子组件可以使用 <code>$emit</code> 方法触发自定义事件。<code>$emit</code> 方法接受两个参数：第一个参数是事件名（字符串），第二个参数是可选的，表示传递给事件监听器的数据。</p><p>例如，在子组件中，可以触发一个名为 <code>my-event</code> 的自定义事件，并传递一个数据对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;my-event&#x27;, &#123; message: &#x27;Hello from the child component!&#x27; &#125;);</span><br></pre></td></tr></table></figure></li><li><p>父组件监听自定义事件： 父组件可以在子组件的标签上使用 <code>v-on</code> 指令（或简写为 <code>@</code>）或者<strong>使用子组件实例的 <code>$on</code> 方法为自定义事件添加监听器</strong> 来监听自定义事件。当子组件触发事件时，父组件的事件监听器将被调用，传递给它的数据可以在监听器函数中使用。</p><p>例如，在父组件模板中，可以监听子组件的 <code>my-event</code> 事件，并将其与一个处理函数绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-component @my-event=&quot;handleMyEvent&quot; ref=&quot;childComponentRef&quot;&gt;&lt;/child-component&gt;  #使用标签方式</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleMyEvent(payload) &#123;</span><br><span class="line">      console.log(&#x27;Received message from child component:&#x27;, payload.message);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 使用 $refs 访问子组件实例，并为自定义事件添加监听器</span><br><span class="line">    this.$refs.childComponentRef.$on(&#x27;my-event&#x27;, this.handleMyEvent);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当子组件触发 <code>my-event</code> 事件时，父组件的 <code>handleMyEvent</code> 方法将被调用，并接收到子组件传递的数据对象。</p></li></ol><p>**需要注意的是，在这使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>n</mi><mtext>这种方法的情况下</mtext><mo>∗</mo><mo>∗</mo><mtext>，你需要确保在组件销毁时移除事件监听器，以避免内存泄漏。可以在父组件的</mtext><mi mathvariant="normal">‘</mi><mi>b</mi><mi>e</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>D</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>y</mi><mi mathvariant="normal">‘</mi><mtext>生命周期钩子中使用子组件实例的</mtext><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">on这种方法的情况下**，你需要确保在组件销毁时移除事件监听器，以避免内存泄漏。可以在父组件的 `beforeDestroy` 生命周期钩子中使用子组件实例的 `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">种</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">下</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">你</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">销</span><span class="mord cjk_fallback">毁</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">监</span><span class="mord cjk_fallback">听</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">避</span><span class="mord cjk_fallback">免</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">泄</span><span class="mord cjk_fallback">漏</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord">‘</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">‘</span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">期</span><span class="mord cjk_fallback">钩</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">的</span><span class="mord">‘</span></span></span></span>off` 方法移除事件监听器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy() &#123;</span><br><span class="line">  // 移除自定义事件监听器</span><br><span class="line">  this.$off(&#x27;my-event&#x27;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>当使用模板语法（<code>v-on</code> 或 <code>@</code>）绑定事件监听器时，你不需要担心手动解绑。</strong></p><p><strong>通过使用自定义事件，可以实现子组件向父组件发送消息的需求，从而实现组件之间的解耦和数据流的单向传递</strong>。这是 Vue 组件通信的一种常用方法。</p><p><strong>如果要使用原生事件的话得使用native修饰符</strong>,不然vue把这个事件当成的是自定义事件</p><h2 id="组件通信">组件通信</h2><h3 id="父子组件通信">父子组件通信</h3><p>在 Vue2 中，父组件和子组件之间通信的主要方法是通过 props 和自定义事件。这种通信方式实现了单向数据流，有助于保持代码的可维护性。以下是父子组件通信的方法及其注意事项：</p><ol><li>父组件向子组件传递数据（通过 props）：<ul><li>父组件在子组件标签上绑定属性，子组件通过 props 接收这些属性。</li><li>子组件不应该直接修改接收到的 props 数据。如果需要修改，应该将其复制到子组件的局部状态（如 data 或 computed 属性）中。</li><li>子组件应在 <code>props</code> 选项中声明接收的属性，以便 Vue 可以对其进行验证和响应式处理。</li><li>可以为 props 提供类型、默认值和验证函数，以确保传递给子组件的数据是正确的。</li><li>优先使用<strong>驼峰式命名法（camelCase）为 props 命名</strong>，<strong>并在父组件中使用短横线分隔（kebab-case）的属性名</strong>。</li></ul></li><li>子组件向父组件发送消息（通过自定义事件）：<ul><li>子组件使用 <code>$emit</code> 方法触发自定义事件，父组件通过 <code>v-on</code> 或 <code>@</code> 监听这些事件。</li><li>避免在子组件中直接访问或修改父组件的状态。相反，应该使用自定义事件将数据发送给父组件，让父组件负责更新其状态。</li><li><strong>使用具有描述性的事件名，遵循 HTML 命名规范（字母、数字、短横线和下划线）</strong>。</li><li><strong>如果使用非模板语法（如 <code>$on</code>）添加事件监听器，需要在父组件销毁时手动解绑，以避免内存泄漏</strong>。</li></ul></li></ol><h3 id="任意组件通信">任意组件通信</h3><h4 id="全局事件总线">全局事件总线</h4><p>全局事件总线是一种用于跨组件通信的方法，它允许不同组件之间发送和接收事件，而无需通过父子关系。全局事件总线通常是一个 Vue 实例，它用作中心事件分发器。这种方法对于兄弟组件、跨层级组件和不直接关联的组件之间的通信非常有用。</p><p>要实现全局事件总线，你可以按照以下步骤操作：</p><ol><li><p>创建全局事件总线实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// eventBus.js</span><br><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">export const EventBus = new Vue();</span><br></pre></td></tr></table></figure></li><li><p>在需要发送事件的组件中，使用全局事件总线的 <code>$emit</code> 方法触发事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ComponentA.vue</span><br><span class="line">import &#123; EventBus &#125; from &#x27;./eventBus.js&#x27;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  sendMessage() &#123;</span><br><span class="line">    EventBus.$emit(&#x27;my-event&#x27;, &#123; message: &#x27;Hello from Component A!&#x27; &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></li><li><p>在需要接收事件的组件中，使用全局事件总线的 <code>$on</code> 方法监听事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ComponentB.vue</span><br><span class="line">import &#123; EventBus &#125; from &#x27;./eventBus.js&#x27;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">created() &#123;</span><br><span class="line">  EventBus.$on(&#x27;my-event&#x27;, this.handleMyEvent);</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleMyEvent(payload) &#123;</span><br><span class="line">    console.log(&#x27;Received message from Component A:&#x27;, payload.message);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>同时，记得在组件销毁时移除事件监听器，以避免内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ComponentB.vue</span><br><span class="line">// ...</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  EventBus.$off(&#x27;my-event&#x27;, this.handleMyEvent);</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></li></ol><p>使用全局事件总线，你可以在不同组件之间发送和接收事件，实现跨组件通信。但是，请注意，<strong>全局事件总线可能导致组件之间的紧耦合和难以维护的代码</strong>。因此，在使用全局事件总线时，请确保遵循良好的设计原则，尽量将组件之间的依赖关系保持在最低限度。对于大型应用程序，你可能需要考虑使用 Vuex 或其他状态管理解决方案以实现更好的组件通信和状态管理。</p><p>一个事件只能对应一个组件到另外一个组件的单向数据流动,这个使用起来可不是很方便</p><p>全局事件总线虽然可以实现跨组件通信，但也存在一些缺点：</p><ol><li>紧耦合：全局事件总线可能导致组件之间的紧耦合。当组件依赖于全局事件总线来进行通信时，它们可能会变得难以理解和维护。当应用程序变得更大时，跟踪和管理这些事件可能会变得复杂。</li><li>不透明性：全局事件总线的使用使得数据流和组件之间的通信变得不太明显。与使用 props 和自定义事件的父子组件通信相比，全局事件总线可能导致组件之间的通信变得难以追踪和理解。</li><li>内存泄漏：如果不正确地使用全局事件总线（例如，忘记在组件销毁时移除事件监听器），可能导致内存泄漏。这可能会影响应用程序性能，尤其是在长时间运行的单页应用程序中。</li><li>命名冲突：<strong>由于全局事件总线是一个共享实例，因此可能会出现命名冲突。当多个组件使用相同的事件名称时，可能会导致意外的行为和难以调试的问题。</strong></li><li>缺乏规模化支持：对于大型应用程序，全局事件总线可能不是最佳选择。随着应用程序的扩展，管理全局事件和组件间通信可能变得困难。在这种情况下，<strong>使用像 Vuex 这样的状态管理库可以提供更好的组织结构和可维护性</strong>。</li></ol><p>总之，虽然全局事件总线提供了跨组件通信的便利，但它也带来了一些缺点。在使用全局事件总线时，请确保遵循良好的设计原则，以便更好地管理组件之间的通信。在大型项目中，考虑使用状态管理库（如 Vuex）来实现更好的数据流管理和组件通信。</p><h4 id="发布与订阅模式">发布与订阅模式</h4><p>发布-订阅模式（Pub/Sub）是一种通信模式，用于在不相关的对象之间传递消息。在这种模式中，组件之间不直接通信。相反，它们通过一个中间代理（通常称为“消息代理”或“事件总线”）进行通信。发布者（Publisher）发布消息，而订阅者（Subscriber）订阅感兴趣的消息类型，并在相关消息到达时接收通知。</p><p>发布-订阅模式的主要优势之一是它可以解耦组件之间的依赖关系。发布者和订阅者之间没有直接的依赖关系，这使得它们更容易地独立地更改和重用。</p><p><strong>在前面的全局事件总线示例中，我们实际上已经实现了发布-订阅模式</strong>。这里的全局事件总线充当了消息代理，允许组件发布消息并订阅感兴趣的消息类型。组件使用 <code>$emit</code> 方法发布消息，使用 <code>$on</code> 方法订阅消息，然后使用 <code>$off</code> 方法取消订阅。</p><p>当然，你也可以使用其他 JavaScript 库来实现发布-订阅模式，如 EventEmitter、EventTarget 或者第三方库（如 PubSubJS、postal.js 等）。这些库可以帮助你创建和管理事件总线，从而实现更易于维护和扩展的发布-订阅模式。</p><h3 id="共享数据-vuex">共享数据(vuex)</h3><h4 id="基本概念">基本概念</h4><p>Vuex 是 Vue.js 应用程序的状态管理库，它采用集中式存储管理应用的所有组件状态，并以相应的规则<strong>保证状态以一种可预测的方式</strong>(就是我们必须提前定义好有哪些数据)发生变化。Vuex 在大型应用中非常有用，特别是当多个组件需要访问和修改共享数据时。</p><p>Vuex 可以帮助我们解决以下问题：</p><ol><li>组件间状态共享：当多个组件需要访问或修改同一数据时，将状态放在全局的 Vuex 存储中可以避免通过 props 和事件进行多层传递的问题。</li><li>状态修改规范化：Vuex 提供了一种规范化的方法来修改状态，通过提交 mutations（同步操作）和 dispatching actions（异步操作），使得状态管理更加可预测和易于追踪。</li><li>状态历史追踪与调试：Vuex 配合 Vue 开发者工具，可以非常方便地追踪状态变化的历史，从而更容易找到问题所在，提高调试效率。</li><li>插件支持：Vuex 支持插件扩展，这使得开发者可以轻松地添加自定义功能，例如日志记录、持久化存储等。</li></ol><p>以下是 Vuex 的主要概念：</p><ol><li>State（状态）</li></ol><p>​ State 是 Vuex store 的状态对象，用于存储应用的全局数据。你可以将需要共享的数据定义在 state 中。在组件中，你可以通过 <code>this.$store.state</code> 访问 state 对象中的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0,</span><br><span class="line">    user: &#123;</span><br><span class="line">      name: &#x27;John Doe&#x27;,</span><br><span class="line">      age: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>Getters（计算属性）</li></ol><p>Getters 是 Vuex store 的计算属性，用于根据 state 计算出衍生数据。它类似于 Vue 实例的计算属性，当依赖的 state 变化时，getters 会自动重新计算。你可以在组件中通过 <code>this.$store.getters</code> 访问 getters。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount(state) &#123;</span><br><span class="line">      return state.count * 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>Mutations（变更）</li></ol><p>Mutations 是用于修改 state 的唯一方法。它们是同步函数，接收 state 作为第一个参数，以及一个可选的 payload（载荷）作为第二个参数。你可以通过 <code>this.$store.commit('mutationName', payload)</code> 在组件中提交 mutation。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state, payload) &#123;</span><br><span class="line">      state.count += payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>Actions（动作）</li></ol><p>Actions 类似于 mutations，但它们负责处理异步操作。Actions 接收一个与 store 实例具有相同属性和方法的 context 对象作为第一个参数，以及一个可选的 payload 作为第二个参数。你可以通过 <code>this.$store.dispatch('actionName', payload)</code> 在组件中分发 action。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state, payload) &#123;</span><br><span class="line">      state.count += payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    asyncIncrement(context, payload) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        context.commit(&#x27;increment&#x27;, payload);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 Vuex 的基本步骤如下：</p><ol><li>安装并引入 Vuex。 vue2要使用3版本,vue3要使用4版本  npm i vuex@版本</li><li>创建一个 Vuex store，配置 state、getters、mutations、actions 和 modules。</li><li>将 store 注册到 Vue 实例。它是一个插件,我们得使用use</li><li>在组件中使用 store 的 state、getters、mutations 和 actions。</li></ol><p>综上所述，Vuex 是一个非常有用的状态管理库，可以帮助我们在 Vue.js 应用程序中更好地管理和维护状态。</p><h4 id="例子">例子</h4><p>我们来写个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// src/store/index.js</span><br><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);  // 创建store对象之间必须先引入vuex</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getCount: state =&gt; state.count</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;  // 这里第一个参数必须是状态, 后面如果需要参数的话我们自己定义,只不过在commit的时候记得传递参数</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement(state) &#123;</span><br><span class="line">      state.count--;</span><br><span class="line">    &#125;,</span><br><span class="line">    reset(state) &#123;</span><br><span class="line">      state.count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment(&#123; commit &#125;) &#123;  // 第一个参数必须是context,里面包含了commit函数,我们使用解构方法拿到commit, 后面如果需要参数的话我们自己定义,只不过在dispatch的时候记得传递参数</span><br><span class="line">      commit(&#x27;increment&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement(&#123; commit &#125;) &#123;</span><br><span class="line">      commit(&#x27;decrement&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    reset(&#123; commit &#125;) &#123;</span><br><span class="line">      commit(&#x27;reset&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再main.js中配置好这个store,然后打印vc看看,多了$store</p><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/image-20230403194500853.png" alt="image-20230403194500853"></p><h4 id="辅助函数">辅助函数</h4><p>Vuex 的四个辅助函数（<code>mapState</code>、<code>mapGetters</code>、<code>mapMutations</code> 和 <code>mapActions</code>）主要用于简化组件中访问 Vuex store 的方式。这些函数可以将 store 中的 state、getters、mutations 和 actions 映射到组件的计算属性或方法中，使得语法更加简洁</p><p>这些辅助函数分别用于不同的场景，它们可以映射到计算属性（<code>mapState</code> 和 <code>mapGetters</code>）或组件方法（<code>mapMutations</code> 和 <code>mapActions</code>）</p><h5 id="mapstate-和-mapgetters">mapState 和 mapGetters</h5><p>数据用法：直接使用字符串数组映射 state,getters的键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState,mapGetters  &#125; from &#x27;vuex&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&#x27;count&#x27;]), // 等同于 this.count === this.$store.state.count  这里必须使用数组</span><br><span class="line">    ...mapGetters([&#x27;getCount&#x27;]) // 等同于 this.getCount === this.$store.getters.getCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象用法：使用对象的键值对映射到组件计算属性的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      myCount: &#x27;count&#x27; // 等同于 this.myCount === this.$store.state.count</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mpaGetters(&#123;</span><br><span class="line">      myGetCount: &#x27;getCount&#x27; // 等同于 this.myGetCount === this.$store.getters.getCount</span><br><span class="line">    &#125;),</span><br><span class="line">    // 当然还有这种函数式</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">    myCount: state=&gt;state.count</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mapmutations-和-mapactions">mapMutations 和  mapActions</h5><p>数组用法：直接使用字符串数组映射 mutations 的键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([&#x27;increment&#x27;]) // 等同于 this.increment(a) === this.$store.commit(&#x27;increment&#x27;,a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象用法：使用对象的键值对映射到组件方法的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &#x27;increment&#x27; // 等同于 this.add() === this.$store.commit(&#x27;increment&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块化">模块化</h4><p>Vuex 支持将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块。模块化使得 Vuex store 更易于组织和维护</p><p>我们在配置文件里面就得这么写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import vuex from &quot;vuex&quot;</span><br><span class="line">import vue from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const student = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        studentlist:[&quot;djm&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    namespaced:true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const teacher = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        teacherlist:[&quot;djm&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    namespaced:true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vue.use(vuex)</span><br><span class="line">export default new vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        student,teacher</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后$store里面就不在是原先那样,state变了,不在是我们原先那个数据,而是分了模块</p><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/image-20230403220156122.png" alt="image-20230403220156122"></p><p>这个namespaced是为了使用那四个辅助函数,现在的四个辅助函数的使用跟前面差不多,只是第一个参数必须是模块名字,第二个参数才是需要拿到的东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters(&#x27;student&#x27;, [&#x27;studentlist&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果不使用辅助函数的话,就会像下面这样访问了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count() &#123;</span><br><span class="line">    return this.$store.state.counter.count;</span><br><span class="line">  &#125;,</span><br><span class="line">  getCount() &#123;</span><br><span class="line">    return this.$store.getters[&#x27;counter/getCount&#x27;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.$store.commit(&#x27;counter/increment&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  decrement() &#123;</span><br><span class="line">    this.$store.commit(&#x27;counter/decrement&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  incrementAsync() &#123;</span><br><span class="line">    this.$store.dispatch(&#x27;counter/incrementAsync&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="nexttick">$nexttick</h2><p><code>nextTick</code> 是 Vue 中的一个方法，它的作用是将一个回调函数延迟到DOM 更新循环之后执行。在 Vue 应用中，数据改变后，Vue 会异步更新 DOM。<code>nextTick</code> 可以帮助你在 DOM 更新完成之后立即执行特定的操作。</p><p><code>nextTick</code> 的常见用途包括：</p><ol><li>在 DOM 更新完成后执行某些操作。当你更改数据并希望在 DOM 更新后立即执行一些操作时，可以使用 <code>nextTick</code>。例如，你可能需要在更改数据后计算新的元素高度或宽度。</li><li>解决因数据更改导致的竞争条件。有时，你可能会遇到因数据更改和 DOM 更新的异步性导致的竞争条件。在这种情况下，<code>nextTick</code> 可以确保在更新 DOM 之后执行某些操作，从而避免潜在的问题。</li></ol><p>以下是一个 <code>nextTick</code> 的简单示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jsCopy codenew Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello, Vue!&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage() &#123;</span><br><span class="line">      this.message = &#x27;Message updated&#x27;;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;DOM updated:&#x27;, this.$el.textContent);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个示例中，我们更改了 <code>message</code> 属性的值，并在 <code>nextTick</code> 的回调函数中打印了更新后的 DOM 内容。这样，我们可以确保在 DOM 更新完成后执行 <code>console.log</code> 语句。</p><h2 id="代理服务器">代理服务器</h2><p>Vue 项目通常需要设置代理服务器，主要是为了解决开发环境中的跨域问题。由于浏览器的同源策略限制，直接向不同域的服务器发送请求会被阻止。使用代理服务器可以将请求转发到目标服务器，从而绕过同源策略。</p><p>Vue CLI 提供了内置的代理服务器功能，以便在开发过程中解决跨域问题。以下是如何在 Vue CLI 项目中使用代理服务器，</p><ol><li><p><strong>配置代理服务器</strong>：在 Vue CLI 项目的根目录中，找到或创建 <code>vue.config.js</code> 文件。在该文件中，配置 <code>devServer.proxy</code> 选项以设置代理规则。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;https://api.example.com&#x27;,  // 这里一定要配置成真实的地址</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#x27;^/api&#x27;: &#x27;&#x27;  // 如果不写这个,会带着原来的请求路径一起带过去</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述配置示例将所有以 <code>/api</code> 开头的请求代理到 <code>https://api.example.com</code>。</p></li></ol><h2 id="插槽slot">插槽slot</h2><h3 id="定义">定义</h3><p>Vue 中的插槽（slots）是一种在组件模板中预留位置，允许父组件向子组件传递自定义内容。插槽的概念类似于 HTML 中的占位符，它们提供了一种灵活的方式来组合和重用组件。</p><p>Vue中有两种主要的插槽类型：普通插槽（匿名插槽）和具名插槽（命名插槽）。在 Vue 3.x 版本中，还引入了新的插槽类型：作用域插槽（Scoped Slots）。</p><ol><li>普通插槽（匿名插槽）： 普通插槽是默认的插槽类型，<strong>当子组件中没有明确的插槽名称时，内容会默认分发到这些插槽</strong>。在子组件中使用<code>&lt;slot&gt;&lt;/slot&gt;</code>标签定义，父组件可以在子组件标签内部放置内容，这些内容会替换子组件中的<code>&lt;slot&gt;&lt;/slot&gt;</code>标签。</li><li>具名插槽（命名插槽）： 具名插槽允许你在组件中定义多个插槽，并使用不同的名字来区分。在子组件中，使用<code>&lt;slot name=&quot;slotName&quot;&gt;&lt;/slot&gt;</code>来定义一个具名插槽。在父组件中，你可以使用<code>&lt;template v-slot:slotName&gt;</code> 或者 <code>&lt;template #slotName&gt;</code> 或者标签属性里面指明插槽比如(&lt;a  slot=“name”&gt;的语法来指定要插入到具体插槽的内容。</li><li>作用域插槽（Scoped Slots）： 作用域插槽是Vue 3.x引入的新概念，允许父组件接收子组件传递过来的数据，并在父组件中使用这些数据来渲染插槽内容。子组件中使用&lt;slot name=<strong>“scopedSlotName”</strong> :propName=“propValue”&gt;&lt;/slot&gt;来定义作用域插槽并传递数据。在父组件中，使用&lt;template v-slot:<strong>scopedSlotName</strong>=“slotProps”&gt;(里面能够使用slotProps,它包含了所有的propValue)<code>或者</code>&lt;template #scopedSlotName=“slotProps”&gt;`的语法来获取子组件传递的数据，并在插槽内部使用这些数据。</li></ol><h3 id="举例">举例</h3><h4 id="匿名插槽-anonymous-slots-：">匿名插槽 (Anonymous Slots)：</h4><p>在子组件中定义一个插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件（ChildComponent.vue） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父组件中使用子组件，并将内容传递给插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件（ParentComponent.vue） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span>&gt;</span>这是匿名插槽的内容<span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="具名插槽-named-slots-：">具名插槽 (Named Slots)：</h4><p>在子组件中定义一个具名插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件（ChildComponent.vue） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父组件中使用子组件，并将内容传递给具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件（ParentComponent.vue） --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-component&gt;</span><br><span class="line">      &lt;template v-slot:header&gt;</span><br><span class="line">        &lt;h1&gt;这是 header 插槽的内容&lt;/h1&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:body&gt;</span><br><span class="line">        &lt;p&gt;这是 body 插槽的内容&lt;/p&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/child-component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="作用域插槽-scoped-slots-：">作用域插槽 (Scoped Slots)：</h4><p>在子组件中定义一个作用域插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件（ChildComponent.vue） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;scoped&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;来自子组件的数据&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父组件中使用子组件，并通过作用域插槽接收并使用子组件传递的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件（ParentComponent.vue） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:scoped</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是作用域插槽的内容：&#123;&#123; slotProps.data.message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意点">注意点</h3><p>使用 Vue 插槽时，需要注意以下几点：</p><ol><li><strong>默认内容： 对于普通插槽和具名插槽，在定义插槽时可以在<code>&lt;slot&gt;</code>标签内部放置默认内容</strong>。如果父组件没有提供插槽内容，子组件会显示默认内容。这在某些情况下非常有用，比如可选的标题或说明性文本。</li><li>动态插槽名： 有时，你可能需要根据一些条件来选择使用哪个插槽。在这种情况下，你可以使用动态插槽名。在父组件中，可以使用<code>&lt;template v-slot:[dynamicSlotName]&gt;</code>或<code>&lt;template #[dynamicSlotName]&gt;</code>的语法来定义动态插槽名。</li><li>插槽传递限制： <strong>需要注意的是，插槽内容在父组件的作用域内进行编译，而非子组件。这意味着在插槽内容中，你不能直接访问子组件的数据或方法</strong>。在作用域插槽中，可以通过子组件传递的数据来实现父子组件之间的数据交互。</li><li>插槽命名规范： 为了避免命名冲突，建议使用具有一定意义的插槽名，这有助于提高代码的可读性。同时，遵循一定的命名规范（如驼峰式命名或短横线分隔式命名）可以确保插槽名在不同平台和环境下的一致性。</li><li>作用域插槽的解构： 在使用作用域插槽时，可以利用解构语法简化插槽属性的访问。例如，如果子组件传递了一个名为<code>item</code>的属性，你可以使用<code>&lt;template v-slot:scopedSlotName=&quot;&#123; item &#125;&quot;&gt;</code>或<code>&lt;template #scopedSlotName=&quot;&#123; item &#125;&quot;&gt;</code>的语法直接获取<code>item</code>属性。</li></ol><h2 id="路由">路由</h2><p>Vue中的路由指的是Vue Router，它是一个官方提供的插件，用于处理单页面应用（SPA）的导航和页面间切换。Vue Router能实现以下功能：</p><ol><li>映射：它可以将不同的URL映射到不同的组件，让用户在访问不同的URL时看到对应的内容。</li><li>嵌套路由：Vue Router支持嵌套路由，这意味着你可以在一个页面中嵌套使用多个组件，构建更复杂的页面结构。</li><li>导航守卫：Vue Router提供了导航守卫功能，允许你在路由切换之前或之后执行一些操作，例如验证用户权限、页面访问权限等。</li><li>路由懒加载：对于较大的应用，Vue Router可以实现路由懒加载，按需加载组件，提高应用的性能。</li><li>响应式导航：Vue Router与Vue.js紧密集成，可以实现响应式导航，自动更新视图。</li></ol><h3 id="如何使用">如何使用</h3><h4 id="安装路由插件">安装路由插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router@3   # vue2安装版本</span><br><span class="line">npm i vue-router@4   # vue3安装版本</span><br></pre></td></tr></table></figure><h4 id="编写router配置项">编写router配置项:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><h4 id="实现切换-active-class可配置高亮样式">实现切换（active-class可配置高亮样式）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h4 id="指定展示位置">指定展示位置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h3 id="路由常用配置项">路由常用配置项</h3><p>Vue Router 的路由配置是一个包含多个路由对象的数组，每个路由对象可以包含以下配置项：</p><ol><li><p><strong>path</strong>（必选）：表示路由的路径，它是一个字符串。路径可以包含动态参数（使用冒号 <code>:</code> 表示），例如 <code>/user/:id</code>。</p></li><li><p><strong>name</strong>（可选）：表示路由的名称，它是一个字符串。为路由指定一个名称可以让你在使用编程式导航时通过名称而不是路径来引用路由。</p></li><li><p><strong>component</strong>（必选）：表示与路由关联的 Vue 组件。当路由被匹配时，这个组件将被渲染。你可以直接提供一个组件对象，或者使用 <code>import()</code> 语法来实现组件的懒加载。</p></li><li><p><strong>components</strong>（可选）：表示与路由关联的多个命名视图组件。它是一个包含组件名称与组件对象的键值对的对象。当使用命名视图时，可以使用此选项替代 <code>component</code>。</p></li><li><p><strong>redirect</strong>（可选）：表示当访问此路由时重定向到的路径或命名路由。它可以是一个字符串（表示路径或路由名称），或者一个函数，该函数接收当前路由对象作为参数，返回一个字符串或一个包含 <code>path</code> 或 <code>name</code> 的对象。</p></li><li><p><strong>alias</strong>（可选）：表示路由的别名。别名是一个字符串（表示路径）或一个字符串数组。当访问别名时，将渲染与原始路由关联的组件，但 URL 保持不变。</p></li><li><p><strong>children</strong>（可选）：表示嵌套路由。它是一个包含多个路由对象的数组。当访问一个嵌套路由时，将渲染父路由关联的组件以及与嵌套路由关联的组件。</p></li><li><p><strong>meta</strong>（可选）：表示路由的元信息。它是一个包含任意键值对的对象。这些信息可以在导航守卫或其他地方访问，以便实现特定的功能（例如权限控制）。</p></li><li><p><strong>props</strong>（可选）：表示将路由参数作为组件的 <code>props</code> 传递给组件。它可以是一个布尔值、一个对象或一个函数。当设置为 <code>true</code> 时，将把 <code>params</code> 作为 <code>props</code> 传递；当设置为一个对象时，将把对象中的键值对作为 <code>props</code> 传递；当设置为一个函数时，将把函数的返回值作为 <code>props</code> 传递。</p></li><li><p><strong>beforeEnter</strong>（可选）：表示路由的独享守卫(前置)。它是一个函数，接收三个参数：<code>to</code>、<code>from</code> 和 <code>next</code>。当访问此路由时，将执行此函数。可以在此函数中执行权限验证、数据获取等操作，并使用 <code>next()</code> 函数来控制导航的行为。<code>beforeEnter</code> 函数可以是异步的</p></li><li><p><strong>caseSensitive</strong>（可选）：表示路由匹配是否区分大小写。它是一个布尔值，默认为 <code>false</code>。当设置为 <code>true</code> 时，路由匹配将区分 URL 路径的大小写。</p></li><li><p><strong>pathToRegexpOptions</strong>（可选）：表示用于将 <code>path</code> 转换为正则表达式的选项。它是一个对象，可以包含 <code>path-to-regexp</code> 库支持的选项。例如，你可以使用 <code>&#123; strict: true &#125;</code> 选项来要求 URL 路径的尾部斜杠严格匹配。</p></li></ol><h3 id="几个注意点">几个注意点</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h3 id="多级路由">多级路由</h3><ol><li><p>配置路由规则，使用children配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="路由匹配规则">路由匹配规则</h3><p>Vue-router 的路由匹配规则主要基于以下几个方面：</p><ol><li><p>路径匹配（Path matching）：Vue-router 使用路径字符串模式进行匹配，这些模式类似于正则表达式，但使用的是一种更简单的语法。以下是一些常见的路径模式：</p><ul><li>静态路径（Static paths）：<code>/foo</code> 匹配 <code>/foo</code> 路径。</li><li>动态路径（Dynamic paths）：<code>/user/:id</code> 匹配 <code>/user/1</code>、<code>/user/2</code> 等路径。冒号后面的部分（<code>:id</code>）表示一个动态路径参数。</li><li>通配符（Wildcard）：<code>/foo/*</code> 匹配 <code>/foo/bar</code>、<code>/foo/baz</code> 等路径。<code>*</code> 表示一个通配符，可以匹配任意字符。</li><li>正则表达式：<code>/user/:id(\\d+)</code> 匹配 <code>/user/1</code>，但不匹配 <code>/user/abc</code>。括号内的部分是一个正则表达式，用于约束动态参数的格式。</li></ul></li><li><p>优先级（Priority）：当多个路由规则与同一个路径匹配时，Vue-router 会根据路由配置中的顺序选择第一个匹配的路由。因此，优先级由路由配置的顺序决定，靠前的路由具有更高的优先级。</p></li><li><p>嵌套路由（Nested routes）：Vue-router 支持嵌套路由，允许在父路由下定义子路由。子路由的路径会与父路由的路径进行拼接，形成完整的路径。例如，父路由路径为 <code>/foo</code>，子路由路径为 <code>/bar</code>，则完整路径为 <code>/foo/bar</code>。</p></li><li><p>重定向（Redirects）：Vue-router 允许配置重定向规则，将一个路径重定向到另一个路径。重定向规则在匹配时具有较高的优先级。例如，将 <code>/a</code> 重定向到 <code>/b</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&#x27;/b&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>别名（Aliases）：Vue-router 支持为路由配置别名，这样一个路由可以有多个路径与之匹配。别名在匹配时具有较低的优先级。例如，为 <code>/foo</code> 配置别名 <code>/bar</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">FooComponent</span>,</span><br><span class="line">  <span class="attr">alias</span>: <span class="string">&#x27;/bar&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>根据这些规则，Vue-router 在接收到路径时，会按照路由配置中的顺序依次匹配，直到找到第一个匹配的路由规则为止。匹配成功后，Vue-router 会将相应的组件渲染到 <code>&lt;router-view&gt;</code> 标签中。</p><h3 id="路由的query参数">路由的query参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="命名路由">命名路由</h3><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;hello&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="路由的params参数">路由的params参数</h3><ol><li><p>配置路由，声明接收params参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 ,如果要携带参数的话,得用模板字符串--&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，<strong>若使用to的对象写法</strong>，<strong>则不能使用path配置项，必须使用name配置！</strong></p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="路由的props配置">路由的props配置</h3><p>​作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="router-link-的replace属性"><code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="编程式路由导航">编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,  <span class="comment">// 这里也可以使用path,但是必须使用query,跟to的对象写法一样</span></span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退,参数是一个整数类型,可以为负数和正数,负数代表后退,正数代表前进</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="缓存路由组件">缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt;  &lt;!-- ,代表要缓存的组件,值为组件名字,配置项里面的name,里面得是router-view标签,不写的话就代表全部缓存,可以是数组,不过得用绑定--&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="两个新的生命周期钩子">两个新的生命周期钩子</h3><ol><li>作用：<strong>路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</strong></li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h3 id="路由守卫">路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制,这里涉及到元数据</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>独享守卫:</p><p><strong>这个是在配置一个路由组件的时候,单独在配置项里面</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/protected&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/ProtectedView.vue&#x27;</span>),</span><br><span class="line">      <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这是一个独享守卫。你可以在这里放置任何你需要的逻辑，比如检查用户是否已经登录。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isLoggedIn</span>()) &#123;</span><br><span class="line">          <span class="title function_">next</span>() <span class="comment">// 允许导航</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">// 重定向到登录页</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 其他路由...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 路由参数变化守卫:</span></span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="路由器的两种工作模式">路由器的两种工作模式</h3><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history模式：<ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol><p>在 Vue 2 中，要设置 Vue Router 的路由模式为 hash（哈希模式）还是 history（历史模式），需要在创建 Vue Router 实例时，使用 <code>mode</code> 属性指定模式。</p><p>以下是如何设置路由模式的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;hash&#x27;</span>, <span class="comment">// 使用哈希模式</span></span><br><span class="line">  <span class="comment">// mode: &#x27;history&#x27;, // 使用历史模式</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们将 <code>mode</code> 属性设置为 <code>'hash'</code>，以便使用哈希模式。如果想使用历史模式，可以将 <code>mode</code> 属性设置为 <code>'history'</code>。</p><h1>Vue3</h1><h2 id="vue3带来了什么">Vue3带来了什么</h2><h3 id="1-性能的提升">1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>…</p></li></ul><h3 id="2-源码的升级">2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>…</p></li></ul><h3 id="3-拥抱typescript">3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性">4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>…</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment</li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>…</li></ul></li></ol><h2 id="常用-composition-api">常用 Composition API</h2><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h3 id="1-拉开序幕的setup">1.拉开序幕的setup</h3><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><p>vue2中data函数的返回值会被修改,通过闭包保留原先的数据变量,通过get,set方法得到和修改这个变量,他自己就变成了代理对象,而且这些数据还会被代理到组件实例对象身上去,而且如果修改了数据,就会进行响应式处理</p><p>在vue3中setup的返回值不会被修改,但是他会被一个proxy对象代理 , 如果我们将一个函数返回出去了,那么这个函数里面的this就是这个代理对象,返回值也会被代理到组件实例对象身上去,<strong>但是默认情况下修改数据不会进行响应式处理,我们能够修改数据,但是不会重新解析模板</strong>,我们需要特殊的函数处理</p><h3 id="2-ref函数">2.ref函数</h3><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code><ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。返回值还是refimpl对象,还得通过value拿到代理的proxy对象</li></ul></li></ul><h3 id="3-reactive函数">3.reactive函数</h3><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><blockquote><p>他代理的对象是跟对象的使用是一样的,ref代理的对象跟ref.value的对象的使用是一样的</p><p>被reactive代理的数组通过索引修改也能做到响应式</p></blockquote><h3 id="4-vue3-0中的响应式原理">4.Vue3.0中的响应式原理</h3><h4 id="vue2-x的代理">vue2.x的代理</h4><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li><strong>新增属性、删除属性, 界面不会更新</strong>。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h4 id="vue3-0的代理">Vue3.0的代理</h4><ul><li><p>实现原理:</p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：<strong>属性值的读写、属性的添加、属性的删除等</strong>。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line"><span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>通过代理,我们能够劫持到数据,然后进行响应式处理,在vue2中数据劫持的时候如果修改了数据,那么就会进行模板重新解析,但是在vue3中,我们必须使用相<strong>应的响应式函数进行处理,这样在对数据修改后才能重新解析模板</strong></p><p>我们可以验证一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    b:1,</span><br><span class="line">    a:ref(1),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有a,b两个数据,当我们修改b的时候数据会变化,但是模板不会解析</p><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/image-20230405132141812.png" alt="image-20230405132141812"></p><p>我们点击b++</p><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/image-20230405132238502.png" alt="image-20230405132238502"></p><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/image-20230405132313884.png" alt="image-20230405132313884"></p><p><strong>这里我们将app组件代理对象放在window上,  发现b的值是2,但是页面还是1</strong></p><p>我们点击a++</p><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/image-20230405132335674.png" alt="image-20230405132335674"></p><p>我们会发现两个值都变了</p><p><img src="/2023/04/01/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/../img/vue%E5%AD%A6%E4%B9%A0assets/image-20230405142549084.png" alt="image-20230405142549084"></p><h3 id="5-reactive对比ref">5.reactive对比ref</h3><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h3 id="6-setup的两个注意点">6.setup的两个注意点</h3><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h3 id="7-计算属性与监视">7.计算属性与监视</h3><h4 id="1-computed函数">1.computed函数</h4><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-watch函数">2.watch函数</h4><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、默认开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中<strong>某个属性时</strong>：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这里的newValue和oldValue有两个数据,sum和msg</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，会默认自动开启深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性,注意这里得用函数</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">age</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的age变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">age</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的age和name变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job里面的东西变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//这里得配置deep,因为这是一个属性对象,想要监视里面的东西,得用deep</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-watcheffect函数">3.watchEffect函数</h4><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的<strong>计算出来的值</strong>（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffec<strong>t更注重的是过程</strong>（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-生命周期">8.生命周期</h3><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：(这些周期函数还能在配置项里面使用,如果要在setup里面定义要用前面的名字,我们还得引入这些东西)<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h3 id="9-自定义hook函数">9.自定义hook函数</h3><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p><strong>类似于vue2.x中的mixin。</strong></p></li><li><p>自定义hook的优势: <strong>复用代码, 让setup中的逻辑更清楚易懂。</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// hook/point.js</span><br><span class="line"></span><br><span class="line">import &#123;reactive,onMounted,onBeforeUnmount&#125; from &#x27;vue&#x27;</span><br><span class="line">export default function ()&#123;</span><br><span class="line">//实现鼠标“打点”相关的数据</span><br><span class="line">let point = reactive(&#123;</span><br><span class="line">x:0,</span><br><span class="line">y:0</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//实现鼠标“打点”相关的方法</span><br><span class="line">function savePoint(event)&#123;</span><br><span class="line">point.x = event.pageX</span><br><span class="line">point.y = event.pageY</span><br><span class="line">console.log(event.pageX,event.pageY)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现鼠标“打点”相关的生命周期钩子</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">window.addEventListener(&#x27;click&#x27;,savePoint)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">window.removeEventListener(&#x27;click&#x27;,savePoint)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">return point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在app.vue中引入</span><br><span class="line">import usepoint from &quot;./hook/point.js&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setup()&#123;</span><br><span class="line">point = userpoint()  //当我们你在setup中使用这个函数的时候,就相当于把里面的代码放进来一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-toref">10.toRef</h3><ul><li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,'name')</code></p></li><li><p>应用:   <strong>要将响应式对象中的某个属性单独提供给外部使用时</strong>。简化我们的模板语法</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">   //数据</span><br><span class="line">   let person = reactive(&#123;</span><br><span class="line">     name: &quot;张三&quot;,</span><br><span class="line">     age: 18,</span><br><span class="line">     job: &#123;</span><br><span class="line">       j1: &#123;</span><br><span class="line">         salary: 20,</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;);</span><br><span class="line">   //返回一个对象（常用）</span><br><span class="line">   return &#123;</span><br><span class="line">     person,</span><br><span class="line">     // name:toRef(person,&#x27;name&#x27;), 这里不能使用 name: ref(person.name) </span><br><span class="line">     // age:toRef(person,&#x27;age&#x27;),</span><br><span class="line">     // salary:toRef(person.job.j1,&#x27;salary&#x27;),</span><br><span class="line">     ...toRefs(person),  // 这样我们能够在模板中直接使用属性名字,而不用对象名字</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里不能使用ref 这样会导致数据不同步, 因为ref并没有引用原数据,而是一个新数据</p></blockquote><h3 id="11-总结">11.总结</h3><p>在setup中返回值都是一些数据和方法和计算属性,  如果要用监视,生命周期钩子函数,得引入这些东西,</p><p>如果要给数据添加响应式的功能,得用ref 和 reactive    基本数据类型用ref, 对象这些用reactive</p><h2 id="其它-composition-api">其它 Composition API</h2><h3 id="1-shallowreactive-与-shallowref">1.shallowReactive 与 shallowRef</h3><ul><li><p>shallowReactive：<strong>只处理对象最外层属性的响应式</strong>（浅响应式,只响应第一层数据）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, <strong>不进行对象的响应式处理</strong>,这里其实也是第一层,只代理value数据,如果我们修改整个value的话,还有会响应的。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换(这里指的是把整个都替换掉会有响应,比不使用多了一个这个功能) ===&gt; shallowRef。</li></ul></li></ul><h3 id="2-readonly-与-shallowreadonly">2.readonly 与 shallowReadonly</h3><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读,第一层不能改,后面的层能改,整个数据也能改）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h3 id="3-toraw-与-markraw">3.toRaw 与 markRaw</h3><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：<strong>标记一个对象，使其永远不会再成为响应式对象</strong>。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li><strong>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</strong>。</li></ol></li></ul></li></ul><h3 id="4-customref">4.customRef</h3><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Demo&#x27;,</span><br><span class="line">setup()&#123;</span><br><span class="line">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">//自定义一个myRef</span><br><span class="line">function myRef(value,delay)&#123;</span><br><span class="line">let timer</span><br><span class="line">//通过customRef去实现自定义</span><br><span class="line">return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">return&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">return value</span><br><span class="line">&#125;,</span><br><span class="line">set(newValue)&#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">timer = setTimeout(()=&gt;&#123;</span><br><span class="line">value = newValue</span><br><span class="line">trigger() //告诉Vue去更新界面</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">return &#123;</span><br><span class="line">keyword</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-provide-与-inject">5.provide 与 inject</h3><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="6-响应式数据的判断">6.响应式数据的判断</h3><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id="composition-api-的优势">Composition API 的优势</h2><h3 id="1-options-api-存在的问题">1.Options API 存在的问题</h3><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left"></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left"> </div><h3 id="2-composition-api-的优势">2.Composition API 的优势</h3><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" style="height:360px"></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" style="height:360px"></div><h2 id="五-新的组件">五、新的组件</h2><h3 id="1-fragment">1.Fragment</h3><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><blockquote><p>不需要我们去写这个标签</p></blockquote><h3 id="2-teleport">2.Teleport</h3><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到<strong>指定位置的技术</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt; // 这里可以放一些选择器</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-suspense">3.Suspense</h3><ul><li><p><strong>等待异步组件时渲染一些额外内容</strong>，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">&lt;template v-slot:default&gt;</span><br><span class="line">&lt;Child/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-slot:fallback&gt;</span><br><span class="line">&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="六-其他">六、其他</h2><h3 id="1-全局api的转移">1.全局API的转移</h3><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h3 id="2-其他改变">2.其他改变</h3><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>…</p></li></ul><h1>Vue3使用的区别</h1><h2 id="setup-语法糖">setup 语法糖</h2><h3 id="props">props</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;foo&#x27;</span>]) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">foo</span>)</span><br></pre></td></tr></table></figure><h3 id="emit">emit</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;event&#x27;</span>])</span><br><span class="line"><span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="多个script">多个script</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default&#123;</span><br><span class="line">        name:&quot;Component&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">   //.....</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义指令">自定义指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line">  <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件名字">组件名字</h2><p>使用语法糖的格式是无法定义组件名字的,我们可以另起一个script标签来定义名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;search&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="异步setup">异步setup</h2><p>如果我们希望我们的setup里面能够调用其他的异步函数并且等待他的话, 我们必须将我们的组件声明为一个异步组件, 异步组件分为两种,一种就是异步普通组件,一种是异步路由组件</p><h3 id="异步路由组件">异步路由组件</h3><p>在router.js中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Index = () =&gt; import(&quot;../pages/Index.vue&quot;)</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#x27;/index&#x27;, component: Index &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后需要父组件中加入Suspense让用户体验更好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense&gt;</span><br><span class="line">  &lt;template #default&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template #fallback&gt;</span><br><span class="line">    &lt;div&gt;Loading...&lt;/div&gt; &lt;!-- 这里可以替换成你的加载状态组件 --&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure><h2 id="普通组件">普通组件</h2><p>在父组件的setup函数中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Index = () =&gt; import(&quot;../pages/Index.vue&quot;)</span><br></pre></td></tr></table></figure><p>引入该组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Suspense&gt;</span><br><span class="line">    &lt;template #default&gt;</span><br><span class="line">      &lt;Index /&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template #fallback&gt;</span><br><span class="line">      &lt;div&gt;Loading...&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/Suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="动态组件">动态组件</h2><p>在 Vue 3 中，动态组件是一种灵活的方式，可以在运行时动态改变要渲染的组件。使用动态组件可以让您的应用更具交互性，并实现代码复用。动态组件的核心概念是通过将组件赋给一个变量，然后使用特殊的 <code>&lt;component&gt;</code> 标签来渲染它。</p><p>要使用动态组件，您需要遵循以下步骤：</p><ol><li>在 <code>&lt;script&gt;</code> 中导入要使用的组件。</li><li>将组件分配给一个响应式变量。</li><li>在模板中使用 <code>&lt;component :is=&quot;currentComponent&quot;&gt;</code> 标签，其中 <code>currentComponent</code> 是存储当前组件的响应式变量。</li></ol><p>下面是一个简单的动态组件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;changeComponent&quot;&gt;Toggle Component&lt;/button&gt;</span><br><span class="line">    &lt;component :is=&quot;currentComponent&quot; /&gt;  </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import ComponentA from &quot;./ComponentA.vue&quot;;</span><br><span class="line">import ComponentB from &quot;./ComponentB.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">const currentComponent = ref(&quot;ComponentA&quot;);  // 可以是组件名字也可以是组件对象</span><br><span class="line"></span><br><span class="line">const changeComponent = () =&gt; &#123;</span><br><span class="line">    currentComponent.value = currentComponent.value === &quot;ComponentA&quot; ? &quot;ComponentB&quot; : &quot;ComponentA&quot;;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个动态组件，它会在 <code>ComponentA</code> 和 <code>ComponentB</code> 之间切换。当用户点击按钮时，<code>changeComponent</code> 函数会更新 <code>currentComponent</code> 的值，从而触发动态组件的切换。</p><p>需要注意的是，在使用动态组件时，Vue 会尽量重用现有的组件实例，以便更高效地更新 DOM。但这可能导致组件状态在切换时得不到清除。为了解决这个问题，您可以使用 <code>key</code> 属性强制 Vue 在切换组件时销毁旧的组件实例并创建新的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;currentComponent&quot; :key=&quot;currentComponent&quot; /&gt;</span><br></pre></td></tr></table></figure><p>这将确保在组件切换时，每个组件都会有一个全新的实例，从而避免潜在的状态问题。</p><h2 id="vue-router">vue-router</h2><p>Vue 3 使用 Vue Router 4，而 Vue 2 使用的是 Vue Router 3。虽然它们在使用方法和核心概念上非常相似，但是 Vue Router 4 为 Vue 3 带来了一些变化和改进。以下是 Vue 3 中路由使用的主要变化：</p><h3 id="安装">安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@next</span><br></pre></td></tr></table></figure><h3 id="创建路由实例">创建路由实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title class_">VueRouter</span>.<span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title class_">VueRouter</span>.<span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> router</span><br></pre></td></tr></table></figure><h3 id="路由匹配">路由匹配</h3><ul><li>通配符路由（Wildcard routes）：在 Vue Router 4 中，匹配任意路径的通配符 <code>*</code> 被废弃。取而代之的是使用 <code>/:catchAll(.*)</code> 的方式来实现类似的功能。这里的catchAll我们可以随意命名</li><li>命名路由的子路由：在 Vue Router 3 中，命名路由可以有一个默认子路由。而在 Vue Router 4 中，如果一个命名路由具有一个默认子路由（没有名称和空路径），那么这将触发一个警告。为了解决这个警告，你可以将父路由的名称移动到子路由，或者为子路由添加一个名称。</li></ul><h3 id="路由守卫">路由守卫</h3><p>全局前置守卫的定义方式发生了变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy code// Vue 2</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Vue 3</span><br><span class="line">router.beforeEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 Vue Router 4 中，不再需要调用 <code>next()</code> 函数。可以直接返回一个响应或者 Promise。</p><h3 id="路由使用">路由使用</h3><p>Vue Router 4 支持 Vue 3 的 Composition API，提供了一些新的函数，如 <code>useRoute</code> 和 <code>useRouter</code>，可以在 <code>setup</code> 函数中使用这些函数访问路由和路由信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRoute, useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">const route = useRoute(); // 获取当前激活路由的信息</span><br><span class="line">const router = useRouter(); // 获取路由实例</span><br><span class="line">console.log(router.params) // 获得路径参数</span><br><span class="line">router.push(&#x27;/&#x27;); // 使用路由实例的 push 方法导航到首页</span><br></pre></td></tr></table></figure><h3 id="路由缓存">路由缓存</h3><p>关于 Vue 3 中的 Vue Router 4 与 Vue 2 中的 Vue Router 3 的缓存路由区别，实际上主要在于 <code>&lt;keep-alive&gt;</code> 组件的使用。</p><p>在 Vue Router 3 中，如果你想要缓存路由组件，可以使用 <code>&lt;keep-alive&gt;</code> 组件包裹 <code>&lt;router-view&gt;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Vue Router 4 中，你仍然可以使用 <code>&lt;keep-alive&gt;</code> 组件来缓存路由组件，但需要注意的是，Vue Router 4 引入了 <code>&lt;router-view&gt;</code> 组件的 <code>v-slot</code> API，用于在路由组件上设置属性。如果你使用了这个新的 API，那么在缓存路由组件时需要做一些调整：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们将 <code>&lt;keep-alive&gt;</code> 组件移动到了 <code>&lt;router-view&gt;</code> 的 <code>v-slot</code> 内部，并使用 <code>&lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;</code> 来渲染路由组件。</p><p>总的来说，在 Vue 3 中使用 Vue Router 4 时，关于缓存路由的区别主要在于如何结合 <code>&lt;keep-alive&gt;</code> 组件和新的 <code>&lt;router-view&gt;</code> 组件的 <code>v-slot</code> API。其他方面，例如如何设置 <code>&lt;keep-alive&gt;</code> 组件的 <code>include</code> 和 <code>exclude</code> 属性等，与 Vue 2 中的用法基本相同。</p><h2 id="vuex">vuex</h2><p>Vue 3 和 Vue 2 在 Vuex 使用方面的区别主要体现在 Vue 3 的新特性上，例如 Composition API。Vuex 4 专为 Vue 3 设计，但 Vuex 4 的核心概念（state、getters、mutations 和 actions）与 Vuex 3 基本相同。以下是 Vuex 在 Vue 3 中的一些变化：</p><h3 id="安装和引入方式">安装和引入方式</h3><p>在 Vue 3 中，你需要使用 <code>vuex@next</code> 来安装 Vuex 4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex@next</span><br></pre></td></tr></table></figure><p>引入和使用的方式也有所改变：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 3</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="创建-vuex-store">创建 Vuex store</h3><p>Vue 3 中创建 Vuex store 的方式发生了变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 2</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 3</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Vuex 4 引入了 <code>createStore</code> 函数，用于创建 store 实例。</p><h3 id="在-vue-项目的-main-js-文件中引入和使用-vuex-store：">在 Vue 项目的 <code>main.js</code> 文件中引入和使用 Vuex store：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 3</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(store);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用-composition-api：">使用 Composition API：</h3><p>在 Vue 3 中，可以使用 Composition API 来访问 Vuex store。例如，可以在 <code>setup</code> 函数中使用 <code>useStore</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>();</span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)&#125;;</span><br></pre></td></tr></table></figure><p>除了这些变化之外，Vuex 在 Vue 3 中的核心概念和使用方法与 Vue 2 中的 Vuex 基本相同。在迁移过程中，只需注意这些变化，并根据 Vue 3 的文档进行相应的调整。</p><h1>总结</h1><h2 id="计算属性与监视属性对比">计算属性与监视属性对比</h2><p>计算属性和监视属性都是 Vue 中用于处理属性值变化的方法，但它们各自适用于不同的场景。以下是计算属性和监视属性的对比，以及它们的优缺点：</p><p>计算属性（Computed properties）：</p><p>优点：</p><ol><li>缓存：计算属性的结果会被缓存，只有当依赖的属性发生变化时，计算属性才会重新计算。这有助于提高性能，特别是在计算过程复杂或计算代价较高的情况下。</li><li>响应式：计算属性自动跟踪它们所依赖的属性。当依赖的属性发生变化时，计算属性会自动更新。这使得计算属性在处理复杂逻辑和依赖关系时非常方便。</li><li>可读性：计算属性可以将复杂的逻辑封装在一个属性中，提高代码的可读性和可维护性。</li></ol><p>缺点：</p><ol><li>无法处理异步操作：计算属性的计算函数必须是同步的，无法直接处理异步操作，如 AJAX 请求等。</li></ol><p>监视属性（Watch properties）：</p><p>优点：</p><ol><li>异步操作：监视属性在属性值发生变化时执行回调函数，可以很容易地处理异步操作，如 AJAX 请求等。</li><li>灵活性：监视属性允许你针对属性值的变化执行特定操作，可以处理一些特定的副作用。</li></ol><p>缺点：</p><ol><li>无缓存：监视属性的回调函数每次都会执行，不具备计算属性的缓存特性。因此，在性能方面可能不如计算属性。</li><li>可读性：相较于计算属性，监视属性的逻辑可能分散在多个地方，导致代码可读性和可维护性较差。</li></ol><p>总结： 计算属性和监视属性各有优缺点，它们适用于不同的场景。在需要根据其他属性计算一个值的情况下，计算属性通常是更好的选择。而在处理异步操作或需要根据属性值变化执行特定操作的场景中，监视属性可能更适合。根据实际需求和场景选择适当的方法来实现功能。</p><h2 id="name-配置项-文件名-引入组件名字">name 配置项  文件名 引入组件名字</h2><p>在 Vue 中，<code>name</code> 配置项、文件名和引入组件时使用的名字有一定的关联，但它们之间也存在区别。下面详细解释一下它们之间的联系和区别：</p><ol><li><code>name</code> 配置项：这是 Vue 组件的一个配置选项，用于指定组件的名字。组件的 <code>name</code> 主要用于调试（在 Vue Devtools 中显示）和递归组件（组件在其模板中调用自身）。<code>name</code> 对于组件的功能并不是必需的，但在实际开发中，为组件设置一个有意义的 <code>name</code> 是个好习惯，可以提高代码的可读性。</li><li>文件名：这是 Vue 单文件组件（SFC）的物理文件名。通常，我们为每个组件使用一个 <code>.vue</code> 文件，并将文件名设置为与组件名相同或相似的名称。这样可以提高项目的组织性和可维护性。虽然文件名与组件名可能相似，但它们没有强制关联。文件名主要用于在文件系统中组织和查找组件。</li><li>引入组件时使用的名字：当你在其他组件或模块中使用某个组件时，需要将其导入并为其分配一个名字。<strong>这个名字通常与组件的 <code>name</code> 配置项或文件名相同或相似</strong>，以保持一致性。然而，这并不是强制性的，你可以为导入的组件分配任何名字。在注册组件时，你可以使用这个名字作为局部组件的键。</li></ol><p>总之，<code>name</code> 配置项、文件名和引入组件时使用的名字之间存在一定的关联，它们通常相同或相似以保持一致性。然而，它们之间并没有强制关联，每个部分都有各自的用途。在实际项目中，建议为这三个部分使用相同或相似的名称，以提高代码的可读性和可维护性。</p><p>对于 Vue 组件的 <code>name</code> 配置项、文件名和引入组件时使用的名字，有一些约束和建议需要遵循：</p><ol><li><code>name</code> 配置项：<ul><li>遵循 HTML 的命名规范，即只包含字母、数字、短横线（-）和下划线（_）。</li><li>通常使用<strong>驼峰命名（CamelCase）或短横线分隔命名（kebab-case）</strong>。</li><li>不能是保留字（如 <code>switch</code>、<code>if</code> 等），以避免与 HTML 标签冲突。</li><li>建议使用有意义的名称，以便于理解组件的功能。</li></ul></li><li>文件名：<ul><li>遵循操作系统和文件系统的命名规范。</li><li>通常使用<strong>驼峰命名（CamelCase）或短横线分隔命名（kebab-case）</strong>。</li><li>文件扩展名应为 <code>.vue</code>，表示这是一个 Vue 单文件组件。</li><li>建议使用与组件 <code>name</code> 相同或相似的文件名，以保持一致性。</li></ul></li><li>引入组件时使用的名字：<ul><li>遵循 JavaScript 变量命名规范，即只包含字母、数字、美元符号（$）和下划线（_），并且不能以数字开头。</li><li>通常使用驼峰命名（CamelCase）。</li><li>建议使用与组件 <code>name</code> 和文件名相同或相似的名字，以保持一致性。</li></ul></li></ol><p>遵循这些约束和建议，可以确保你的 Vue 项目具有良好的组织结构和可维护性。同时，使用一致的命名规范有助于提高代码的可读性。</p><p><strong>以后我就全部用驼峰命名了</strong></p><h2 id="vue3中setup中的方法和methods中方法this的区别">Vue3中setup中的方法和methods中方法this的区别</h2><p><strong>setup中方法如果被提交到返回值中,那么this就是被代理了的返回值对象,如果没有在返回值中,那么this就是window</strong>,methods方法中的this是组件实例对象</p><h2 id="vue3中给子组件添加v-model指令">vue3中给子组件添加v-model指令</h2><p>当我们给子组件添加一个v-mdel指令之后,它会像如下一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomInput v-model = &quot;searchText&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;CustomInput</span><br><span class="line">  :modelValue=&quot;searchText&quot;</span><br><span class="line">  @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相当于添加了一个props,一个自定义事件 事件名字是update:modelValue,我们需要在子组件中声明这两个东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    :value=&quot;modelValue&quot;</span><br><span class="line">    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;modelValue&#x27;],</span><br><span class="line">  emits: [&#x27;update:modelValue&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="命名规则">命名规则</h2><h3 id="props-和-自定义事件">props 和 自定义事件</h3><p>我们在子组件上定义的时候可以使用 HTML标签属性的风格  比如 user-name 但是我们接受的时候得  userName 这样接收,  当然我们也可以定义的时候使用userName这样,这是推荐定义的时候使用短横线分割两个单词的方法</p><p>绑定事件的时候可以  @some-event  子组件发起事件的时候可以  $emit(“someEvent”)</p>]]></content>
      
      
      <categories>
          
          <category> 框架学习 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css+js学习</title>
      <link href="/2023/03/30/%E5%89%8D%E7%AB%AF/html+css+js%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/30/%E5%89%8D%E7%AB%AF/html+css+js%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>以前总是学了忘,忘了学,后面发现还是很多东西都没掌握,所以这次我打算看书系统学习一下</p><h1>HTML</h1><p>HTML是一种用于创建Web页面的标记语言。HTML的全称是<strong>Hyper Text Markup Language</strong>，即超文本标记语言。它是Web页面的基础，用于定义页面的结构、内容和样式。</p><p>浏览器根据这些标记对我们要展示的文本进行相应的布局,让文本不在那么单调</p><h2 id="元素">元素</h2><p>元素也就是那些标签,比如p,div这些 ,元素可以按照不同的功能分成几类元素</p><h3 id="替换元素与非替换元素">替换元素与非替换元素</h3><p>替换元素就是它这个标签代表的是其他的一些数据,比如图片,输入框这些,它本身不是文档内容直接显示</p><p>非替换元素就是在原本的文档内容上对其进行修饰</p><h3 id="块级元素与行内元素">块级元素与行内元素</h3><p>块级元素会<strong>填满父元素的宽度</strong>,也就是说在父元素的区域里面, 它的左右将不再有其他任何元素,常见的块级元素有p,div</p><p>行内元素的只会占据自己的宽度,并不会自动填满父元素宽度,比如span,a   而且对行内元素设置width与height不会生效,垂直方向的内,外边距会被应用,但是不会推开其他行内元素</p><h2 id="元素的父子关系">元素的父子关系</h2><p>如果一个元素在某一个元素的包含下,比如  A包含B,那么 B就是A的父亲元素,  同理就还有祖先元素这些</p><h1>CSS</h1><p>CSS是层叠样式表（Cascading Style Sheets）的缩写，是一种用于定义Web页面外观和布局的标记语言。它与HTML结合使用，可以为页面中的各种元素设置样式，如字体、颜色、背景、边框、布局等等。CSS可以分离出页面的内容和样式，使页面更加清晰和易于维护</p><p>CSS的作用如下：</p><ol><li>分离内容和样式：CSS可以将页面的内容和样式分离，使页面更加清晰和易于维护。通过将样式定义在CSS文件中，可以在多个页面中重复使用相同的样式，避免在每个页面上重复定义样式。</li><li>提高页面加载速度：CSS可以提高页面的加载速度。通过将样式定义在外部的CSS文件中，浏览器可以将样式和页面内容分别下载和缓存，从而使页面加载更快。</li><li>提供样式继承：CSS可以提供样式的继承。通过使用继承，可以将样式从父元素传递到子元素，减少重复的代码，提高页面的可维护性。</li><li>提供响应式设计：CSS可以提供响应式设计，使页面可以在不同的设备上自适应布局。通过使用CSS媒体查询，可以根据屏幕尺寸和分辨率等条件调整页面布局和样式。</li></ol><blockquote><p>“层叠”一词表示了CSS的样式规则可以叠加，即多个样式可以同时应用于同一元素，并且可以通过优先级来确定应用的顺序。当多个样式规则冲突时，CSS会按照一定的优先级规则进行层叠和应用，使最终的样式符合预期。</p><p>此外，CSS还具有继承机制，即子元素可以继承父元素的样式，从而减少了代码的冗余。这种继承机制也可以看作一种层叠机制，因为子元素的样式会叠加在继承自父元素的样式之上。</p></blockquote><h2 id="选择器">选择器</h2><p>通过使用CSS选择器，可以非常精确地选择页面中的元素，并为它们应用各种样式,而且他还具有下面的优点</p><ol><li>精确选择元素：CSS选择器可以非常精确地选择HTML元素，使开发人员可以为每个元素应用自己的样式。通过选择器，开发人员可以选择页面中任何一个或多个元素，对它们进行样式的设置。</li><li>简化CSS代码：CSS选择器可以帮助开发人员简化CSS代码。通过使用选择器，可以为多个元素同时应用相同的样式，避免重复的代码。</li><li>提高页面性能：CSS选择器可以提高页面的性能。通过使用选择器，可以减少浏览器渲染页面所需的时间，使页面更快地加载和显示。</li><li>增强代码可读性：CSS选择器可以增强代码的可读性。通过使用选择器，可以更加清晰地表达代码的意图，使代码更易于理解和维护。</li></ol><h3 id="基本规则">基本规则</h3><h4 id="结构">结构</h4><p>选择器 + 代码块 代码块中属性得用;分开    选择器代表要选择哪些元素, 代码块代表要进行什么操作</p><h4 id="选择器分组">选择器分组</h4><p>如果有多个选择器想应用同一个样式,那么多个选择器之间得用逗号分开</p><h3 id="元素选择器">元素选择器</h3><p>就是通过标签名选择元素,这个是最基本的选择器,我们开看看下面这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p,div&#123;</span><br><span class="line">    color: red;</span><br><span class="line">    font-size: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符选择器">通配符选择器</h3><p>就是选择所有元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类选择器和id选择器">类选择器和id选择器</h3><p>类选择器是选中具有相同class属性的元素, id 选择器只选择一个 id相同的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 类选择器 */</span><br><span class="line">.myclass&#123;</span><br><span class="line">    color: green;</span><br><span class="line">&#125;</span><br><span class="line">/* id选择器 */</span><br><span class="line">#myid&#123;</span><br><span class="line">    color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有一群元素要应用相同的样式,我们可以使用类选择器,如果是具体某一个元素要用某个样式,可以用id选择器</p><p>一个元素可以有多个类,但是只能一个id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;pid&quot; class=&quot;class1 class2&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="属性选择器">属性选择器</h3><p>属性选择器可以根据元素是否具有某个属性,或者属性值等于给定的值选择出元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 单属性选择器 */</span><br><span class="line">a[href]&#123;</span><br><span class="line">    color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">/* 属性满足要求的选择器 */</span><br><span class="line">a[href=&quot;hello&quot;]&#123;</span><br><span class="line">    color: wheat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 多属性选择器 */</span><br><span class="line">p[data][datashow]&#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全部形式如下</p><ol><li><code>[attribute]</code>：选择所有带有指定属性的元素。</li><li><code>[attribute=value]</code>：选择所有带有指定属性值的元素。</li><li><code>[attribute~=value]</code>：选择所有属性值中包含指定单词的元素，其中单词可以通过空格分隔。</li><li><code>[attribute|=value]</code>：选择所有属性值以指定值开头，或以指定值开头后紧跟一个连字符的元素，通常用于选择语言子代码。</li><li><code>[attribute^=value]</code>：选择所有属性值以指定值开头的元素。</li><li><code>[attribute$=value]</code>：选择所有属性值以指定值结尾的元素。</li><li><code>[attribute*=value]</code>：选择所有属性值包含指定值的元素。</li></ol><h3 id="后代选择器">后代选择器</h3><p>后代选择器就是选择某个元素的子元素,<strong>通过空格</strong>将选择器隔开就变成了了后代选择器</p><ol><li>（空格）：选择后代元素，即嵌套在某个元素内部的所有子元素，可以是任意深度的子孙元素。</li><li><code>&gt;</code>：选择直接子元素，即嵌套在某个元素内部的所有直接子元素。</li><li><code>+</code>：选择相邻兄弟元素，即在同一父元素下，位于某个元素后面且紧随其后的元素。</li><li><code>~</code>：选择兄弟元素，即在同一父元素下，位于某个元素后面的所有元素。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ul li &#123;</span><br><span class="line">  list-style-type: square;</span><br><span class="line">&#125;</span><br><span class="line">ul &gt; li &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">/* h1 和  p在同一个父亲元素下 而且 p位于h1后面 紧紧挨着  只能选1个或者0个 */</span><br><span class="line">h1 + p &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">&#125;</span><br><span class="line">/* h1 和  p在同一个父亲元素下 而且 p位于h1后面 可以不用紧紧挨着 */</span><br><span class="line">h1 ~ p &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪类选择器">伪类选择器</h3><p>伪类（pseudo-class）是用来描述元素特定状态的关键词，它可以与选择器组合使用，用于选择 HTML 文档中特定状态的元素。它们可以用于许多不同的场景，比如用于<strong>链接状态的样式</strong>、<strong>表单元素的状态</strong>、鼠标交互状态、元素位置等</p><ol><li><code>:active</code>：表示当前激活的元素。</li><li><code>:checked</code>：表示被选中的元素（用于 input 类型为 checkbox 或 radio 的元素）。</li><li><code>:disabled</code>：表示被禁用的元素。</li><li><code>:empty</code>：表示没有任何子元素的空元素。</li><li><code>:enabled</code>：表示可用的元素。</li><li><code>:first-child</code>：表示是其父元素的第一个子元素。</li><li><code>:first-of-type</code>：表示是其父元素的某种类型的第一个子元素。</li><li><code>:focus</code>：表示获得焦点的元素。</li><li><code>:hover</code>：表示鼠标悬停在上面的元素。</li><li><code>:lang(language)</code>：表示使用指定语言的元素。</li><li><code>:last-child</code>：表示是其父元素的最后一个子元素。</li><li><code>:last-of-type</code>：表示是其父元素的某种类型的最后一个子元素。</li><li><code>:not(selector)</code>：表示不匹配指定选择器的元素。</li><li><code>:nth-child(n)</code>：表示是其父元素的第 n 个子元素。</li><li><code>:nth-last-child(n)</code>：表示是其父元素的倒数第 n 个子元素。</li><li><code>:nth-last-of-type(n)</code>：表示是其父元素的某种类型的倒数第 n 个子元素。</li><li><code>:nth-of-type(n)</code>：表示是其父元素的某种类型的第 n 个子元素。</li><li><code>:only-child</code>：表示是其父元素的唯一子元素。</li><li><code>:only-of-type</code>：表示是其父元素的某种类型的唯一子元素。</li><li><code>:root</code>：表示文档的根元素。</li><li><code>:target</code>：表示与文档的 URL 指定的相应元素匹配的元素。</li></ol><h3 id="伪元素选择器">伪元素选择器</h3><p>CSS 中的伪元素（pseudo-elements）是一种虚拟的元素，它们不是 HTML 文档中实际存在的元素，而是被 CSS 用来在文档中生成特殊效果的元素。伪元素以双冒号 <code>::</code> 开头，并且是选择器的一部分。</p><p>伪元素与伪类（pseudo-classes）有所不同。伪类用于描述元素的某个特殊状态（例如鼠标悬停、被点击等），而伪元素则用于描述元素的某个部分（例如第一行文本、第一个字母等）。</p><p>CSS 中的一些常见伪元素包括：</p><ul><li><code>::before</code>：在元素内部的内容前插入一个虚拟元素。</li><li><code>::after</code>：在元素内部的内容后插入一个虚拟元素。</li><li><code>::first-letter</code>：选中元素的第一个字母。</li><li><code>::first-line</code>：选中元素的第一行文本。</li><li><code>::selection</code>：选中元素中被用户选择的部分。</li><li><code>::marker</code>：选中列表项的标记符号。</li></ul><p>使用伪元素可以实现很多特殊效果，比如可以使用 <code>::before</code> 和 <code>::after</code> 伪元素来添加一些装饰性的元素，比如 icon、箭头等。可以使用 <code>::first-letter</code> 和 <code>::first-line</code> 伪元素来对文本进行特殊样式处理，比如首字母大写、第一行缩进等。可以使用 <code>::selection</code> 伪元素来对选中的文本进行特殊样式处理，比如高亮、背景色等。</p><h3 id="选择器优先级">选择器优先级</h3><p>CSS选择器优先级是指在多个CSS规则应用到同一个HTML元素时的同一个属性的时候，如何决定哪个规则的样式会被实际应用。优先级是根据以下4个等级来确定的：</p><ol><li>内联样式（Inline Styles）</li><li>ID选择器（ID Selectors）</li><li>类、伪类和属性选择器（Class, Pseudo-class, and Attribute Selectors）</li><li>元素和伪元素选择器（Element and Pseudo-element Selectors）</li></ol><p>优先级从高到低排序，可以表示为一个四位数：(a, b, c, d)。当比较两个选择器的优先级时，我们可以从左到右逐位进行比较。例如，如果一个选择器的优先级为(1, 0, 0, 0)，另一个选择器的优先级为(0, 1, 0, 0)，则第一个选择器的优先级更高。</p><blockquote><p>如果使用了 !important 的话 就不需要看这个规则</p></blockquote><p><img src="/2023/03/30/%E5%89%8D%E7%AB%AF/html+css+js%E5%AD%A6%E4%B9%A0/../img/html+css%E5%AD%A6%E4%B9%A0assets/image-20230330210215306.png" alt="image-20230330210215306"></p><p><img src="/2023/03/30/%E5%89%8D%E7%AB%AF/html+css+js%E5%AD%A6%E4%B9%A0/../img/html+css%E5%AD%A6%E4%B9%A0assets/image-20230330210241694.png" alt="image-20230330210241694"></p><p>对于第三位 和 第四位 这个是可以叠加的,比如有多个类一起选择</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p.class1.class2&#123;</span><br><span class="line">    color: aqua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.class1.class2&#123;</span><br><span class="line">    color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.class3&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后肯定显示的是aqua这个颜色</p><h3 id="空格-逗号-和直接放一起的区别">空格,逗号,和直接放一起的区别</h3><p>我们来看一下下面这些选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p.class1.class2&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.class1, .class2&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p  .class1  .class2&#123;</span><br><span class="line">    color: #000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接放一起代表是一个选择器要满足这些要求,  逗号代表 两个选择器,空格代表后代选择器</p><h2 id="属性的继承">属性的继承</h2><p>CSS的继承性指的是，某个元素的样式不仅会应用于自身，也会传递给它的子元素。也就是说，如果一个元素设置了某个样式，那么这个样式会自动应用于它的所有子元素，除非子元素自己定义了相同的样式并覆盖了继承的样式。</p><p>CSS的继承性可以简化样式表的编写，因为可以通过将样式应用于父元素来一次性为多个元素设置相同的样式。例如，可以将文字颜色应用于整个页面的body元素，这样就会自动应用于页面中的所有子元素，而无需为每个元素都手动指定相同的文字颜色。</p><p>不过需要注意的是，并非所有的样式都具有继承性。例如，设置边框、背景图像、宽度等属性不会继承给子元素(<strong>一般跟布局有关的就不会被继承</strong>)。此外，继承的样式也可以被子元素覆盖，例如，如果子元素定义了自己的文字颜色，那么它会覆盖继承的父元素的颜色设置。因此，在设计样式时需要仔细考虑哪些属性应该具有继承性，哪些属性不应该具有继承性，以达到最佳的样式效果。</p><h2 id="值和单位">值和单位</h2><h3 id="值">值</h3><p>包括整数小数百分数   百分数一般是相对于父元素来说,特殊一点的就是颜色的百分比,是相对于255来说</p><h3 id="命名颜色">命名颜色</h3><p><img src="/2023/03/30/%E5%89%8D%E7%AB%AF/html+css+js%E5%AD%A6%E4%B9%A0/../img/html+css%E5%AD%A6%E4%B9%A0assets/image-20230330214654302.png" alt="image-20230330214654302"></p><h3 id="长度单位">长度单位</h3><p>使用单位可以让我们更精确地控制样式的外观和行为，同时也使得样式更具有可重用性和可维护性。</p><h4 id="绝对长度单位">绝对长度单位</h4><ol><li>英寸（in）：1英寸等于2.54厘米。</li><li>厘米（cm）：1厘米等于10毫米。</li><li>毫米（mm）：1毫米等于0.1厘米。</li><li>点（pt）：1点等于1/72英寸。</li><li>派卡（pc）：1派卡等于12点。</li></ol><p>这个不常用</p><h4 id="相对长度单位">相对长度单位</h4><p>CSS 中的相对长度单位是相对于某些其他长度单位的单位，它们的值是相对于父元素、根元素或者浏览器的默认字体大小等相对尺寸而言的，而不是固定的物理尺寸</p><p>相对长度单位有：</p><ol><li><code>em</code>：相对于当前元素的字体大小。例如，<code>font-size</code> 设置为 <code>16px</code>，如果一个元素的 <code>padding</code> 设置为 <code>1em</code>，那么它的 <code>padding</code> 大小为 <code>16px</code>。</li><li><code>rem</code>：相对于根元素（即 <code>&lt;html&gt;</code> 元素）的字体大小。例如，如果根元素的 <code>font-size</code> 设置为 <code>16px</code>，那么一个元素的 <code>padding</code> 设置为 <code>1rem</code>，那么它的 <code>padding</code> 大小为 <code>16px</code>。</li><li><code>vw</code>：相对于视窗宽度的百分比，其中 <code>1vw</code> 等于视口宽度的 <code>1%</code>。</li><li><code>vh</code>：相对于视窗高度的百分比，其中 <code>1vh</code> 等于视口高度的 <code>1%</code>。</li><li><code>vmin</code>：相对于视窗宽度和高度中较小的那个的百分比。</li><li><code>vmax</code>：相对于视窗宽度和高度中较大的那个的百分比。</li></ol><p>使用相对长度单位可以保证页面元素在不同尺寸的设备上以一致的比例缩放，提高了页面的可维护性和可扩展性。</p><h2 id="字体">字体</h2><ol><li><p><code>font-family</code>: 用于设置文本的字体系列。可以指定多个字体，以逗号分隔。浏览器会按照指定的顺序查找可用的字体，如果找不到，则使用默认字体。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>font-size</code>: 用于设置文本的字体大小。可以使用绝对值（如像素、点等）或相对值（如百分比、em、rem等）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>font-weight</code>: 用于设置文本的字体粗细。可以使用数字（100、200、300等，400表示正常，700表示粗体）或关键字（如<code>normal</code>、<code>bold</code>、<code>bolder</code>、<code>lighter</code>）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>font-style</code>: 用于设置文本的字体样式，通常用于斜体。可以使用关键字<code>normal</code>（默认值）、<code>italic</code>或<code>oblique</code>。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>font-variant</code>: 用于设置文本的字体变体，例如小型大写字母。可以使用关键字<code>normal</code>（默认值）或<code>small-caps</code>。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  font-variant: small-caps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>line-height</code>: 用于设置文本的行高。可以使用数值、百分比或单位（如像素、em等）。行高可以影响到文本的可读性、视觉美感、<strong>垂直居中等方面。通过调整行高可以改变文本在行框盒子中的垂直位置，使文本垂直居中、上下留白合适、行间距匀称等</strong></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>font</code>: 是以上属性的简写。可以按照以下顺序一起设置：<code>font-style</code>, <code>font-variant</code>, <code>font-weight</code>, <code>font-size</code>/<code>line-height</code>, <code>font-family</code>。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  font: italic small-caps bold 16px/1.5 &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​      在 <code>font</code> 的简写形式中，必须包括以下两个属性：</p><ol><li><code>font-size</code>：定义字体的大小；</li><li><code>font-family</code>：定义字体的类型。</li></ol><p>如果省略其中任何一个属性，则简写形式无效，样式将不会被应用。此外，<code>font-size</code> 和 <code>font-family</code> 的位置是可以互换的，但是为了代码可读性，建议按照上面的顺序书写。</p><h2 id="文本属性">文本属性</h2><p>文本属性主要用于设置文本的样式和排版</p><ol><li><code>color</code>: 设置文本颜色。可设置为十六进制颜色值、RGB、RGBA、HSL、HSLA或颜色关键字。</li><li><code>text-align</code>: 设置文本的水平对齐方式。可选值：<code>left</code>（左对齐）、<code>right</code>（右对齐）、<code>center</code>（居中对齐）、<code>justify</code>（两端对齐）。</li><li><code>text-decoration</code>: 设置文本的装饰效果。可选值：<code>none</code>（无装饰）、<code>underline</code>（下划线）、<code>overline</code>（上划线）、<code>line-through</code>（删除线）。</li><li><code>text-indent</code>: 设置文本的首行缩进。可设置具体单位（如像素、em等）或百分比。</li><li><code>letter-spacing</code>: 设置文本的字符间距。可设置具体单位（如像素、em等）或<code>normal</code>（正常间距）。</li><li><code>word-spacing</code>: 设置文本的单词间距。可设置具体单位（如像素、em等）或<code>normal</code>（正常间距）。</li><li><code>line-height</code>: 设置文本的行高。可设置数值、百分比或具体单位（如像素、em等）。</li><li><code>text-transform</code>: 设置文本的大小写转换。可选值：<code>none</code>（无转换）、<code>capitalize</code>（首字母大写）、<code>uppercase</code>（全部大写）、<code>lowercase</code>（全部小写）。</li><li><code>white-space</code>: 设置文本的空白字符处理方式。可选值：<code>normal</code>（正常处理）、<code>nowrap</code>（不换行）、<code>pre</code>（保留空白字符）、<code>pre-wrap</code>（保留空白字符并换行）、<code>pre-line</code>（合并空白字符并换行）。</li><li><code>text-overflow</code>: 设置文本溢出时的处理方式。可选值：<code>clip</code>（裁剪文本）、<code>ellipsis</code>（显示省略号）或自定义字符串。</li><li><code>word-break</code>: 设置文本换行的规则。可选值：<code>normal</code>（正常换行）、<code>break-all</code>（任意位置换行）、<code>keep-all</code>（仅在允许的断点换行）。</li><li><code>word-wrap</code> 或 <code>overflow-wrap</code>: 设置文本在长单词或 URL 地址等不规则字符串中的换行规则。可选值：<code>normal</code>（正常换行）、<code>break-word</code>（在最小宽度限制下尽可能换行）。</li><li><code>text-shadow</code>: 设置文本的阴影效果。需要设置水平偏移、垂直偏移、模糊半径和阴影颜色。</li><li><code>direction</code>: 设置文本的书写方向。可选值：<code>ltr</code>（从左到右，Left-to-Right）或<code>rtl</code>（从右到左，Right-to-Left）</li><li><code>unicode-bidi</code>: 设置文本的双向排版。可选值：<code>normal</code>（正常双向排版）、<code>embed</code>（内嵌双向排版）、<code>bidi-override</code>（覆盖双向排版）、<code>isolate</code>（隔离双向排版）、<code>isolate-override</code>（隔离覆盖双向排版）或<code>plaintext</code>（无格式文本双向排版）。</li><li><code>vertical-align</code>: 设置文本的垂直对齐方式。可选值：<code>baseline</code>（基线对齐）、<code>sub</code>（下标对齐）、<code>super</code>（上标对齐）、<code>top</code>（顶部对齐）、<code>text-top</code>（文本顶部对齐）、<code>middle</code>（居中对齐）、<code>bottom</code>（底部对齐）、<code>text-bottom</code>（文本底部对齐）或具体单位（如像素、百分比等）。</li><li><code>tab-size</code>: 设置制表符的宽度。可设置为整数或具体单位（如像素、em等）。</li><li><code>hyphens</code>: 设置文本的连字符（断字）使用。可选值：<code>none</code>（不使用连字符）、<code>manual</code>（手动插入连字符）、<code>auto</code>（自动插入连字符）。</li><li><code>text-justify</code>: 设置文本的对齐方式（仅在 <code>text-align: justify</code> 下有效）。可选值：<code>auto</code>（自动对齐）、<code>inter-word</code>（词间对齐）、<code>inter-character</code>（字符间对齐）。</li></ol><p>word-break 是当文本超出父元素宽度时,<strong>允许在哪些地方换行</strong>, 而word-wrap  是当文本超过父元素宽度的时候,<strong>选择在一个合适的地方换行</strong></p><h2 id="盒模型">盒模型</h2><p>盒模型是CSS中用于描述HTML元素布局的一种模型。它将每个HTML元素看作一个矩形盒子,每个盒子里面又包含了子盒子，由内容区域、内边距区域、边框区域和外边距区域四部分组成。这些部分的宽度和高度可以通过CSS进行调整和控制，从而实现灵活的布局效果。</p><p>在标准盒模型中，<strong>元素的宽度和高度指的是其内容区域的宽度和高度</strong>。而在IE盒模型中，<strong>元素的宽度和高度包括了内容区域、内边距区域和边框区域</strong>，这也是标准盒模型和IE盒模型的主要区别之一。在CSS中可以通过box-sizing属性来控制使用哪种盒模型，其取值可以是content-box（标准盒模型）和border-box（IE盒模型）。</p><h2 id="背景">背景</h2><p>CSS中的背景属性用于设置元素的背景，包括背景颜色、背景图片、背景大小、背景重复方式等等。以下是常用的背景属性和它们的含义：</p><ol><li>background-color：设置元素的背景颜色。可以设置任何有效的颜色值，如颜色名称、十六进制颜色码或RGB颜色值。</li><li>background-image：设置元素的背景图像。可以指定一个URL，或使用关键字none，表示没有背景图像。也可以使用线性渐变或径向渐变作为背景图像。</li><li>background-repeat：设置背景图像的重复方式。可以设置repeat（默认值，背景图像在水平和垂直方向上平铺）、repeat-x（仅在水平方向上平铺）、repeat-y（仅在垂直方向上平铺）、no-repeat（不平铺）。</li><li>background-position：设置背景图像的位置。可以使用关键字left、center、right和top、center、bottom，也可以使用像素、百分比等单位。</li><li>background-size：设置背景图像的大小。可以使用像素、百分比、cover(让背景图片缩放以完全覆盖背景区域，并保持其宽高比。可能会裁剪背景图片的某些部分)。和contain（让背景图片缩放以适应背景区域，保持其宽高比。可能会有留白，不会裁剪背景图片。）等值。</li><li>background-origin：设置背景图像的起点。可以设置为border-box（从边框开始绘制），padding-box（从内边距开始绘制），或content-box（从内容区开始绘制）。</li><li>background-clip：设置背景图像的裁剪区域。可以设置为border-box（不超出边框）、padding-box（不超出内边距）或content-box（不超出内容区）。</li><li>background-attachment：设置背景图像的滚动方式。可以设置为scroll（随元素滚动）或fixed（固定在视口，不随元素滚动）。</li></ol><p>在使用背景属性时，需要注意一些问题，例如：</p><ul><li>如果同时设置了background-image和background-color，而背景图像不透明，那么背景颜色将不可见。</li><li><strong>背景图像的位置是相对于背景区域的，而不是相对于元素本身的</strong>。</li><li>在某些情况下，背景图像可能会被剪切或拉伸，导致失真或不适当的显示。在这种情况下，可以尝试使用background-size或background-position属性进行调整。</li></ul><p>我觉得下面这个属性基本就能应对所有的情况了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-repeat: no-repeat;</span><br><span class="line">background-size: cover;</span><br><span class="line">background-position: center center;</span><br></pre></td></tr></table></figure><p>CSS中，可以使用background属性将背景相关的属性设置在一起，而不必一个个单独设置。 background属性可以包含以下属性：</p><ul><li>background-color: 背景颜色</li><li>background-image: 背景图片的URL</li><li>background-repeat: 背景图片的重复方式（repeat, repeat-x, repeat-y, no-repeat）</li><li>background-position: 背景图片的位置</li><li>background-size: 背景图片的尺寸</li><li>background-attachment: 背景图片的滚动方式（scroll, fixed）</li></ul><p>在<code>background</code>简写属性中，至少要指定背景图片（<code>background-image</code>）和背景颜色（<code>background-color</code>）其中之一是必须的，其他属性都是可选的。如果没有指定背景颜色，会默认为透明色</p><h2 id="浮动">浮动</h2><p>在CSS中，浮动（float）是一种布局技术，它允许开发者将一个元素从文档流中移出，使其沿着其父容器的左侧或右侧边缘对齐。这样，其他元素可以围绕浮动元素进行排列。浮动最初是为了实现文字环绕图像而设计的，但后来它也被广泛应用于其他布局场景。<strong>浮动会将元素变成块级元素</strong></p><p>浮动的主要作用包括：</p><ol><li>实现文字环绕图像效果。</li><li>创建水平导航栏。</li><li>实现多列布局。</li></ol><p>浮动的特点</p><ol><li>脱离正常文档流：浮动元素会从正常的文档流中脱离，不再占据原先的位置。这意味着浮动元素后面的元素会忽略浮动元素的位置进行排列。</li><li>沿着父容器边缘对齐：浮动元素会沿着其父容器的左侧或右侧边缘对齐。这取决于 <code>float</code> 属性的值，可以设置为 <code>left</code>、<code>right</code> 或 <code>none</code>。</li><li>影响后续元素：浮动元素会影响其后续元素的排列方式。后续的行内元素和块级元素中的行内内容会围绕浮动元素排列。这使得实现文本环绕图片等效果成为可能。</li><li>不会重叠：浮动元素之间不会发生重叠。如果有多个相邻浮动元素，它们会根据各自的宽度在同一行显示，直至容纳不下时才会换行。</li><li>外边距不会合并：浮动元素的上外边距（margin-top）和下外边距（margin-bottom）不会与相邻元素的外边距发生合并。</li><li>可能导致父元素高度塌陷：由于浮动元素脱离文档流，其父元素可能无法正确计算高度。这可能导致父元素的高度塌陷。为解决这个问题，可以使用清除浮动（clearfix）技术。</li><li>与 <code>clear</code> 属性相关：<code>clear</code> 属性可以用来控制元素与浮动元素的关系，防止元素与浮动元素重叠。<code>clear</code> 属性可以设置为 <code>left</code>、<code>right</code>、<code>both</code> 或 <code>none</code>。</li></ol><p>浮动会导致一些问题，比如父元素高度塌陷。为了解决这些问题，通常会使用清除浮动（clearfix）技术。在浮动元素之后添加一个空元素，为其设置 <code>clear</code> 属性，取值为 <code>left</code>、<code>right</code>、<code>both</code> 或 <code>none</code>，以清除浮动带来的影响。现在，很多开发者也倾向于使用Flexbox和Grid布局替代浮动来实现更复杂的布局需求。</p><h2 id="定位">定位</h2><p>CSS3中的定位属性包括：</p><ol><li><code>position</code>：用于设置元素的定位方式，有<code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>和<code>sticky</code>等几种取值。</li><li><code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>：用于设置元素相对于父元素或前一个元素的定位偏移值。如果是百分比的话,就是父亲的宽度和高度的百分比</li><li><code>z-index</code>：用于设置元素的层级关系。</li></ol><p>这些属性的作用分别是：</p><ul><li><code>position</code>：决定了一个元素是基于正常文档流定位还是相对于其父元素、文档或视口定位。</li><li><code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>：用于设置元素相对于其定位的容器的上下左右偏移值。当元素的<code>position</code>值为<code>absolute</code>、<code>fixed</code>或<code>sticky</code>时，这些属性才会生效。</li><li><code>z-index</code>：用于设置元素的堆叠顺序，具有更高<code>z-index</code>值的元素将显示在具有较低<code>z-index</code>值的元素的上方。</li></ul><p>在使用这些属性时需要注意：</p><ul><li><code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>属性只有在<code>position</code>的值为<code>absolute</code>、<code>fixed</code>或<code>sticky</code>时才会生效。</li><li><code>z-index</code>属性只能应用于定位元素（即<code>position</code>值为<code>absolute</code>、<code>fixed</code>或<code>sticky</code>的元素），对于非定位元素，<code>z-index</code>属性无效。</li><li><code>position</code>属性会改变元素的定位方式，一般来说，除非需要使用绝对或固定定位，否则最好不要使用<code>position</code>属性。</li></ul><p>在使用 CSS 定位时，有一些需要注意的点：</p><ol><li>使用绝对定位或固定定位时，最好在元素的父元素中设置相对定位，以便让定位相对于父元素而不是整个页面。</li><li>当使用相对定位时，元素会在其正常位置上留下空白，可以通过设置负值的 top、left、right、bottom 属性来调整元素的位置。</li><li>使用定位时要注意层叠顺序，通过设置 z-index 属性来控制元素的层叠顺序。z-index 值越大的元素，越靠近视图者，也就是越显示在最上层。</li><li>在某些情况下，会发生定位元素相互遮挡的情况，可以通过设置 visibility 属性或者使用透明度来解决。</li><li>定位元素如果超出了其父元素的范围，可能会导致滚动条的出现，需要注意元素的位置和大小。</li></ol><p>总之，在使用 CSS 定位时，需要注意元素的位置、层叠顺序、遮挡、滚动条等问题，以确保页面的正常显示和交互。</p><h2 id="flexbox布局">Flexbox布局</h2><p>Flexbox是CSS3中一种布局方式，可以方便地实现弹性的、响应式的布局，适用于各种屏幕尺寸的网页设计。</p><p>使用Flexbox布局，需要将父容器的display属性设置为flex或inline-flex，子容器的布局就会受到父容器的控制，可以使用flex-grow、flex-shrink、flex-basis等属性进行灵活的布局调整。</p><p>下面是一些常用的Flexbox布局属性：</p><ol><li>flex-direction：指定子容器在主轴方向上的排列方式。默认为row，即横向排列；设置为column，则纵向排列。</li><li>justify-content：指定子容器在主轴上的对齐方式。默认为flex-start，即左对齐；其他取值包括flex-end、center、space-between、space-around等。</li><li>align-items：指定子容器在交叉轴上的对齐方式。默认为stretch，即拉伸；其他取值包括flex-start、flex-end、center、baseline等。</li><li>flex-wrap：指定子容器是否换行。默认为nowrap，即不换行；设置为wrap，则换行。</li><li>align-content：指定多行子容器在交叉轴上的对齐方式。只有在多行情况下生效。默认为stretch，即拉伸；其他取值包括flex-start、flex-end、center、space-between、space-around等。</li><li>order：指定子容器的排列顺序。默认为0，数字越小越靠前；可以设置为正数或负数。</li><li>flex：指定子容器的伸缩属性。flex属性是flex-grow、flex-shrink、flex-basis三个属性的简写形式，用于设置子容器的伸缩性、收缩性和初始大小。</li></ol><h2 id="媒体查询">媒体查询</h2><p>CSS媒体查询（Media Query）是一种CSS3的技术，允许你根据设备的属性（如屏幕分辨率、屏幕尺寸、屏幕方向等）来针对不同设备展现不同的样式，实现响应式布局。</p><p>媒体查询可以通过在CSS样式表中定义媒体类型、媒体特性和媒体值的组合来控制不同设备的样式。媒体类型包括all（所有设备）、print（打印机设备）、screen（计算机屏幕设备）、speech（语音合成器设备）等，而媒体特性则包括宽度、高度、分辨率、方向、可视区域等等。</p><p>媒体查询可以使用<code>@media</code>规则进行定义。下面是一个简单的媒体查询示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 默认样式 */</span><br><span class="line">body &#123;</span><br><span class="line">  background-color: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 当屏幕宽度大于等于768px时应用的样式 */</span><br><span class="line">@media screen and (min-width: 768px) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    background-color: coral;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 当屏幕宽度大于等于1024px时应用的样式 */</span><br><span class="line">@media screen and (min-width: 1024px) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    background-color: lightgreen;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>@media</code>规则指定了<code>screen</code>作为媒体类型，<code>and</code>作为媒体特性与媒体类型之间的连接符，<code>(max-width: 600px)</code>指定了设备的最大宽度为600像素。因此，当设备宽度小于或等于600像素时，<code>body</code>元素的背景色将变为<code>lightblue</code>。</p><p>除了<code>max-width</code>之外，还有许多其他的媒体特性可以用来设置媒体查询，例如<code>min-width</code>、<code>orientation</code>、<code>resolution</code>等等。同时，媒体查询也支持逻辑运算符<code>not</code>、<code>and</code>和<code>only</code>，以及逗号分隔的多个媒体查询条件。</p><p>媒体查询可以嵌套使用，因此可以根据需要定义不同的媒体查询规则来适应不同的设备和场景。在使用媒体查询时，可以利用浏览器的开发者工具来模拟不同设备的屏幕大小和分辨率，以便进行样式的调试和优化。</p><blockquote><p>好吧,我真的不适合学css</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django 学习</title>
      <link href="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>学习了python,觉得python简单好用,那它的web框架肯定也不错,就想着学了以后拿来自己用</p><h1>环境搭建</h1><h2 id="安装django-4-0-4">安装Django 4.0.4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django==4.0.4</span><br></pre></td></tr></table></figure><h2 id="查看版本">查看版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m django --version</span><br></pre></td></tr></table></figure><h1>文件介绍</h1><p>我们通过pycharm可以直接创建Django项目,它会默认给我们创建一些文件,然后通过命令行新建一个app</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manager.py startapp test1</span><br></pre></td></tr></table></figure><p>我们也可以使用 djang-admin startproject mysite</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230324151910678.png" alt="image-20230324151910678"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">djangoProject</span><br><span class="line">    - djangoProject   # 对整个程序进行配置</span><br><span class="line">    - init.py         # 一个空文件，它告诉Python这个目录应该被看做一个Python包</span><br><span class="line">    - settings.py     # 项目配置文件</span><br><span class="line">    - url.py          # URL对应关系（路由）</span><br><span class="line">   - wsgi.py         # 遵循WSIG规范，uwsgi + nginx</span><br><span class="line">- manage.py           # 一个命令行工具，可以使你用多种方式对Django项目进行交互</span><br><span class="line">- templates           # 放前端页面的地方</span><br><span class="line">-test1# app配置以及代码</span><br><span class="line">- admin.py        #对应应用后台管理配置文件。</span><br><span class="line">  - apps.py         #对应应用的配置文件。</span><br><span class="line">  - models.py       #数据模块，数据库设计就在此文件中设计。后面重点讲解</span><br><span class="line">  - tests.py        #自动化测试模块，可在里面编写测试脚本自动化测试</span><br><span class="line">  - views.py        #视图文件，用来执行响应代码的。你在浏览器所见所得都是它处理的。  我们的业务代码就写在这里面</span><br><span class="line">  - init.py # 包初始文件</span><br><span class="line">- migrations      #数据迁移、移植文目录，记录数据库操作记录，内容自动生成。</span><br><span class="line">  - __init__.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后我们还需要在 settings文件里面 加入我们这个APP</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230324152831346.png" alt="image-20230324152831346"></p><h2 id="官方介绍">官方介绍</h2><p>让我们看看 <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/django-admin/#django-admin-startproject"><code>startproject</code></a> 创建了些什么:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><p>这些目录和文件的用处是：</p><ul><li><strong>最外层的 <code>mysite/</code> 根目录只是你项目的容器</strong>， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。</li><li><code>manage.py</code>: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/django-admin/">django-admin 和 manage.py</a> 获取所有 <code>manage.py</code> 的细节。</li><li><strong>里面一层的 <code>mysite/</code> 目录包含你的项目</strong>，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 <code>mysite.urls</code>).</li><li><code>mysite/__init__.py</code>：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 <a href="https://docs.python.org/3/tutorial/modules.html#tut-packages">更多关于包的知识</a>。</li><li><code>mysite/settings.py</code>：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 <a href="https://docs.djangoproject.com/zh-hans/4.1/topics/settings/">Django 配置</a> 了解细节。</li><li><code>mysite/urls.py</code>：Django 项目的 URL 声明，就像你网站的“目录”。阅读 <a href="https://docs.djangoproject.com/zh-hans/4.1/topics/http/urls/">URL调度器</a> 文档来获取更多关于 URL 的内容。</li><li><code>mysite/asgi.py</code>：作为你的项目的运行在 ASGI 兼容的 Web 服务器上的入口。阅读 <a href="https://docs.djangoproject.com/zh-hans/4.1/howto/deployment/asgi/">如何使用 ASGI 来部署</a> 了解更多细节。</li><li><code>mysite/wsgi.py</code>：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 <a href="https://docs.djangoproject.com/zh-hans/4.1/howto/deployment/wsgi/">如何使用 WSGI 进行部署</a> 了解更多细节。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp polls</span><br></pre></td></tr></table></figure><p>这将会创建一个 <code>polls</code> 目录，它的目录结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">polls/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations/</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure><blockquote><p>Django会对每一次的访问请求重新载入一遍 Python 代码。所以你不需要为了让修改的代码生效而频繁的重新启动服务器。然而，一些动作，比如添加新文件，将不会触发自动重新加载，这时你得自己手动重启服务器。</p></blockquote><h1>常用命令</h1><p>django-admin startproject djangoproject   通过django-admin创建一个Django项目</p><ul><li>python <a href="http://manage.py">manage.py</a> runserver port or ip:port  启动项目, 这里启动项目的时候</li><li>python <a href="http://manage.py">manage.py</a> startapp appname  给项目新增一个新应用</li><li>python <a href="http://manage.py">manage.py</a> makemigrations  将模型的更改记录到app/migrations下面  相当于编写sql语句</li><li>python <a href="http://manage.py">manage.py</a> migrate 将app/migrations下的修改更改到数据库,相当于执行sql语句</li><li>python <a href="http://manage.py">manage.py</a> test appname 执行app的测试方法</li><li>python <a href="http://manage.py">manage.py</a> createsuperuser 创建超级用户</li></ul><h1>settings配置</h1><p>基本设置:</p><ul><li>SECRET_KEY: 用于为密码重置、cookie等敏感数据进行加密和签名。这是一个必需的设置项，确保它在生产环境中保持私密。</li><li>DEBUG: 控制是否启用调试模式。当启用调试模式时，Django会显示详细的错误信息。建议在开发环境中将其设置为True，生产环境中设置为False。</li><li>ALLOWED_HOSTS: 用于指定允许访问站点的主机列表。在生产环境中，将此设置为允许的域名列表以增加安全性。</li><li>INSTALLED_APPS: 包含所有应用程序的列表，可以是Django自带的或第三方的应用程序。这些应用程序将被包含在项目中，以便Django可以找到和使用它们。</li><li>MIDDLEWARE: 中间件类的列表，用于处理请求/响应处理过程中的全局操作。例如，跨站请求伪造防护、用户认证等。</li></ul><p>数据库设置:</p><ul><li>DATABASES: 配置项目使用的数据库连接。默认情况下，Django使用SQLite数据库。您可以通过修改此选项来更改数据库类型（如PostgreSQL, MySQL等）。</li></ul><p>URL设置:</p><ul><li>ROOT_URLCONF: 项目的根URL配置。这通常指向项目中的urls.py文件，用于定义所有URL模式。</li><li>STATIC_URL: 静态文件（如CSS, JavaScript等）的URL前缀。例如：<code>/static/</code>。</li><li>MEDIA_URL: 用户上传的媒体文件（如图片，音频等）的URL前缀。例如：<code>/media/</code>。</li></ul><p>模板设置:</p><ul><li>TEMPLATES: 一个包含模板配置的字典列表。配置选项包括模板引擎、模板文件夹的位置等。</li></ul><p>国际化和本地化设置:</p><ul><li>LANGUAGE_CODE: 默认语言代码，如’zh-hans’（简体中文）或’en-us’（美国英语）。</li><li>TIME_ZONE: 默认时区设置。例如，‘Asia/Shanghai’或’UTC’。</li><li>USE_I18N: 启用或禁用国际化（多语言支持）。</li><li>USE_L10N: 启用或禁用本地化（使用地区格式显示数据）。</li><li>USE_TZ: 启用或禁用时区支持。</li></ul><p>静态文件设置:</p><ul><li>STATIC_URL: 静态文件的URL前缀。Django在查找静态文件时会使用这个前缀。</li><li>STATICFILES_DIRS: 包含额外静态文件目录的列表，Django会在这些目录中查找静态文件。默认情况下会在每个app目录下查找static文件夹里面的东西</li><li>STATIC_ROOT: 静态文件的集中存储路径。运行<code>collectstatic</code>命令时，Django会将所有静态文件收集到这个目录中。</li></ul><h1>路由配置</h1><h2 id="简单示例">简单示例</h2><p>在 Django中 一个URL对应一个函数,因此我们想新增一个URL就得在 urls.py中新增一个记录 和 views.py中新增一个函数</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230324155121362.png" alt="image-20230324155121362"></p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230324155129383.png" alt="image-20230324155129383"></p><p>我们可以访问看一下: <a href="http://127.0.0.1:8000/hello/">127.0.0.1:8000/hello/</a></p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230324155155322.png" alt="image-20230324155155322"></p><h2 id="url配置规则">url配置规则</h2><p>一般情况下我们都是这么写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(路径表达式, views视图函数，参数，别名),</span><br><span class="line">]</span><br><span class="line">参数说明：</span><br><span class="line">1、一个表达式字符串</span><br><span class="line">2、一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串</span><br><span class="line">3、可选的要传递给视图函数的默认参数（字典形式）</span><br><span class="line">4、一个可选的name参数(别名)</span><br></pre></td></tr></table></figure><p>如果我们需要捕获url中的参数的话,我们需要自己使用 &lt;类型:名字&gt; 这种方式来捕获</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(user/&lt;int:id&gt;,视图,参数,别名)</span><br></pre></td></tr></table></figure><p><strong>注意点:</strong></p><ol><li>要捕获一段url中的值，需要使用尖括号；</li><li>可以转换捕获到的值为指定类型，比如例子中的<code>&lt;int:name&gt;</code>。默认情况下，捕获到的结果保存为字符串类型，不包含**<code>/</code>**这个特殊字符；</li><li>规则的前面不需要添加**<code>/</code><strong>，因为默认情况下，每个url都带一个最前面的</strong><code>/</code>**。比如：articles, 不能写成 /articles。</li></ol><h3 id="匹配例子">匹配例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">    path(&#x27;hello/&#x27;, views.hello),</span><br><span class="line">    path(&#x27;user/&lt;int:id&gt;&#x27;, views.user),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当我们访问 /user/10 这个url的时候  后台会调用   view.user(request,id=10)</strong>,这样是不是就很清晰明朗了</p><blockquote><p>我们需要注意请求参数是不会影响到我们的路径匹配的,也就是说 /hello 和 /hello?a=10 是一样的</p><p>对于 最后面的/ 这个分隔符,我的建议是加上 比如 我们写的是 hello  那么 hello 能够匹配,那么hello/ 不能匹配,如果我们写的是hello/ 那么两个都能匹配上</p></blockquote><h3 id="path转换器">path转换器</h3><p>我们刚说的路径参数中,默认是字符串格式, 我们可以自己指定转化器,将它变成其他类型</p><p>1、str：匹配任何非空字符串，但不含斜杠/，如果你没有专门指定转换器，那么这个是默认使用的；<br>2、int：匹配0和正整数，返回一个int类型<br>3、slug：可理解为注释、后缀、附属等概念，是url拖在最后的一部分解释性字符。该转换器匹配任何ASCII字符以及连接符和下划线，比如’ building-your-1st-django-site‘；<br>4、uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号，所有字母必须小写，例如’075194d3-6885-417e-a8a8-6c931e272f00‘ 。返回一个UUID对象；</p><p>在举几个列子吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;articles/2003/&#x27;, views.special_case_2003),</span><br><span class="line">    path(&#x27;articles/&lt;int:year&gt;/&#x27;, views.year_archive),</span><br><span class="line">    path(&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&#x27;, views.month_archive),</span><br><span class="line">    path(&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/&#x27;, views.article_detail),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>1、/articles/2005/03/ 将匹配第三条，并调用views.month_archive(request, year=2005, month=3)；</p><p>2、/articles/2003/匹配第一条，并调用views.special_case_2003(request)；</p><p>3、/articles/2003将一条都匹配不上，因为它最后少了一个斜杠，而列表中的所有模式中都以斜杠结尾；</p><p>4、/articles/2003/03/building-a-django-site/ 将匹配最后一个，并调用views.article_detail(request, year=2003, month=3, slug=“building-a-django-site”</p><h3 id="自定义路径转换器">自定义路径转换器</h3><p>对于更复杂的匹配需求，您可以定义自己的路径转换器。自定义，就是单独写一个类，它包含下面的内容：<br>1、类属性regex：一个字符串形式的正则表达式属性；<br>2、to_python(self, value) 方法：一个用来将匹配到的字符串转换为你想要的那个数据类型，并传递给视图函数。如果不能转换给定的值，则会引发ValueError。</p><p>3、to_url(self, value)方法：将Python数据类型转换为一段url的方法，上面方法的反向操作。</p><p>比如我们在urls.py里面写一个转换器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class convert:</span><br><span class="line">    regex=&#x27;[0-9]&#x27;</span><br><span class="line"></span><br><span class="line">    def to_python(self,value):</span><br><span class="line">        return int(value)</span><br><span class="line"></span><br><span class="line">    def to_url(self,value):</span><br><span class="line">        return f&#x27;&#123;value:4d&#125;&#x27;</span><br><span class="line">register_converter(convert,&#x27;d&#x27;)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">    path(&#x27;hello/&#x27;, views.hello),</span><br><span class="line">    path(&#x27;user/&lt;int:id&gt;&#x27;, views.user),</span><br><span class="line">    path(&#x27;user/&lt;int:id&gt;/&lt;d:t&gt;&#x27;, views.user), # 使用转换器</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="使用正则表达式">使用正则表达式</h3><p>如果path和自定义转换器不能满足要求我们可以使用正则表达式,但是我们不能使用path了,得用re_path,如果需要捕获路径参数,我们可以使用命名分组(?P<name>pattern)</name></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;articles/2003/&#x27;, views.special_case_2003),</span><br><span class="line">    re_path(r&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&#x27;, views.year_archive),</span><br><span class="line">    re_path(r&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$&#x27;, views.month_archive),</span><br><span class="line">    re_path(r&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[\w-]+)/$&#x27;, views.article_detail),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3 id="re-path-和-path-区别">re_path 和 path 区别</h3><p>path 可以将 路径参数进行转化,re_path 不可以,匹配到的参数都是字符串</p><p>re_path 可以使用正则表达式匹配,path不可以</p><p>path 匹配参数是 &lt; 类型:名字&gt; 的方式  re_path匹配参数是 命名分组的方式</p><h2 id="官方对path的用法解释">官方对path的用法解释</h2><p>函数 <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/urls/#django.urls.path"><code>path()</code></a> 具有四个参数，两个必须参数：<code>route</code> 和 <code>view</code>，两个可选参数：<code>kwargs</code> 和 <code>name</code>。现在，是时候来研究这些参数的含义了。</p><h3 id="path-参数：-route"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/urls/#django.urls.path"><code>path()</code></a> 参数： <code>route</code></h3><p><code>route</code> 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 <code>urlpatterns</code> 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。</p><p>这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 <code>https://www.example.com/myapp/</code> 时，它会尝试匹配 <code>myapp/</code> 。处理请求 <code>https://www.example.com/myapp/?page=3</code> 时，也只会尝试匹配 <code>myapp/</code>。</p><h3 id="path-参数：-view"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/urls/#django.urls.path"><code>path()</code></a> 参数： <code>view</code></h3><p>当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/request-response/#django.http.HttpRequest"><code>HttpRequest</code></a> 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。</p><h3 id="path-参数：-kwargs"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/urls/#django.urls.path"><code>path()</code></a> 参数： <code>kwargs</code></h3><p>任意个关键字参数可以作为一个字典传递给目标视图函数。本教程中不会使用这一特性。</p><h3 id="path-参数：-name"><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/urls/#django.urls.path"><code>path()</code></a> 参数： <code>name</code></h3><p>为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。</p><h2 id="错误页面处理">错误页面处理</h2><p>当Django找不到与请求匹配的URL时，或者当抛出一个异常时，将调用一个错误处理视图。错误视图包括400、403、404和500，分别表示请求错误、拒绝服务、页面不存在和服务器错误。它们分别位于：</p><ul><li>handler400 —— django.conf.urls.handler400。</li><li>handler403 —— django.conf.urls.handler403。</li><li>handler404 —— django.conf.urls.handler404。</li><li>handler500 —— django.conf.urls.handler500。</li></ul><p>这些值可以在根urls.py中设置</p><p>我们只需要将函数赋值给这些值就可以了,要注意这些函数必须得有两个参数,一个是request,一个是exception,这个exception的名字必须是这个名字</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230324185219522.png" alt="image-20230324185219522"></p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230324185234530.png" alt="image-20230324185234530"></p><blockquote><p>这里还需要把settings.py里面的DEBUG改为False</p></blockquote><h2 id="url分层转发">url分层转发</h2><p>如果所有路由全部写在根urls.py的urlpatterns中的话,那么可能会出现很多冗余的前缀路劲,我们不妨把具有相同的前缀路径写在一块</p><h3 id="方法一-转发给不同urls-py">方法一 <a href="http://xn--urls-fb5fk91a3lar14z9f5a.py">转发给不同urls.py</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import include, path</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;student/&#x27;, include(&#x27;student.urls&#x27;)),</span><br><span class="line">    path(&#x27;teacher/&#x27;, include(&#x27;teacher.urls&#x27;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>比如学生跟老师分别在不同的APP中,我们就可以这样</p><h3 id="方法二-转发给一个列表">方法二 转发给一个列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import include, path</span><br><span class="line">student = [</span><br><span class="line">path(&quot;socre/&quot;,student.getsocre)</span><br><span class="line">]</span><br><span class="line">teacher = [</span><br><span class="line">path(&quot;student/&quot;,teacher.getstudent)</span><br><span class="line">]</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;student/&#x27;, include(studnet)),</span><br><span class="line">    path(&#x27;teacher/&#x27;, include(teacher)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>就算url分层转发,参数捕获还是跟前面一样</p></blockquote><h1>MVC与MVT</h1><h2 id="mvc">MVC</h2><p><strong>M</strong> ：数据存取部分，由django数据库层处理，本章要讲述的内容。<br><strong>V</strong>：选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。<br><strong>C</strong>：根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。</p><h2 id="mvt">MVT</h2><p>在Django里，由于 C层由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），所以Django 也被称为 MTV框架 。在MTV开发模式中：<br><strong>M</strong> ：代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效<br><strong>T</strong> ：代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。<br><strong>V</strong> ：代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p><h1>视图</h1><p>在Django中, 一个url对应的函数就是一个视图, 我们可以通过视图函数响应各式各样的东西</p><p>在一个http请求中会产生两个核心对象,一个是HTTPRequest 和 HTTPResponse, 一个包含用户请求信息,一个包含响应信息</p><h2 id="httprequest">HttpRequest</h2><p>里面包含了各式各样的方法和属性,供我们去得到请求信息</p><blockquote><p>任何可能用于更改系统状态的请求应该使用 <code>POST</code> —— 比如一个更改数据库的请求。<code>GET</code> 应该只被用于不会影响系统状态的请求。</p></blockquote><h3 id="属性">属性</h3><ul><li><code>method</code>：HTTP 请求方法，例如 <code>GET</code>、<code>POST</code> 等。</li><li><code>path</code>：请求的 URL 路径部分，不包括查询参数。</li><li><code>GET</code>：一个包含 GET 请求参数的字典。只会包含请求路径中的参数</li><li><code>POST</code>：一个包含 POST 请求参数的字典。只会包含请求体里面的参数内容</li><li><code>COOKIES</code>：一个包含客户端发送的所有 Cookie 的字典。</li><li><code>FILES</code>：一个包含所有上传文件的字典。 字典里面的键是参数名字,值是文件</li><li><code>META</code>：一个包含请求元数据的字典。注意 只有当请求方法是 <code>POST</code>，至少有一个文件字段被实际发布，并且发布请求的 <code>&lt;form&gt;</code> 有 <code>enctype=&quot;multipart/form-data&quot;</code> 属性时，才会包含数据。否则 <code>request.FILES</code> 将为空。</li><li><code>content_type</code>：请求正文的 MIME 类型，例如 <code>text/plain</code>、<code>application/json</code> 等。</li><li><code>content_params</code>：一个包含请求正文的 MIME 类型的参数的字典。</li><li><code>body</code>：请求正文的字节表示。</li><li><code>user</code>：表示当前请求的用户对象。如果用户未通过身份验证，则该属性将是匿名用户对象。</li><li><code>auth</code>：包含通过 HTTP 身份验证传递的用户名和密码的元组。</li><li><code>session</code>：表示当前请求的会话对象。</li><li><code>scheme</code>：表示使用的网络协议，通常为 <code>http</code> 或 <code>https</code>。</li><li><code>path_info</code>：URL 路径的附加部分。例如，如果请求的 URL 为</li><li><code>encoding</code>：表示请求正文的编码格式。</li><li><code>content_length</code>：表示请求正文的字节数。</li><li><code>headers</code>: 请求头</li></ul><h3 id="方法">方法</h3><ul><li><code>get_full_path()</code>：返回请求的完整路径，包括查询参数。</li><li><code>get_host()</code>：返回请求的主机名，包括端口号（如果有）。</li><li><code>get_port()</code>：返回请求的端口号。</li><li><code>get_raw_uri()</code>：返回原始请求的 URI，包括查询参数和片段标识符。</li><li><code>get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)</code>：返回已签名的 Cookie 的值，如果 Cookie 不存在则返回默认值。如果无法验证 Cookie，则引发 <code>django.core.signing.BadSignature</code> 异常。</li><li><code>get_full_url()</code>：返回完整的 URL，包括主机名、端口号和路径。</li><li><code>is_ajax()</code>：如果请求是通过 AJAX 发送的，则返回 <code>True</code>。</li><li><code>is_secure()</code>：如果请求是通过 HTTPS 发送的，则返回 <code>True</code>。</li><li><code>is_valid()</code>：如果请求是有效的，则返回 <code>True</code>。该方法的实现由 Django 的安全中间件提供，可以用于检查请求是否受到 CSRF 攻击。</li><li><code>read()</code>：读取请求正文的全部内容，并将其作为字符串返回。如果请求正文太大，则不建议使用该方法，因为它会将所有内容读取到内存中，可能会导致内存不足错误。</li><li><code>readline()</code>：读取请求正文的下一行，并将其作为字符串返回。该方法在处理大型请求正文时比 <code>read()</code> 更有效。</li></ul><h3 id="meta属性字典里面包含的属性">META属性字典里面包含的属性</h3><p><code>META</code> 字典中包含了许多键值对，其中一些常用的键值对如下：</p><ul><li><code>CONTENT_TYPE</code>：请求正文的 MIME 类型。</li><li><code>CONTENT_LENGTH</code>：请求正文的长度（以字节为单位）。</li><li><code>HTTP_USER_AGENT</code>：客户端浏览器的 User-Agent 字符串。</li><li><code>HTTP_REFERER</code>：包含当前请求页面的 URL，通常用于追踪用户的浏览历史。</li><li><code>HTTP_HOST</code>：请求的主机名和端口号。</li><li><code>HTTP_ACCEPT_LANGUAGE</code>：客户端浏览器的首选语言。</li><li><code>QUERY_STRING</code>：请求 URL 中的查询参数。</li><li><code>REMOTE_ADDR</code>：客户端的 IP 地址。</li><li><code>REMOTE_HOST</code>：客户端的主机名（如果可用）。</li><li><code>REMOTE_USER</code>：如果客户端已经进行了身份验证，则包含用户名。</li><li><code>SERVER_NAME</code>：服务器的主机名。</li><li><code>SERVER_PORT</code>：服务器的端口号。</li><li><code>SERVER_PROTOCOL</code>：使用的 HTTP 协议的名称和版本号。</li></ul><h3 id="获取客户端ip地址">获取客户端ip地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@csrf_exempt</span><br><span class="line">def getclientip(res:HttpRequest):</span><br><span class="line">    return HttpResponse(res.META[&quot;REMOTE_ADDR&quot;])</span><br></pre></td></tr></table></figure><h3 id="上传文件">上传文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@csrf_exempt</span><br><span class="line">def uploadfile(res:HttpRequest):</span><br><span class="line">    file = res.FILES.get(&quot;file&quot;)</span><br><span class="line">    print(type(file))</span><br><span class="line">    # 获得文件大小</span><br><span class="line">    print(f&quot;&#123;file.size&#125;B&quot;)</span><br><span class="line">    with open(f&quot;&#123;file&#125;&quot;,&quot;wb&quot;) as file2:</span><br><span class="line"></span><br><span class="line">        for data in file:</span><br><span class="line">            file2.write(data)</span><br><span class="line">    return HttpResponse(&quot;上传成功&quot;)</span><br></pre></td></tr></table></figure><h2 id="httpresponse">HttpResponse</h2><p>这个是响应数据回去的对象, 我们可以响应很多类型的数据,比如json html xml 等等</p><h3 id="属性">属性</h3><ul><li><code>content</code>：响应内容。它可以是字符串、字节序列或文件对象。</li><li><code>charset</code>：响应的字符集。</li><li><code>status_code</code>：HTTP响应状态码。</li><li><code>reason_phrase</code>：HTTP响应状态码对应的原因短语。</li><li><code>cookies</code>：一个包含所有Cookie的字典，其中键是Cookie的名称，值是Cookie的值。</li><li><code>closed</code>：一个布尔值，指示响应是否已关闭。</li></ul><h3 id="方法">方法</h3><ul><li><code>__init__(content=None, status=None, reason=None, charset=None, content_type=None)</code>：初始化HttpResponse对象。</li><li><code>write(content)</code>：向响应中写入内容。</li><li><code>flush()</code>：刷新响应内容，使其可用于传输。</li><li><code>set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)</code>：设置响应的Cookie。</li><li><code>delete_cookie(key, path='/', domain=None)</code>：从响应中删除Cookie。</li><li><code>setdefault(key, value)</code>：返回响应头的值，如果键不存在，则设置键的值为给定的值。</li><li><code>items()</code>：返回响应头的键值对，作为元组的列表。</li><li><code>keys()</code>：返回响应头的键列表。</li><li><code>values()</code>：返回响应头的值列表。</li><li><code>has_header(header)</code>：检查响应头是否存在给定的标头。</li><li><code>get(value, default=None)</code>：获取响应头中给定键的值。如果键不存在，则返回给定的默认值。</li></ul><h3 id="render">render</h3><p>这个是渲染html返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def render(</span><br><span class="line">    request, template_name, context=None, content_type=None, status=None, using=None</span><br><span class="line">):</span><br><span class="line">     content = loader.render_to_string(template_name, context, request, using=using)</span><br><span class="line">     return HttpResponse(content, content_type, status)</span><br></pre></td></tr></table></figure><p>我们可以看到他的返回值还是一个HTTPResponse对象,只不过这个内容是渲染出来的</p><h3 id="redirect">redirect</h3><p>这个是重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@csrf_exempt</span><br><span class="line">def testdirect(res:HttpRequest):</span><br><span class="line"># 如果项目路径是 http://127.0.0.1:8000/,这个函数的请求路径为 http://127.0.0.1:8000/testdirect</span><br><span class="line"># 这样是相对项目路径   http://127.0.0.1:8000/hello/</span><br><span class="line">return redirect(&quot;/hello/&quot;) http://127.0.0.1:8000/testdirect/hello/</span><br><span class="line"># 这样是相对当前路径下路径 </span><br><span class="line">    return redirect(&quot;hello/&quot;) </span><br><span class="line">    # 注意,后面这个/绝对不能省</span><br></pre></td></tr></table></figure><p>对于render 和 redirect区别就是 如果是render的话 地址栏路径不会变化的,所以刷新页面的话就会重新渲染,redirect的就是地址栏会变化,刷新页面就是就是请求</p><h1>中间件</h1><p>在Django中，中间件是一个处理HTTP请求和响应的组件，它在<strong>请求进入视图函数之前和响应离开视图函数之后起作用</strong>。中间件可以用于实现多种功能，如<strong>身份验证、授权、会话管理、跨站请求伪造（CSRF）保护、缓存</strong>等。中间件的主要目的是在处理请求和响应的过程中添加额外的处理逻辑，从而使代码更加模块化和可重用。</p><h2 id="定义中间件">定义中间件</h2><p>要定义一个中间件，你需要创建一个类，并实现特定的方法，这些方法对应不同的处理阶段。一个中间件可以包含以下方法：</p><ol><li><code>__init__(self, get_response)</code>：初始化方法，用于接收一个<code>get_response</code>参数。这是一个可调用对象，用于获取下一个中间件或视图函数的响应。</li><li><code>__call__(self, request)</code>：当中间件类被实例化后，它将变为一个可调用对象。<code>__call__</code>方法在每次请求时都会被调用，用于处理请求并返回响应。在这个方法里，您可以处理请求前和请求后的逻辑，但无法捕获视图函数抛出的异常。</li><li><code>process_view(self, request, view_func, view_args, view_kwargs)</code>：这个方法在视图函数被调用之前执行。它允许您修改请求对象、视图参数或拦截视图调用。</li><li><code>process_exception(self, request, exception)</code>：当视图函数抛出异常时，这个方法会按照相反的顺序（从后向前）被执行。您可以在这里捕获异常并进行处理，例如返回自定义的错误响应。如果返回<code>None</code>，Django会继续执行其他中间件的<code>process_exception</code>方法或内置的异常处理器。</li><li><code>process_template_response(self, request, response)</code>：如果视图函数返回一个<code>TemplateResponse</code>对象，这个方法会被调用。它允许您在模板被渲染之前修改响应对象。</li><li><code>process_response(self, request, response)</code>：这个方法在响应被发送回客户端之前执行。您可以在这里修改响应对象，例如设置响应头或修改响应内容。请注意，如果<code>process_exception</code>已经处理了异常并返回了响应，<code>process_response</code>方法也会被调用。</li></ol><p>它的执行步骤如下:</p><ul><li>首先初始化中间就是调用init,给对象传递一个可以响应的方法</li><li>有请求到来的时候,调用中间件的call方法,响应请求</li><li>进入到get_response函数里面</li><li><strong>依次调用每个中间的 process_request方法</strong></li><li>再一次调用每个中间件的process_view方法,这里其实它会组织一下,当<strong>前process_view函数的view_func一定是下一个中间件的process_view方法</strong>,而最后一个中间件的view_func是视图函数</li><li>对于异常,我们可以通过process_execption去处理</li></ul><blockquote><p>编写好中间件后一定要在settings.py中去注册</p></blockquote><h2 id="注意点">注意点</h2><h3 id="放置中间件的顺序">放置中间件的顺序</h3><p>在Django中，中间件的顺序非常重要，因为它影响了中间件在请求和响应处理过程中的执行顺序。以下是有关如何放置中间件的一些建议：</p><ol><li><p>了解每个中间件的功能：确保您了解每个中间件的作用，以便在安排它们时做出明智的决策。一些中间件可能依赖于其他中间件的输出，或者需要在其他中间件之前或之后执行。</p></li><li><p>遵循第三方中间件的文档：当使用第三方中间件时，请仔细阅读其文档以获取有关放置顺序的建议。通常，文档会提供关于中间件之间的依赖关系以及它们在请求/响应过程中的执行顺序的详细信息。</p></li><li><p>顺序从上到下：<code>MIDDLEWARE</code>列表中的顺序从上到下决定了中间件在请求处理过程中的执行顺序。在响应处理阶段，顺序是相反的。通常，您应该首先放置处理请求的核心中间件，然后是处理视图、模板和响应的中间件。</p></li><li><p><strong>处理异常的中间件应靠后放置</strong>：由于异常处理过程是按照相反的顺序执行的，因此处理异常的中间件（实现了<code>process_exception</code>方法的中间件）应靠后放置。这样可以确保在异常发生时，它们可以先于其他中间件捕获异常并采取相应的操作。</p></li><li><p><strong>考虑性能和安全性：在安排中间件时，确保考虑到性能和安全性。对于那些需要在请求开始时执行的中间件（例如，身份验证、授权和缓存中间件），应该将它们放在<code>MIDDLEWARE</code>列表的前面</strong>。这有助于减少不必要的计算和网络开销，以及在请求被拒绝之前尽早识别潜在的安全问题。</p></li></ol><p>总之，中间件的放置顺序应该根据中间件的功能、依赖关系和执行顺序来安排。务必阅读中间件的文档以获取关于顺序的建议，并确保在处理请求和响应时考虑性能和安全性。</p><h3 id="按照指南使用中间件">按照指南使用中间件</h3><p>为了避免混乱，可以遵循以下指南来确定在中间件中使用哪些方法：</p><ol><li><p><code>__init__(self, get_response)</code>：始终在中间件中定义这个方法，用于接收<code>get_response</code>参数并存储为实例变量。</p></li><li><p><code>__call__(self, request)</code>：在以下情况下使用此方法：</p><ul><li>需要在请求前后执行一些操作</li><li>需要在视图函数执行前修改请求对象</li><li>需要在视图函数执行后修改响应对象<br>请注意，<code>__call__</code>方法无法捕获视图函数抛出的异常。</li></ul></li><li><p><code>process_view(self, request, view_func, view_args, view_kwargs)</code>：在以下情况下使用此方法：</p><ul><li>需要在视图函数执行之前修改请求对象、视图参数或拦截视图调用</li><li>需要根据视图函数的特定属性（如视图函数本身、参数或其他条件）执行特定操作<br>请注意，<code>process_view</code>方法可以捕获视图函数中抛出的异常，但需要显式调用视图函数并处理异常。</li></ul></li><li><p><code>process_exception(self, request, exception)</code>：在以下情况下使用此方法：</p><ul><li>需要捕获视图函数抛出的异常并执行特定操作，例如返回自定义错误响应<br>请注意，如果返回<code>None</code>，Django会继续执行其他中间件的<code>process_exception</code>方法或内置的异常处理器。</li></ul></li><li><p><code>process_template_response(self, request, response)</code>：在以下情况下使用此方法：</p><ul><li>需要在模板被渲染之前修改<code>TemplateResponse</code>对象<br>请注意，此方法仅在视图函数返回<code>TemplateResponse</code>对象时执行。</li></ul></li><li><p><code>process_response(self, request, response)</code>：在以下情况下使用此方法：</p><ul><li>需要在响应被发送回客户端之前执行操作，例如设置响应头或修改响应内容<br>请注意，如果<code>process_exception</code>已经处理了异常并返回了响应，<code>process_response</code>方法也会被调用。</li></ul></li></ol><p>根据这些指南，可以根据需要在中间件中实现相应的方法。遵循这些指南，您可以保持中间件逻辑的清晰和简洁，并确保每个方法都专注于其特定的职责。当然，在实际项目中，您可能需要根据实际需求灵活运用这些方法。但是，确保每个方法的职责清晰且互不干扰，可以有效减少混乱。</p><h2 id="装饰器">装饰器</h2><p>上面的那种方式定义的中间件是全局有效的,有时候,我们希望对某些视图函数做定制的需求(比如权限校验),我们可以使用装饰器,下面是一个简单的装饰器用来检查用户是否登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def check_is_login(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def wrapper(request, *args, **kwargs):</span><br><span class="line">        if request.session.get(&quot;email&quot;) is None:</span><br><span class="line">            return JsonResponse(&#123;&quot;code&quot;: Code.USER_NOT_LOGIN, &quot;info&quot;: &quot;用户未登录&quot;&#125;)</span><br><span class="line">        return func(request, *args, **kwargs)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p>我们只需要在需要检查的视图函数上加上这个装饰器就行</p><p>使用装饰器的优点是：</p><ol><li>更精确地控制哪些视图函数受到额外逻辑的影响。</li><li>使代码更易于理解，因为额外的逻辑与视图函数紧密相关。</li></ol><p>然而，装饰器也有一些缺点：</p><ol><li>如果需要将相同的逻辑应用于许多视图函数，您需要在每个视图函数上重复应用装饰器。这可能导致代码冗余和难以维护。</li><li>与中间件相比，装饰器在全局范围内的控制力较弱。例如，中间件可以在每个请求的开始和结束时执行某些操作，而装饰器只能在特定视图函数上执行。</li></ol><p>因此，在选择使用装饰器还是中间件时，需要根据您的需求和代码结构进行权衡。如果您需要为特定视图函数添加功能，装饰器可能是更好的选择。然而，如果您需要在全局范围内控制请求处理，中间件可能更适合。</p><h1>管理后台</h1><p>Django为我们提供了一个很方便的管理后台,我们只需要少量的操作就能管理数据库里面的模型数据</p><p>首先得保证数据库中已经有了管理后台需要的各种表</p><h2 id="创建各种表">创建各种表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h2 id="创建管理员账号密码">创建管理员账号密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser  # 按照提示创建好账号</span><br></pre></td></tr></table></figure><h2 id="将自己的app注册">将自己的app注册</h2><p>我们必须注册好自己的app才能对其模型进行管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在settings.py中</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;app01.apps.Test1Config&#x27;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="创建自己的模型">创建自己的模型</h2><p>在自己的app下的models.py中创建模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class User(models.Model):</span><br><span class="line">    name = models.CharField(max_length=10,verbose_name=&quot;名字&quot;)</span><br><span class="line">    password = models.CharField(max_length=50,verbose_name=&quot;密码&quot;)</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&quot;&#123;self.name&#125;&quot;</span><br></pre></td></tr></table></figure><p>创建这个模型对应的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations app01</span><br><span class="line">python manage.py migrate app01</span><br></pre></td></tr></table></figure><h2 id="将自己模型托管给admin管理">将自己模型托管给admin管理</h2><p>在app下的admin.py中注册模型(多个app也是这样)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from .models import User</span><br><span class="line">admin.site.register(User)</span><br></pre></td></tr></table></figure><p>这样我们登录后就能看到了</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230327211430483.png" alt="image-20230327211430483"></p><p>我们可以对其进行增删改查,有没有发现这个Users并不是那么好看,我们后续可以通过一些操作进行更改</p><h1>ORM</h1><p>在python中 我们不需要自己去写sql语句, 一个类对应一张表,一个对象对应一条数据,它包含了对这个数据的增删改查操作,因此我们只需要去定义类就可以了</p><blockquote><p>使用ORM之前一定要把APP注册到settings文件中去</p></blockquote><p>我们定义一个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User(models.Model):</span><br><span class="line">    name = models.CharField(max_length=10,verbose_name=&quot;名字&quot;)</span><br><span class="line">    nametest = models.CharField(max_length=10,default=None)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&quot;&#123;self.name&#125;&quot;</span><br></pre></td></tr></table></figure><p>然后在pycharm运行manage.py输入下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makemigrations test1  # 对数据模型进行修改,这里会输出我们对表进行了哪些操作,但是不会同步到数据库</span><br><span class="line">migrate test1 # 将操作同步到数据库</span><br></pre></td></tr></table></figure><p>执行完后我们会发现数据库中会多一张表test1_user</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230327103955446.png" alt="image-20230327103955446"></p><p>名字为app名字_小写类名,如果我们不指定主键,Django会默认创建一个自增主键为id</p><h2 id="数据模型字段及其属性">数据模型字段及其属性</h2><p>字段是模型中最重要的内容之一，也是唯一必须的部分。字段在Python中表现为一个类属性，体现了数据表中的一个列。Django不允许下面两种字段名：1、与Python关键字冲突。2、字段名中不能有两个以上下划线在一起，因为两个下划线是Django的查询语法。也不要使用clean、save、delete等Django内置的模型API名字，防止命名冲突。</p><h3 id="常用字段">常用字段</h3><p><strong>1、AutoField</strong>  —自增列 = int(11)  如果没有的话，默认会生成一个名称为 id 的列，如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=True。<br><strong>2、CharField</strong>  —字符串字段 单行输入，用于较短的字符串，如要保存大量文本, 使用 TextField。必须 max_length 参数，django会根据这个参数在数据库层和校验层限制该字段所允许的最大字符数。<br><strong>3、BooleanField</strong>  —布尔类型=tinyint(1)  不能为空，Blank=True<br><strong>4、ComaSeparatedIntegerField</strong>  —用逗号分割的数字=varchar  继承CharField，所以必须 max_lenght 参数，<br><strong>5、DateField</strong>  —日期类型 date  对于参数，auto_now = True 则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。<br><strong>6、DateTimeField</strong>  —日期类型 datetime  同DateField的参数<br><strong>7、Decimal</strong>  —十进制小数类型 = decimal  必须指定整数位max_digits和小数位decimal_places<br><strong>8、EmailField</strong>  —字符串类型（正则表达式邮箱） =varchar  对字符串进行正则表达式  一个带有检查 Email 合法性的 CharField，不接受 maxlength 参数。<br><strong>9、FloatField</strong>  —浮点类型 = double  浮点型字段。 必须提供两个 参数， 参数描述：<br>max_digits：总位数(不包括小数点和符号）<br>decimal_places：小数位数。如：要保存最大值为 999 (小数点后保存2位)，你要这样定义字段：FloatField(…，max_digits=5， decimal_places=2)，要保存最大值一百万(小数点后保存10位)的话，你要这样定义：FloatField(…，max_digits=19， decimal_places=10)<br><strong>10、IntegerField</strong>  —整形  用于保存一个整数<br><strong>11、BigIntegerField</strong>  —长整形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">integer_field_ranges = &#123;</span><br><span class="line">    &#x27;SmallIntegerField&#x27;: (-32768, 32767),</span><br><span class="line">    &#x27;IntegerField&#x27;: (-2147483648, 2147483647),</span><br><span class="line">    &#x27;BigIntegerField&#x27;: (-9223372036854775808, 9223372036854775807),</span><br><span class="line">    &#x27;PositiveSmallIntegerField&#x27;: (0, 32767),</span><br><span class="line">    &#x27;PositiveIntegerField&#x27;: (0, 2147483647),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12、IPAddressField</strong>  —字符串类型（ip4正则表达式）  一个字符串形式的 IP 地址， (如 “202.1241.30″)。<br><strong>13、GenericIPAddressField</strong>  —字符串类型（ip4和ip6是可选的）  参数protocol可以是：both、ipv4、ipv6  验证时，会根据设置报错<br><strong>14、NullBooleanField</strong>  —允许为空的布尔类型  类似 BooleanField， 不过允许 NULL 作为其中一个选项。 推荐使用这个字段而不要用 BooleanField 加 null=True 选项。 admin 用一个选择框 　　　　<select> (三个可选择的值： “Unknown”， “Yes” 和 “No” ) 来表示这种字段数据。<br><strong>15、PositiveIntegerField</strong>  —正Integer  类似 IntegerField， 但取值范围为非负整数（这个字段应该是允许0值的…可以理解为无符号整数）<br><strong>16、PositiveSmallIntegerField</strong>  —正smallInteger 正小整型字段，类似 PositiveIntegerField， 取值范围较小(数据库相关)SlugField“Slug” 是一个报纸术语。 slug 是某个东西的小小标记(短签)， 只包　　含字母，数字，下划线和连字符。它们通常用于URLs。 若你使用 Django 开发版本，你可以指定 maxlength。 若 maxlength 未指定， Django 会使用默认长度： 50，它接受一个额外的参数：<br>prepopulate_from: 来源于slug的自动预置列表<br><strong>17、SlugField</strong>  —减号、下划线、字母、数字  它们通常用于URLs。<br><strong>18、SmallIntegerField</strong>  —数字  数据库中的字段有：tinyint、smallint、int、bigint.  类似 IntegerField， 不过只允许某个取值范围内的整数。(依赖数据库)<br><strong>19、TextField</strong>  —字符串=longtext ，一个容量很大的文本字段， admin 管理界面用 </select><textarea>多行编辑框表示该字段数据。<br><strong>20、TimeField</strong>  —时间 HH:MM[:ss[.uuuuuu]]  时间字段，类似于 DateField 和 DateTimeField。<br><strong>21、URLField</strong>  —字符串，地址正则表达式  用于保存URL。若 verify_exists 参数为 True (默认)， 给定的 URL 会预先检查是否存在(即URL是否被有效装入且没有返回404响应).<br><strong>22、BinaryField</strong>  —二进制<br><strong>23、ImageField</strong>  —图片  类似 FileField， 不过要校验上传对象是否是一个合法图片。用于保存图像文件的字段。其基本用法和特性与FileField一样，只不过多了两个属性height和width。默认情况下，该字段在HTML中表现为一个ClearableFileInput标签。在数据库内，我们实际保存的是一个字符串类型，默认最大长度100，可以通过max_length参数自定义。真实的图片是保存在服务器的文件系统内的。<br>**height_field参数：**保存有图片高度信息的模型字段名。width_field参数：保存有图片宽度信息的模型字段名。<br>使用Django的ImageField需要提前安装pillow模块，pip install pillow即可。<br><strong>使用FileField或者ImageField字段的步骤：</strong><br>在settings文件中，配置MEDIA_ROOT，作为你上传文件在服务器中的基本路径（为了性能考虑，这些文件不会被储存在数据库中）。再配置个MEDIA_URL，作为公用URL，指向上传文件的基本路径。请确保Web服务器的用户账号对该目录具有写的权限。<br>添加FileField或者ImageField字段到你的模型中，定义好upload_to参数，文件最终会放在MEDIA_ROOT目录的“upload_to”子目录中。<br>所有真正被保存在数据库中的，只是指向你上传文件路径的字符串而已。可以通过url属性，在Django的模板中方便的访问这些文件。例如，假设你有一个ImageField字段，名叫mug_shot，那么在Django模板的HTML文件中，可以使用来获取该文件。其中的object用你具体的对象名称代替。<br>可以通过name和size属性，获取文件的名称和大小信息。</textarea></p><p><strong>24、FilePathField</strong>  —选择指定目录按限制规则选择文件，有三个参数可选， 其中”path”必需的，这三个参数可以同时使用， 参数描述：<br>path：必需参数，一个目录的绝对文件系统路径。 FilePathField 据此得到可选项目。 Example： “/home/images”；<br>match：可选参数， 一个正则表达式， 作为一个字符串， FilePathField 将使用它过滤文件名。 注意这个正则表达式只会应用到 base filename 而不是路径全名。 Example： “foo。<em>\。txt^”， 将匹配文件 foo23.txt 却不匹配 bar.txt 或 foo23.gif；<br>recursive：可选参数， 是否包括 path 下全部子目录，True 或 False，默认值为 False。<br>match 仅应用于 base filename， 而不是路径全名。 如：FilePathField(path=”/home/images”， match=”foo.</em>”， recursive=True)…会匹配 /home/images/foo.gif 而不匹配 /home/images/foo/bar.gif<br><strong>25、FileField</strong>  —文件上传字段。 要求一个必须有的参数： upload_to， 一个用于保存上载文件的本地文件系统路径。 这个路径必须包含 strftime formatting， 该格式将被上载文件的 date/time 替换(so that uploaded files don’t fill up the given directory)。在一个 model 中使用 FileField 或 ImageField 需要以下步骤：在你的 settings 文件中， 定义一个完整路径给 MEDIA_ROOT 以便让 Django在此处保存上传文件。 (出于性能考虑，这些文件并不保存到数据库。) 定义 MEDIA_URL 作为该目录的公共 URL。 要确保该目录对 WEB 服务器用户帐号是可写的。在你的 model 中添加 FileField 或 ImageField， 并确保定义了 upload_to 选项，以告诉 Django 使用 MEDIA_ROOT 的哪个子目录保存上传文件。你的数据库中要保存的只是文件的路径(相对于 MEDIA_ROOT)。 出于习惯你一定很想使用 Django 提供的 get_<fieldname>_url 函数。举例来说，如果你的 ImageField 叫作 mug_shot， 你就可以在模板中以  这样的方式得到图像的绝对路径。<br><strong>26、PhoneNumberField</strong>  —一个带有合法美国风格电话号码校验的 CharField(格式：XXX-XXX-XXXX)<br><strong>27、USStateField</strong>  —美国州名缩写，由两个字母组成（天朝人民无视）。<br><strong>28、XMLField</strong>  —XML字符字段，校验值是否为合法XML的 TextField，必须提供参数：<br>schema_path：校验文本的 RelaxNG schema 的文件系统路径。</fieldname></p><h3 id="常用选项参数">常用选项参数</h3><ol><li><p><strong>max_length</strong>：字符串类型字段的最大长度。例如，定义一个 CharField 时可以指定 max_length=100 来限制字段长度不超过 100 个字符。</p></li><li><p><strong>name</strong>: 设置字段在数据库列中的名字</p></li><li><p><strong>default</strong>：字段的默认值。例如，定义一个 BooleanField 时可以指定 default=False，表示默认值为 False。</p></li><li><p><strong>null</strong>：字段是否可以为空值。例如，定义一个 CharField 时可以指定 null=True，表示该字段可以为空值。</p></li><li><p><strong>blank</strong>：字段是否可以为空字符串。例如，定义一个 CharField 时可以指定 blank=True，表示该字段可以为空字符串。注意该选项与 <code>null</code> 不同， <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#django.db.models.Field.null"><code>null</code></a> 选项仅仅是数据库层面的设置，而 <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#django.db.models.Field.blank"><code>blank</code></a> 是涉及表单验证方面。如果一个字段设置为 <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#django.db.models.Field.blank"><code>blank=True</code></a> ，在进行表单验证时，接收的数据该字段值允许为空，而设置为 <a href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#django.db.models.Field.blank"><code>blank=False</code></a> 时，不允许为空</p></li><li><p><strong>choices</strong>：一个可选值列表。例如，定义一个 CharField 时可以指定 choices=[(‘M’, ‘Male’), (‘F’, ‘Female’)]，表示该字段只能取值为 ‘M’ 或 ‘F’。sex=models.IntegerField(choices=[(0,‘男’),(1,‘女’),],default=1)</p></li><li><p><strong>help_text</strong>：字段的帮助文本。例如，定义一个 CharField 时可以指定 help_text=‘Enter your full name.’，表示在表单中该字段下方显示该帮助文本。</p></li><li><p><strong>verbose_name</strong>：字段的人类可读名称。例如，定义一个 CharField 时可以指定 verbose_name=‘Full Name’，表示该字段在 Admin 界面上显示的名称为 ‘Full Name’。</p></li><li><p><strong>unique</strong>：字段的值是否必须是唯一的。例如，定义一个 CharField 时可以指定 unique=True，表示该字段的值必须唯一。</p></li><li><p><strong>primary_key</strong>：字段是否为主键。例如，定义一个 IntegerField 时可以指定 primary_key=True，表示该字段为模型的主键。</p></li><li><p><strong>auto_created</strong>：字段是否是自动生成的。例如，定义一个 ForeignKey 时可以指定 auto_created=True，表示该字段是自动生成的。</p></li><li><p><strong>upload_to</strong>：上传文件的路径。例如，定义一个 ImageField 时可以指定 upload_to=‘photos’，表示上传的图片将保存在项目根目录下的 photos 文件夹中。</p></li><li><p><strong>validators</strong>：一个验证器列表。例如，定义一个 CharField 时可以指定 validators=[validate_slug]，表示该字段需要通过 validate_slug 函数的验证。</p></li><li><p><strong>editable</strong>：指定字段是否可以在 Admin 界面中编辑。例如，定义一个 CharField 时可以指定 editable=False，表示该字段不能在 Admin 界面中编辑。</p></li><li><p><strong>error_messages</strong>：指定验证错误时的错误消息。例如，定义一个 CharField 时可以指定 error_messages={‘required’: ‘Please enter your name.’}，表示在验证时如果该字段为空，会显示 ‘Please enter your name.’ 的错误消息。</p></li><li><p><strong>db_column</strong>：指定字段在数据库中的列名。例如，定义一个 CharField 时可以指定 db_column=‘full_name’，表示该字段在数据库中的列名为 ‘full_name’。</p></li><li><p><strong>db_index</strong>：指定字段是否需要创建索引。例如，定义一个 CharField 时可以指定 db_index=True，表示该字段需要创建索引。</p></li><li><p><strong>db_tablespace</strong>：指定该字段所在的数据库表空间。例如，定义一个 CharField 时可以指定 db_tablespace=‘my_tablespace’，表示该字段所在的数据库表空间为 ‘my_tablespace’。</p></li><li><p><strong>db_collation</strong>：指定该字段在数据库中使用的排序规则。例如，定义一个 CharField 时可以指定 db_collation=‘utf8mb4_bin’，表示该字段在数据库中使用 utf8mb4_bin 排序规则。</p></li><li><p><strong>serialize</strong>：指定字段在序列化时是否被包含。例如，定义一个 CharField 时可以指定 serialize=False，表示该字段在序列化时不被包含。</p></li><li><p><strong>unique_for_date</strong>：指定该字段在某个日期范围内必须是唯一的。例如，定义一个 DateTimeField 时可以指定unique_for_date=‘pub_date’，表示该字段在 pub_date 字段的日期范围内必须是唯一的。</p></li><li><p><strong>unique_for_month</strong>：指定该字段在某个月份范围内必须是唯一的。例如，定义一个 DateTimeField 时可以指定 unique_for_month=‘pub_date’，表示该字段在 pub_date 字段的月份范围内必须是唯一的。</p></li><li><p><strong>unique_for_year</strong>：指定该字段在某个年份范围内必须是唯一的。例如，定义一个 DateTimeField 时可以指定 unique_for_year=‘pub_date’，表示该字段在 pub_date 字段的年份范围内必须是唯一的。</p></li></ol><h2 id="多个模型之间的关系">多个模型之间的关系</h2><p>假设有两张表 A,B  我们要通过A的一条数据查找出B中的一条数据</p><ul><li>一对一   A中的一条数据只对应B中的一条数据,B中的一条数据也只对应A中的一条数据 <strong>OneToOneField</strong>比如通过账号查找个人信息</li><li>一对多   A 中的一条数据对应B中的多条数据 比如 一个班级对应多个学生 <strong>ForeignKey</strong></li><li>多对多   A 中的一条数据对应B中的多条数据,但是B中的一条数据也对应A中的多条数据 比如一个学生有多个老师的课,一个老师也有多个学生  <strong>ManyToManyField</strong>,这个往往需要一个第三张表来记录多对多的关系</li></ul><h3 id="onetoonefiled">OneToOneFiled</h3><p><strong>用来限制一对一的关系,就算创建了一个新的对象(一行数据),当我们写入数据库的时候,也是更新,而不是新创建</strong></p><p><code>OneToOneField</code> 字段可以设置以下属性：</p><ul><li><code>to</code>: 必须指定，表示与之关联的模型。</li><li><code>on_delete</code>: 必须指定，表示当关联的模型实例被删除时如何处理该实例。可以选择从模型中删除该实例，或将该字段设置为 <code>null</code> 或 <code>default</code> 值，或引发异常。</li><li><code>related_name</code>: 指定反向关系的名称，用于从关联的模型中引用该模型。默认引用名字为 模型名字小写</li></ul><p>这个related_name 有必要讲一下, 相当于建立了一个双向关系,我能得到你,你也能得到我,我们现在有一个个人信息表和个人简历表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 个人信息</span><br><span class="line">class Person(models.Model):</span><br><span class="line">    name = models.CharField(max_length=100)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&quot;name:&#123;self.name&#125;,age:&#123;self.age&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 个人简历</span><br><span class="line">class Profile(models.Model):</span><br><span class="line">    person = models.OneToOneField(Person, on_delete=models.CASCADE, related_name=&#x27;profile&#x27;)</span><br><span class="line">    bio = models.TextField()</span><br><span class="line">    website = models.URLField()</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&quot;bio:&#123;self.bio&#125;,website:&#123;self.website&#125;\n&#123;self.person&#125;&quot;</span><br></pre></td></tr></table></figure><p>我们下面来看一下通过Person得到Profile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person = Person.objects.create(**&#123;&quot;name&quot;:&quot;djm&quot;,&quot;age&quot;:20&#125;)  </span><br><span class="line">profile = Profile.objects.create(person=person,bio=&quot;hh&quot;,website=&quot;http://www.baidu.com&quot;) </span><br><span class="line"># 上面创建了两个对象,分别写入了数据库</span><br><span class="line"># 我们现在来通过person得到profile信息</span><br><span class="line"></span><br><span class="line"># 这样是不是就实现了互相查找</span><br><span class="line">person = Person.objects.get(id=1)</span><br><span class="line">print(person.profile)  </span><br><span class="line"></span><br><span class="line">profile = Profile.objects.get(id=1)</span><br><span class="line">print(profile.person)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这个related_name这是设置名字而已,就算我们没有设置,它会默认使用类名小写</p></blockquote><p>我们可以通过ForeignKey(unique=True)代替OneToOneField</p><h3 id="foreignkey">ForeignKey</h3><p>这个可以做多一对多,一张表的外键是另一张表的加了唯一性约束或者主键的字段</p><p>我们经常使用它的下面属性:</p><p><code>to_field</code>：指定关联的模型中用于关联的字段，默认为模型的主键字段。</p><p><code>on_delete</code>：当关联的对象被删除时，指定ForeignKey的处理方式，可以取以下值：</p><ul><li>CASCADE：级联删除,把关联了这个对象的数据全部删除</li><li>PROTECT：保护模式，当存在外键关联时，阻止删除</li><li>SET_NULL：设置外键为NULL</li><li>SET_DEFAULT：设置外键为默认值</li><li>SET()：将外键设置为给定值或调用给定函数</li></ul><p><code>related_name</code>: 指定反向关系的名称，用于从关联的模型中引用该模型,默认引用属性名字为  模型名字小写_set</p><h3 id="manytomanyfield">ManyToManyField</h3><p>在Django中，ManyToManyField是一种用于表示多对多关系的字段类型，它允许两个模型之间建立多对多的关联关系。<strong>ManyToManyField需要通过中间表来实现关联</strong>，<strong>该中间表</strong>记录了两个关联模型之间的多对多关系。</p><ul><li><code>on_delete</code>：指定ManyToManyField所关联的模型被删除时的处理方式。</li><li><code>related_name</code>：用于设置反向引用的名称，用于通过关联对象进行反向查询。默认情况下，反向引用名称为<code>&lt;model&gt;_set</code>。注意和一对一的那个区别,这里多了_set,因为它是多个</li><li><code>related_query_name</code>：用于设置反向查询的名称。</li><li><code>through</code>：指定用于关联两个模型的中间表模型。如果没有指定，Django将自动创建一个中间表。</li><li><code>through_fields</code>：指定用于关联两个模型的中间表模型中的字段。如果没有指定，Django将自动查找中间表模型中的外键。</li><li><code>symmetrical</code>：指定关系是否是对称的，如果设置为True，则表示两个模型之间的关系是对称的。默认为True。</li><li><code>db_table</code>：指定用于中间表的数据库表名。</li><li><code>db_constraint</code>：指定是否需要在中间表中创建外键约束。默认为True。</li><li><code>blank</code>和<code>null</code>：与其他字段一样，也可以设置<code>blank</code>和<code>null</code>属性，表示ManyToManyField是否可以为空。</li></ul><p>举个例子吧</p><p>我们有作者和图书两个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Author(models.Model):</span><br><span class="line">    name = models.CharField(max_length=100)</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    title = models.CharField(max_length=100)</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一本书可以由多个作者写,一个作者也可以写多本书,我们只需要在Author或者Book中加一个多对多字段就行,另外一个可以通过 模型名字_set得到另外一个数据</p><p>book表(app01_book)</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230327180602809.png" alt="image-20230327180602809"></p><p>author表(app01_author)</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230327180310734.png" alt="image-20230327180310734"></p><p>他们之间的关系表(名字默认为 app名字_具有多对多字段模型名字_另一个模型名字)(app01_book_author)</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230327180733256.png" alt="image-20230327180733256"></p><p>我们现在添加他们之间的关系</p><p>c++由两个人创作, python只由djm创作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">titles = [&quot;c++&quot;,&quot;python&quot;]</span><br><span class="line">cbook,pbook = [Book.objects.get(title=title) for title in titles]</span><br><span class="line"></span><br><span class="line">authors = [&quot;djm&quot;,&quot;djm2&quot;]</span><br><span class="line">djm,djm2 = [Author.objects.get(name=name) for name in authors]</span><br><span class="line"></span><br><span class="line"># 通过书添加作者</span><br><span class="line">cbook.authors.add(djm,djm2)</span><br><span class="line"># 通过作者添加书</span><br><span class="line">djm2.book_set.add(pbook)  # 这个访问方式可以通过related_name修改</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在查看关系表</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230327203323462.png" alt="image-20230327203323462"></p><h2 id="模型元数据meta">模型元数据Meta</h2><p>Meta类的作用是为模型类提供一些额外的元数据信息，以控制模型类的行为和与其他模型类的交互。通过设置Meta类中的属性和方法，可以使模型类更容易理解和使用，也可以提高模型类与数据库的交互效率.</p><blockquote><p>这个元数据就像表的元数据,我们可以对表进行一些约束</p></blockquote><p>比如我们就可以通过给定元数据修改模型在admin页面中的展现方式等等…</p><p>我们来看看它的常用属性吧</p><ol><li><code>db_table</code>：指定模型类在数据库中的表名。</li><li><code>ordering</code>：指定查询结果的排序方式。</li><li><code>verbose_name</code>和<code>verbose_name_plural</code>：分别指定模型类在后台管理站点中的显示名称和复数形式的显示名称。</li><li><code>unique_together</code>：指定哪些字段组合在一起必须是唯一的。</li><li><code>index_together</code>：指定哪些字段组合需要创建索引。</li><li><code>permissions</code>：指定模型类的权限，可以用于控制用户对模型类的访问和操作。</li><li><code>abstract</code>：指定模型类是否是抽象类。</li><li><code>app_label</code>：指定模型类所属的应用程序的名称。</li><li><code>verbose_name</code>和<code>verbose_name_plural</code>：分别指定模型类在后台管理站点中的显示名称和复数形式的显示名称</li></ol><p>我们可以修改verbose_name和verbose_name_plural来修改模型在admin平台显示的名字(管理后台那个例子)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class User(models.Model):</span><br><span class="line">    name = models.CharField(max_length=10,verbose_name=&quot;名字&quot;)</span><br><span class="line">    password = models.CharField(max_length=50,verbose_name=&quot;密码&quot;)</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&quot;&#123;self.name&#125;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &quot;用户&quot;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><p>我们来对比一下前后</p><p>没有加元数据前</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230328105428020.png" alt="image-20230328105428020"></p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230328105437630.png" alt="image-20230328105437630"></p><p>加了元数据后</p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230328105322677.png" alt="image-20230328105322677"></p><p><img src="/2023/03/24/python/Django%E5%AD%A6%E4%B9%A0/../img/Django%E5%AD%A6%E4%B9%A0assets/image-20230328105334861.png" alt="image-20230328105334861"></p><h2 id="操作表的api">操作表的API</h2><p>一旦创建 数据模型 后，Django 自动给予你一套数据库抽象 API，允许你创建，检索，更新和删除对象</p><p>要从数据库检索对象，要通过模型类的 Manager 构建一个 QuerySet。一个 QuerySet 代表来自数据库中对象的一个集合。</p><p>你能通过模型的 Manager 获取 QuerySet。每个模型至少有一个 Manager，默认名称是 objects,只能通过模型类来访问，不能通过模型实例来访问</p><h3 id="对象常用方法">对象常用方法</h3><p>save  保存到数据库</p><p>delete 从数据库中删除 (如果数据库中没有的话报错)</p><h3 id="objects常用方法">objects常用方法</h3><p>objects常用方法就是QuerySet 里面的常用方法,我们可以直接看QuerySet 中的方法</p><h3 id="queryset-常用方法">QuerySet 常用方法</h3><ol><li><p>filter(**kwargs): 用于筛选出满足给定查找参数的对象。参数可以是模型字段和值的映射。</p><p>示例：<code>Post.objects.filter(title__icontains='django', published=True)</code></p></li><li><p>exclude(**kwargs): 与filter相反，返回不满足给定参数的对象。</p><p>示例：<code>Post.objects.exclude(published=True)</code></p></li><li><p>get(**kwargs): 返回满足给定查找参数的单个对象。如果没有找到或找到多个对象，会抛出异常。</p><p>示例：<code>Post.objects.get(id=1)</code></p></li><li><p>all(): 返回QuerySet中包含的所有对象。</p><p>示例：<code>Post.objects.all()</code></p></li><li><p>none(): 返回一个空的QuerySet。</p><p>示例：<code>Post.objects.none()</code></p></li><li><p>count(): 返回QuerySet中的对象数量。</p><p>示例：<code>Post.objects.count()</code></p></li><li><p>exists(): 检查QuerySet是否包含任何对象。这比使用count()更高效。</p><p>示例：<code>Post.objects.exists()</code></p></li><li><p>order_by(*fields): 对查询结果进行排序。默认是升序，使用负号(-)表示降序。</p><p>示例：<code>Post.objects.order_by('-publish_date', 'title')</code></p></li><li><p>distinct(*fields): 返回QuerySet中不重复的对象。</p><p>示例：<code>Author.objects.distinct('country')</code></p></li><li><p>values(*fields): 返回一个包含字典的QuerySet，其中包含指定字段的值。<strong>这个就相当于分组</strong>,当我们使用后面的aggregate,或者annotate时就相当于对这个字段分组进行的</p><p>示例：<code>Post.objects.values('id', 'title')</code></p></li><li><p>values_list(*fields, flat=False): 返回一个包含元组（或单值，如果设置了flat=True）的QuerySet，其中包含指定字段的值。</p><p>示例：<code>Post.objects.values_list('id', 'title')</code></p></li><li><p>first(): 返回QuerySet中的第一个对象，如果没有对象，则返回None。</p><p>示例：<code>Post.objects.first()</code></p></li><li><p>last(): 返回QuerySet中的最后一个对象，如果没有对象，则返回None。</p><p>示例：<code>Post.objects.last()</code></p></li><li><p>aggregate(*args, **kwargs): 对查询结果进行聚合操作，如计数、求和、平均值等。</p><p>示例：<code>from django.db.models import Count, Avg</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Post.objects.aggregate(Count(&#x27;author&#x27;), Avg(&#x27;views&#x27;))</span><br></pre></td></tr></table></figure></li><li><p>annotate(*args, **kwargs): 为查询结果的每个对象添加注解，如计数、求和、平均值等。</p><p>示例：<code>from django.db.models import Count</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Author.objects.annotate(post_count=Count(&#x27;post&#x27;))</span><br></pre></td></tr></table></figure></li><li><p>select_related(*fields): 对于ForeignKey和OneToOneField字段，执行一个SQL join并包括查询中指定的相关对象。</p><p>示例：<code>Post.objects.select_related('author')</code></p></li><li><p>prefetch_related(*related_lookups): 用于对多对多关系和反向ForeignKey关系的查询优化。</p><p>示例：<code>Author.objects.prefetch_related('post_set')</code></p></li><li><p>using() 操作哪个数据库的数据</p></li><li><p>raw(sql, params=None, translations=None): 执行原始SQL查询，并返回一个包含指定模型实例的RawQuerySet。</p><p>示例：<code>Post.objects.raw('SELECT * FROM blog_post WHERE published = 1')</code></p></li></ol><h3 id="aggregate-与-annotate-的区别"><strong>aggregate 与 annotate 的区别</strong></h3><p><strong>aggregate会对当前QuerySet的所有数据当成一个分组,执行聚合函数,而且返回值是一个字典,里面只包含了我们分组的字段的数据</strong></p><p><strong>annotate 会根据values中的分组执行聚合函数,返回值是QuerySet  里面包含很多字典,字典和aggregate产生的字典很像(如果不使用values的话,每个数据自己是一个分组,而且返回值是一个queryset,里面包含的是对象)</strong></p><p>在实际应用中，您可以根据需要选择使用<code>aggregate()</code>或<code>annotate()</code>。如果您需要对整个数据集执行聚合操作，可以使用<code>aggregate()</code>。如果您需要在分组的基础上执行聚合操作，可以使用<code>annotate()</code></p><h3 id="q对象">Q对象</h3><p>我们发现objects中的参数连接起来后都是  and连接 ,如果我们想使用or连接的话,我们就得使用Q对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import Q</span><br><span class="line"></span><br><span class="line">Q(question__startswith=&#x27;Who&#x27;) | ~Q(pub_date__year=2005)</span><br></pre></td></tr></table></figure><p>我们可以对其进行普通的逻辑操作</p><h3 id="f对象">F对象</h3><p>F对象在Django中用于在查询或更新操作中引用字段的值。它允许在查询中<strong>使用模型字段的当前值，而不是传递一个固定值</strong>。F对象位于<code>django.db.models</code>模块中</p><ol><li>比较字段值：假设我们有一个博客模型，其中有两个字段：浏览次数（views）和点赞次数（likes）。我们想找出浏览次数大于点赞次数的文章：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F</span><br><span class="line"></span><br><span class="line">Post.objects.filter(views__gt=F(&#x27;likes&#x27;))</span><br></pre></td></tr></table></figure><p>这里，<code>views__gt=F('likes')</code>表示筛选出views字段的值大于likes字段的值的对象。</p><ol start="2"><li>更新字段值：假设我们想要在文章的浏览次数上加1，我们可以使用F对象实现这个功能：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F</span><br><span class="line"></span><br><span class="line">Post.objects.update(views=F(&#x27;views&#x27;) + 1)</span><br></pre></td></tr></table></figure><p>这里，<code>views=F('views') + 1</code>表示将每篇文章的views字段的值加1。</p><ol start="3"><li>对字段值进行计算：F对象可以与标准Python运算符一起使用，例如加法、减法、乘法和除法。例如，如果我们想要计算文章的点赞率（点赞次数除以浏览次数），我们可以这样做：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F, ExpressionWrapper, FloatField</span><br><span class="line"></span><br><span class="line">Post.objects.annotate(like_ratio=ExpressionWrapper(F(&#x27;likes&#x27;) / F(&#x27;views&#x27;), output_field=FloatField()))</span><br></pre></td></tr></table></figure><p>这里，我们使用<code>annotate</code>方法和<code>ExpressionWrapper</code>创建了一个名为<code>like_ratio</code>的新字段，该字段表示每篇文章的点赞率。</p><p>注意：当使用F对象执行运算时，可能会遇到数据库间的不一致性。为了避免这个问题，可以使用<code>django.db.models.functions</code>模块中的数据库函数。例如，对于上面的点赞率计算，我们可以使用<code>Div</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F</span><br><span class="line">from django.db.models.functions import Div</span><br><span class="line"></span><br><span class="line">Post.objects.annotate(like_ratio=Div(F(&#x27;likes&#x27;), F(&#x27;views&#x27;)))</span><br></pre></td></tr></table></figure><p>总之，F对象在Django查询中非常有用，它可以让你直接引用模型字段的值，而不是传递固定值。这样可以让你编写更灵活、更高效的查询。</p><h3 id="每个-queryset-都是唯一的">每个 QuerySet 都是唯一的</h3><p>每次精炼一个 QuerySet，你就会获得一个全新的 QuerySet，后者与前者毫无关联。每次精炼都会创建一个单独的、不同的 QuerySet，能被存储，使用和复用。</p><h3 id="queryset-是惰性的">QuerySet 是惰性的</h3><p>QuerySet 是惰性的 —— 创建 QuerySet 并不会引发任何数据库活动。你可以将一整天的过滤器都堆积在一起，Django 只会在 QuerySet 被 计算 时执行查询操作。来瞄一眼这个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q = Entry.objects.filter(headline__startswith=&quot;What&quot;)</span><br><span class="line">&gt;&gt;&gt; q = q.filter(pub_date__lte=datetime.date.today())</span><br><span class="line">&gt;&gt;&gt; q = q.exclude(body_text__icontains=&quot;food&quot;)</span><br><span class="line">&gt;&gt;&gt; print(q)</span><br></pre></td></tr></table></figure><p>虽然这看起来像是三次数据库操作，实际上只在最后一行 (print(q)) 做了一次。一般来说， QuerySet 的结果直到你 “要使用” 时才会从数据库中拿出。当你要用时，才通过数据库 计算 出 QuerySet</p><h2 id="分页">分页</h2><p>Django提供了一个方便的分页工具，可以帮助您轻松地对查询结果进行分页。以下是如何在Django项目中使用分页功能的基本步骤：</p><ol><li><p>导入Paginator和PageNotAnInteger、EmptyPage类：</p><p>首先，您需要从<code>django.core.paginator</code>模块中导入<code>Paginator</code>类，以及用于处理分页异常的<code>PageNotAnInteger</code>和<code>EmptyPage</code>类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, PageNotAnInteger, EmptyPage</span><br></pre></td></tr></table></figure></li><li><p>创建Paginator对象：</p><p>然后，您需要创建一个<code>Paginator</code>对象，传递查询结果和每页的对象数量。例如，如果您有一个<code>Post</code>模型并且希望每页显示5篇文章，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Post</span><br><span class="line"></span><br><span class="line">post_list = Post.objects.<span class="built_in">all</span>() <span class="comment"># 这里其实并不会去拿到所有的文章,因为它是惰性的</span></span><br><span class="line">paginator = Paginator(post_list, <span class="number">5</span>)  <span class="comment"># 每页显示5篇文章</span></span><br></pre></td></tr></table></figure></li><li><p>获取当前页的对象列表：</p><p>使用<code>Paginator</code>对象，您可以获取特定页码上的对象列表。为此，您需要从请求参数中获取当前页码（例如，从<code>page</code>参数中获取），然后使用<code>Paginator</code>对象的<code>get_page()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page = request.GET.get(<span class="string">&#x27;page&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    posts = paginator.get_page(page)</span><br><span class="line"><span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">    <span class="comment"># 如果页码不是整数，则显示第一页</span></span><br><span class="line">    posts = paginator.get_page(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> EmptyPage:</span><br><span class="line">    <span class="comment"># 如果页码超出范围，则显示最后一页</span></span><br><span class="line">    posts = paginator.get_page(paginator.num_pages)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先尝试获取请求中指定的页码。如果页码不是整数或超出范围，我们将返回第一页或最后一页的对象列表。</p></li></ol><h2 id="数据库事务">数据库事务</h2><p>在Django中，事务是用于确保一组数据库操作要么全部成功执行，要么全部失败，从而维护数据库的一致性。Django提供了几种使用事务的方法：</p><ol><li><p><strong>使用装饰器</strong>：<code>django.db.transaction.atomic</code>是一个装饰器，可以用来确保被装饰的函数中的数据库操作在一个原子事务中执行。如果函数中的任何操作失败，整个事务将被回滚。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.db import transaction</span><br><span class="line"></span><br><span class="line">@transaction.atomic</span><br><span class="line">def create_user_and_profile(username, email):</span><br><span class="line">    user = User.objects.create(username=username, email=email)</span><br><span class="line">    profile = UserProfile.objects.create(user=user)</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>create_user_and_profile</code>函数被<code>@transaction.atomic</code>装饰器包裹，确保<code>User</code>和<code>UserProfile</code>的创建操作在一个原子事务中执行。</p></li><li><p><strong>使用上下文管理器</strong>：<code>django.db.transaction.atomic</code>还可以作为上下文管理器使用，将一段代码块包含在一个原子事务中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.db import transaction</span><br><span class="line"></span><br><span class="line">def create_user_and_profile(username, email):</span><br><span class="line">    with transaction.atomic():</span><br><span class="line">        user = User.objects.create(username=username, email=email)</span><br><span class="line">        profile = UserProfile.objects.create(user=user)</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用<code>with transaction.atomic()</code>语句确保代码块中的<code>User</code>和<code>UserProfile</code>的创建操作在一个原子事务中执行。</p></li><li><p><strong>手动管理事务</strong>：在某些情况下，您可能需要更精细地控制事务的行为。Django提供了<code>transaction.commit()</code>、<code>transaction.rollback()</code>和<code>transaction.set_autocommit()</code>等方法，以便手动管理事务。</p><p>请注意，手动管理事务可能导致更复杂的代码和更高的错误风险。因此，除非有特殊需求，否则建议使用<code>transaction.atomic</code>装饰器或上下文管理器。</p></li></ol><p>总之，在Django中，您可以使用<code>django.db.transaction.atomic</code>装饰器或上下文管理器来确保一组数据库操作在一个原子事务中执行。这有助于确保数据库的一致性和数据完整性。在需要更精细的事务控制时，您还可以使用手动管理事务的方法，但这可能导致代码更加复杂。</p><h1>模板</h1><p>Django 模板语言是一种简单的、可扩展的标记语言，用于在 Django 视图中呈现数据。它包括变量、标签和过滤器。以下是 Django 模板语法的基本概述。</p><h2 id="基本语法">基本语法</h2><h3 id="变量">变量</h3><p>变量是从视图传递给模板的数据。在模板中，变量用双大括号<code>&#123;&#123; &#125;&#125;</code>括起来。</p><h3 id="特定标签">特定标签</h3><p>标签是用于执行特定操作的模板指令。它们用大括号和百分号<code>&#123;% %&#125;</code>括起来。Django 提供了许多内置标签，也允许您创建自定义标签。</p><ul><li>for：遍历列表或字典</li><li>if/elif/else：条件判断</li><li>include：包含另一个模板的内容</li><li>block/extends：模板继承</li><li>load：加载自定义标签和过滤器</li><li>with：创建模板中的局部变量</li></ul><h3 id="过滤器">过滤器</h3><p>过滤器用于在模板中对变量执行某些操作。它们在变量后使用管道符<code>|</code>表示。以下是一些内建过滤器：</p><ul><li>lower：将文本转换为小写</li><li>date：格式化日期</li><li>length：获取列表或字符串的长度</li><li>default：设置默认值</li><li>escape：转义HTML字符</li><li>safe：标记变量内容为安全的HTML  可以将我们的变量字符串变成html</li></ul><h2 id="上下文">上下文</h2><p>我们在模板中能够使用的变量都是在上下文中能找到的</p><h3 id="django帮我们添加好的变量">Django帮我们添加好的变量</h3><ol><li><code>django.template.context_processors.debug</code>:<ul><li><code>debug</code>: 布尔值，表示当前是否处于调试模式（由<code>settings.DEBUG</code>决定）。</li></ul></li><li><code>django.template.context_processors.request</code>:<ul><li><code>request</code>: 当前的HttpRequest对象，包含请求的详细信息，如URL、HTTP方法、GET/POST参数等。</li></ul></li><li><code>django.template.context_processors.media</code>:<ul><li><code>MEDIA_URL</code>: 用于访问媒体文件的基本URL（由<code>settings.MEDIA_URL</code>定义）。</li></ul></li><li><code>django.template.context_processors.static</code>:<ul><li><code>STATIC_URL</code>: 用于访问静态文件的基本URL（由<code>settings.STATIC_URL</code>定义）。</li></ul></li><li><code>django.contrib.auth.context_processors.auth</code>:<ul><li><code>user</code>: 表示当前已登录的用户，或者是一个匿名用户。</li><li><code>perms</code>: 一个对象，包含当前用户的所有权限。</li></ul></li><li><code>django.contrib.messages.context_processors.messages</code>:<ul><li><code>messages</code>: 当前请求中的一次性消息（flash messages），通常用于显示成功、错误或信息提示</li></ul></li></ol><h3 id="如何自己往上下文中添加变量">如何自己往上下文中添加变量</h3><p>以下是一些常见的方法来将变量放入上下文：</p><ol><li>使用render()函数：<br>render()函数是在视图中渲染模板并将结果作为HttpResponse返回的最常用方法。它接受三个参数：请求对象（request）、模板名称和上下文字典（可选）。</li><li>使用TemplateView类：<br>如果你使用基于类的视图（class-based views），可以通过在TemplateView子类中定义get_context_data()方法来添加上下文变量</li><li>使用上下文处理器（context processors）：<br>上下文处理器是一种将全局变量添加到所有模板上下文的方法。要创建一个上下文处理器，你需要编写一个函数，该函数接受一个request参数并返回一个字典。然后将此函数添加到settings.py中的TEMPLATES选项的’context_processors’列表中</li></ol><h1>需要注意的点</h1><h2 id="创建数据模型对象的方式">创建数据模型对象的方式</h2><p>如果我们使用的是普通方式的创建对象的话,必须使用save方法,不然不会保存到数据库,  如果我们使用的是 objects.create的方法的话就不需要使用save方法</p><h2 id="修改数据后要调用save方法">修改数据后要调用save方法</h2><p>我们对对象的属性进行修改后必须使用save方法才能修改到数据库</p><h1>额外补充</h1><h2 id="加密密码">加密密码</h2><p><strong>为什么要对密码进行加密？</strong></p><p>加密密码的原因是为了保护用户的隐私和安全。当用户在应用程序中注册并提供密码时，<strong>如果以明文形式存储密码，那么任何可以访问数据库的人都可以查看和使用这些密码。这可能导致用户数据泄露，黑客攻击，以及其他安全问题</strong>。为了防止这种情况，我们应该将密码加密存储，以便即使数据库被泄露，攻击者也无法轻易地获取原始密码。</p><p>Django提供了<code>make_password</code>和<code>check_password</code>这两个方便的函数，用于处理密码哈希和验证。它们位于<code>django.contrib.auth.hashers</code>模块中。</p><ol><li><code>make_password</code>：这个函数将明文密码转换为哈希值，可以在数据库中存储。默认情况下，它使用Django的默认哈希器（在Django的设置中通过<code>PASSWORD_HASHERS</code>设置）。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password</span><br><span class="line"></span><br><span class="line">plaintext_password = <span class="string">&quot;my_password&quot;</span></span><br><span class="line">hashed_password = make_password(plaintext_password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将哈希密码存储到数据库中</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>check_password</code>：这个函数接受明文密码和哈希密码作为参数。它会尝试使用同样的哈希算法将明文密码转换为哈希值，并将结果与已存储的哈希密码进行比较。如果哈希值匹配，则验证成功，函数返回<code>True</code>；否则，返回<code>False</code>。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> check_password</span><br><span class="line"></span><br><span class="line">plaintext_password = <span class="string">&quot;my_password&quot;</span></span><br><span class="line">stored_hashed_password = <span class="string">&quot;some_hashed_password_from_database&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> check_password(plaintext_password, stored_hashed_password):</span><br><span class="line">    <span class="comment"># 密码验证成功</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 密码验证失败</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>通过使用Django的<code>make_password</code>和<code>check_password</code>函数，您可以在自定义数据库字段中方便地处理密码哈希和验证。这些函数已经为您处理了加密和哈希算法，确保了密码的安全性。</p><h2 id="时区问题">时区问题</h2><p>在使用Django的时候,如果数据库里面字段是Date字段,我发现它总是和中国时区差8个小时,只有将USE_TZ 设置成False的时候才能正确</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE_TZ=<span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="如何发送qq邮件">如何发送QQ邮件</h2><ol><li>首先，确保已经安装了 <code>django-smtp-ssl</code> 包。 pip install django-smtp-ssl</li><li>登录你的 QQ 邮箱，然后进入 <a href="https://mail.qq.com/cgi-bin/frame_html">设置 -&gt; 账户 -&gt; POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</a> 页面，开启 SMTP 服务。注意，开启后会获得一个授权码，记下这个授权码，稍后在 Django 项目中使用。</li><li>在 <code>searchproject</code> 项目的 <code>settings.py</code> 文件中，配置邮件发送设置，使用 QQ 邮箱的 SMTP 服务器和刚刚获得的授权码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EMAIL_BACKEND = &#x27;django_smtp_ssl.SSLEmailBackend&#x27;</span><br><span class="line">EMAIL_HOST = &#x27;smtp.qq.com&#x27;</span><br><span class="line">EMAIL_PORT = 465</span><br><span class="line">EMAIL_USE_SSL = True</span><br><span class="line">EMAIL_HOST_USER = &#x27;your-qq-email@example.com&#x27;  # 你的 QQ 邮箱地址</span><br><span class="line">EMAIL_HOST_PASSWORD = &#x27;your-qq-email-authorization-code&#x27;  # 你的 QQ 邮箱授权码</span><br></pre></td></tr></table></figure><p>写一个简单的例子吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.core.mail import EmailMultiAlternatives</span><br><span class="line">from email.utils import formataddr</span><br><span class="line">def send_verification_code(to_email, verification_code):</span><br><span class="line">    subject = f&#x27;搜题系统验证码&#x27;</span><br><span class="line">    plain_text_message = f&#x27;您的验证码为: &#123;verification_code&#125;,五分钟内有效&#x27;</span><br><span class="line">    html_message = f&#x27;&lt;p&gt;您的验证码为: &lt;span style=&quot;color: blue; text-decoration: underline;&quot;&gt;&#123;verification_code&#125;&lt;/span&gt;,五分钟内有效&lt;/p&gt;&#x27;</span><br><span class="line">    from_email = formataddr((&#x27;搜题系统&#x27;,settings.EMAIL_HOST_USER))  # 设置发件人名字和邮箱</span><br><span class="line"></span><br><span class="line">    email = EmailMultiAlternatives(subject, plain_text_message, from_email, [to_email])</span><br><span class="line">    email.attach_alternative(html_message, &quot;text/html&quot;)</span><br><span class="line">    email.send()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用内置缓存框架">使用内置缓存框架</h2><p>Django提供了一个灵活的内置缓存框架，可以轻松地为您的项目添加缓存功能。以下是如何使用Django内置缓存框架的基本步骤：</p><ol><li><p>配置缓存后端</p><p>在<code>settings.py</code>文件中，需要配置一个<code>CACHES</code>字典来设置缓存后端。Django支持多种缓存后端，例如内存、文件、Memcached和Redis。以下是一个使用内存缓存的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.locmem.LocMemCache&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;unique-snowflake&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关更多缓存配置选项，请参阅Django文档：<a href="https://docs.djangoproject.com/en/3.2/topics/cache/#setting-up-the-cache">https://docs.djangoproject.com/en/3.2/topics/cache/#setting-up-the-cache</a></p></li><li><p>使用缓存API</p><p>Django提供了一个简单的API来存储、获取和删除缓存项。以下是一些基本示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置缓存值，超时时间为300秒</span></span><br><span class="line">cache.<span class="built_in">set</span>(<span class="string">&#x27;my_key&#x27;</span>, <span class="string">&#x27;my_value&#x27;</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取缓存值</span></span><br><span class="line">value = cache.get(<span class="string">&#x27;my_key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除缓存值</span></span><br><span class="line">cache.delete(<span class="string">&#x27;my_key&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Django缓存API还提供了许多其他功能，例如增量操作、批量获取和设置等。有关详细信息，请参阅文档：<a href="https://docs.djangoproject.com/en/3.2/topics/cache/#the-low-level-cache-api">https://docs.djangoproject.com/en/3.2/topics/cache/#the-low-level-cache-api</a></p><blockquote><p>这个缓存过期后就会被删除,因此再调用get方法时就是None</p></blockquote></li></ol><h2 id="检查路由是否存在">检查路由是否存在</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> resolve</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">match</span> = resolve(request.path)  <span class="comment"># 如果不存在就会抛出异常</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;code&quot;</span>: Code.NOT_FOUND, <span class="string">&quot;info&quot;</span>: <span class="string">&quot;请求不存在&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="状态码">状态码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HttpStatusCodes</span>:</span><br><span class="line">    <span class="comment"># 2xx 成功状态码</span></span><br><span class="line">    HTTP_200_OK = <span class="number">200</span>  <span class="comment"># 请求成功，服务器成功处理了请求</span></span><br><span class="line">    HTTP_201_CREATED = <span class="number">201</span>  <span class="comment"># 请求已成功处理，创建了新资源</span></span><br><span class="line">    HTTP_202_ACCEPTED = <span class="number">202</span>  <span class="comment"># 请求已接受，但服务器尚未处理</span></span><br><span class="line">    HTTP_203_NON_AUTHORITATIVE_INFORMATION = <span class="number">203</span>  <span class="comment"># 返回非权威性信息</span></span><br><span class="line">    HTTP_204_NO_CONTENT = <span class="number">204</span>  <span class="comment"># 请求成功，但无需返回任何内容（如删除资源）</span></span><br><span class="line">    HTTP_205_RESET_CONTENT = <span class="number">205</span>  <span class="comment"># 请求成功，需要客户端重置文档视图</span></span><br><span class="line">    HTTP_206_PARTIAL_CONTENT = <span class="number">206</span>  <span class="comment"># 部分GET请求已成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3xx 重定向状态码</span></span><br><span class="line">    HTTP_300_MULTIPLE_CHOICES = <span class="number">300</span>  <span class="comment"># 提供多种可选资源</span></span><br><span class="line">    HTTP_301_MOVED_PERMANENTLY = <span class="number">301</span>  <span class="comment"># 永久重定向，资源已被分配了新的URL</span></span><br><span class="line">    HTTP_302_FOUND = <span class="number">302</span>  <span class="comment"># 临时重定向，资源现在临时位于不同的URL</span></span><br><span class="line">    HTTP_303_SEE_OTHER = <span class="number">303</span>  <span class="comment"># 参照其他信息，请查看其他URI</span></span><br><span class="line">    HTTP_304_NOT_MODIFIED = <span class="number">304</span>  <span class="comment"># 资源未更改，缓存有效</span></span><br><span class="line">    HTTP_305_USE_PROXY = <span class="number">305</span>  <span class="comment"># 必须使用代理访问</span></span><br><span class="line">    HTTP_306_UNUSED = <span class="number">306</span>  <span class="comment"># 未使用的状态码</span></span><br><span class="line">    HTTP_307_TEMPORARY_REDIRECT = <span class="number">307</span>  <span class="comment"># 临时重定向，请求应保持原HTTP方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4xx 客户端错误状态码</span></span><br><span class="line">    HTTP_400_BAD_REQUEST = <span class="number">400</span>  <span class="comment"># 错误请求，服务器无法理解或处理</span></span><br><span class="line">    HTTP_401_UNAUTHORIZED = <span class="number">401</span>  <span class="comment"># 需要身份验证</span></span><br><span class="line">    HTTP_402_PAYMENT_REQUIRED = <span class="number">402</span>  <span class="comment"># 需要付款，预留状态码</span></span><br><span class="line">    HTTP_403_FORBIDDEN = <span class="number">403</span>  <span class="comment"># 禁止访问，服务器拒绝请求</span></span><br><span class="line">    HTTP_404_NOT_FOUND = <span class="number">404</span>  <span class="comment"># 未找到，服务器找不到请求的资源</span></span><br><span class="line">    HTTP_405_METHOD_NOT_ALLOWED = <span class="number">405</span>  <span class="comment"># 方法禁用，服务器禁止使用该方法</span></span><br><span class="line">    HTTP_406_NOT_ACCEPTABLE = <span class="number">406</span>  <span class="comment"># 无法满足请求头中的条件</span></span><br><span class="line">    HTTP_407_PROXY_AUTHENTICATION_REQUIRED = <span class="number">407</span>  <span class="comment"># 需要代理身份验证</span></span><br><span class="line">    HTTP_408_REQUEST_TIMEOUT = <span class="number">408</span>  <span class="comment"># 请求超时，服务器等待请求超时</span></span><br><span class="line">    HTTP_409_CONFLICT = <span class="number">409</span>  <span class="comment"># 请求冲突，请求与服务器当前状态冲突</span></span><br><span class="line">    HTTP_410_GONE = <span class="number">410</span>  <span class="comment"># 资源已永久删除，服务器找不到请求的资源</span></span><br><span class="line">    HTTP_411_LENGTH_REQUIRED = <span class="number">411</span>  <span class="comment"># 需要Content-Length请求头</span></span><br><span class="line">    HTTP_412_PRECONDITION_FAILED = <span class="number">412</span>  <span class="comment"># 服务器未满足请求头中的条件</span></span><br><span class="line">    HTTP_413_REQUEST_ENTITY_TOO_LARGE = <span class="number">413</span>  <span class="comment"># 请求实体过大</span></span><br><span class="line">    HTTP_414_REQUEST_URI_TOO_LONG = <span class="number">414</span>  <span class="comment"># 请求URI过长</span></span><br><span class="line">    HTTP_415_UNSUPPORTED_MEDIA_TYPE = <span class="number">415</span> <span class="comment"># 请求的媒体类型不受支持</span></span><br><span class="line">    HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="number">416</span>  <span class="comment"># 请求的范围无效</span></span><br><span class="line">    HTTP_417_EXPECTATION_FAILED = <span class="number">417</span>  <span class="comment"># 未满足期望请求头的要求</span></span><br><span class="line">    HTTP_418_IM_A_TEAPOT = <span class="number">418</span>  <span class="comment"># 当服务器是一个茶壶时返回，主要用于愚人节玩笑</span></span><br><span class="line">    HTTP_422_UNPROCESSABLE_ENTITY = <span class="number">422</span>  <span class="comment"># 请求格式正确，但服务器无法处理实体内容</span></span><br><span class="line">    HTTP_423_LOCKED = <span class="number">423</span>  <span class="comment"># 资源被锁定</span></span><br><span class="line">    HTTP_424_FAILED_DEPENDENCY = <span class="number">424</span>  <span class="comment"># 依赖请求失败</span></span><br><span class="line">    HTTP_426_UPGRADE_REQUIRED = <span class="number">426</span>  <span class="comment"># 需要客户端升级协议</span></span><br><span class="line">    HTTP_428_PRECONDITION_REQUIRED = <span class="number">428</span>  <span class="comment"># 要求先决条件</span></span><br><span class="line">    HTTP_429_TOO_MANY_REQUESTS = <span class="number">429</span>  <span class="comment"># 请求过多，超过服务器限制</span></span><br><span class="line">    HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = <span class="number">431</span>  <span class="comment"># 请求头字段过大</span></span><br><span class="line">    HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = <span class="number">451</span>  <span class="comment"># 因法律原因不可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5xx 服务器错误状态码</span></span><br><span class="line">    HTTP_500_INTERNAL_SERVER_ERROR = <span class="number">500</span>  <span class="comment"># 服务器内部错误</span></span><br><span class="line">    HTTP_501_NOT_IMPLEMENTED = <span class="number">501</span>  <span class="comment"># 服务器不具备完成请求的功能</span></span><br><span class="line">    HTTP_502_BAD_GATEWAY = <span class="number">502</span>  <span class="comment"># 作为网关或代理，服务器从上游服务器接收到无效响应</span></span><br><span class="line">    HTTP_503_SERVICE_UNAVAILABLE = <span class="number">503</span>  <span class="comment"># 服务器不可用，暂时过载或维护</span></span><br><span class="line">    HTTP_504_GATEWAY_TIMEOUT = <span class="number">504</span>  <span class="comment"># 作为网关或代理，服务器未及时从上游服务器接收请求</span></span><br><span class="line">    HTTP_505_HTTP_VERSION_NOT_SUPPORTED = <span class="number">505</span>  <span class="comment"># 服务器不支持请求所使用的HTTP协议版本</span></span><br><span class="line">    HTTP_506_VARIANT_ALSO_NEGOTIATES = <span class="number">506</span>  <span class="comment"># 服务器存在内部配置错误</span></span><br><span class="line">    HTTP_507_INSUFFICIENT_STORAGE = <span class="number">507</span>  <span class="comment"># 服务器无法存储完成请求所必须的内容</span></span><br><span class="line">    HTTP_508_LOOP_DETECTED = <span class="number">508</span>  <span class="comment"># 服务器在处理请求时检测到无限循环</span></span><br><span class="line">    HTTP_510_NOT_EXTENDED = <span class="number">510</span>  <span class="comment"># 获取资源所需的策略并没有被满足</span></span><br><span class="line">    HTTP_511_NETWORK_AUTHENTICATION_REQUIRED = <span class="number">511</span>  <span class="comment"># 需要进行网络认证</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>遇到的问题</h1><h2 id="无法访问">无法访问</h2><p>两个地方要注意</p><p>第一个地方是 <a href="http://setttings.py">setttings.py</a> 文件的ALLOWED_HOSTS</p><p>另外一个是  启动命令  使用 python runserve  0.0.0.0:8000</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python实用技巧</title>
      <link href="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据结构">基本数据结构</h2><h3 id="序列分解为单独变量">序列分解为单独变量</h3><p>对于一个可分解对象(迭代器,生成器,列表,元组,集合),我们可以直接用变量去接收里面的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a,b,c,d,e = l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果数量不匹配则会报错</span></span><br><span class="line"><span class="comment"># a,b = l   # ValueError: too many values to unpack (expected 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们只想要一些数据的话,可以用占位符(可以是任何字符,我们习惯用_),_代表占用一个 *_ 代表占用一群</span></span><br><span class="line"></span><br><span class="line">_ , a , *_ = l</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><blockquote><p>如果解压出来的数据里面又包含序列,我们还想解压的话,必须使用()包裹起来</p><p>a = [1,(2,3)]</p><p>b,(c,d) = a</p></blockquote><h4 id="举例实用性">举例实用性</h4><p>去除一个列表的最高值和最低值,求中间值的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">socres</span>):</span><br><span class="line">    first,*mid,last = socres</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(mid) / <span class="built_in">len</span>(mid)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(average([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><h3 id="保留最后n个元素">保留最后N个元素</h3><p>我们希望我们的队列中只保留最后N个元素,当元素超过N的时候就把前面的删掉,我们可以用队列实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">queue = deque(maxlen=<span class="number">5</span>)  <span class="comment"># 只保留最后五个</span></span><br><span class="line">queue.extend([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> queue: </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意 append 和 extend 的区别 ,append是添加一个元素,extend是把后面这个可迭代对象拆开放进去</p></blockquote><blockquote><p>列表适合做栈,不适合做队列,它的出队列是o(N)时间复杂度</p></blockquote><h3 id="获得最大或者最小的n个元素">获得最大或者最小的N个元素</h3><p>从可迭代数据中或者最大或者最小的N个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;FB&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;HPQ&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">35</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;YHOO&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">45</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ACME&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pprint.pprint(heapq.nsmallest(<span class="number">2</span>,portfolio,<span class="keyword">lambda</span> x:x[<span class="string">&#x27;price&#x27;</span>]))</span><br><span class="line">pprint.pprint(heapq.nlargest(<span class="number">2</span>,portfolio,<span class="keyword">lambda</span> x:x[<span class="string">&#x27;price&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>heapq的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">10</span>,<span class="number">34</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">heapq.heapify(nums)  <span class="comment"># 必须得先进行排序</span></span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(nums)) <span class="comment"># 删除堆顶</span></span><br><span class="line">heapq.heappush(nums,<span class="number">20</span>) <span class="comment"># 添加一个元素</span></span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><h3 id="字典中的键映射多个值">字典中的键映射多个值</h3><p>其实就是利用列表这些数据结构当成键对应的值,然后可以往这个列表中多添加些数据,其实还是只能一个键对应一个值</p><p>我们可以自己这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a.setdefault(<span class="string">&quot;name&quot;</span>,[]).append(<span class="string">&quot;djm&quot;</span>)</span><br><span class="line">a.setdefault(<span class="string">&quot;name&quot;</span>,[]).append(<span class="string">&quot;nb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然,看着这么多代码还是有点不舒服的,我们就用python提供的 defaultdict吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">a = defaultdict(<span class="built_in">list</span>)  <span class="comment"># 帮我们的值默认初始化为 list</span></span><br><span class="line">a[<span class="string">&quot;name&quot;</span>].append(<span class="string">&quot;djm&quot;</span>)</span><br><span class="line">a[<span class="string">&quot;name&quot;</span>].append(<span class="string">&quot;nb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h3 id="控制字典顺序">控制字典顺序</h3><p>当我们遍历字典的时候,发现出来的数据并不是我们原先添加进去的顺序,因为这个用的是hash算法来放位置的,如果我们想要按添加时候的顺序来遍历数据就要用  orderdict ,它的底层多了一个双向链表,这也就意味着内存的增加,所以我们要酌情使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&#x27;bar&#x27;</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">&#x27;spam&#x27;</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">&#x27;grok&#x27;</span>] = <span class="number">4</span></span><br><span class="line"><span class="comment"># Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot;</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(key, d[key])</span><br></pre></td></tr></table></figure><h3 id="切片命名">切片命名</h3><p>如果对于一个固定的切片大小,而且要经常使用,我们不妨使用slice 函数来生成切片序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">slice</span>(<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>)  </span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(a[s])</span><br><span class="line"><span class="built_in">print</span>(b[s])</span><br></pre></td></tr></table></figure><h3 id="counter">counter</h3><p>这个类可以用来对一个存放有可hash的对象的可迭代的列表进行计数,厉害的是它还可以进行数据运算,还有其他的强大的功能,比我们自己用dict 去计数要方便很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">a = [<span class="built_in">int</span>(random.random()*<span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">b = [<span class="built_in">int</span>(random.random()*<span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># [2, 2, 0, 0, 2]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [2, 2, 1, 1, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter跟dict的方法差不多</span></span><br><span class="line">ca = Counter(a)</span><br><span class="line">cb = Counter(b) </span><br><span class="line"><span class="built_in">print</span>(ca)  <span class="comment"># Counter(&#123;2: 3, 0: 2&#125;)</span></span><br><span class="line"><span class="built_in">print</span>(cb)  <span class="comment"># Counter(&#123;2: 2, 1: 2, 0: 1&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求出前2个数量最多的,列表里面套元组,而且是已经排好序的</span></span><br><span class="line"><span class="built_in">print</span>(ca.most_common(<span class="number">2</span>))  <span class="comment"># [(2, 3), (0, 2)]</span></span><br><span class="line"><span class="built_in">print</span>(cb.most_common(<span class="number">2</span>))  <span class="comment">#  [(2, 2), (1, 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 做数学运算</span></span><br><span class="line"><span class="built_in">print</span>(ca-cb) <span class="comment"># Counter(&#123;2: 1, 0: 1&#125;)</span></span><br><span class="line"><span class="built_in">print</span>(ca+cb) <span class="comment"># Counter(&#123;2: 5, 0: 3, 1: 2&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="提供关键字排序函数">提供关键字排序函数</h3><p>在排序的时候,我们有时候会按照一些自定义规则排序,或者是使用关键字排序,我们可以使用lambda,也可以使用python提供的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter,itemgetter</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">rows = [</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Beazley&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Cleese&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Big&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, user_id</span>):</span><br><span class="line">        self.user_id = user_id</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;User(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(self.user_id)</span><br><span class="line">users = [User(<span class="number">23</span>), User(<span class="number">3</span>), User(<span class="number">99</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># itemgetter(key) 相当于 lambda x:x[key]</span></span><br><span class="line">pprint(<span class="built_in">sorted</span>(rows,key=itemgetter(<span class="string">&quot;lname&quot;</span>)))</span><br><span class="line"><span class="comment"># attrgetter(key) 相当于  lambda x:x.getter(key)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(users, key=attrgetter(<span class="string">&quot;user_id&quot;</span>)))</span><br></pre></td></tr></table></figure><h3 id="根据某个字段分组">根据某个字段分组</h3><p>有时候我们希望根据某个字段分组,然后依次遍历这个分组,这是非常使用的一个东西,如果让我们自己来遍历的话,必须得先定义一个变量比较是否属于一个分组,这样太麻烦了,我们看看python提供的groupby函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">rows = [</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5412 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5148 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;2122 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/03/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;4801 N BROADWAY&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1039 W GRANVILLE&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 必须先排好序</span></span><br><span class="line">rows.sort(key=itemgetter(<span class="string">&quot;date&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据日期分组,得到每个分组里面数据,以及分组数量</span></span><br><span class="line">groups = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> date, items <span class="keyword">in</span> groupby(rows,key=itemgetter(<span class="string">&quot;date&quot;</span>)):</span><br><span class="line">    groups += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;groups&#125;</span>分组的内容为:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>记得先排好序</p></blockquote><h3 id="将下标序列变成命名序列">将下标序列变成命名序列</h3><p>有时候我们通过下标访问序列的方式让代码看起来很不清晰,不知道这个下标表示什么意思,我们不妨将这个序列变成命名分组,这样我们可以通过.名字的方法访问数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 名字,语文,数学</span></span><br><span class="line">Students = [</span><br><span class="line">    [<span class="string">&quot;djm&quot;</span>,<span class="number">10</span>,<span class="number">20</span>],</span><br><span class="line">    [<span class="string">&quot;dd&quot;</span>,<span class="number">80</span>,<span class="number">20</span>],</span><br><span class="line">    [<span class="string">&quot;aa&quot;</span>,<span class="number">10</span>,<span class="number">90</span>],</span><br><span class="line">    [<span class="string">&quot;cc&quot;</span>,<span class="number">100</span>,<span class="number">20</span>],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 求每个学生总分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用下标</span></span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> Students:</span><br><span class="line">    <span class="built_in">print</span>(student[<span class="number">0</span>],<span class="string">&quot;:&quot;</span>,student[<span class="number">1</span>]+student[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命名分组</span></span><br><span class="line">Student = namedtuple(<span class="string">&quot;Student&quot;</span>,[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;chinese&quot;</span>,<span class="string">&quot;math&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> Students:</span><br><span class="line">    student = Student(*student) <span class="comment"># 这里必须使用参数展开符</span></span><br><span class="line">    <span class="built_in">print</span>(student.name,<span class="string">&quot;:&quot;</span>,student.chinese+student.math)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方法是不是可以让代码看起来更直观</p><p>记住这里生成的对象里面的数据是不可以变的,它这个对象跟元组差不多,都是不可变对象,如果非要更改,必须使用_replace方法生成一个新的对象</p><h3 id="合并多个字典">合并多个字典</h3><p>现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作， 比如查找值或者检查某些键是否存在。其实也就是用个链表将多个dict连接起来,查找的时候从当前一直向后查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">a = &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;z&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">m = ChainMap(a,b)</span><br><span class="line"><span class="built_in">print</span>(m[<span class="string">&quot;x&quot;</span>])  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(m[<span class="string">&quot;z&quot;</span>])  <span class="comment"># 3</span></span><br><span class="line">m[<span class="string">&quot;u&quot;</span>] = <span class="number">10</span>  <span class="comment">#  相当于 a[&quot;u&quot;] = 10</span></span><br><span class="line"><span class="built_in">print</span>(m) <span class="comment"># ChainMap(&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;u&#x27;: 10&#125;, &#123;&#x27;x&#x27;: 2, &#x27;z&#x27;: 3&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="二分查找库">二分查找库</h3><p><code>bisect</code>模块提供了以下两个主要函数：</p><ul><li><code>bisect_left(a, x, lo=0, hi=len(a))</code>：在已排序的列表a中查找元素x应该插入的位置，返回值是一个整数，表示x应该插入的位置。如果x已经存在于a中，则返回与之相等的元素的左侧位置。<code>lo</code>和<code>hi</code>参数用于指定查找范围，默认是整个列表a。</li><li><code>bisect_right(a, x, lo=0, hi=len(a))</code>：与<code>bisect_left()</code>函数类似，但如果x已经存在于a中，则返回与之相等的元素的右侧位置。</li></ul><p>除此之外，<code>bisect</code>模块还提供了以下两个函数，用于在已排序的序列中插入元素：</p><ul><li><code>insort_left(a, x, lo=0, hi=len(a))</code>：将元素x插入到已排序的列表a中，并保持列表的升序排列。</li><li><code>insort_right(a, x, lo=0, hi=len(a))</code>：与<code>insort_left()</code>函数类似，但如果x已经存在于a中，则将x插入到相等元素的右侧。</li></ul><h2 id="字符串">字符串</h2><h3 id="指定分隔符分割字符串">指定分隔符分割字符串</h3><p>我们可以用字符串提供的split方法 以及 更强大的re.split方法,前者只能指定一个分隔符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">line = <span class="string">&#x27;asdf fjdk; afed, fjek,asdf, foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只能指定一个分隔符</span></span><br><span class="line"><span class="built_in">print</span>(line.split(<span class="string">&#x27;;&#x27;</span>)) <span class="comment">#[&#x27;asdf fjdk&#x27;, &#x27; afed, fjek,asdf, foo&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(line.split(<span class="string">&#x27;,;&#x27;</span>)) <span class="comment"># [&#x27;asdf fjdk; afed, fjek,asdf, foo&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以指定多个分隔符</span></span><br><span class="line"><span class="built_in">print</span>(re.split(<span class="string">r&#x27;[ ,;]+&#x27;</span>,line)) <span class="comment">#[&#x27;asdf&#x27;, &#x27;fjdk&#x27;, &#x27;afed&#x27;, &#x27;fjek&#x27;, &#x27;asdf&#x27;, &#x27;foo&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定分组的话分割好的列表中会包含分隔符</span></span><br><span class="line"><span class="built_in">print</span>(re.split(<span class="string">r&#x27;([ ,;]+)&#x27;</span>,line)) <span class="comment">#[&#x27;asdf&#x27;, &#x27; &#x27;, &#x27;fjdk&#x27;, &#x27;; &#x27;, &#x27;afed&#x27;, &#x27;, &#x27;, &#x27;fjek&#x27;, &#x27;,&#x27;, &#x27;asdf&#x27;, &#x27;, &#x27;, &#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="多个开头或者结尾匹配">多个开头或者结尾匹配</h3><p>如果我们要看一个字符串的开头或者结尾是否满足一群要求,我们可以在endswith 或者 startswith中传递一个<strong>元组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ishttp</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> url.startswith((<span class="string">&quot;http&quot;</span>,<span class="string">&quot;https&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(ishttp(url))</span><br><span class="line"><span class="built_in">print</span>(ishttp(<span class="string">&quot;https://www.baidu.com&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="使用通配符匹配字符串">使用通配符匹配字符串</h3><p>就像用shell里面的通配符去匹配字符串一样,我们需要使用fnmatch模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fnmatch</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fnmatch.fnmatch(<span class="string">&quot;A.TXT&quot;</span>,<span class="string">&quot;*.txt&quot;</span>)) <span class="comment"># windows下为True  linux下为False</span></span><br><span class="line"><span class="built_in">print</span>(fnmatch.fnmatchcase(<span class="string">&quot;A.TXT&quot;</span>,<span class="string">&quot;*.txt&quot;</span>)) <span class="comment"># False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="将将字符串变量变成原始字符串">将将字符串变量变成原始字符串</h3><p>有时候我们希望不要进行转义,就要原始字符串,有两种方法,如果是在定义的时候,可以用r加在前面,如果是一个变量,我们可以用repr函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;\n&#x27;</span> <span class="comment"># 输出换行</span></span><br><span class="line">a = <span class="built_in">repr</span>(a) <span class="comment"># \n</span></span><br><span class="line">a = <span class="string">r&#x27;\n&#x27;</span> <span class="comment"># \n</span></span><br></pre></td></tr></table></figure><h3 id="字符串的替换">字符串的替换</h3><p>有两种方法,一个是字符串自带的replace方法,还有一个就是re模块的sub方法,这个方法比较强大</p><p>replace定义</p><p><img src="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/../img/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7assets/image-20230317144457884.png" alt="image-20230317144457884"></p><p>re.sub函数定义</p><p><img src="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/../img/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7assets/image-20230317144437058.png" alt="image-20230317144437058"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;yeah, but no, but yeah, but no, but yeah&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># replace 默认全部替换,我们也可以限制替换数量</span></span><br><span class="line"><span class="built_in">print</span>(text.replace(<span class="string">&quot;yeah&quot;</span>,<span class="string">&quot;yep&quot;</span>)) <span class="comment"># yep, but no, but yep, but no, but yep</span></span><br><span class="line"><span class="built_in">print</span>(text.replace(<span class="string">&quot;yeah&quot;</span>,<span class="string">&quot;yep&quot;</span>,<span class="number">2</span>)) <span class="comment"># yep, but no, but yep, but no, but yeah</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;now is 3/17/2023, now is 3/17/2023&#x27;</span></span><br><span class="line"><span class="comment"># sub 中的 替换字符串正则表达式可以使用 匹配字符串中的分组</span></span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">r&quot;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;4&#125;)&quot;</span>,<span class="string">r&#x27;\3-\2-\1&#x27;</span>,text)) <span class="comment"># now is 2023-17-3, now is 2023-17-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以指定替换数量</span></span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">r&quot;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;4&#125;)&quot;</span>,<span class="string">r&#x27;\3-\2-\1&#x27;</span>,text,<span class="number">1</span>)) <span class="comment"># now is 2023-17-3, now is 3/17/2023</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果替换逻辑比较复杂,我们也可以用回调函数,函数的参数类型为 re.Match</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">m</span>): </span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;m.group(<span class="number">3</span>)&#125;</span>-<span class="subst">&#123;m.group(<span class="number">2</span>)&#125;</span>-<span class="subst">&#123;m.group(<span class="number">1</span>)&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">r&quot;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;4&#125;)&quot;</span>,func,text)) <span class="comment"># now is 2023-17-3, now is 2023-17-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们还可以用subn获得替换了多少次</span></span><br><span class="line"><span class="built_in">print</span>(re.subn(<span class="string">r&quot;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;4&#125;)&quot;</span>,<span class="string">r&#x27;\3-\2-\1&#x27;</span>,text)) <span class="comment"># (&#x27;now is 2023-17-3, now is 2023-17-3&#x27;, 2)</span></span><br></pre></td></tr></table></figure><h3 id="字符与数字的相互转换">字符与数字的相互转换</h3><p>我们有时候需要使用一个字符的ASCII码对应的数字,也需要将一个数字对应的字符</p><p>使用 ord 可以将一个字符变成数字,  chr可以将数值变成字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">69</span>)) <span class="comment"># E</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;D&#x27;</span>)) <span class="comment"># 68</span></span><br></pre></td></tr></table></figure><h3 id="字符串的拼接">字符串的拼接</h3><p>对于少量的字符串我们可以使用 + 连接起来, 对应很多的字符串拼接我们可以使用 ‘’.join这样会快很多, join方法是将调用者为分割符,连接所有字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">a = <span class="string">&quot;10&quot;</span></span><br><span class="line">b = <span class="string">&quot;20&quot;</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s += a+b</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;+拼接字符串耗时<span class="subst">&#123;end-start&#125;</span>s&quot;</span>) <span class="comment">#1.0576465129852295s</span></span><br><span class="line">start = time.time()</span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line">s = s.join(a+b <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;join拼接字符串耗时<span class="subst">&#123;end-start&#125;</span>s&quot;</span>) <span class="comment"># 0.15259289741516113s</span></span><br></pre></td></tr></table></figure><blockquote><p>当n的不多的时候,两者差不多,当n比较大的时候差距就明显了</p></blockquote><h3 id="字符串与字节的转换">字符串与字节的转换</h3><p>我们在文件操作的时候,通常要用到字符串和字节的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数字-日期-时间">数字 日期 时间</h2><h3 id="浮点数的精确运算">浮点数的精确运算</h3><p>我们都知道,使用float变量计算是肯定有误差的,我们需要使用decimal模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">4.2</span>+<span class="number">2.1</span>) <span class="comment">#6.300000000000001</span></span><br><span class="line"></span><br><span class="line">num = Decimal(<span class="string">&quot;4.2&quot;</span>) + Decimal(<span class="string">&quot;2.1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 6.3</span></span><br></pre></td></tr></table></figure><h3 id="二进制八进制十六进制十进制转化">二进制八进制十六进制十进制转化</h3><p>我们可以将十进制数据变成对应进制的字符串,也可以用int函数将对应的进制字符串变成10进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(x)) <span class="comment">#0b1100100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(x)) <span class="comment">#0o144</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(x)) <span class="comment">#0x64</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(x,<span class="string">&#x27;b&#x27;</span>))<span class="comment">#1100100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(x,<span class="string">&#x27;o&#x27;</span>))<span class="comment">#144</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(x,<span class="string">&#x27;x&#x27;</span>))<span class="comment">#64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0B1111</span>) <span class="comment"># 15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0O1111</span>) <span class="comment"># 585</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0X1111</span>) <span class="comment"># 4396</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;1111&quot;</span>,<span class="number">2</span>)) <span class="comment">#15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;1111&quot;</span>,<span class="number">8</span>)) <span class="comment">#585</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;1111&quot;</span>,<span class="number">16</span>)) <span class="comment">#4396</span></span><br></pre></td></tr></table></figure><h3 id="字节与整数的相互转换">字节与整数的相互转换</h3><p>你有一个字节字符串并想将它解压成一个整数。或者，你需要将一个大整数转换为一个字节字符串。</p><p>调用整数提供的方法</p><p><img src="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/../img/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7assets/image-20230317163713939.png" alt="image-20230317163713939"></p><p><img src="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/../img/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7assets/image-20230317163901939.png" alt="image-20230317163901939"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a =-<span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.to_bytes(<span class="number">4</span>,<span class="string">&quot;big&quot;</span>,signed=<span class="literal">True</span>)) <span class="comment"># b&#x27;\xff\xff\xff\x80&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.from_bytes(<span class="string">b&#x27;\xff\xff\xff\x80\x80&#x27;</span>,<span class="string">&quot;big&quot;</span>,signed=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><blockquote><p>我们可以通过bit_length() 来获得需要的字节数量</p></blockquote><h3 id="无穷大和nan">无穷大和NaN</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nan = <span class="built_in">float</span>(<span class="string">&quot;Nan&quot;</span>)</span><br><span class="line">inf = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)  <span class="comment"># 大小写无所谓</span></span><br><span class="line">finf = <span class="built_in">float</span>(<span class="string">&quot;-inF&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(nan)</span><br><span class="line"><span class="built_in">print</span>(inf)</span><br><span class="line"><span class="built_in">print</span>(finf)</span><br></pre></td></tr></table></figure><p>无穷大数在执行数学计算的时候会传播</p><p>NaN值会在所有操作中传播，而不会产生异常</p><p>NaN值的一个特别的地方时它们之间的比较操作总是返回False</p><p>测试一个NaN值得唯一安全的方法就是使用 <code>math.isnan()</code></p><h3 id="大型数组运算">大型数组运算</h3><p>当我们有大量的数组数据需要计算的时候,我们可以用Numpy这个库,这个库比我们用循环快很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment">#&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a+<span class="number">10</span>) <span class="comment">#[11 20 13 14 15]</span></span><br><span class="line"><span class="comment"># 注意和列表的区别</span></span><br><span class="line"><span class="built_in">print</span>(a*<span class="number">2</span>) <span class="comment"># [ 2 20  6  8 10]</span></span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">a = np.array(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,<span class="number">1</span>]) <span class="comment"># 这里也是numpy独有的  5</span></span><br></pre></td></tr></table></figure><blockquote><p>numpy有很多厉害的功能,这里就不介绍了,上面这些都只是数组的运算,而不是矩阵的运算,我们得用matrix去产生矩阵</p></blockquote><h3 id="随机选择">随机选择</h3><p>从一个序列中随机抽取若干元素，或者想生成几个随机数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选一个</span></span><br><span class="line"><span class="built_in">print</span>(random.choice(a))</span><br><span class="line"><span class="comment"># 随机选多个,可以包含位置的数</span></span><br><span class="line"><span class="built_in">print</span>(random.choices(a,k=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 随机选出多个不同位置的数,注意是位置,如果列表中的数不同,选出来的数肯定也不相同</span></span><br><span class="line"><span class="built_in">print</span>(random.sample(a,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 打乱顺序</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 随机产生一个[a,b]之间的整数</span></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"><span class="comment"># 随机产生一个[0,1)的小数</span></span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br></pre></td></tr></table></figure><h3 id="日期与时间的转换">日期与时间的转换</h3><p>有时候需要得到时间信息,以及时间之间的转换,我们可以用datetime模块,这个模块可以自己处理闰年</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># timedelta代表的是一个时间段,可以设置天数,小时,分钟,秒,毫秒,微秒  小时会被转化成秒,微秒会转化成秒</span></span><br><span class="line">fivedays = datetime.timedelta(days=<span class="number">5</span>)</span><br><span class="line">tendays = <span class="number">2</span>*fivedays  <span class="comment"># 可以执行基本运算</span></span><br><span class="line"><span class="built_in">print</span>(tendays.days)  <span class="comment"># 得到天数 10</span></span><br><span class="line"><span class="built_in">print</span>(tendays.seconds) <span class="comment"># 0s</span></span><br><span class="line"><span class="built_in">print</span>(tendays.total_seconds())  <span class="comment"># 得到全部秒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日期的运算</span></span><br><span class="line">datea = datetime.datetime(<span class="number">2002</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">dateb = datetime.datetime(<span class="number">2001</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算结果是一个时间段,a-b 和 b-a结果一样</span></span><br><span class="line">subdate = dateb-datea</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((datea-dateb).days) <span class="comment"># 相差了 365天</span></span><br><span class="line"><span class="built_in">print</span>((datea-dateb).seconds) <span class="comment"># 0s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># adddate = datea + dateb 日期与日期不支持加法</span></span><br><span class="line"></span><br><span class="line">datec = datea + fivedays   <span class="comment">#  日期与时间段支持加法</span></span><br><span class="line"><span class="built_in">print</span>(datec)   <span class="comment"># 2002-4-10</span></span><br><span class="line"></span><br><span class="line">datec = datetime.datetime(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datec.year)</span><br><span class="line"><span class="built_in">print</span>(datec.month)</span><br><span class="line"><span class="built_in">print</span>(datec.day)</span><br><span class="line"><span class="built_in">print</span>(datec.weekday())  <span class="comment"># 从0开始的 0代表星期一</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算上个周五的日期</span></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">prefive = now-datetime.timedelta(<span class="number">7</span>-(now.weekday()-<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(prefive.date())</span><br></pre></td></tr></table></figure><blockquote><p>如果涉及大量的日期时间计算,推荐使用第三方包,calendar是用来打印日历这些的</p></blockquote><h2 id="迭代器和生成器">迭代器和生成器</h2><h3 id="使用生成器代替迭代器">使用生成器代替迭代器</h3><p>如果用迭代器的话,我们需要自己去维护很多状态,而使用生成器,就方便很多了,它会自己保存好局部变量</p><p>我们来对比一下吧</p><h4 id="自己实现迭代器">自己实现迭代器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setleft</span>(<span class="params">self,node</span>):</span><br><span class="line">        self.left = node</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setright</span>(<span class="params">self,node</span>):</span><br><span class="line">        self.right = node</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> helpIterator(self)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;node(<span class="subst">&#123;self._value&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">helpIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,node</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.node = node</span><br><span class="line">        self.leftiter = <span class="literal">None</span></span><br><span class="line">        self.rightiter = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">if</span> self.leftiter <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.leftiter = <span class="built_in">iter</span>(helpIterator(self.node.left))</span><br><span class="line">            <span class="keyword">return</span> self.node</span><br><span class="line">        <span class="keyword">elif</span> self.rightiter <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = <span class="built_in">next</span>(self.leftiter)</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> s:</span><br><span class="line">                self.rightiter = <span class="built_in">iter</span>(helpIterator(self.node.right))</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">next</span>(self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span>(self.rightiter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Node(<span class="number">10</span>)</span><br><span class="line">root.setleft(Node(<span class="number">11</span>))</span><br><span class="line">root.setright(Node(<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> root:</span><br><span class="line">    <span class="built_in">print</span>(val)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用生成器生成迭代器">使用生成器生成迭代器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setleft</span>(<span class="params">self,node</span>):</span><br><span class="line">        self.left = node</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setright</span>(<span class="params">self,node</span>):</span><br><span class="line">        self.right = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line">        <span class="keyword">if</span> self.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">iter</span>(self.left)</span><br><span class="line">        <span class="keyword">if</span> self.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">iter</span>(self.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;node(<span class="subst">&#123;self._value&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">root = Node(<span class="number">10</span>)</span><br><span class="line">left = Node(<span class="number">11</span>)</span><br><span class="line">right = Node(<span class="number">14</span>)</span><br><span class="line">root.setleft(left)</span><br><span class="line">root.setright(right)</span><br><span class="line">left.setleft(Node(<span class="number">12</span>))</span><br><span class="line">left.setright(Node(<span class="number">13</span>))</span><br><span class="line">right.setleft(Node(<span class="number">15</span>))</span><br><span class="line">right.setright(Node(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> root:</span><br><span class="line">    <span class="built_in">print</span>(val)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>对比一下,真是节省了不少代码啊,太牛了</p></blockquote><h3 id="反向迭代">反向迭代</h3><p>反向迭代必须实现__reversed()__方法,它的返回值也必须是一个具有__next()__方法的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reversed__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(test())))</span><br></pre></td></tr></table></figure><h3 id="itertools">itertools</h3><h4 id="islice">islice</h4><p>我们可能只需要迭代器的一部分数据,那么我们可以使用itertools.islice方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testiter</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">it = testiter()</span><br><span class="line"><span class="comment"># 它的用法跟range差不多</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.islice(it,<span class="number">10</span>,<span class="number">20</span>))) <span class="comment">#[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span></span><br></pre></td></tr></table></figure><h4 id="dropwhile">dropwhile</h4><p>跳过某些符合要求的的数据直到一个不符合要求的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testiter</span>():</span><br><span class="line">   a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">   <span class="keyword">yield</span> <span class="keyword">from</span> a</span><br><span class="line"></span><br><span class="line">it = testiter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当数据小于5的时候就丢弃</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.dropwhile(<span class="keyword">lambda</span> x:x&lt;<span class="number">5</span>,it))) <span class="comment"># [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span></span><br></pre></td></tr></table></figure><h4 id="排列与组合">排列与组合</h4><p>permutations 可以进行排列  combinations可以进行组合</p><p><img src="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/../img/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7assets/image-20230318144612500.png" alt="image-20230318144612500"></p><p>​<img src="/2023/03/14/python/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/../img/python%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7assets/image-20230318144807813.png" alt="image-20230318144807813"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取前N个数据进行排列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(l,<span class="number">3</span>): </span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 返回的是一个元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取N个数据进行组合,N个数据不能选取同一个位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.combinations(l,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取N个数据进行组合,N个数据能选取同一个位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.combinations_with_replacement(l,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>要注意他们的区别哦   另外如果元素里面有相同的数据,使用这个方法得到的结果并不正确</p></blockquote><h3 id="迭代索引">迭代索引</h3><p>我们发现使用迭代器并没有记录我们当前是第几个,如果我们需要索引可以使用enumerate函数,这个函数使用起来就很优雅了,我们不需要额外定义一个变量去计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> index,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(<span class="number">10</span>,<span class="number">0</span>,-<span class="number">1</span>),<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;index&#125;</span>个数:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 第1个数:10</span></span><br><span class="line"><span class="comment"># 第2个数:9</span></span><br><span class="line"><span class="comment"># 第3个数:8</span></span><br><span class="line"><span class="comment"># 第4个数:7</span></span><br><span class="line"><span class="comment"># 第5个数:6</span></span><br><span class="line"><span class="comment"># 第6个数:5</span></span><br><span class="line"><span class="comment"># 第7个数:4</span></span><br><span class="line"><span class="comment"># 第8个数:3</span></span><br><span class="line"><span class="comment"># 第9个数:2</span></span><br><span class="line"><span class="comment"># 第10个数:1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="同时迭代多个序列">同时迭代多个序列</h3><p>我们可以使用zip函数同时迭代多个序列,但是迭代次数以最短的为主</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">10</span>),<span class="built_in">range</span>(<span class="number">11</span>,<span class="number">0</span>,-<span class="number">1</span>)):</span><br><span class="line">    <span class="built_in">print</span>((i,j))</span><br><span class="line"></span><br><span class="line"><span class="comment"># (0, 11)</span></span><br><span class="line"><span class="comment"># (1, 10)</span></span><br><span class="line"><span class="comment"># (2, 9)</span></span><br><span class="line"><span class="comment"># (3, 8)</span></span><br><span class="line"><span class="comment"># (4, 7)</span></span><br><span class="line"><span class="comment"># (5, 6)</span></span><br><span class="line"><span class="comment"># (6, 5)</span></span><br><span class="line"><span class="comment"># (7, 4)</span></span><br><span class="line"><span class="comment"># (8, 3)</span></span><br><span class="line"><span class="comment"># (9, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要最长的为主的话</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> itertools.zip_longest(<span class="built_in">range</span>(<span class="number">10</span>),<span class="built_in">range</span>(<span class="number">11</span>,<span class="number">0</span>,-<span class="number">1</span>)):</span><br><span class="line"><span class="built_in">print</span>((i,j))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># (0, 11)</span></span><br><span class="line"><span class="comment"># (1, 10)</span></span><br><span class="line"><span class="comment"># (2, 9)</span></span><br><span class="line"><span class="comment"># (3, 8)</span></span><br><span class="line"><span class="comment"># (4, 7)</span></span><br><span class="line"><span class="comment"># (5, 6)</span></span><br><span class="line"><span class="comment"># (6, 5)</span></span><br><span class="line"><span class="comment"># (7, 4)</span></span><br><span class="line"><span class="comment"># (8, 3)</span></span><br><span class="line"><span class="comment"># (9, 2)</span></span><br><span class="line"><span class="comment"># (None, 1)</span></span><br></pre></td></tr></table></figure><h3 id="连续迭代不同集合">连续迭代不同集合</h3><p>如果我们对不同的集合里面的数据有相同操作,我平时肯定是写两段相同的代码,或者是拼接起来,这样都不是最好的选择,我们可以使用chain</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环求和</span></span><br><span class="line">sums = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    sums += i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    sums += i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用加法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(a+b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用chain</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(itertools.chain(a,b)))</span><br></pre></td></tr></table></figure><blockquote><p>chain 比加法要快,而且使用加法对于集合,有时候可不是那么友好,毕竟有去重功能</p></blockquote><h3 id="按顺序连续迭代不同序列">按顺序连续迭代不同序列</h3><p>如果我们有两个序列,他们都是有序的,但是我们想将他们合并然后使用,如果让我们自己来,肯定还要判断大小,我们不妨使用heapq.merge</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(heapq.merge(a,b))) <span class="comment"># [1, 2, 3, 4, 6, 8, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure><h3 id="使用迭代器代替while">使用迭代器代替while</h3><p>使用iter函数,如果所给参数不是一个可迭代对象而是一个函数的话,那么会一直调用这个函数,直到返回值满足要求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据输入求和,直到输入quit</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">iter</span>(<span class="built_in">input</span>,<span class="string">&quot;quit&quot;</span>))))</span><br></pre></td></tr></table></figure><h2 id="文件与io">文件与io</h2><blockquote><p>其实对于文件读写的文本模式与二进制模式, 文本模式只能写入字符串, 二进制模式只能写入字节,  其实本质没有什么区别,都是写入01数据, 之所以二进制模式会乱码是因为我们写入了多字节数据,比如整数 ,文本编辑器打开的时候将这些多个字节拆分来译码,那当然就会造成乱码了,如果我们只写写入字符串,无论哪种模式,只要跟文本编辑器的编码一样,那就都不会乱码</p></blockquote><h3 id="输出重定向">输出重定向</h3><p>我们可以将print的输出内容写入到文件里面去,必须是文本模式,如果是二进制模式的话,会出错,因为文本模式与二进制模式打开的文件对象不是一样的,他们的写入方法需要的参数有区别,一个是字符串,一个是字节数据,而print只能传递字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;wt&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(a,file=f)</span><br></pre></td></tr></table></figure><h3 id="模拟文件io">模拟文件io</h3><p>我们可以通过 io 模块的StringIO 和 BytesIO 来模拟文件IO,在一些单元测试中用得着</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">files = io.StringIO(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(files.read())</span><br><span class="line"></span><br><span class="line">fileb = io.BytesIO(<span class="string">b&#x27;hello world&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(fileb.read())</span><br></pre></td></tr></table></figure><h3 id="读写压缩文件">读写压缩文件</h3><p>导入相应的模块就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(<span class="string">&quot;test.gz&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">b&quot;12345&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="os中相关的函数">os中相关的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">filepath = <span class="string">r&quot;C:\Users\asus\Desktop\hexoblog\source\_posts\python\代码文件\python实用技巧\迭代器跟生成器\ostest.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.path.basename(filepath)) <span class="comment"># 文件名字 ostest.py</span></span><br><span class="line"><span class="built_in">print</span>(os.path.dirname(filepath))  <span class="comment"># 目录名字</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isabs(filepath))    <span class="comment"># 是否是绝对路径  True</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isdir(filepath))    <span class="comment"># 是否是目录 False</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(filepath))   <span class="comment"># 是否是文件 True</span></span><br><span class="line"><span class="built_in">print</span>(os.path.islink(filepath))   <span class="comment"># 是否是链接文件 False</span></span><br><span class="line"><span class="built_in">print</span>(os.path.ismount(filepath))  <span class="comment"># 是否是挂载文件 False</span></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(filepath))   <span class="comment"># 文件是否存在  True</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getsize(filepath))  <span class="comment"># 文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strftime</span>(<span class="params">seconds</span>):</span><br><span class="line">    <span class="keyword">return</span> time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,time.localtime(seconds))</span><br><span class="line"><span class="built_in">print</span>(strftime(os.path.getatime(filepath)))  <span class="comment"># 上一次文件访问时间</span></span><br><span class="line"><span class="built_in">print</span>(strftime(os.path.getmtime(filepath)))  <span class="comment"># 上一次文件修改时间</span></span><br><span class="line"><span class="built_in">print</span>(strftime(os.path.getctime(filepath)))  <span class="comment"># 上一次文件元信息修改时间 比如文件名字更改 文件权限变化</span></span><br></pre></td></tr></table></figure><ol><li><code>os.rename(src, dst)</code>：重命名文件或目录，将src改名为dst。</li><li><code>os.stat(path)</code>：获取指定路径的文件或目录的状态信息。</li><li><code>os.access(path, mode)</code>：检查指定路径的文件或目录是否有指定的权限。</li><li><code>os.chmod(path, mode)</code>：修改指定路径的文件或目录的权限。</li><li><code>os.utime(path, times)</code>：修改指定路径的文件或目录的访问和修改时间。</li><li><code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code>：遍历指定目录及其子目录中的所有文件和目录。</li><li><code>os.environ</code>：一个包含环境变量的字典对象。</li><li><code>os.getenv(var)</code>：获取指定环境变量的值。</li><li><code>os.putenv(var, value)</code>：设置指定环境变量的值。</li><li><code>os.system(command)</code>：在命令行上执行指定的命令。</li><li><code>os.startfile(path)</code>：使用关联程序打开指定的文件。</li><li><code>os.popen(command[, mode[, bufsize]])</code>：打开一个管道用于读取命令的输出。</li><li><code>os.pipe()</code>：创建一个管道并返回两个文件描述符，一个用于读取，一个用于写入。</li><li><code>os.dup(fd)</code>：复制文件描述符。</li><li><code>os.execl(path, arg0, arg1, ..., argN)</code>：替换当前进程的映像，使用指定的可执行文件。</li><li><code>os.abort()</code>：生成异常，中止当前进程。</li><li><code>os.kill(pid, signal)</code>：发送指定的信号给进程。</li><li><code>os.waitpid(pid, options)</code>：等待指定的子进程结束并返回其状态。</li><li><code>os.getpid()</code>：获取当前进程的ID。</li><li><code>os.getppid()</code>：获取当前进程的父进程ID。</li><li><code>os.getuid()</code>：获取当前进程的用户ID。</li><li><code>os.getgid()</code>：获取当前进程的组ID。</li><li><code>os.setuid(uid)</code>：设置当前进程的用户ID。</li><li><code>os.setgid(gid)</code>：设置当前进程的组ID。</li><li><code>os.system()</code>：在新进程中执行系统命令。</li><li><code>os.times()</code>：获取当前进程的CPU时间和系统时间等信息。</li><li><code>os.cpu_count()</code>：获取当前系统的CPU核心数。</li><li><code>os.listdir(path)</code>：返回指定目录下的文件和目录列表。</li><li><code>os.link(src, dst)</code>：创建指向现有文件的硬链接。</li><li><code>os.symlink(src, dst)</code>：创建指向现有文件的符号链接。</li></ol><h2 id="元编程">元编程</h2><h3 id="让装饰器保留函数元信息">让装饰器保留函数元信息</h3><p>普通的装饰器并不会保留函数的元信息,比如name doc 这些,我们可以使用functools里面的wraps装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwds</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;func&#125;</span>被调用&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwds)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b</span>):</span><br><span class="line">   a-=<span class="number">1</span></span><br><span class="line">   b-=<span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func.__name__)  <span class="comment"># 如果不使用wraps会输出wrapper,使用wraps会输出func</span></span><br></pre></td></tr></table></figure><blockquote><p>如果使用了wraps, 我们还可以通过 func.__wrapped__得到原始函数</p></blockquote><h3 id="属性描述符">属性描述符</h3><p>既然是属性描述符,它当然是描述一个属性, 而且这个属性必须是<strong>类的属性</strong>,有了属性描述符,我们就可以对这个属性进行限制,检查</p><p>如果一个类实现了__get__ 方法,他就是一个属性描述符,比如一个function类,属性描述符只有在类或者对象通过点的方式去调用才会生效</p><p>因此我们可以解释为什么对象调用方法不用写self参数, function对象就是一个属性描述符,  它会帮我们执行的时候自动加入self参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">t = test()</span><br><span class="line"><span class="built_in">print</span>(t.hello,test.hello,sep=<span class="string">&quot;\n&quot;</span>) </span><br><span class="line"><span class="comment"># &lt;bound method test.hello of &lt;__main__.test object at 0x00000236D2D2E4C0&gt;&gt;</span></span><br><span class="line"><span class="comment"># &lt;function test.hello at 0x00000236D2D81700&gt;</span></span><br></pre></td></tr></table></figure><p>我们发现这两个方法并不一样,这是因为在function 里面的 get方法返回的值不一样导致的</p><h2 id="包和模块">包和模块</h2><h3 id="运行目录或者压缩文件">运行目录或者压缩文件</h3><p>如果我们在目录中定义了__main__文件的话,我们就可以使用 python 目录名字 这样的方式运行目录 , 如果我们的压缩包也包含__main__文件的话,我们也可以直接使用 python 压缩包的方式运行</p>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程快速上手 总结</title>
      <link href="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
      <url>/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>编程是一项创造性任务</p></blockquote><h1>前言</h1><blockquote><p>程序开发要学会 <strong>站在巨人的肩膀上</strong> 。动手写代码前，先调研一番，看是否有现成的解决方案。 <strong>切忌重复造轮子</strong> ，浪费时间不说，可能代码质量还差，效果也不好。</p></blockquote><p>这个是基于python 3.8 总结的</p><p>在 <em>Python</em> 中，一切皆对象，基本数据类型也是如此</p><h1>第一部分 python 基础</h1><h2 id="基本运算符">基本运算符</h2><blockquote><p>这里介绍python独特的运算符</p></blockquote><h3 id="算数运算符">算数运算符</h3><table><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>*</td><td>数字相乘求积,字符串,列表这些跟整数相乘是复制</td></tr><tr><td>**</td><td>指数</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>//</td><td>除法取整,但是<strong>结果的数据类型是两个操作数中表示范围最大的一个的数据类型</strong></td></tr><tr><td>+</td><td>字符串,列表这些加法拼接,数字加法求和</td></tr></tbody></table><blockquote><p>整数如果在数值上与浮点数是相同的,用==比较时,他们就是相同的,不用管浮点数误差问题</p><p>记住python 没有 ++ --这种操作符</p></blockquote><h2 id="逻辑运算符">逻辑运算符</h2><table><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>and</td><td>两边表达式都为真才返回真</td></tr><tr><td>or</td><td>两边表达式有一边为真就返回真</td></tr><tr><td>not</td><td>返回表达式的相反情况</td></tr></tbody></table><h2 id="特殊运算符">特殊运算符</h2><table><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>in</td><td>判断前面这个对象是否存在后面的对象中</td></tr><tr><td>not in</td><td>自然是in的相反</td></tr><tr><td>is</td><td>判断地址值是否相同</td></tr><tr><td>==</td><td>通过调用__eq__方法得到结果</td></tr></tbody></table><p>三元运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>( <span class="number">1</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="number">10</span>)  <span class="comment"># 如果flag 为 True则返回 1否则返回 10</span></span><br></pre></td></tr></table></figure><p>只有0 空字符串 和 None 还有 nan 为False</p><h2 id="常用函数">常用函数</h2><table><thead><tr><th>函数名</th><th>操作</th></tr></thead><tbody><tr><td>str()</td><td>将其他数据类型变成字符串</td></tr><tr><td>int()</td><td>将其他数据类型变成整数</td></tr><tr><td>float()</td><td>将其他数据类型变成浮点数</td></tr><tr><td>list()</td><td>将其他可迭代数据(字符串,元组)变成列表</td></tr><tr><td>tuple()</td><td>将其他可迭代数据(字符串,列表)变成元组</td></tr><tr><td>set()</td><td>将其他可迭代数据(字符串,列表)变成集合</td></tr><tr><td>range(start,stop,step)</td><td>产生一个序列 [ start,stop), 步长为step</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="代码块">代码块</h2><blockquote><p>代码块就是出于同一个块里面的代码,他们要么一起执行,要么都不执行</p></blockquote><p>在python中 以缩进表示一个代码块, 相同缩进的且所有父代码都相同代码是处于同一个代码块的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= b:</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 代码块1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(b)  <span class="comment"># 代码块2</span></span><br><span class="line"><span class="comment">#虽然他们 有着相同的缩进,但是父代码不同</span></span><br></pre></td></tr></table></figure><h2 id="控制流语句">控制流语句</h2><h3 id="if">if</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> :</span><br><span class="line"><span class="keyword">elif</span> :</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="while">while</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true:</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="for">for</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这个for 要特别注意,它和c++,java 这些里面的for不同,这里的for <strong>只能用来遍历后面的数据,里面用的是迭代器</strong></p></blockquote><h2 id="包和模块">包和模块</h2><h3 id="模块">模块</h3><p><a href="http://xn--4gqvd7y.py">一个以.py</a> 结尾的文件就是一个模块,模块让你能够有逻辑地组织你的 Python 代码段，把相关的代码分配到一个模块里能让你的代码更好用，更易懂</p><p>模块需要注意的是 __ name__ 这个属性, 当我们执行的是这个模块的时候,它的值  是 __ main__ 如果是被导入的时候 那就是 模块名</p><h4 id="导入模块">导入模块</h4><p>import 模块名</p><p>import 用于导入某个模块</p><p>from  import 用于导入某个模块的某些东西</p><p>import  a.b as b = from a import b</p><p>上面都是绝对路径,还有相对路径的</p><p>import .a  导入当前模块下的a</p><p>import …a  导入上层模块下的a</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> r</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当你导入模块的时候，Python解释器会把模块的代码编译成字节码，并放入 <code>__pycache__</code>文件夹中。这样以后再次运行的话，如果被调用的模块未发生改变，那就直接跳过编译这一步，直接去<code>__pycache__</code>文件夹中去运行相关的 *.pyc 文件，大大缩短了项目运行前的准备时间。</p><h3 id="包">包</h3><p>在早一点的 Python 版本（Python 3.3 之前）中，如果一个文件夹下有一个 <strong><code>__init__.py</code></strong> 文件，那我们就称之为包，英文名 Package。</p><p>在后来的 Python 版本（Python 3.3 开始）中，就没有这个要求了，<strong>只要是文件夹就可以当做包</strong>，我们称之为空间命名包，为做区分，我把上面那种包称之为 传统包。</p><p>今天这节里主要讲讲传统包的内容。</p><p>传统包里的 <code>__init__.py</code> 可以为空文件，但一定要有该文件，它是包的标志性文件，在需要情况下可以在里面进行一些包的初始化工作。</p><p>一个包里可以有多个模块，比如一个 demo 包包含<code>foo.py</code> 和 <code>bar.py</code>,那么在引用的时候就需要:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> demo.foo</span><br><span class="line"><span class="keyword">import</span> demo.bar</span><br></pre></td></tr></table></figure><h3 id="库">库</h3><p>Python 库是指一定功能的代码集合，通常认为他是一个完整的项目打包。</p><p>库-&gt;包-&gt;模块，是从大到小的层级关系！</p><ul><li>库：一个库可能由多个包和模块组成</li><li>包：一个包可能由多个模块组成</li><li>模块：一堆函数、类、变量的集合</li></ul><h3 id="小结">小结</h3><p>from module import * 这样的导入将会导入所有不以下划线开头的东西, 如果我们在模块里面声明了 __all__ 的话,则只会导入这里面包含的东西</p><h2 id="列表">列表</h2><p>列表就是一些数据的集合,他可以使用负数作为下标访问,也可以使用切片,s[a:b] = [s[a],…s[b-1]] ,这些切片都是浅拷贝出来的,字符串,元组也有这些特性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">s[-<span class="number">1</span>] <span class="comment"># 3</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">1</span>] <span class="comment"># [1]</span></span><br><span class="line">s[<span class="number">0</span>:-<span class="number">1</span>] <span class="comment">#[1,2]</span></span><br><span class="line">s[:] <span class="comment"># [1,2,3]</span></span><br><span class="line">s[<span class="number">0</span>:] <span class="comment"># [1,2,3]</span></span><br><span class="line">s[:<span class="number">1</span>] <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305185214450.png" alt="image-20230305185214450"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305185233509.png" alt="image-20230305185233509"></p><h2 id="元组">元组</h2><p>元组用()把数据包起来,而且如果数据只有一个的时候,我们必须以逗号结尾,不然python会以为我们是一个数据带了个括号而已</p><p>元组是Python中的不可变序列，它有以下几个方法：</p><ol><li><code>count(x)</code>：返回元组中出现x的次数。</li><li><code>index(x)</code>：返回元组中第一次出现x的位置。</li></ol><p>因为元组是不可变序列，所以它没有像列表那样的方法来添加、删除或修改元素</p><p>我们可以使用切片来做一些转化,比如翻转元组   a[::-1]</p><h2 id="集合">集合</h2><p>集合是一种无序、不重复的数据结构，集合中的元素必须是可哈希的。下面是一些常用的集合方法：</p><ol><li><code>add(elem)</code>：向集合中添加一个元素。</li><li><code>clear()</code>：清空集合中的所有元素。</li><li><code>copy()</code>：返回集合的一个浅拷贝。</li><li><code>difference(*others)</code>：返回集合与其他一个或多个集合的差集。</li><li><code>difference_update(*others)</code>：移除集合中与其他一个或多个集合重叠的元素。</li><li><code>discard(elem)</code>：移除集合中指定元素。如果元素不存在，不会发生任何变化。</li><li><code>intersection(*others)</code>：返回集合与其他一个或多个集合的交集。</li><li><code>intersection_update(*others)</code>：修改集合，使其只包含与其他一个或多个集合相同的元素。</li><li><code>isdisjoint(other)</code>：如果集合与另一个集合没有交集，返回True，否则返回False。</li><li><code>issubset(other)</code>：如果集合是另一个集合的子集，返回True，否则返回False。</li><li><code>issuperset(other)</code>：如果集合是另一个集合的超集，返回True，否则返回False。</li><li><code>pop()</code>：移除并返回集合中的任意一个元素。如果集合为空，会引发KeyError异常。</li><li><code>remove(elem)</code>：移除集合中指定元素。如果元素不存在，会引发KeyError异常。</li><li><code>symmetric_difference(other)</code>：返回集合与另一个集合的对称差集。</li><li><code>symmetric_difference_update(other)</code>：修改集合，使其只包含与另一个集合不相同的元素。</li><li><code>union(*others)</code>：返回集合与其他一个或多个集合的并集。</li><li><code>update(*others)</code>：将其他一个或多个集合中的元素添加到集合中。</li></ol><p>这些方法可以让我们方便地对集合进行操作，例如合并两个集合、求两个集合的交集或差集等。同时，集合也支持使用<code>len()</code>函数获取集合的大小，以及使用<code>in</code>和<code>not in</code>关键字来检查集合中是否包含某个元素。</p><h2 id="字典">字典</h2><p>一个键对应一个值,跟c++里面的map一样,字典不是连续摆放键值对的,因此无法像列表那样使用切片</p><p><strong>创建空字典的方式是使用 {}</strong></p><p>Python中的字典是一种无序的键值对数据结构，下面是一些常用的字典方法：</p><ol><li><code>clear()</code>：清空字典中的所有元素。</li><li><code>copy()</code>：返回字典的一个浅拷贝。</li><li><code>fromkeys(seq[, value])</code>：创建一个新字典，使用给定的序列作为键，可选的给定值作为值。</li><li><code>get(key[, default])</code>：返回字典中给定键的值。如果键不存在，则返回指定的默认值。</li><li><code>items()</code>：返回一个包含所有字典项的列表，每个元素是一个(key, value)的元组。</li><li><code>keys()</code>：返回一个包含所有字典键的列表。</li><li><code>pop(key[, default])</code>：如果键存在，则移除并返回指定键的值，否则返回指定的默认值。</li><li><code>popitem()</code>：移除并返回字典中的一项，以 (key, value) 的形式返回。如果字典为空，则引发 KeyError 异常。</li><li><code>setdefault(key[, default])</code>：如果键存在，则返回对应的值；如果不存在，则将键插入字典中，并返回给定的默认值（默认为 None）。</li><li><code>update([other])</code>：使用另一个字典或可迭代对象中的键值对更新字典。</li><li><code>values()</code>：返回一个包含所有字典值的列表。</li></ol><p>这些方法可以让我们方便地对字典进行操作，例如获取某个键的值、添加或删除键值对、获取字典中的所有键或值等。除此之外，字典也支持使用<code>len()</code>函数获取字典的大小，以及使用<code>in</code>和<code>not in</code>关键字来检查字典中是否包含某个键。</p><h3 id="in-字典和-in-keys-的区别">in 字典和 in keys()的区别</h3><p>对于字典来说，<code>in</code>运算符可以用来判断一个键（key）是否在字典中存在。当我们使用<code>in</code>运算符来检查一个键是否在字典中时，可以直接使用<code>in</code>后面跟上字典对象，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line">print(&#x27;a&#x27; in d)    # 输出 True</span><br><span class="line">print(&#x27;d&#x27; in d)    # 输出 False</span><br></pre></td></tr></table></figure><p>也可以使用<code>in</code>后面跟上字典的<code>keys()</code>方法，来判断一个键是否在字典中存在，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bashCopy coded = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line">print(&#x27;a&#x27; in d.keys())    # 输出 True</span><br><span class="line">print(&#x27;d&#x27; in d.keys())    # 输出 False</span><br></pre></td></tr></table></figure><p>这两种方式本质上是一样的，都是在字典中查找指定的键，判断其是否存在。但是从效率上来看，<strong>直接使用<code>in</code>运算符来判断键是否存在更加高效</strong>，<strong>因为它会利用字典内部的哈希表（hash table）,也就是set集合,算法来快速查找键</strong>，而使用<code>keys()</code>方法会先创建一个键的列表，再进行查找，效率会相对低一些。</p><p>因此，<strong>如果只是判断一个键是否存在</strong>，建议直接使用<code>in</code>运算符；<strong>如果需要遍历字典的所有键，可以使用<code>keys()</code>方法获取所有的键</strong>，并进行遍历。</p><blockquote><p>如果是 in items() 的话和 in keys() 差别不大</p></blockquote><h2 id="字符串">字符串</h2><p>字符串可以用单引号,双引号,三引号包裹,前两个没有什么区别,第三个可以用来表示注释,也可以换行写字符串,对于那些有很多行的字符串,我们可以使用三引号包裹,如果字符串里面有引号的话,需要使用转义字符 \ 来转义,或者使用原始字符串的格式 r’’</p><p>Python字符串是一种不可变的序列类型，字符串对象有许多内置方法，下面列出一些常用的字符串方法：</p><ol><li><code>capitalize()</code>：将字符串的第一个字符转换为大写字母，其他字符转换为小写字母。</li><li><code>casefold()</code>：将字符串转换为小写并删除所有标点符号和空格，用于忽略大小写的比较。</li><li><code>center(width[, fillchar])</code>：返回一个指定宽度的字符串，原字符串居中，并使用指定的字符（默认为空格）在两侧进行填充。</li><li><code>count(sub[, start[, end]])</code>：<strong>返回指定子字符串在字符串中出现的次数</strong>。</li><li><code>endswith(suffix[, start[, end]])</code>：检查字符串是否以指定的后缀结尾，返回True或False。</li><li><code>find(sub[, start[, end]])</code>：<strong>在字符串中查找指定子字符串的第一次出现，返回索引值，未找到则返回-1</strong>。</li><li><code>index(sub[, start[, end]])</code>：在字符串中查找指定子字符串的第一次出现，返回索引值，未找到则引发ValueError异常。</li><li><code>isalnum()</code>：检查字符串是否只包含字母和数字，返回True或False。</li><li><code>isalpha()</code>：检查字符串是否只包含字母，返回True或False。</li><li><code>isdigit()</code>：检查字符串是否只包含数字，返回True或False。</li><li><code>islower()</code>：检查字符串中所有字母是否都是小写，返回True或False。</li><li><code>isspace()</code>：检查字符串是否只包含空格，返回True或False。</li><li><code>istitle()</code>：检查字符串中每个单词的首字母是否都是大写，返回True或False。</li><li><code>isupper()</code>：检查字符串中所有字母是否都是大写，返回True或False。</li><li><code>join(iterable)</code>：<strong>将可迭代对象中的所有字符串拼接成一个字符串，使用当前字符串作为分隔符</strong>。</li><li><code>lstrip([chars])</code>：返回去掉左侧指定字符（默认为空格）的字符串。</li><li><code>replace(old, new[, count])</code>：返回将指定旧子字符串替换为新子字符串的字符串，可指定替换次数。</li><li><code>rstrip([chars])</code>：返回去掉右侧指定字符（默认为空格）的字符串。</li><li><code>split([sep[, maxsplit]])</code>：<strong>将字符串以指定分隔符（默认为空格）分割成多个子字符串，并返回一个列表</strong>。</li><li><code>startswith(prefix[, start[, end]])</code>：检查字符串是否以指定的前缀开头，返回True或False。</li><li><code>strip([chars])</code>：返回去掉左右两侧指定字符（默认为空格）的字符串。</li><li><code>title()</code>：返回所有单词的首字母大写的字符串。</li><li><code>upper()</code>：将字符串中所有字母转换为大写。</li><li><code>lower()</code>：将字符串中所有字母转换为小写。</li></ol><h2 id="可变数据与不可变数据">可变数据与不可变数据</h2><p>在Python中，可变（mutable）<strong>对象指的是可以修改其内部状态的对象</strong>，例如列表、字典和集合等。而不<strong>可变（immutable）对象指的是不能修改其内部状态的对象</strong>，例如数字、字符串和元组等。</p><p>对于可变对象，我们可以通过修改对象的内部状态来改变对象本身，例如向列表中添加或删除元素、修改字典中的键值对等。而对于不可变对象，我们不能修改对象的内部状态，但是可以通过创建新的对象来代替原有对象，从而实现对象的修改。</p><p>需要注意的是，<strong>Python中的变量实际上是对象的引用（reference），而不是对象本身</strong>。当我们给一个变量赋值时，实际上是将变量指向一个对象的内存地址。如果这个对象是可变的，我们可以修改其内部状态，但是变量指向的对象仍然是同一个，即对象的内存地址没有改变。如果这个对象是不可变的，我们不能修改其内部状态，但是可以将变量指向一个新的对象，从而实现变量的修改。</p><h2 id="del语句">del语句</h2><p>在Python中，<code>del</code>是一个关键字，<strong>用于删除Python对象</strong>。以下是<code>del</code>的一些用法：</p><ol><li><p><strong>删除变量</strong>：你可以使用<code>del</code>来删除一个或多个变量。例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line"><span class="keyword">del</span> x, y</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x</code>和<code>y</code>在<code>del</code>语句执行后将不再存在。</p></li><li><p><strong>删除列表元素</strong>：你可以使用<code>del</code>来删除列表中的一个或多个元素。例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，列表中的第二个元素（索引为1）将被删除，所以<code>list</code>现在是<code>['a', 'c', 'd', 'e']</code>。</p></li><li><p><strong>删除字典元素</strong>：你可以使用<code>del</code>来删除字典中的一个或多个元素。例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[<span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，字典中的键为<code>'b'</code>的元素将被删除，所以<code>dict</code>现在是<code>&#123;'a': 1, 'c': 3&#125;</code>。</p></li><li><p><strong>删除对象属性</strong>：你可以使用<code>del</code>来删除一个对象的属性。例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="keyword">del</span> obj.x</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>obj.x</code>在<code>del</code>语句执行后将不再存在。</p></li></ol><p>注意，<code>del</code>只是删除了名称和对象之间的引用，而不是删除对象本身。如果对象没有其他引用，它将在垃圾收集过程中被删除。</p><h2 id="多重赋值">多重赋值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">9</span></span><br><span class="line">a,b = b,a</span><br><span class="line"></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a,b = s</span><br></pre></td></tr></table></figure><h2 id="copy模块">copy模块</h2><p>它包含了浅拷贝copy和深拷贝deepcopy两个函数</p><h2 id="关于缩进">关于缩进</h2><p>对于列表,元组这种数据定义的时候,缩进其实是没有用的,还有就是如果我们想把语句分成多行可以使用 \ 这个字符来续行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\</span></span><br><span class="line"><span class="string">world&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="漂亮打印pprint">漂亮打印pprint</h2><p>如果列表,元组,字典里面数据较多或者相互嵌套的话,那么使用print打印出来的就比较丑,这个时候我们可以使用pprint 模块</p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230304165050060.png" alt="image-20230304165050060"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230304165059827.png" alt="image-20230304165059827"></p><p>对比一下吧,而且我们还可以使用它的pformat将其变成字符串格式</p><h2 id="pass">pass</h2><p>在 Python3.x 的时候 pass 可以写或不写。</p><p>python2.x：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="comment"># 空函数在Python2.x版本中pass是必须的</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>python3.x</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="comment"># 在Python3.x的时候pass可以写或不写</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="函数">函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">args</span>):</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>默认返回None</p><h3 id="参数问题">参数问题</h3><p>个人把参数问题分为两类:</p><ul><li>定义的时候参数问题</li><li>传递的时候参数问题</li></ul><p>在定义的时候有这几种:</p><h4 id="必选参数">必选参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b</span>): <span class="comment"># 这样定义的参数就叫必选参数</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">func(<span class="number">10</span>,<span class="number">20</span>)  <span class="comment"># 这样传递的参数就是位置参数</span></span><br><span class="line">func(<span class="number">10</span>,b=<span class="number">30</span>) <span class="comment"># b =30 这样就是关键字参数</span></span><br></pre></td></tr></table></figure><h4 id="默认参数">默认参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b=<span class="number">10</span></span>):  <span class="comment"># 必须在必选参数后面</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="不定长参数">不定长参数</h4><p>超出的<strong>位置参数</strong>当成元组放入argv中,超出的 关键字参数放入kwd</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*argv,**kwd</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="特殊参数">特殊参数</h4><p>/ 和 *</p><p>/代表之前的参数只能用位置参数,* 代表之后的参数只能用关键字参数</p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305190550055.png" alt="image-20230305190550055"></p><p>要注意下面的规则:</p><ol><li><p><strong>传递参数的时候</strong>位置参数必须出现在关键字参数前面</p></li><li><p>定义函数的时候 , **kwd这种参数必须放在*argv这种参数后面,因为上一条规则,普通参数必须放在默认参数前面,这也就意味着, kwd一定是放在最后面了</p></li><li><p>定义的时候*argv这中参数可以放在必选参数前面，但是在调用时，必选参数必须要指定参数名来传入，否则会报错</p></li><li><p>不定长参数中的关键字参数不能跟函数定义参数名字相同,否则会冲突</p></li></ol><h3 id="参数解析">参数解析</h3><p>比如说我们一个函数可以传递位置参数,我们可以解析列表进去,如果一个函数可以传递关键字参数,我们可以解析字典进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(a,b,c,d,sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">func(*[<span class="number">1</span>,<span class="number">2</span>],**&#123;<span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure><p>这样确实可以省点事</p><h2 id="lambda表达式">lambda表达式</h2><p>第一个位置是参数,第二个是表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y: x+y  <span class="comment"># 求和</span></span><br><span class="line"><span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y <span class="comment"># 比大小</span></span><br><span class="line">func = <span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">else</span> n * func(n-<span class="number">1</span>) <span class="comment"># 递归</span></span><br></pre></td></tr></table></figure><h2 id="高阶函数">高阶函数</h2><h3 id="map-映射">map(映射)</h3><p>它是将可迭代对象的每一个数据都分别放入函数中,然后将函数的返回值变成一个map(可迭代对象)返回</p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306155639537.png" alt="image-20230306155639537"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">map</span>(Iterator[_S], <span class="type">Generic</span>[_S]): <span class="comment"># 我们发现这个对象是可以迭代,也是生成器</span></span><br></pre></td></tr></table></figure><p>第一个参数是一个函数,第二个参数是可变长迭代对象,返回的是一个map对象,他也是可以迭代的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ll = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ll)) <span class="comment"># [1,4,9]</span></span><br><span class="line">ll = <span class="built_in">map</span>(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ll)) <span class="comment"># [5,7,9]</span></span><br></pre></td></tr></table></figure><h3 id="filter-过滤">filter(过滤)</h3><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160339383.png" alt="image-20230306160339383"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160405245.png" alt="image-20230306160405245"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ll)) <span class="comment"># [2]</span></span><br></pre></td></tr></table></figure><h3 id="reduce-归约">reduce(归约)</h3><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160903441.png" alt="image-20230306160903441"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306160818570.png" alt="image-20230306160818570"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">res = functools.reduce(<span class="keyword">lambda</span> x,y : x+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><h3 id="zip">zip</h3><p>将后面的每个可迭代对象迭代一次的值组成一个元组变成一个新的迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">zip</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></table></figure><blockquote><p>这些函数的返回值都是一次性的,因为迭代器就是一次性的</p></blockquote><h3 id="compress">compress</h3><p>跟filter很像,但是呢它是根据后一个可迭代对象的真假决定第一个可迭代对象的值是否返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line"></span><br><span class="line">addresses = [</span><br><span class="line">    <span class="string">&#x27;5412 N CLARK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5148 N CLARK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5800 E 58TH&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2122 N CLARK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1060 W ADDISON&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;4801 N BROADWAY&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1039 W GRANVILLE&#x27;</span></span><br><span class="line">]</span><br><span class="line">counts = [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(compress(addresses,[n&gt;<span class="number">5</span> <span class="keyword">for</span> n <span class="keyword">in</span> counts])))</span><br></pre></td></tr></table></figure><h3 id="partial">partial</h3><p>如果我们需要某个函数的一些参数值固定,我们就可以使用这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d</span><br><span class="line"></span><br><span class="line">three = partial(func,<span class="number">1</span>)</span><br><span class="line">two = partial(func,<span class="number">1</span>,d=<span class="number">4</span>)</span><br><span class="line">one = partial(func,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(three(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(two(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(one(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>其实这个也很简单,我们自己都能实现, 记录下给的函数与默认参数,然后返回一个可调用对象,那个可调用对象的call方法里面把默认参数给上去就可以了</p><h2 id="反射">反射</h2><p>这就是反射吧</p><ol><li>告诉别人，我是谁</li><li>告诉别人，我能做什么</li></ol><p>我们可以通过反射函数知道某个模块,某个类的一些信息</p><h3 id="dir">dir()</h3><p>返回传递给它的任何对象的属性名称,是一个排好序的列表</p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306162731170.png" alt="image-20230306162731170"></p><h3 id="type">type()</h3><p>返回类型</p><h3 id="hasattr">hasattr()</h3><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306162708633.png" alt="image-20230306162708633"></p><p>使用 dir() 函数会返回一个对象的属性列表。</p><p>但是，有时我们只想测试一个或多个属性是否存在。如果对象具有我们正在考虑的属性，那么通常希望只检索该属性。这个任务可以由 hasattr() 来完成.</p><h3 id="getattr">getattr()</h3><p>使用 hasattr 获知了对象拥有某个属性后，可以搭配 getattr() 函数来获取其属性值。</p><h3 id="id">id()</h3><p><strong>id()</strong> 函数返回对象的唯一标识符，标识符是一个整数。</p><h3 id="isinstance">isinstance()</h3><p>使用 isinstance() 函数可以确定一个对象是否是某个特定类型或定制类的实例。</p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230306163223421.png" alt="image-20230306163223421"></p><h3 id="callable">callable()</h3><p>使用 callable 可以确定一个对象是否是可调用的，比如函数，类这些对象都是可以调用的对象。</p><h3 id="模块的魔法属性">模块的魔法属性</h3><ol><li><code>__name__</code>：模块的名称，可以使用<code>import</code>语句导入模块。如果当前模块时被运行的模块,那么他就是 __main__</li><li><code>__file__</code>：模块的文件名，可以用于获取模块所在的文件路径。</li><li><code>__doc__</code>：模块的文档字符串，可以使用<code>help()</code>函数查看模块的文档。</li><li><code>__all__</code>：模块的公开接口，用于限制模块中的变量、函数和类的访问范围。</li></ol><h3 id="类的魔法属性">类的魔法属性</h3><ol><li><code>__doc__</code>：类的文档字符串，可以使用<code>help()</code>函数查看类的文档。</li><li><code>__name__</code>：类的名称，可以用于获取类所在的模块名称。</li><li><code>__module__</code>：类所属的模块名称，可以用于获取类所在的模块路径。</li><li><code>__dict__</code>：类或实例的命名空间，包含类或实例的所有属性和方法。</li><li><code>__bases__</code>：类的基类元组，可以用于获取类的所有父类。</li><li><code>__subclasses__()</code>：类的所有直接子类的列表，可以用于获取类的所有子类。</li><li><code>__class__</code>：类的元类，用于控制类的创建和行为。</li></ol><h2 id="作用域-和-命名空间">作用域  和 命名空间</h2><p>分为 <strong>全局作用域 G</strong>,<strong>局部作用域 L</strong>,<strong>内建作用域B</strong>,<strong>闭包函数外的函数中E</strong></p><p>变量/函数 的查找顺序： L –&gt; E –&gt; G –&gt;B</p><p>每个作用域都包含一个<strong>命名空间</strong>,我们在使用变量的时候会先在当前命名空间里面找有没有这个变量,如果没有会向外层找,我们在给变量赋值的时候,如果没有使用<strong>global,nonlocal</strong> 这些关键字向外面引入变量,那么将会在自己的命名空间里面创建这么一个变量</p><h3 id="全局与局部">全局与局部</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = <span class="number">10</span>  <span class="comment"># 局部</span></span><br><span class="line">a = <span class="number">20</span>  <span class="comment"># 全局</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出20</span></span><br></pre></td></tr></table></figure><p>我们发现在func里面对a赋值其实是在局部作用域里面创建了一个a,而不是对全局的a做修改,那么如何在函数里面修改全局变量呢?</p><h3 id="global-关键字">global 关键字</h3><p>引入全局作用域里面的变量,如果不存在,当我们对这个变量赋值的时候,则会在全局作用于的命名空间里面定义这么一个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">     b = <span class="number">10</span>  <span class="comment"># 不能再出现a的使用</span></span><br><span class="line">     <span class="keyword">global</span> a  <span class="comment"># 如果不使用这条语句,下面这条语句将变成 定义一个局部变量</span></span><br><span class="line">     a = <span class="number">10</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><blockquote><p>在函数里面,我们不能再<strong>global语句前面出现任何关于使用global指定变量的语句</strong></p></blockquote><p><strong>另外还需要注意的点,如果局部变量跟全局变量重名了,在局部变量声明前,是不能使用这个变量名字的,会被看做未定义</strong>,比如这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">   <span class="built_in">print</span>(a)  <span class="comment"># 这里会报错</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h3 id="nonlocal关键字">nonlocal关键字</h3><p><strong>这个呢是用来引入外层命名空间里面的变量的,而不是全局</strong>,如果不存在,则会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">nonlocal</span> a  </span><br><span class="line">        a = <span class="number">10</span></span><br><span class="line">     <span class="comment"># 这个其实也是E作用域相对于func2里面来说</span></span><br><span class="line">    a = <span class="number">20</span>   <span class="comment"># 如果不定义 那么在 func2 里面会报错</span></span><br><span class="line">    func2()</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 输出10</span></span><br><span class="line">    </span><br><span class="line">func1()</span><br></pre></td></tr></table></figure><h3 id="变量集合">变量集合</h3><p>在Python中，有两个内建函数，你可能用不到，但是需要掌握它们。</p><ul><li>globals() ：以dict的方式存储所有全局变量/函数</li><li>locals()：以dict的方式存储所有局部变量/函数</li></ul><h3 id="总结">总结</h3><p>如果我们仅仅使用变量而不赋值,那么会从当前作用域一层一层向外找,<strong>而且外层的声明语句必须在调用这个作用域的时候的前面</strong>,如果我们对变量进行赋值了, 如果没有特殊关键字修饰,那么就是当前作用域定义,如果有global修饰,那么就是修改全局作用域中的变量,或者是赋值(全局可以不存在这个变量),如果有nonlocal修饰,那么就是修改外面一层作用域的变量而且外层作用域必须先定义好这个变量</p><h2 id="闭包">闭包</h2><p>闭包（closure）在Python中是一个非常强大的功能，它涉及到函数和作用域的概念。</p><p>在Python中，一个函数可以定义在另一个函数内部，而内部函数可以访问外部函数中定义的变量。如果一个函数被定义在另一个函数的作用域内，并且引用了外部函数的变量，那么这个内部函数就被称为闭包。</p><p>以下是一个闭包的简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> inner_function</span><br><span class="line"></span><br><span class="line">closure = outer_function(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(closure(<span class="number">5</span>))  <span class="comment"># 输出 15</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>inner_function</code>就是一个闭包，因为它在<code>outer_function</code>的作用域内定义，并且引用了<code>outer_function</code>的参数<code>x</code>。当我们调用<code>outer_function(10)</code>时，它返回了<code>inner_function</code>函数对象，我们将这个对象赋值给了<code>closure</code>。这个对象记住了当时<code>outer_function</code>的参数<code>x</code>的值，所以即使<code>outer_function</code>已经结束，<code>closure</code>依然可以正确地计算<code>x + y</code>。</p><p>闭包有许多好处，以下是一些主要的优点：</p><ol><li><p><strong>数据隐藏</strong>：闭包可以用来提供数据隐藏和封装。由于闭包只能通过外部函数来访问其内部的状态，因此这些状态对于外部世界是隐藏的。</p></li><li><p><strong>函数工厂</strong>：你可以使用闭包来创建函数工厂，即根据参数生成特定功能的函数。在上面的例子中，<code>outer_function</code>就是一个函数工厂，根据传入的<code>x</code>参数生成了不同的<code>inner_function</code>。</p></li><li><p><strong>持久化状态</strong>：闭包可以记住并持久化包含它的作用域中的状态，即使包含它的函数已经结束。</p></li><li><p><strong>实现装饰器</strong>：在Python中，装饰器是一种高级功能，它允许你修改一个函数的行为，而不改变其源代码。装饰器的实现离不开闭包。</p></li></ol><p>总的来说，闭包是一种强大的工具，它可以让你编写出更加灵活和功能强大的代码。</p><h2 id="异常处理">异常处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">代码</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># 建议这样做,才能得到异常对象,如果不加 as 的话就是异常类</span></span><br><span class="line">处理</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没发生异常执行</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    都会执行的代码</span><br><span class="line"><span class="keyword">raise</span>  <span class="comment"># 向上抛出异常</span></span><br></pre></td></tr></table></figure><h2 id="类和对象">类和对象</h2><p>感觉python的类和对象整的就很…,不知道咋说,感受一下吧,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:  <span class="comment"># 也可以class Car()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:   <span class="comment"># 初始化函数,也就是构造函数吧</span></span><br><span class="line">        self.price = <span class="number">10</span>  <span class="comment"># 这里必须用self.xxx 的格式,不然就不是这个对象的属性,还记的作用域跟命名空间么,但是这里不能用nonlocal</span></span><br><span class="line">        self.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    </span><br><span class="line">car1 = Car()</span><br><span class="line">car1.number = <span class="string">&#x27;10000&#x27;</span>   <span class="comment"># 这样的话 number 也属于 car1 的属性了</span></span><br><span class="line"><span class="built_in">print</span>(car1)</span><br></pre></td></tr></table></figure><p>当我们使用对象名.方法名的时候相当于 类名.方法名(对象名)  所以方法的第一个参数就是self,也可以取别的名字,当我们使用类名.方法名的时候,就相当于普通函数</p><h3 id="类属性">类属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    a = <span class="number">10</span>        </span><br><span class="line">user = User()</span><br><span class="line">user.a = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(user.a)</span><br><span class="line"><span class="built_in">print</span>(User.a)</span><br></pre></td></tr></table></figure><p>类属性存在与类的dict里面,  而不在实例的dict里面</p><h3 id="静态方法-类方法-实例方法">静态方法 类方法 实例方法</h3><p>静态方法和类方法必须使用@staticmethod   @classmethod  两个装饰器装饰才行,不然一律当做实例方法</p><p>这三个东西真的比较混乱,我们从调用上来理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">a</span>):</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">a</span>):</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    </span><br><span class="line">user = User()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例调用的时候,第一个参数传递的是自己</span></span><br><span class="line"><span class="comment"># 类名调用的时候就是普通函数调用</span></span><br><span class="line">user.test()  </span><br><span class="line">User.test(user)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种方式都是普通函数调用</span></span><br><span class="line">user.test1(<span class="number">1</span>)</span><br><span class="line">User.test1(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#两种方式都会将类当成第一个参数传进去</span></span><br><span class="line">user.test2()</span><br><span class="line">User.test2()</span><br></pre></td></tr></table></figure><p>三种方法声明要注意:  静态方法必须使用@staticmethod装饰,然后参数可以定义也可以不定义, 类方法必须使用@classmethod装饰,必须定义一个参数,这个参数就是类本身, 实例方法必须要定义一个参数(除非你不通过实例调用这个方法),这个参数就是实例本身</p><h3 id="私有变量和方法">私有变量和方法</h3><p>python中其实并没有提供这种功能,我们可以在类外调用任何变量和方法,这个只是一种规范罢了</p><h4 id="单前导下划线-var">单前导下划线 _var</h4><p>下划线前缀的含义是告知其他程序员：<strong>以单个下划线开头的变量或方法仅供内部使用</strong>。</p><h4 id="双前导下划线-var">双前导下划线 __var</h4><p>双下划线前缀会导致Python解释器<strong>重写属性名称</strong>，以避免子类中的命名冲突。</p><p>这也叫做<strong>名称修饰(name mangling)</strong> - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__name = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name  </span><br><span class="line"><span class="built_in">print</span>(User().__dict__)  <span class="comment">#&#123;&#x27;_User__name&#x27;: &#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(User.__dict__)  <span class="comment"># &#x27;_User__func&#x27;: &lt;function User.__func at 0x0000027AF68C2820&gt;</span></span><br><span class="line"><span class="built_in">print</span>(User().getage())  <span class="comment">#  这样是没有问题的</span></span><br><span class="line"><span class="built_in">print</span>(User().__name)  <span class="comment"># 这样会报错</span></span><br></pre></td></tr></table></figure><p>我们发现,名字被重写了,变成了 _类名变量名 的格式了,  我们在内部可以直接使用__name这样的形式,而在外部则不行,这样是不是也做到了一定上的私有化呢?</p><h3 id="继承">继承</h3><h4 id="单继承">单继承</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, weight</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 说: 我<span class="subst">&#123;self.age&#125;</span>岁。&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, weight, grade</span>):</span><br><span class="line">        <span class="comment"># 调用父类的实例化方法,这里必须带上self</span></span><br><span class="line">        People.__init__(self, name, age, weight)</span><br><span class="line">        self.grade = grade</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写父类的speak方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        People.speak(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我在读<span class="subst">&#123;self.grade&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>子类的属性和方法会重写父类的属性和方法</p><h3 id="多继承">多继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类(父类1, 父类2, 父类3...):</span><br></pre></td></tr></table></figure><p>如果多个父类中有相同的方法跟属性,访问的时候优先选择左边的</p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307171808747.png" alt="image-20230307171808747"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307171850020.png" alt="image-20230307171850020"></p><p>从左到右再深度选择</p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307171918818.png" alt="image-20230307171918818"></p><h3 id="super">super</h3><p>这个玩意也有很多坑,这个东西是用来调用父类的属性跟方法,但是如果父类中的方法也使用了super 调用方法的话,那就得注意了,<strong>它不是简简单单的调用父类的父类的方法,而是去_mro_中找下一个父类的顺序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Base.__init__&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Base&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A,B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>)</span><br><span class="line">        self.hello()</span><br><span class="line">C()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Base.__init__</span></span><br><span class="line"><span class="comment"># B.__init__</span></span><br><span class="line"><span class="comment"># A.__init__</span></span><br><span class="line"><span class="comment"># C.__init__</span></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>按理来说是不是应该输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base.__init__</span><br><span class="line">A.__init__</span><br><span class="line">C.__init__</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>有没有发现多输出了B的,这就说明了如果父类方法也使用了super,那么下一个找的是mro链里面的方法</p><h3 id="property装饰器">property装饰器</h3><p>使用property去装饰类里面的一个方法的时候,会将其变成属性,当我们访问这个属性的时候就会调用里面的方法,(这个和vue的计算属性很像),如果直接对对象里面的其他属性赋值的话,那么就不能对其进行约束和检查,如果我们采用这个property修饰的属性去赋值,那么就能够实现检查和约束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,age</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将方法变成属性</span></span><br><span class="line"><span class="meta">    @property </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">    <span class="comment"># 检查值是否合法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self,age</span>):</span><br><span class="line">        <span class="keyword">if</span> age &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;age invalid&quot;</span>)</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">user = User(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 不合法,会抛出异常</span></span><br><span class="line">user = User(-<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>我们打印User.__dict__ 会输出 ‘age’: &lt;property object at 0x0000022BB2FEBF90&gt;  他变成了property的对象了</p><ul><li>当你读取属性值时，会进入被 <code>property</code> 装饰的函数。</li><li>当你对属性进行赋值时，会进入被 <code>@xx.setter</code> 装饰的函数。</li><li>两个装饰器，一定是 <code>@property</code> 在前面，而 <code>@xx.setter</code> 在后</li></ul><h3 id="类的魔法方法">类的魔法方法</h3><h4 id="构造方法">构造方法</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180058571.png" alt="image-20230307180058571"></p><h4 id="比较运算符">比较运算符</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180040473.png" alt="image-20230307180040473"></p><h4 id="一元操作符">一元操作符</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180154965.png" alt="image-20230307180154965"></p><h4 id="算数操作符">算数操作符</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180229621.png" alt="image-20230307180229621"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180258476.png" alt="image-20230307180258476"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180447324.png" alt="image-20230307180447324"></p><h4 id="增强赋值运算符">增强赋值运算符</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180538110.png" alt="image-20230307180538110"></p><h4 id="类型转换运算符">类型转换运算符</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180601912.png" alt="image-20230307180601912"></p><h4 id="类的表示">类的表示</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180721780.png" alt="image-20230307180721780"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307180802074.png" alt="image-20230307180802074"></p><h4 id="访问控制">访问控制</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181404626.png" alt="image-20230307181404626"></p><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181131165.png" alt="image-20230307181131165"></p><h4 id="自定义序列">自定义序列</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181441101.png" alt="image-20230307181441101"></p><h4 id="反射">反射</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181630304.png" alt="image-20230307181630304"></p><h4 id="可调用对象">可调用对象</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181648695.png" alt="image-20230307181648695"></p><h4 id="上下文管理器">上下文管理器</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181712884.png" alt="image-20230307181712884"></p><h4 id="属性描述符">属性描述符</h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230308180510390.png" alt="image-20230308180510390"></p><blockquote><p>千万要注意,它一定要属于某个类的属性才能使用,是对象属性都不行,而且必须得是被对象或者类去用点.去访问或者修改才会触发set和get函数,使用dict 是没有用的</p></blockquote><p>这里很有必要讲一下这个东西,它能够限制和检查类里面的属性,跟__setattr__ 这样差不多,不过它相当于另外一种数据类型,而且如果使用__setattr__ 来做检查与限制会使得代码很冗余,而属性描述符就很简单了,看下面这个代码,基本上所有的分数都可以用这个描述符去限制,如果用__setattr__ 来的话,那岂不是每个分数都要判断一次,而且他可以做到每一次修改都能检查跟限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,score</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__get__&quot;</span>,instance,owner,sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__set__&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;value invalid&quot;</span>)</span><br><span class="line">        self.score = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    math = Score(<span class="number">0</span>)</span><br><span class="line">    chinese = Score(<span class="number">0</span>)</span><br><span class="line">    english = Score(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, math, chinese, english</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.math = math</span><br><span class="line">        self.chinese = chinese</span><br><span class="line">        self.english = english</span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">&quot;dd&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">student.english</span><br></pre></td></tr></table></figure><p>这里要注意一下,我们在初始化函数里面明明是对实例属性赋值,但是由于属性描述符的原因,所以赋值变成对属性描述符修饰的属性赋值,而name则不受影响,所以我们打印student.__dict__的时候只能看到name</p><h4 id="数据描述符与非数据描述符">数据描述符与非数据描述符</h4><p>如果只有__get__  那么就是非数据描述符,如果有 __set__和__get__两个就是数据描述符,<strong>数据描述符和非数据描述符的区别在于：通过实例修改与类属性同名的描述符时,数据描述符是修改类属性,而非数据描述符则是修改或者创建这么一个实例属性</strong>。</p><h4 id="拷贝"><strong>拷贝</strong></h4><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230307181840529.png" alt="image-20230307181840529"></p><blockquote><p>这些魔法方法,其实都是为了方便或者提供一种好的办法给我们,我们可以通过这些魔法方法让我们的类能够支持更多的操作,比如加法,减法,支持内建函数这些,这些方法也不是必选的,你需要什么功能,你就去实现什么方法</p></blockquote><h3 id="元类">元类</h3><p><strong>类是用来创建对象的</strong>,<strong>元类是用来创建类的</strong>  因此类时元类的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User = <span class="built_in">type</span>(<span class="string">&quot;User&quot;</span>,(),&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;djm&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">user = User()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(user.name)</span><br><span class="line"><span class="built_in">print</span>(user.__class__) <span class="comment"># 打印出创建自己的类  User</span></span><br><span class="line"><span class="built_in">print</span>(User.__class__) <span class="comment"># 打印出创建自己的类  type</span></span><br></pre></td></tr></table></figure><p><strong>一个类要具有创建其他类的本领的话就必须继承type</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,*args,**kwd</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in test&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,*args,**kwd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(metaclass = test):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>上面我们说到,User类时test元类的一个实例,因此必然会走test的 new 方法,因此 会输出in test</p><p>既然这样我们是不是可以在创建类时候自定义一些属性,还有是在类在创建对象的时候往对象身上添加一些属性(利用 call函数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,*args,**kwd</span>):</span><br><span class="line">        </span><br><span class="line">        obj =  <span class="built_in">super</span>().__new__(cls,*args,**kwd) </span><br><span class="line">        obj.age = <span class="number">10</span> <span class="comment"># 往User类上添加一些属性</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>) :</span><br><span class="line">        obj = <span class="built_in">super</span>().__call__(*args, **kwds)</span><br><span class="line">        obj.name = <span class="string">&#x27;hello world&#x27;</span>  <span class="comment"># 往User 实例对象上添加属性</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(metaclass = test):</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>所以这不就正符合框架的做法了么,毕竟通过元类我们能够动态的做很多事,而我们平常基本上是用不到元类的</p><h2 id="文件和io">文件和io</h2><p>python使用 open函数用来打开文件,默认情况下是 “rt” 模式,当然我们也能够自己指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">iter</span>(f.read,<span class="string">&#x27;&#x27;</span>)))</span><br></pre></td></tr></table></figure><h2 id="迭代器">迭代器</h2><p>python的列表,元组,集合,字典这些容器都提供了迭代器,所以我们能够使用for in 来循环遍历,如果我们想让for in 来遍历我们自己的对象,我们需要在类中定义好 __iter__方法,并且它的返回值对象实现了 __next__方法 和   __iter__ 方法</p><blockquote><p>如果只是为了实现for in 的话  实现 __getitem__ 这个方法就行</p></blockquote><p>我们可以使用 iter 方法获得对象的迭代器,然后使用next遍历数据,当next 抛出StopIteration 异常就代表迭代结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">5</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">myclass = MyNumbers()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (myclass):</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">iter</span>(myclass)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure><h2 id="生成器">生成器</h2><p>生成器的出现（Python 2.2 +），实现了延时计算，从而缓解了在大量数据下内存消耗过猛的问题。</p><h3 id="创建生成器">创建生成器</h3><p>第一种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="comment"># [0,1,2,3,4]</span></span><br><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)) <span class="comment"># 注意和列表推导式的区别哦,这个返回的是一个生成器对象</span></span><br></pre></td></tr></table></figure><p>第二种方式</p><p>使用yield</p><p><code>yield</code> 是什么东西呢? 它相当于我们函数里的 return，但与 return 又有所不同。</p><ul><li>当一个函数运行到 yield 后，函数的运行会暂停，并且会把 yield 后的值返回出去。</li><li>若 yield 没有接任何值，则返回 None,是指这条语句返回None</li><li>yield 虽然返回了，但是函数并没有结束,等到下一次继续运行的时候会接着yield后面这里运行</li></ul><h3 id="生成器的使用">生成器的使用</h3><p>可以使用for in 循环跟 next函数,这个就跟迭代器的使用差不多了</p><p>还可以使用send方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;<span class="number">5</span>:</span><br><span class="line">        b = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        i += b</span><br><span class="line">    </span><br><span class="line">gen = func()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>send方法可以传递参数,作为 yield返回值,<strong>而且第一次传递参数必须是None</strong></p><p>当我们第一次执行send函数的时候,是直接停在了yield那里,那么这个返回值当然不是它设置,而是第二次继续send的时候将传递来的参数当做返回值, 就是这么设计的</p><h3 id="生成器异常">生成器异常</h3><p>当我们的函数执行完后,会自动抛出一个停止异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;前面&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;后面&quot;</span>)</span><br><span class="line">    </span><br><span class="line">gen = func(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">gen.send(<span class="literal">None</span>)</span><br><span class="line">gen.send(<span class="literal">None</span>) <span class="comment"># 这里会出一个异常,其实也是为了告诉别的使用者,生成器已经执行完了</span></span><br></pre></td></tr></table></figure><h3 id="生成器的函数返回值">生成器的函数返回值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>,<span class="number">20</span></span><br><span class="line"></span><br><span class="line">gen = func()</span><br><span class="line"><span class="built_in">next</span>(gen)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">next</span>(gen)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> s:</span><br><span class="line">    <span class="built_in">print</span>(s.value)  <span class="comment"># (10,20)</span></span><br></pre></td></tr></table></figure><h3 id="生成器常用方法">生成器常用方法</h3><p>send(val) :  传递val作为 yield 语句的返回值</p><p>throw: 传递异常给生成器里面的yield语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;前面&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">lambda</span> x:<span class="number">1</span>/x</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;出现异常&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;后面&quot;</span>)</span><br><span class="line">    </span><br><span class="line">gen = func()</span><br><span class="line">div = gen.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(div(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(div(<span class="number">0</span>))  <span class="comment"># 这里会出现异常</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        gen.throw(Exception) <span class="comment"># 我们将异常交给生成器内部去处理</span></span><br><span class="line">    <span class="keyword">except</span> Exception:   <span class="comment"># 这里是为了处理stop那个异常</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="yield-from">yield from</h3><p>这个语句后面要跟一个可迭代对象(自然就包括生成器)  然后调用这个生成器就能一次遍历这个对象,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span>  a  <span class="comment">#等价于 for i in a: yield i</span></span><br><span class="line"></span><br><span class="line">f = func()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看一下yield from 的参考代码吧,看看它干了些什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">_i：子生成器，同时也是一个迭代器</span></span><br><span class="line"><span class="string">_y：子生成器生产的值</span></span><br><span class="line"><span class="string">_r：yield from 表达式最终的值</span></span><br><span class="line"><span class="string">_s：调用方通过send()发送的值</span></span><br><span class="line"><span class="string">_e：异常对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">_i = <span class="built_in">iter</span>(EXPR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = <span class="built_in">next</span>(_i)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.close</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()</span><br><span class="line">            <span class="keyword">raise</span> _e</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e:</span><br><span class="line">            _x = sys.exc_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.throw</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _y = _m(*_x)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    _y = <span class="built_in">next</span>(_i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                _r = _e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">RESULT = _r</span><br></pre></td></tr></table></figure><p>可以发现,它帮我们做了很多的异常处理</p><h2 id="上下文管理器">上下文管理器</h2><h3 id="什么是上下文管理器">什么是上下文管理器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.file&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.readline()</span><br></pre></td></tr></table></figure><ol><li><p>上下文表达式：<code>with open('test.txt') as file:</code></p></li><li><p>上下文管理器：<code>open('test.txt')</code> 的返回值</p></li></ol><p>有没有发现,我们不需要自己去关闭文件</p><h3 id="有什么好处">有什么好处?</h3><ol><li>可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；</li><li>可以以一种更加优雅的方式，处理异常；</li></ol><h3 id="如何编写上下文管理器">如何编写上下文管理器</h3><p>需要定义__enter__,__exit__这两个方法,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;====enter=====&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===close resource connection===&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>   <span class="comment"># 这里如果不返回True的话,产生的异常就会接着往上面抛</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operator</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Resource() <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>运行之后,发现并没有报错</p><h3 id="使用contextlib">使用contextlib</h3><p>这个可以只使用一个函数就可以了,不需要重新多写一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_func</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="comment"># __enter__方法</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;open file:&#x27;</span>, file_name, <span class="string">&#x27;in __enter__&#x27;</span>)</span><br><span class="line">    file_handler = <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> file_handler</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="comment"># deal with exception</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the exception was thrown&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;close file:&#x27;</span>, file_name, <span class="string">&#x27;in __exit__&#x27;</span>)</span><br><span class="line">        file_handler.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open_func(<span class="string">&#x27;/Users/MING/mytest.txt&#x27;</span>) <span class="keyword">as</span> file_in:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_in:</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><h3 id="自己实现contextlib">自己实现contextlib</h3><p>我们要明白这个with 的用法, with 后面的表达式的返回值必须是上下文管理器,也就是必须有 exit 和 enter 两个方法的对象, 然后调用它的enter方法得到返回值,就是资源对象, 等到结束后就执行exit方法,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">context</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,func</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.func = func  <span class="comment"># 保存好函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwds = kwds</span><br><span class="line">        <span class="keyword">return</span>  self   <span class="comment"># 这里要返回自己,但是要保存好参数信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">       self.handler = self.func(*self.args,**self.kwds)  <span class="comment"># 执行函数得到生成器</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">next</span>(self.handler)  <span class="comment"># 返回资源对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> exc_type != <span class="literal">None</span>:</span><br><span class="line">                self.handler.throw(exc_type)  <span class="comment"># 如果有异常,就将异常交给用户去处理</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.handler.send() <span class="comment"># 没有异常就继续</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="meta">@context</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__enter__&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> func2</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;产生异常&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__exit__&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> func() <span class="keyword">as</span> f:</span><br><span class="line">    f(<span class="number">20</span>)</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="装饰器">装饰器</h2><p>装饰器就像代理一样,在不改变原先的代码的情况下,对其进行增强,这样我们就能够节省很多代码,减少耦合</p><h3 id="普通装饰器">普通装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testtime</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwd</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args,**kwd)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(func.__name__+<span class="string">&quot;用时&quot;</span>+<span class="built_in">str</span>((end-start)) +<span class="string">&quot;s&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用装饰器之后相当于这样一条语句   test = testtime(test)</span></span><br><span class="line"><span class="meta">@testtime  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;<span class="number">1000000000</span>:</span><br><span class="line">        j = j+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">test() <span class="comment"># 等价于 testtime(test)()</span></span><br></pre></td></tr></table></figure><h3 id="带参数的函数装饰器">带参数的函数装饰器</h3><p>上面这种普通的装饰器只能执行固定的逻辑,我们并不能对其传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delay</span>(<span class="params">ns</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper2</span>(<span class="params">*argv,**kwd</span>):</span><br><span class="line">            time.sleep(ns)</span><br><span class="line">            result = func(*argv,**kwd)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper2</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@delay(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayhello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">sayhello()   <span class="comment"># 等价于  delay(1)(sayhello)()</span></span><br><span class="line">delay(<span class="number">1</span>)(sayhello)()</span><br></pre></td></tr></table></figure><p>比如这个带参数的装饰器,我们可以给定延迟时间执行</p><h3 id="不带参数的类装饰器">不带参数的类装饰器</h3><p>上面这些都是函数装饰器,我们还可以用类来做装饰器,用类做装饰器必须实现两个方法,一个是__init__(用于传递被装饰函数)和 __call__(用来实现装饰逻辑)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testtime</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,func</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = self.func(*args,**kwds)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(self.func.__name__+<span class="string">&quot;用时&quot;</span>+<span class="built_in">str</span>((end-start)) +<span class="string">&quot;s&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@testtime</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;<span class="number">1000000</span>:</span><br><span class="line">        j = j+<span class="number">1</span></span><br><span class="line">test() <span class="comment"># testtime(test).__call__() == testtime(test)()</span></span><br></pre></td></tr></table></figure><h3 id="带参数的类装饰器">带参数的类装饰器</h3><p>这个与不带参数的类装饰器有很大的变化 __init__(用于传递参数)和 __call__(用来接收被装饰函数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">delay</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ns</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ns = ns</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper2</span>(<span class="params">*argv,**kwd</span>):</span><br><span class="line">            time.sleep(self.ns)</span><br><span class="line">            result = func(*argv,**kwd)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper2</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">@delay(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayhello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">sayhello()   <span class="comment"># 等价于  delay(1).__call__(sayhello)() == delay(1)(sayhello)()</span></span><br><span class="line">delay(<span class="number">1</span>)(sayhello)()</span><br></pre></td></tr></table></figure><h3 id="其他装饰器">其他装饰器</h3><ul><li>类方法</li><li>实例方法</li><li>静态方法</li></ul><h3 id="总结">总结</h3><p>有没有发现其实就只有两种装饰器  一种带参数,一种不带参数   最终使用格式分别为 A§(B)() 和 A(B)()  A代表装饰器,P代表参数,B代表被装饰的东西(<strong>可以是类</strong>,也可以是函数)</p><p><strong>函数总是作为装饰器的返回值可调用对象的第一个参数</strong></p><p>我们需要明白一个东西,我们可以使用@装饰器 的方式  也可以直接使用 A = 装饰器(A) 这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(cls)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"><span class="meta">@test</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">A = test(A)</span><br></pre></td></tr></table></figure><p>我们来分析一下下面这个代码吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">func</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwds</span>):</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwds)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">info</span>):</span><br><span class="line">    <span class="built_in">print</span>(info)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> test1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test3</span>(<span class="params">info2</span>):</span><br><span class="line">    <span class="built_in">print</span>(info2)</span><br><span class="line">    <span class="keyword">return</span> test2(info2*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@test3(<span class="params"><span class="string">&quot;hello&quot;</span></span>) </span><span class="comment"># 首先执行 test3() 然后 执行 test2() 然后返回 test1函数,所以func一定是test1的参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="comment"># func = test3(&quot;hello&quot;)(func)</span></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>有了这个我们就可以写出可以带参数,也可以不带参数的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger</span>(<span class="params">func = <span class="literal">None</span>, info=<span class="string">&quot;logger&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> func:logger(func,info)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwd</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;info&#125;</span>:<span class="subst">&#123;func.__name__&#125;</span>被执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwd)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@logger()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@logger(<span class="params">info=<span class="string">&quot;djm&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func1()  <span class="comment"># func1 和 func2 不同的区别在于  func1 直接执行wrapper函数  func2 还执行了 lambda函数</span></span><br><span class="line">func2()</span><br><span class="line">func3()</span><br></pre></td></tr></table></figure><h2 id="并发编程">并发编程</h2><h3 id="多线程的使用">多线程的使用</h3><p>创建多线程的两种方式</p><blockquote><p>两种方式各有千秋,第一个简单,第二个可以自定义很多内容</p></blockquote><ul><li>使用Thread 类 创建线程</li><li>继承Thead 类 重写run 方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义线程函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>(<span class="params">name=<span class="string">&quot;Python&quot;</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, name)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程01，不指定参数</span></span><br><span class="line">thread_01 = Thread(target=target)</span><br><span class="line"><span class="comment"># 启动线程01</span></span><br><span class="line">thread_01.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程02，指定参数，注意逗号</span></span><br><span class="line">thread_02 = Thread(target=target, args=(<span class="string">&quot;MING&quot;</span>,))</span><br><span class="line"><span class="comment"># 启动线程02</span></span><br><span class="line">thread_02.start()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">type</span>=<span class="string">&quot;Python&quot;</span></span>):</span><br><span class="line">        <span class="comment"># 注意：super().__init__() 必须写</span></span><br><span class="line">        <span class="comment"># 且最好写在第一行</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.<span class="built_in">type</span>=<span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, self.<span class="built_in">type</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建线程01，不指定参数</span></span><br><span class="line">    thread_01 = MyThread()</span><br><span class="line">    <span class="comment"># 创建线程02，指定参数</span></span><br><span class="line">    thread_02 = MyThread(<span class="string">&quot;MING&quot;</span>)</span><br><span class="line"></span><br><span class="line">    thread_01.start()</span><br><span class="line">    thread_02.start()</span><br></pre></td></tr></table></figure><h3 id="锁机制">锁机制</h3><h4 id="互斥锁">互斥锁</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成锁对象，全局唯一</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取锁。未获取到会阻塞程序，直到获取到锁才会往下执行</span></span><br><span class="line">lock.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁，归还锁，其他人可以拿去用了</span></span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><p>推荐使用 with lock</p><h4 id="可重入锁">可重入锁</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 生成可重入锁对象</span></span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=main)</span><br><span class="line">t1.start()</span><br></pre></td></tr></table></figure><h4 id="全局锁gil">全局锁GIL</h4><blockquote><p>在python中多个线程其实并不是并行,而是并发,交替运行</p></blockquote><p>什么是GIL呢？ &gt;任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><h3 id="线程通信">线程通信</h3><h4 id="event">Event</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置event，使得所有该event事件都处于待命状态</span></span><br><span class="line">event.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待接收event的指令，决定是否阻塞程序执行</span></span><br><span class="line">event.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送event指令，使所有设置该event事件的线程执行</span></span><br><span class="line">event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">event = Event()  </span><br><span class="line">rank = <span class="number">0</span></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">name</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> rank</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;name&#125;</span>,我已经准备好了&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待发出枪声</span></span><br><span class="line">    event.wait()</span><br><span class="line">    <span class="comment"># 开始竞争</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    rank += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;rank&#125;</span>名:<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    lock.release()</span><br><span class="line">    </span><br><span class="line">event.clear()</span><br><span class="line">runners = [Thread(target=run,args=[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[runner.start() <span class="keyword">for</span> runner <span class="keyword">in</span> runners]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;各就位&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始跑&quot;</span>)</span><br><span class="line">event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><p>上面这个代码是5名选手参加跑步比赛,用event来控制统一开始跑, lock来模拟速度,谁先抢到谁排名高</p><h4 id="condition">condition</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cond = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似lock.acquire() 抢占锁</span></span><br><span class="line">cond.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似lock.release() 释放锁</span></span><br><span class="line">cond.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待指定触发，同时会释放对锁的获取,直到被notify才重新竞争这个琐。必须得先拥有锁也就是acquire</span></span><br><span class="line">cond.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送指定，触发执行</span></span><br><span class="line">cond.notify()</span><br></pre></td></tr></table></figure><h4 id="queue">Queue</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="comment"># maxsize默认为0，不受限</span></span><br><span class="line"><span class="comment"># 一旦&gt;0，而消息数又达到限制，q.put()也将阻塞</span></span><br><span class="line">q = Queue(maxsize=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认阻塞程序，等待队列消息，可设置超时时间</span></span><br><span class="line">q.get(block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息：默认会阻塞程序至队列中有空闲位置放入数据</span></span><br><span class="line">q.put(item, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有的消息都被消费完</span></span><br><span class="line">q.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知队列任务处理已经完成，当所有任务都处理完成时，join() 阻塞将会解除</span></span><br><span class="line">q.task_done()</span><br></pre></td></tr></table></figure><h3 id="信息隔离">信息隔离</h3><p>就是每个线程来的时候,去找他们自己对应的字典信息,我简略的实现一下就知道了,每个线程都有一个自己的字典域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,currentThread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">local1</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, __name: <span class="built_in">str</span></span>) :</span><br><span class="line">      <span class="keyword">if</span> __name == <span class="string">&quot;__dict__&quot;</span>:</span><br><span class="line">         <span class="built_in">object</span>.__getattribute__(self,__name).setdefault(currentThread(),&#123;&#125;)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self,__name)[currentThread()]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> self.__dict__[__name]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, __name, __value</span>):</span><br><span class="line">      self.__dict__[__name] = __value</span><br><span class="line">      </span><br><span class="line">       </span><br><span class="line">n2 = local1()</span><br><span class="line">n2.name = <span class="string">&quot;main&quot;</span></span><br><span class="line">n2.t = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line">   n2.name = name</span><br><span class="line">   <span class="built_in">print</span>(n2.__dict__)</span><br><span class="line"></span><br><span class="line">[Thread(target=func,args=[<span class="string">&quot;thread&quot;</span>+<span class="built_in">str</span>(i)]).start() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n2.__dict__)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230312185501172.png" alt="image-20230312185501172"></p><h3 id="线程池">线程池</h3><p>在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，需要切换上下文环境，依然会造成cpu的大量开销。还有就是创建销毁线程也会消耗资源,为解决这个问题，线程池的概念被提出来了。预先创建好一个合理数量的线程池，让过来的任务立刻能够使用，就形成了线程池。</p><p>在Python3中，创建线程池是通过<code>concurrent.futures</code>函数库中的<code>ThreadPoolExecutor</code>类来实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">f&quot;<span class="subst">&#123;threading.get_ident()&#125;</span> : <span class="subst">&#123;i&#125;</span> &quot;</span> )</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    pool.submit(func)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用with 这样的方式更加优雅, submit 之后有一个返回值,  我们可以调用它的result 方法得到结果  但是这个方法是阻塞的,除非我们就是要现在得到结果,否则就将这个句柄保存起来,等到后面再得到结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">f&quot;<span class="subst">&#123;threading.get_ident()&#125;</span> : <span class="subst">&#123;i&#125;</span> &quot;</span> )</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> threading.get_ident()</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">5</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    handlers = [pool.submit(func) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    res = [handler.result() <span class="keyword">for</span> handler <span class="keyword">in</span> handlers]</span><br><span class="line">    dicts = &#123;&#125;</span><br><span class="line">    <span class="built_in">dict</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">        dicts[r] = dicts.get(r,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> dicts.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> 执行了 <span class="subst">&#123;v&#125;</span>的函数&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异步io-asyncio框架">异步io asyncio框架</h3><h4 id="协程">协程</h4><p>怎么去理解协程呢, 拿线程去对比一下吧, 如果我们有一个网络请求,需要1s钟才能得到响应, 如果是线程的话,它会一直在那等着,如果是协程,我们可以让CPU去干别的事情</p><p>协程的实现就是依靠生成器</p><h4 id="创建一个协程">创建一个协程</h4><p>只要在函数声明的前面用async声明就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(request())  <span class="comment"># &lt;coroutine object request at 0x000001F8FAE163C0&gt;</span></span><br></pre></td></tr></table></figure><h4 id="概念">概念</h4><p>在了解<code>asyncio</code>的使用方法前，首先有必要先介绍一下，这几个贯穿始终的概念。</p><ul><li><code>event_loop 事件循环</code>：程序开启一个无限的循环，程序员会把一些函数（协程）注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。</li><li><code>coroutine 协程</code>：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</li><li><code>future 对象</code>： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别</li><li><code>task 任务</code>：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。Task 对象是 Future 的子类，它将 coroutine 和 Future 联系在一起，将 coroutine 封装成一个 Future 对象。</li><li><code>async/await 关键字</code>：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。其作用在一定程度上类似于yield。</li></ul><blockquote><p><strong>async里面不能使用 yield ,await 也必须在async里面使用</strong></p></blockquote><h4 id="协程的并发">协程的并发</h4><p>协程的并发其实是需要异步函数的支持,如果不是异步函数的话,协程是不能并发的,我们来对比一下</p><p>不支持异步的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 不支持异步</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = request()</span><br><span class="line">    task2 = request()</span><br><span class="line"></span><br><span class="line">    task1 = asyncio.create_task(task1)</span><br><span class="line">    task2 = asyncio.create_task(task2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">asyncio.run(main())</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;一共运行<span class="subst">&#123;end-start:<span class="number">.2</span>f&#125;</span>s&quot;</span>) <span class="comment"># 2s</span></span><br></pre></td></tr></table></figure><p>支持异步的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 这个是支持异步的</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = request()</span><br><span class="line">    task2 = request()</span><br><span class="line"></span><br><span class="line">    task1 = asyncio.create_task(task1)</span><br><span class="line">    task2 = asyncio.create_task(task2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">asyncio.run(main())</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;一共运行<span class="subst">&#123;end-start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)  <span class="comment"># 1s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="网络编程">网络编程</h2><h1>第二部分 自动化</h1><h2 id="正则表达式">正则表达式</h2><blockquote><p>关于什么是正则表达式,我已经在我的另外一篇博客里面介绍清楚了,这里只做关于python如何使用正则表达式的总结</p></blockquote><p>python的正则表达式的使用有两种:</p><p>第一种就是 直接使用 re 模块里面的函数 比如 re.search(pattern,string,flags) re.match() re.findall() …</p><p>第二种就是 使用re.compile(pattern,flags)  得到一个对象,然后调用这个对象的search(string),match findall 方法</p><p>第一种呢,方便我们一次性使用,第二种方便一个匹配模式多次使用</p><h3 id="search方法">search方法</h3><p>搜索第一个匹配的字符串,并且返回包含这个字符串的匹配对象</p><h3 id="match方法">match方法</h3><p>从开头开始匹配,如果没有匹配成功,则不会继续匹配</p><h3 id="findall方法">findall方法</h3><p><strong>返回全部匹配的字符串的所有分组(0分组除外,如果只有0分组的话就必须包含0分组)</strong>,并且都放在列表中返回</p><h3 id="finditer方法">finditer方法</h3><p>匹配所有字符串,而且<strong>我们可以迭代遍历所有的匹配对象</strong></p><p>四个方法总结一下吧:</p><p>如果我们只是想看某个字符串是否包含这个模式,我们可以使用search</p><p>如果我们要看从开头是否匹配,使用match</p><p>如果只需要得到所有匹配结果的分组,使用findall</p><p>如果要获得所有的匹配字符串,还要获得所有的匹配字符串的分组,使用finditer</p><h2 id="读写文件">读写文件</h2><h1>好用的功能</h1><h2 id="格式化字符串"><strong>格式化字符串</strong></h2><ol><li><p>通过字符串前加f/F  然后直接引用变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">s = <span class="string">f&#x27;i have <span class="subst">&#123;a:-<span class="number">3</span>&#125;</span> apples&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure></li><li><p>通过字符串的format方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:-3&#125; apples&#x27;</span>.<span class="built_in">format</span>(<span class="number">10</span>)) <span class="comment"># 左对齐三位格式</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/04/python/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/../img/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96assets/image-20230305204838893.png" alt="image-20230305204838893"></p></li></ol><h2 id="不一样的作用域">不一样的作用域</h2><p>在python中,貌似对这个代码块作用域不太敏感</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出10</span></span><br></pre></td></tr></table></figure><p>如果在c++和 java中,这个代码肯定会报错,我去,那这样也太爽了</p><h2 id="call-方法">__call__方法</h2><p>a.__call__ () == a()  这么一来,我感觉函数跟类其实也没有什么区别</p><h2 id="type返回值">type返回值</h2><p>type的返回值就是一个类,他也是一个对象,因此我们是不是可以根据某个数据直接造出跟它一样类型的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getobj</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(obj)()</span><br><span class="line"><span class="built_in">print</span>(getobj(<span class="number">111</span>))</span><br><span class="line"><span class="built_in">print</span>(getobj(<span class="string">&quot;111&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(getobj([]))</span><br><span class="line"><span class="built_in">print</span>(getobj(&#123;&#125;))</span><br></pre></td></tr></table></figure><h2 id="切片">切片</h2><p>对于列表,元组,字符串这种,我们都可以使用切片来获得他们的子序列,  而且切片是可以越界的, 只会返回包含的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">print(a[1:10:1]) # [2,3]</span><br></pre></td></tr></table></figure><h1>额外补充</h1><h2 id="可变对象与不可变对象">可变对象与不可变对象</h2><p>我们可以通过id()得到一个整数值,它代表唯一的一个对象,我们也可以把它理解成地址</p><p>可变对象就是我们可以修改对象里面的内容,不可变对象是不可以修改里面的内容的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变对象</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">l += [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变对象</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 2775197888320  </span></span><br><span class="line"><span class="comment"># 2775197888320</span></span><br><span class="line"><span class="comment"># 140721313420960</span></span><br><span class="line"><span class="comment"># 140721313420992</span></span><br></pre></td></tr></table></figure><p>l += [10] 其实调用的是 __add__ 方法,它里面只是将10添加进去然后返回自己,所以地址值肯定没有变,而 a += 1 是返回了一个新的对象,所以地址值肯定变了, 所以对于这个所谓的可变对象与不可变对象,只是我们取决于我们在这些方法里面返回什么罢了,还有就是不可变对象可以通过 __setattr__里面抛出异常禁止我们设置值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.score = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, __name: <span class="built_in">str</span>, __value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;不允许操作&quot;</span>)</span><br><span class="line">s = Score()</span><br><span class="line">s.score = <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="对象属性访问和创建的规则">对象属性访问和创建的规则</h2><ul><li><p>当我们对一个实例属性进行访问时，Python 会按 <code>obj.__dict__</code> → <code>type(obj).__dict__</code> → <code>type(obj)的父类.__dict__</code> 顺序进行查找</p></li><li><p>当我们对一个实例属性,<strong>跟类属性不重名,或者类属性不是一个数据描述符</strong>,进行赋值的时候,如果obj.__dict__ 里面不存在,那么就创建,如果存在则修改</p></li><li><p>当我们对一个实例属性,<strong>跟类属性重名,而且类属性是一个数据描述符</strong>,进行赋值的时候, 一定是按照这个顺序<code>type(obj).__dict__</code> → <code>type(obj)的父类.__dict__</code> 去修改数据</p></li></ul><h2 id="property实现原理">property实现原理</h2><p>装饰器  +  属性描述符</p><p>我们好好想想这三个东西的功能:  property是将方法当成属性访问或者赋值,而且只要一访问就会执行这个方法并且得到返回值, 装饰器,能够增强函数的功能,  <strong>把函数当做参数传递到装饰器里面</strong>,属性描述符  当通过类或者实例点.属性名字的时候就会执行里面的 get set 方法</p><p>如果我们设计一个装饰器类,在init方法中保存修饰函数,它又正好是属性描述符,在get 和 set 方法里面执行对应的函数,用这个装饰器去修饰方法,那是不是就做到了通过访问属性名就能代替方法了</p><p>先看一个简单的例子吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testfunc</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,func</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.func(instance)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @testfunc</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">                </span><br><span class="line">t = test()   </span><br><span class="line"><span class="built_in">print</span>(t.age)  <span class="comment"># 输出18</span></span><br></pre></td></tr></table></figure><p>通过类装饰器testfunc 保存好age 函数,而且这个属性age也变成了testfunc类型,所以age是属性(非数据)描述符,所以当我们访问age这个属性的时候,就会调用get方法,而且还会传递实例对象和类对象过去,我们正好利用实例对象执行这个方法得到数据返回</p><p>这里我们只实现了get方法,那要是要设置set方法呢? 那就必须在test里面重载一个age方法,而且必须使用原先的age修饰器对象重新建一个新的对象,把set 和 get 方法都保存好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testfunc</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,get = <span class="literal">None</span>,<span class="built_in">set</span> = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.get = get</span><br><span class="line">        self.<span class="built_in">set</span> = <span class="built_in">set</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get(instance)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">set</span>(instance,value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setter</span>(<span class="params">self,<span class="built_in">set</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in setter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> testfunc(self.get, <span class="built_in">set</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @testfunc</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">    <span class="built_in">print</span>(age) </span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self,_age</span>):</span><br><span class="line">        self._age = _age</span><br><span class="line">    <span class="built_in">print</span>(age)   </span><br><span class="line">t = test()  </span><br><span class="line">t.age = <span class="number">28</span> </span><br><span class="line"><span class="built_in">print</span>(t.age)  <span class="comment"># 输出28</span></span><br></pre></td></tr></table></figure><p>在 test 类中 我们 打印了两次 age修饰器对象,发现两个是不一样的,但是最终又只有一个age对象存在类中,所以我们必须用原先的装饰器对象创建一个新的装饰器对象,这样才能把所有的 get set 方法 保存下来</p><h2 id="所有实例共享数据描述符">所有实例共享数据描述符</h2><p>先看看下面这种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,score</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;value invalid&quot;</span>)</span><br><span class="line">        self.score = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    score = Score(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,score</span>):</span><br><span class="line">       self.score = score</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">60</span>)</span><br><span class="line">student2 = Student(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(student.score)  <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span>(student2.score) <span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>我们惊奇的发现student 与 student2的 值居然一样了,这种数据描述符是有问题的,我们需要修改get 和 set方法,让他们返回和各个实例的属性值(但是这不意味着当我们通过实例访问与类同名的实例属性的时候就是直接访问它,其实还是访问的 类的dict,只不过我们根据不同实例返回不同值罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self,instance,owner</span>):</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self,instance,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;value invalid&quot;</span>)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    math = Score(<span class="string">&quot;math&quot;</span>)</span><br><span class="line">    chinese = Score(<span class="string">&quot;chinese&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,math,chinese</span>):</span><br><span class="line">       self.math = math</span><br><span class="line">       self.chinese = chinese</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">60</span>,<span class="number">60</span>)</span><br><span class="line">student2 = Student(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(student.math,student.chinese) <span class="comment"># 60 60</span></span><br><span class="line"><span class="built_in">print</span>(student2.math,student2.chinese) <span class="comment"># 100 100</span></span><br></pre></td></tr></table></figure><p>这样就可以啦,当我们进入Score 的 get 和 set 方法的时候,我们返回他们自己对应的属性,记得一定要用 dict 不要直接 .  因为使用 dict 不会触发 get 和 set 方法</p><h2 id="类装饰器注意点">类装饰器注意点</h2><p>在使用<strong>类装饰器</strong>修饰<strong>类方法</strong>时候,我们还必须得实现__get__ 这个方法,这是因为类方法属于一个属性,当我们通过类或者对象通过点去调用它的时候,会走__get__ 这个函数得到返回值再执行,所以我们的通过对象调用方法不需要再传递self,是因为function的__get__帮我们传递了,因此我们也需要自己在类修饰器的__get__里面传递self,  而<strong>函数装饰器我们就不需要去管这件事</strong></p><h2 id="多个装饰器需要注意的点">多个装饰器需要注意的点</h2><p>多个装饰器最需要注意的点是 后一个装饰器返回的东西到底是什么,是一个函数还是一个对象还是一个属性描述符,函数和可调用对象调用起来需要几个参数, 如果是一个属性描述符而且我们需要他的get方法被调用的话则必须位于第一个装饰器,所以像@staticmethod 和 @ classmethod 这些就必须放在最前面</p><h2 id="getattribute-和-getattr的区别">getattribute 和 getattr的区别</h2><p><strong>getattribute 对任何属性的获取都会走这个方法</strong>,  如果我们没有重写这个方法,  默认会调用object.__getattribute__这个方法,如果找到了访问的属性就会返回,如果没有找到就会调用getattr方法, 如果都没有找到就会报错</p><h2 id="线程池的实现">线程池的实现</h2><h2 id="设置清华源">设置清华源</h2><h3 id="临时使用">临时使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure><h3 id="设为默认">设为默认</h3><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip</span><br></pre></td></tr></table></figure><h1>答疑解惑</h1><h2 id="为什么类没有实现call方法却可以被调用-生成对象">为什么类没有实现call方法却可以被调用()生成对象</h2><p>哈哈哈,这里确实是一个迷惑点,  其实类也是一个对象,它是元类的对象, 一个对象能不能像方法那样被调用,是要看创建它的类是否具有call方法, 所以我们在类中有没有声明的call方法跟类能不能创建对象没有任何关系,而跟它创建的对象能不能被调用才有关系,  真正跟类能不能调用是跟元类中有没有call方法有关系**,type 是所有类的父类**,而它具有call 方法,所以所有的类一定能被调用</p><h2 id="实例对象属性的访问流程与赋值流程">实例对象属性的访问流程与赋值流程</h2><h3 id="默认访问流程-没有重写getattribute方法">默认访问流程(没有重写getattribute方法)</h3><ol><li>调用object.<code>__getattribute__</code>方法。</li><li>在类对象的<code>__dict__</code>中查找属性,如果是数据描述符,就调用它的get方法得到返回值返回,如果不是数据描述符就继续</li><li>在实例对象的<code>__dict__</code>中查找属性。<strong>如果找到了就返回这个值,没找到就继续往下走</strong></li><li>在类对象的<code>__dict__</code>中查找属性。<strong>处理方法、类变量和非数据描述符</strong></li><li>调用<code>__getattr__</code>方法 (<strong>这个方法一般需要我们重写,如果没有重写就不会调用,所以这个方法只有当属性找不到的时候才会被调用</strong>)</li><li>如果上述步骤都没有找到,抛出<code>AttributeError</code>异常。</li></ol><h3 id="默认赋值流程-没有重写setter方法">默认赋值流程(没有重写setter方法)</h3><ol><li>调用object.<code>__setattr__</code>方法。</li><li>在类对象的<code>__dict__</code>中查找属性。如果找到一个属性而且是数据描述符(具有get和set方法,其实只有set方法也可以,但是只要set方法没有意义),就会调用这个属性set方法并且将值传递给他, 如果没有找到属性,或者这个属性不具有set方法,那么就会往下走</li><li>将属性赋值到实例对象的<code>__dict__</code>。</li></ol><p><strong>这里我们就能解释数据描述符了, 为什么我们在init方法的时候对一个数据描述符赋值不会赋值到自己的dict里面,而是调用了类属性的set方法</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2023/03/03/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/03/03/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数学公式部分">数学公式部分</h2><p>使用$$ $$ 来定义一个公式块</p><p>列如下面这样</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hello world</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span></span></span></span></span></p><h3 id="公式">公式</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">markdown格式</th><th style="text-align:center">数学公式</th></tr></thead><tbody><tr><td style="text-align:center">上标</td><td style="text-align:center">A^2</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">A^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">下标</td><td style="text-align:center">A_2</td><td style="text-align:center">$ A_2 $</td></tr><tr><td style="text-align:center">组合</td><td style="text-align:center">B^{AC}</td><td style="text-align:center">$ B^{AC} $</td></tr><tr><td style="text-align:center">分数</td><td style="text-align:center">\frac{a+b}{c+d}</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mrow><mi>c</mi><mo>+</mo><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{a+b}{c+d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.283439em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td></tr><tr><td style="text-align:center">累乘</td><td style="text-align:center">\prod_1^n{n^2}</td><td style="text-align:center">$ \prod_1^n{n^2} $</td></tr><tr><td style="text-align:center">累加</td><td style="text-align:center">\sum_1^n{n}</td><td style="text-align:center">$ \sum_1^n{n}$</td></tr><tr><td style="text-align:center">开方</td><td style="text-align:center">\sqrt[3]{8}</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mn>8</mn><mn>3</mn></mroot></mrow><annotation encoding="application/x-tex">\sqrt[3]{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7868839999999999em;"><span style="top:-2.964664em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">8</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">积分</td><td style="text-align:center">\int^{10}_0{f(x)}dx</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mn>10</mn></msubsup><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int^{10}_0{f(x)}dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3648280000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0090080000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></td></tr><tr><td style="text-align:center">二重积分</td><td style="text-align:center">\iint f(x)dx</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∬</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\iint f(x)dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0004999999999999727em;">∬</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></td></tr><tr><td style="text-align:center">多重积分</td><td style="text-align:center">\iiiint f(x)dx</td><td style="text-align:center"><span class="katex-error" title="ParseError: KaTeX parse error: Undefined control sequence: \iiiint at position 1: \̲i̲i̲i̲i̲n̲t̲ ̲f(x)dx">\iiiint f(x)dx</span></td></tr><tr><td style="text-align:center">无穷</td><td style="text-align:center">\infty</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></td></tr><tr><td style="text-align:center">极限</td><td style="text-align:center">\lim_{n-&gt;\infty}</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>n</mi><mo>−</mo><mo>&gt;</mo><mi mathvariant="normal">∞</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\lim_{n-&gt;\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">−</span><span class="mrel mtight">&gt;</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">右箭头</td><td style="text-align:center">\lim_{n\rightarrow\infty}</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\lim_{n\rightarrow\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">长箭头</td><td style="text-align:center">\longrightarrow</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span></td></tr><tr><td style="text-align:center">大于等于</td><td style="text-align:center">\geq</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span></td></tr><tr><td style="text-align:center">小于等于</td><td style="text-align:center">\leq</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span></td></tr><tr><td style="text-align:center">属于</td><td style="text-align:center">\in</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span></td></tr><tr><td style="text-align:center">加减</td><td style="text-align:center">\pm</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo></mrow><annotation encoding="application/x-tex">\pm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">±</span></span></span></span></td></tr><tr><td style="text-align:center">点乘</td><td style="text-align:center">A \cdot B</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cdot B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></td></tr><tr><td style="text-align:center">除</td><td style="text-align:center">\div</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">÷</span></span></span></span></td></tr><tr><td style="text-align:center">删除线</td><td style="text-align:center">\not =</td><td style="text-align:center">$ \not =$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">\not 5</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5̸</mn></mrow><annotation encoding="application/x-tex">\not 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></td></tr><tr><td style="text-align:center">对数</td><td style="text-align:center">\log_28</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mn>8</mn></mrow><annotation encoding="application/x-tex">\log_28</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span></span></span></span></td></tr><tr><td style="text-align:center">对数</td><td style="text-align:center">\ln10</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ln</mi><mo>⁡</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\ln10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></td></tr><tr><td style="text-align:center">垂直</td><td style="text-align:center">A \bot B</td><td style="text-align:center">$ A \bot B $</td></tr><tr><td style="text-align:center">度数</td><td style="text-align:center">30^\circ</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mn>0</mn><mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">30^\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∘</span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">正弦</td><td style="text-align:center">\sin 30^\circ</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mn>3</mn><msup><mn>0</mn><mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">\sin30^\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∘</span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td style="text-align:center">省略号</td><td style="text-align:center">\cdots</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span></td></tr><tr><td style="text-align:center">向量</td><td style="text-align:center">\mathbf A</td><td style="text-align:center">$ \mathbf A $</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="希腊字母表">希腊字母表</h3><p><img src="/2023/03/03/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/markdown%E8%AF%AD%E6%B3%95/../img/markdown%E8%AF%AD%E6%B3%95assets/view.png" alt="preview"></p><h3 id="矩阵">矩阵</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">  \begin&#123;matrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;matrix&#125; \tag&#123;1&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line"> \left\&#123;</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;matrix&#125;</span><br><span class="line">  \right\&#125; \tag&#123;2&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line"> \left[</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;matrix&#125;</span><br><span class="line">  \right] \tag&#123;3&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1      &amp; 2      &amp; \cdots &amp; 4      \\</span><br><span class="line"> 7      &amp; 6      &amp; \cdots &amp; 5      \\</span><br><span class="line"> \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line"> 8      &amp; 9      &amp; \cdots &amp; 0      \\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] \tag&#123;4&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$ </span><br><span class="line">\left[</span><br><span class="line">    \begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">      1 &amp; 2 &amp; 3 \\</span><br><span class="line">      4 &amp; 5 &amp; 6</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right] \tag&#123;5&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd></mtr></mtable></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{matrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \end{matrix} \tag{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left\{ \begin{matrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \end{matrix}  \right\} \tag{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.00501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎭</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎬</span></span></span><span style="top:-4.00501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[ \begin{matrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \end{matrix}  \right] \tag{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(4)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[ \begin{matrix} 1      &amp; 2      &amp; \cdots &amp; 4      \\ 7      &amp; 6      &amp; \cdots &amp; 5      \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 8      &amp; 9      &amp; \cdots &amp; 0      \\ \end{matrix} \right] \tag{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.5799999999999996em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.3800000000000006em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">4</span></span><span class="mord">)</span></span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnalign="center center center" columnlines="none solid" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(5)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\left[    \begin{array}{cc|c}      1 &amp; 2 &amp; 3 \\      4 &amp; 5 &amp; 6    \end{array} \right] \tag{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="vertical-separator" style="height:2.4em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-0.95em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span><span class="tag"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8位CPU制作</title>
      <link href="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/"/>
      <url>/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我感觉做CPU对于电子专业的人来说应该是容易事,我一个计算机专业的,感觉有点小吃力,但是我还是决定把它啃完</p><p>本次采用LogicCircuit仿真软件</p><h2 id="半加器">半加器</h2><p>SUM = A^B  CO = A&amp;B</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230227164357496.png" alt="image-20230227164357496"></p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230227164441719.png" alt="image-20230227164441719"></p><h2 id="全加器">全加器</h2><p>全加器有三个输入位,一个是上一位加法的进位</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230227165116663.png" alt="image-20230227165116663"></p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230227165126475.png" alt="image-20230227165126475"></p><h2 id="八位加法器">八位加法器</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230227171422226.png" alt="image-20230227171422226"></p><h2 id="8位选择器">8位选择器</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230227200823907.png" alt="image-20230227200823907"></p><p>两个输入中选一个输出</p><h2 id="8位取反器">8位取反器</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230227200901508.png" alt="image-20230227200901508"></p><h2 id="8为与门">8为与门</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228145237465.png" alt="image-20230228145237465"></p><h2 id="8位或门">8位或门</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228145251282.png" alt="image-20230228145251282"></p><h2 id="au">AU</h2><p>AU模块包含了加法和减法</p><p>当OP为0时做加法</p><p>当OP为1时做减法</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228145334754.png" alt="image-20230228145334754"></p><p>控制端为0 表示 A+B 控制端为1表示 A-B</p><h2 id="lu">LU</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228145542397.png" alt="image-20230228145542397"></p><p>控制端为0 表示 A&amp;B 控制端为1表示 A | B</p><h2 id="alu">ALU</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228174359707.png" alt="image-20230228174359707"></p><p>真值表</p><table><thead><tr><th style="text-align:center">控制端</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">xx00</td><td style="text-align:center">A+B</td></tr><tr><td style="text-align:center">xx01</td><td style="text-align:center">A-B</td></tr><tr><td style="text-align:center">xx10</td><td style="text-align:center">A&amp;B</td></tr><tr><td style="text-align:center">xx11</td><td style="text-align:center">A|B</td></tr></tbody></table><h2 id="单数码管-2进制变16进制">单数码管(2进制变16进制)</h2><p>通过4位地址控制ROM输出8位控制数据,让数码管显示一位16进制数据,控制线en控制是否显示</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228171734877.png" alt="image-20230228171734877"></p><h2 id="双数码管-2进制变16进制">双数码管(2进制变16进制)</h2><p>这里面的数码管是上面的单数码管,前四位控制第一个16进制数据,后四位控制第二个16进制数据</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228172212397.png" alt="image-20230228172212397"></p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228155356963.png" alt="image-20230228155356963"></p><h2 id="三数码管-2进制变10进制">三数码管(2进制变10进制)</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228172758212.png" alt="image-20230228172758212"></p><p>通过ROM将八位二进制数据对应的十进制的分成三个四位bcd码,然后依次交给单个数码管</p><p>ROM里面的数据经过精心处理的</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228171014085.png" alt="image-20230228171014085"></p><p>这个数据的生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\asus\\Desktop\\a&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">short</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] array = ByteBuffer.allocate(<span class="number">2</span>).order(ByteOrder.LITTLE_ENDIAN).putShort(Short.valueOf(i+<span class="string">&quot;&quot;</span>,<span class="number">16</span>)).array();</span><br><span class="line">            System.out.println(Arrays.toString(array)+<span class="string">&quot;  ----  &quot;</span>+array.length);</span><br><span class="line">            fileOutputStream.write(array);</span><br><span class="line">        &#125;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="震荡电路">震荡电路</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228175243121.png" alt="image-20230228175243121"></p><p>当我们运行打开开关之后</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228175346278.png" alt="image-20230228175346278"></p><h2 id="r-s触发器">R-S触发器</h2><p>这个触发器可以一直所存一位数据</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228210230222.png" alt="image-20230228210230222"></p><p>这个电路有缺点,输出是随机的,你可以自己去分析一下,因此我们需要置零和预设</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228222905500.png" alt="image-20230228222905500"></p><p>这个电路还有有缺陷,因为我们必须保证R 和 S 不同时为1,你想啊,你同时set跟ReSet,是不是就不太对,所以有了下面的电路</p><h2 id="d触发器">D触发器</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228222918819.png" alt="image-20230228222918819"></p><p>这样我们可以在EN为1的情况下通过D数据端设置输出</p><h2 id="d边缘触发器">D边缘触发器</h2><p>我们只有在低电平变成高电平才能设置数据</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230228222935854.png" alt="image-20230228222935854"></p><h2 id="t触发器">T触发器</h2><p>这个其实也是反转器,当时钟从低电平到高电平,内部状态会反转一次,要么0-&gt;1要么1-&gt;0</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301132414332.png" alt="image-20230301132414332"></p><h2 id="计数器">计数器</h2><p>我们将多个T触发器相连,就构成了计数器</p><blockquote><p>通过看电路图我们可以分析到,前一个T触发器从低电平到高电平跳变两次,后一个才会跳变一次,这不就是天然的二进制么</p></blockquote><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301170505076.png" alt="image-20230301170505076"></p><h2 id="三态门-可以控制八位数据的输出">三态门(可以控制八位数据的输出)</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301144600702.png" alt="image-20230301144600702"></p><h2 id="字节存储器">字节存储器</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301144259006.png" alt="image-20230301144259006"></p><p>这个可以存储八个字节的数据</p><h2 id="寄存器">寄存器</h2><p>寄存器相对于上面这个字节存储器多了一个读写线</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301165653013.png" alt="image-20230301165653013"></p><h2 id="38译码器">38译码器</h2><p>真值表</p><table><thead><tr><th>A2</th><th>A1</th><th>A0</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td>0</td><td>1</td><td></td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td>1</td><td>0</td><td></td><td></td><td>1</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td>1</td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr><tr><td>1</td><td>0</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td>1</td><td>1</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td><td>1</td><td></td></tr><tr><td>1</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>1</td></tr></tbody></table><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301152522954.png" alt="image-20230301152522954"></p><blockquote><p>这里其实用ROM来做更快</p></blockquote><h2 id="寄存器组">寄存器组</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301160739830.png" alt="image-20230301160739830"></p><h2 id="存储器扩展">存储器扩展</h2><p>位扩展: 就是存储单元数量不变,存储单元变大,这个样的话地址线不用变,数据线需要变多</p><p>字扩展: 就是存储单元数量变多,存储单元大小不变,这样的话地址线需要扩充,数据线不用变</p><p>8x1 就代表 有8个存储单元,每个存储单元能存8比特(1字节)  =&gt; 我们可以得出 地址线为3根 数据线为8根</p><p>8x2 就代表 有8个存储单元,每个存储单元能存16比特(2字节)  =&gt; 我们可以得出 地址线为3根 数据线为16根</p><p>16x2 就代表 有16个存储单元,每个存储单元能存16比特  =&gt; 我们可以得出 地址线为4根 数据线为8根</p><h2 id="特殊开关">特殊开关</h2><p>这个开关可以用来控制ALU加法,可以自动加法,也可以手动调试加法</p><p>解释一下吧,POW相当于电源,RES 是清零按钮(负责清楚寄存器和计数器的值),MAN 是开启手工调试按钮,PULL 是手动产生时钟变化按钮,p是输入位,用于停止产生时钟</p><p>如果POW没有被开启,那么reset会一直生效,这样的话寄存器和计数器肯定被清零,</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301192644742.png" alt="image-20230301192644742"></p><h2 id="自动加法">自动加法</h2><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230301193804122.png" alt="image-20230301193804122"></p><h2 id="程序计数器">程序计数器</h2><h2 id="解答疑惑">解答疑惑</h2><p>自我提问:  为什么寄存器要设置成只有时钟信号从0变成1并且允许写入数据时才能接受数据,而不是直接设置成只要允许写入数据的时候就可以接受数据了呢?</p><p>解答:    如果只片面的看待寄存器,那么它确实只需要一个控制端就行而不需要时钟, 但是我们需要站在全局的角度来看, 首先要计算机能够自动化,必须要有时钟,也就是震荡器,然后配合计数器,这样它能够推动指令一条一条执行,通过了解计数器我们知道,指令会持续一整个时钟周期,也就是从0-&gt;1-&gt;0,就像下面这个红色范围内的黑色线一样</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230302173257501.png" alt="image-20230302173257501"></p><p>如果我们的寄存器只需要允许写入数据就行的话,那么当我们的指令是从某种提供了数据之后就会立即变化的组件中拿数据到寄存器中的时候就会出现问题,持续0时间段数据就已经拿到寄存器了**,0-&gt;1 后<strong>提供数据的组件提供数据发生变化(0-&gt;1 跳变或者 1-&gt;0 跳变 是很多自动化的组件的执行时机,因此数据很有可能就会变化),你别忘了,指令是一整个周期有效,那么持续1的时间,就会把新的数据拿到寄存器中,这样是不是出现了问题,如果我们把寄存器设置成只有从</strong>0-&gt;1跳变的时候**才会接收数据,那么就不会出现这个问题</p><p>在逻辑电路中,我们确实只需要一个控制端,但是在时序电路中,这是不行的,必须要一个时钟 控制信号</p><p>我们可以用一个从内存中取数据做减法的电路图证明</p><p>内存数据</p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230302175237595.png" alt="image-20230302175237595"></p><p><strong>不需要时钟线的寄存器电路</strong></p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230302175557041.png" alt="image-20230302175557041"></p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230302175848382.png" alt="image-20230302175848382"></p><p><strong>带有时钟线的寄存器电路</strong></p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230302180017215.png" alt="image-20230302180017215"></p><p><img src="/2023/02/26/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPU/../img/%E8%87%AA%E5%88%B6%E5%85%AB%E4%BD%8DCPUassets/image-20230302180556348.png" alt="image-20230302180556348"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Proteus 仿真软件的使用</title>
      <link href="/2023/02/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Proteus%208/"/>
      <url>/2023/02/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Proteus%208/</url>
      
        <content type="html"><![CDATA[<h2 id="常用元器件英文名字">常用元器件英文名字</h2><p><strong>resistor</strong> 电阻</p><p><strong>LED</strong> LED灯</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>考研-计算机组成原理总结</title>
      <link href="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/"/>
      <url>/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/</url>
      
        <content type="html"><![CDATA[<h1>第一章 计算机系统概述</h1><p>计算机系统由软件系统和硬件系统组成</p><p>计算机的性能的好坏取决于软件,硬件的总和</p><p>我们需要将源代码翻译成汇编代码,然后再将汇编代码转变成机器码, 源代码翻译成汇编代码然后变成机器码有两种方式,一种是编译,另外一种是解释</p><p>编译是一次性将代码全部机器码,生成目标可执行文件,后续无需在翻译,可以直接执行</p><p>解释是执行一条语句翻译一次,后续需要使用还需要重新翻译</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225165856304.png" alt="image-20230225165856304"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225165914713.png" alt="image-20230225165914713"></p><p>这个微程序机器其实是由硬件实现的,将机器语言转变为一系列的微指令</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225170045953.png" alt="image-20230225170045953"></p><p><strong>计算机体系结构</strong>关注的是<strong>计算机系统的概念性设计和功能特点</strong>，而<strong>计算机组成则更关注计算机系统的具体实现和运作方式</strong>。两者相互依存，计算机组成是计算机体系结构实现的基础，而计算机体系结构则为计算机组成提供了设计和指导的思路。</p><h2 id="计算机的组成">计算机的组成</h2><h3 id="冯洛伊曼计算机特点">冯洛伊曼计算机特点</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225170731190.png" alt="image-20230225170731190"></p><blockquote><p>需要注意的是,典型的冯洛伊曼计算机是以运算器为中心,而现代计算机都是以存储器为中心</p></blockquote><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225170908530.png" alt="image-20230225170908530"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225171033337.png" alt="image-20230225171033337"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225171142763.png" alt="image-20230225171142763"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225171214215.png" alt="image-20230225171214215"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225171329092.png" alt="image-20230225171329092"></p><p>运算器各个寄存器的作用和功能</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225173130778.png" alt="image-20230225173130778"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225172409980.png" alt="image-20230225172409980"></p><p>控制器是计算机的指挥中枢,负责指挥各个部件协调,自动工作,完成执行指令需要三个阶段: 取指,分析,执行</p><p>控制器中的寄存器</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225173151852.png" alt="image-20230225173151852"></p><p>PC 是程序计数器,记录下一条指令的地址   IR 是指令寄存器  记录当前执行指令</p><h2 id="计算机硬件的指标">计算机硬件的指标</h2><h3 id="机器字长">机器字长</h3><p>机器字长是CPU一次能够处理数据的位数,与CPU里面的寄存器位数有关,机器字长也会影响运算速度,对于那些多字节数据的运算,如果机器字长不够,可能需要几次运算</p><h3 id="存储容量">存储容量</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225174219161.png" alt="image-20230225174219161"></p><h3 id="运算速度">运算速度</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225174901639.png" alt="image-20230225174901639"></p><h1>第三章 总线</h1><h2 id="总线分类">总线分类</h2><h3 id="片内总线">片内总线</h3><p>CPU内部的线,用于连接各个寄存器,寄存器与ALU</p><h3 id="系统总线">系统总线</h3><p>CPU,内存,IO设备之间的连线</p><p>系统总线按照类别又可以分为三类: 数据总线 地址总线 控制总线</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225182628212.png" alt="image-20230225182628212"></p><h3 id="通信总线">通信总线</h3><p>用于连接各个计算机之间的线</p><h2 id="总线特性">总线特性</h2><h3 id="机械特性">机械特性</h3><p>尺寸啊,形状,连接设备的引脚个数,排列顺序啊</p><h3 id="电气特性">电气特性</h3><p>有效信号的电平范围,信号的传递方向</p><h3 id="功能特性">功能特性</h3><p>传递信号所代表的功能</p><h3 id="时间特性">时间特性</h3><p>信号在哪个时间内有效</p><h2 id="总线性能指标">总线性能指标</h2><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225183349208.png" alt="image-20230225183349208"></p><h2 id="总线结构">总线结构</h2><h3 id="单总线结构">单总线结构</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225182202728.png" alt="image-20230225182202728"></p><p>列如这种,多个IC连接在一根总线上的结构就是单总线结构</p><p>这种结构有个缺点就是,只能有一个部件发送数据,这会影响系统的工作效率,对于有很多的部件连接在上面,那么势必会有延时,而且如果传输大量数据,会一直占据总线,这样是会极大的降低系统工作效率的</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225183949055.png" alt="image-20230225183949055"></p><h3 id="多总线结构">多总线结构</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225182103940.png" alt="image-20230225182103940"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225182211351.png" alt="image-20230225182211351"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184100371.png" alt="image-20230225184100371"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184107206.png" alt="image-20230225184107206"></p><h2 id="总线判优">总线判优</h2><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184402050.png" alt="image-20230225184402050"></p><h3 id="集中式">集中式</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184840709.png" alt="image-20230225184840709"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184903901.png" alt="image-20230225184903901"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184916782.png" alt="image-20230225184916782"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184924343.png" alt="image-20230225184924343"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184933306.png" alt="image-20230225184933306"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225184942619.png" alt="image-20230225184942619"></p><h2 id="总线通信控制">总线通信控制</h2><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225204414865.png" alt="image-20230225204414865"></p><h3 id="同步通信">同步通信</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225204750103.png" alt="image-20230225204750103"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225204813052.png" alt="image-20230225204813052"></p><p>这样其实是有缺点的,如果两个设备速度不统一的话,时间就要设置的长一些,必须要满足慢的设备能够接受</p><h3 id="异步通信">异步通信</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225204944790.png" alt="image-20230225204944790"></p><h4 id="不互锁方式">不互锁方式</h4><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225205041835.png" alt="image-20230225205041835"></p><p>就是发完请求之后,等待一段时间,撤销请求,就可以直接发送数据了</p><h4 id="半互锁方式">半互锁方式</h4><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225205212110.png" alt="image-20230225205212110"></p><p>发送方必须等到接收方答复后才能撤销请求,然后发起数据,而接收方不用等到发送方撤销请求后才能撤销回答,过一段时间后自动撤销回答信号</p><h4 id="全互锁方式">全互锁方式</h4><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225205645387.png" alt="image-20230225205645387"></p><p>发送方必须等到接收方回答后才能撤销请求,接收方必须等到发送发撤销请求后才能撤销回答</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225205923159.png" alt="image-20230225205923159"></p><p>做到题吧</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225210017379.png" alt="image-20230225210017379"></p><p>120 * (7+1+1+1) = 1200 bps</p><h3 id="半同步通信">半同步通信</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225210450258.png" alt="image-20230225210450258"></p><p>其实就是多了一根等待线,如果是低电平,主模块就是等从模块一下</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225210821542.png" alt="image-20230225210821542"></p><h3 id="分离式通信">分离式通信</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225210952996.png" alt="image-20230225210952996"></p><h2 id="知识点总结">知识点总结</h2><h3 id="总线概述">总线概述</h3><p>​<strong>总线的定义</strong>: 是一种能由多个部件分时共享的公共传输路线</p><p>​<strong>总线传输特点</strong>: 某一时刻只允许一个部件发送数据,但是可以多个部件接收相同数据</p><p>​<strong>总线中地址线是单向的,数据线是双向的</strong></p><h3 id="总线判优">总线判优</h3><p>​总线判优是为了解决<strong>多个部件同时</strong>使用总线时<strong>使用权的分配问题</strong></p><p>​<strong>三种总线判优方式对比</strong></p><p>​链式查询方式连线简单,易于扩充,对电路故障敏感</p><p>​计数器定时查询优先级设置灵活,对故障不敏感,连线和控制过程复杂</p><p>​独立查询请求方式最快,但如果硬件量多,连线就很多,成本高</p><h3 id="总线性能指标">总线性能指标</h3><p>​总线<strong>宽度</strong>: 数据总线的根数</p><p>​总线带宽: 传输数据的速率</p><p>​总线复用: 同一个线可以传输不通的信号</p><h3 id="总线通信">总线通信</h3><p>​<img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225213743308.png" alt="image-20230225213743308"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E7%8E%8B%E9%81%93408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230225213850353.png" alt="image-20230225213850353"></p><p>分离式通信主要用于大型计算机系统</p><h3 id="总线标准">总线标准</h3><p>总线标准的设置主要解决不同厂家各类模块化产品的兼容问题</p><h1>第四章 存储器</h1><h2 id="概述">概述</h2><h3 id="存储器的分类">存储器的分类</h3><ol><li><p>根据存储介质：</p><p>a. 半导体存储器：以半导体芯片为基础的存储器，如RAM（随机存取存储器）和ROM（只读存储器）。</p><p>b. 磁存储器：使用磁介质进行信息存储的设备，如硬盘、磁带和磁盘阵列。</p><p>c. 光存储器：使用光学介质进行信息存储的设备，如CD、DVD和蓝光光盘。</p></li><li><p>根据数据存取方式：</p><p>a. 随机存取存储器（RAM）：允许任意顺序访问数据的存储器，如DRAM（动态随机存取存储器）和SRAM（静态随机存取存储器）。</p><p>b. 只读存储器（ROM）：存储内容在生产后就固定的存储器，如EPROM（可擦写可编程只读存储器）和EEPROM（电可擦写可编程只读存储器）。</p><p>c. 顺序存取存储器（SAM）：按顺序访问数据的存储器，如磁带存储器。</p></li><li><p>根据存储器容量和性能：</p><p>a. 主存储器（Primary Memory）：直接与处理器进行数据交换的存储器，如RAM和部分ROM。主存储器通常具有较高的存取速度和较低的容量。</p><p>b. 辅助存储器（Secondary Memory）：作为主存储器容量扩展的存储器，如硬盘、光盘和磁带。辅助存储器通常具有较大的容量，但存取速度相对较慢。</p></li><li><p>根据数据保持特性：</p><p>a. 易失性存储器（Volatile Memory）：在断电时会丢失存储的数据，如DRAM和SRAM。</p><p>b. 非易失性存储器（Non-Volatile Memory）：在断电时仍能保持存储的数据，如ROM、闪存（Flash Memory）、硬盘和光盘。</p></li></ol><h2 id="主存储器">主存储器</h2><h3 id="技术指标">技术指标</h3><p>主存的主要技术指标是容量和速度</p><h4 id="存储容量">存储容量</h4><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412170319655.png" alt="image-20230412170319655"></p><h4 id="存储速度">存储速度</h4><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412170554039.png" alt="image-20230412170554039"></p><h4 id="存储带宽">存储带宽</h4><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412170736647.png" alt="image-20230412170736647"></p><h3 id="随机存储器">随机存储器</h3><p>随机存储分为两类,静态RAM 和动态RAM</p><p>它们各自具有不同的特点和性能，以下是它们的特点和区别：</p><p>静态RAM（SRAM）：</p><ol><li>存储单元：SRAM中每个存储单元由六个晶体管（或四个晶体管和两个电容）组成，形成一个双稳态触发器，用于存储一个比特（0或1）。</li><li>存储数据稳定性：SRAM不需要刷新以保持存储的数据。只要有电源供应，数据就会保持稳定。</li><li>速度：SRAM的访问速度较快，因为不需要刷新操作。</li><li>功耗：SRAM在操作和待机时功耗较高，因为需要维持双稳态触发器的状态。</li><li>成本和集成度：SRAM的制造成本较高，集成度较低，因为每个存储单元需要更多的晶体管。</li><li>应用场景：SRAM常用于高速缓存（如CPU的L1、L2和L3缓存）、实时系统和低容量高速存储器的应用。</li></ol><p>动态RAM（DRAM）：</p><ol><li>存储单元：DRAM中每个存储单元由一个晶体管和一个电容组成。电容用于存储一个比特（0或1），电荷表示1，无电荷表示0。</li><li>存储数据稳定性：DRAM需要定期刷新以保持存储的数据，因为电容会随时间漏电。</li><li>速度：DRAM的访问速度相对较慢，因为需要定期进行刷新操作。</li><li>功耗：DRAM在操作时功耗较高（因为需要刷新），但待机时功耗较低。</li><li>成本和集成度：DRAM的制造成本较低，集成度较高，因为每个存储单元只需要一个晶体管和一个电容。</li><li>应用场景：DRAM常用于主存储器（如计算机、服务器和工作站的系统内存），因为具有较高的容量和较低的成本。</li></ol><h4 id="dram-的刷新操作">DRAM 的刷新操作</h4><p>由于DRAM是用电容来存储数据的,而电容具有易失性,因此我们需要隔一段时间就刷新一下,一般是2ms就需要刷新一次</p><p><strong>集中刷新</strong></p><p>就是统一一个时间对DRAM中的每一行进行刷新,这个过程中CPU是不能访问DRAM的,因此这个时间也被称为死区</p><p><strong>分散刷新</strong></p><p>每读写一次数据,就对DRAM中的一行进行刷新,这样的话会导致刷新频率较高,对于分散刷新没有死区我们可以理解为将时钟周期分为两半,前一半用来读取数据,后一半用来刷新</p><p><strong>异步刷新</strong></p><p>我们发现分散刷新的频率有点快了,我们可以在一定时间范围内,刷新一行数据,如果还把这个时间时间安排在CPU译码阶段,那么久不存在死区</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230413172256523.png" alt="image-20230413172256523"></p><h1>第七章 指令系统</h1><h2 id="机器指令">机器指令</h2><p>机器指令是计算机能够理解和执行的一种基本指令。它通常是以二进制代码表示的，直接被计算机硬件解释和执行。机器指令是构成程序的基本元素，计算机执行程序时，实际上是在按顺序执行一系列机器指令</p><h3 id="指令的一般格式">指令的一般格式</h3><p>计算机指令的一般格式因架构和指令集而异，但大多数指令都包含以下几个部分：</p><ol><li>操作码（Opcode）：操作码是指令的核心部分，它指示了计算机应执行的操作。操作码通常是一个固定长度的二进制字段，每个操作码对应一种特定的操作，如加法、减法、乘法、除法、逻辑运算等。</li><li>操作数（Operands）：操作数是指令中需要进行操作的数据。操作数可以是寄存器、内存地址或立即数。指令可以包含一个或多个操作数，具体取决于操作的类型。</li><li>寻址模式（Addressing Mode）：寻址模式描述了如何从指令中获取操作数。例如，立即寻址表示操作数是一个立即数，直接在指令中给出；寄存器寻址表示操作数存储在寄存器中；间接寻址表示操作数的地址存储在另一个寄存器或内存单元中。</li><li>其他字段：根据具体的指令集和架构，指令可能还包含其他字段，如条件码、标志位、扩展位等。</li></ol><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412124103968.png" alt="image-20230412124103968"></p><h2 id="寻址方法">寻址方法</h2><h3 id="指令寻址">指令寻址</h3><p>指令寻址是指计算机如何确定下一条指令的地址。这里的“指令寻址”可能涉及到程序计数器（Program Counter，PC）的更新和控制流指令。以下是一些常见的指令寻址方式：</p><ol><li>顺序寻址（Sequential Addressing）：程序计数器按顺序递增，指向下一条指令。这是最基本的指令寻址方式，通常用于顺序执行指令。</li><li>跳转寻址（Jump Addressing）：程序计数器被设置为一个指令中给出的地址，从而实现无条件跳转。这种寻址方式常用于实现循环、子程序调用和返回等。</li><li>条件跳转寻址（Conditional Jump Addressing）：根据某个条件（如标志寄存器的状态），程序计数器被设置为一个指令中给出的地址或顺序递增。这种寻址方式常用于实现条件分支和循环控制。</li><li>间接跳转寻址（Indirect Jump Addressing）：程序计数器被设置为一个寄存器或内存单元中存储的地址。这种寻址方式实现了指针和引用的功能，可以用于实现动态跳转、函数指针等。(<strong>地址中的地址</strong>,也就是一个地址指向了指令的地址)</li><li>返回寻址（Return Addressing）：程序计数器被设置为调用子程序时保存的返回地址。这种寻址方式常用于实现子程序调用的返回。</li><li>中断寻址（Interrupt Addressing）：在中断发生时，程序计数器被设置为一个预先定义的中断处理程序的地址。这种寻址方式常用于实现中断处理和异常处理。</li></ol><p>指令寻址方式决定了计算机如何确定下一条指令的地址。这些寻址方式与数据寻址方式共同构成了计算机指令的执行过程，影响着程序的控制流和数据处理能力。不同的计算机架构和指令集可能支持不同的指令寻址方式组合，以满足不同的应用需求。</p><h3 id="数据寻址">数据寻址</h3><p>寻址格式</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412144220718.png" alt="image-20230412144220718"></p><p>数据寻址是指计算机指令中如何确定操作数地址的方法。不同的计算机架构和指令集可能支持不同的寻址方式。以下是一些常见的寻址方式：</p><ol><li>立即寻址（Immediate Addressing）：操作数直接在指令中给出，不需要访问内存。这种寻址方式适用于常数和小值。</li><li>寄存器寻址（Register Addressing）：操作数存储在寄存器中，指令中给出寄存器的编号。这种寻址方式速度快，因为寄存器是处理器内部的存储单元。</li><li>直接寻址（Direct Addressing）：操作数的内存地址直接在指令中给出。这种寻址方式适用于访问全局变量和静态数据。</li><li>间接寻址（Indirect Addressing）：操作数的内存地址存储在另一个寄存器或内存单元中。指令中给出该寄存器或内存单元的地址。这种寻址方式可以实现指针和引用的功能。</li><li>基址寻址（Base Addressing）：操作数的内存地址由一个基址寄存器的值加上一个指令中给出的偏移量计算得出。这种寻址方式适用于访问数组和结构体等复合数据类型。<strong>这个过程中基址寄存器里面的值是不能变的</strong></li><li>变址寻址（Indexed Addressing）：操作数的内存地址由一个索引寄存器的值加上一个指令中给出的偏移量计算得出。这种寻址方式常用于循环和迭代操作。<strong>这个过程中基址寄存器里面的值是可以变的</strong></li><li>相对寻址（Relative Addressing）：操作数的内存地址由当前指令的地址加上一个指令中给出的偏移量计算得出。这种寻址方式常用于条件分支和跳转指令。</li><li>堆栈寻址（Stack Addressing）：<strong>操作数存储在堆栈中</strong>，指令通过操作堆栈指针（如入栈、出栈）来访问操作数。这种寻址方式常用于函数调用和局部变量的管理。<strong>本质也还是间接寻址</strong></li></ol><h2 id="指令设计考虑因素">指令设计考虑因素</h2><p>在设计指令格式时，需要考虑以下几个关键因素：</p><ol><li>操作码（Opcode）：操作码需要足够长，以便表示足够多的指令。操作码的长度将影响指令集的大小和指令集的可扩展性。</li><li>寻址模式（Addressing Modes）：需要考虑支持哪些寻址模式以满足不同类型的操作数访问需求。设计时应在功能丰富和复杂度之间进行权衡。</li><li>操作数（Operands）：需要确定操作数的长度和表示方式。操作数的长度将影响数据处理的范围和精度。</li><li>寄存器数量和寄存器宽度：需要确定寄存器文件的大小，以及每个寄存器的位宽。这会影响指令的编码方式以及处理器的性能和资源利用率。</li><li>指令长度：需要确定指令的长度。较短的指令可以节省存储空间和带宽，但可能限制了操作码和操作数的表示范围。较长的指令可以提供更多的操作码和操作数表示范围，但可能增加存储和带宽需求。</li><li>扩展性和兼容性：设计时需要考虑指令格式的扩展性，以便未来添加新的指令或修改现有指令。同时，也需要考虑与现有或其他指令集的兼容性。</li><li>性能和功耗：需要考虑指令格式对处理器性能和功耗的影响。指令格式的设计应该有助于简化处理器的实现，提高执行效率并降低功耗。</li><li>简单性和易用性：设计时需要权衡指令格式的简单性和易用性。简单的指令格式有助于降低处理器的实现复杂度和提高可靠性，但可能限制了功能的丰富性。</li></ol><p>这些因素相互影响，设计指令格式时需要在各种需求之间进行权衡。不同的计算机架构和指令集可能采用不同的指令格式设计，以满足特定的应用场景和性能需求。</p><h2 id="risc技术">RISC技术</h2><p>RISC（Reduced Instruction Set Computer，精简指令集计算机）是一种计算机架构理念，其核心思想是使用较少的指令和简化的指令集来提高处理器性能。RISC架构的主要特点如下：</p><ol><li><strong>指令集简化</strong>：RISC采用较少的指令和寻址模式，降低了处理器实现的复杂性。</li><li><strong>固定长度指令</strong>：RISC通常使用固定长度的指令，有助于简化指令解码和提高指令执行效率。</li><li>加载/存储架构：RISC通常采用加载/存储架构，<strong>即所有数据操作都是在寄存器之间进行</strong>，<strong>内存访问仅通过加载和存储指令完成</strong>。这有助于简化指令和处理器实现。</li><li>大量寄存器：RISC通常具有较多的通用寄存器，以减少对内存的访问需求，提高性能。</li><li>单周期指令执行：RISC设计中的许多指令可以在一个时钟周期内完成执行，提高了处理器的吞吐量。</li></ol><p>相比之下，CISC（Complex Instruction Set Computer，复杂指令集计算机）是另一种计算机架构理念。CISC架构的特点包括：</p><ol><li><strong>复杂的指令集</strong>：CISC包含大量的指令和寻址模式，以便支持更丰富的功能。</li><li><strong>变长指令</strong>：CISC通常使用变长指令，可以节省存储空间，但可能增加指令解码的复杂性。</li><li>内存操作：<strong>CISC允许某些指令直接操作内存，而不仅仅是加载和存储</strong>。</li><li>多周期指令执行：<strong>CISC中的许多指令可能需要多个时钟周期才能完成执行</strong>。</li></ol><p>RISC和CISC架构有各自的优缺点。RISC架构通过简化指令集和指令格式以提高性能，但可能牺牲了功能丰富性。CISC架构具有丰富的功能和灵活性，但可能导致处理器实现和性能方面的问题。这两种架构并非绝对的优劣之分，而是针对不同需求和应用场景所作的权衡。</p><p>随着技术的发展，RISC和CISC架构之间的界限逐渐模糊。许多现代处理器采用了混合架构，结合了RISC和CISC的优点。例如，许多现代处理器在内部采用RISC架构，但对外提供CISC兼容的指令集，从而兼顾了性能和兼容性。</p><h2 id="习题">习题</h2><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412161025285.png" alt="image-20230412161025285"></p><h3 id="指令设计">指令设计</h3><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412161200025.png" alt="image-20230412161200025"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412161243554.png" alt="image-20230412161243554"></p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412161257867.png" alt="image-20230412161257867"></p><p>做这是设计指令的题目的时候,我们要注意他的操作码是定长还是变长,  指令字长是定长还是变长, 寻址方式有多少种等等,一般按照这种格式来设计</p><p><img src="/2023/02/25/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86assets/image-20230412161510977.png" alt="image-20230412161510977"></p><blockquote><p>A可能有很多,毕竟操作数又不止一个</p></blockquote><p>op代表操作码,M代表寻址模式,A代表地址或者寄存器或者就是操作数</p><p>做上面这些道题的时候我们应该要注意这些单位,比如指令长度,机器字长,存储字长</p><h2 id="总结">总结</h2><h1>BCD码</h1><p>BCD码（Binary-Coded Decimal，二进制编码的十进制数）是一种将十进制数表示为二进制数的编码方法。在BCD编码中，每个十进制数字（0-9）都用一个4位的二进制数表示。这种编码方法使得二进制系统能够方便地表示和处理十进制数据。</p><p>BCD码的主要应用和优点如下：</p><ol><li>易于阅读和理解：与纯二进制表示相比，BCD码表示的十进制数更容易阅读和理解。这对于需要人与计算机之间直接进行数据交互的场景非常有用，例如显示器、计算器等。</li><li>简化数据转换：BCD编码简化了十进制与二进制之间的转换过程。因为每个十进制数字都有一个固定的4位二进制表示，所以在将十进制数转换为BCD码或将BCD码转换为十进制数时，不需要复杂的算法，只需简单地映射即可。</li><li>错误检测：BCD编码可以更容易地检测一些数据错误。例如，如果一个4位二进制数的值大于1001（即十进制的9），那么这个数就是一个无效的BCD码。这种错误检测能力有助于提高数据处理的可靠性。</li></ol><p>然而，BCD编码也存在一些缺点，如存储和计算效率较低。由于每个十进制数用4位二进制表示，BCD码需要更多的存储空间来存储相同数量的数据。此外，在进行算术运算时，BCD编码需要特殊的算法和硬件支持，这可能导致运算效率低于纯二进制表示。</p><p>尽管如此，在某些应用场景中，BCD编码仍然非常有用，特别是在需要处理十进制数据或方便人类阅读的场合。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序是怎么样运行的</title>
      <link href="/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-计算机进行小数运算时出错的原因">第三章 计算机进行小数运算时出错的原因</h2><p>如果我们使用简单的二进制来表示小数,我们会发现二进制有时候根本表示不了很多小数</p><p><img src="/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/../img/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84assets/image-20230224211210629.png" alt="image-20230224211210629"></p><p>如果我们想让二进制表示一个0.1 他都表示不了,只能无限接近,因此在做运算的时候肯定会有误差的,当然我们也不会用这种二进制简单的来表示浮点数,人很聪明,想到了科学计数法,我们可以模仿这种方法来设计如何保存浮点数</p><p><img src="/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/../img/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84assets/image-20230224212803370.png" alt="image-20230224212803370"></p><h3 id="浮点数的保存方法">浮点数的保存方法</h3><p>一般的语言都会提供<strong>double</strong>(双精度),<strong>float</strong>(单精度)这两种方式记录浮点数</p><p><img src="/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/../img/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84assets/image-20230224212818197.png" alt="image-20230224212818197"></p><p>符号部分记录这个数的正负</p><p><strong>指数部分</strong>保存指数的值(基数是2哦),这里不是简单的使用这个值去表示指数,而是以中间值为基准,中间值代表0,列如浮点数中</p><p>(11111111)/2 = 01111111  这个数代表0, 10000000 表示1 ,01111110 表示-1</p><p><strong>尾数部分</strong>保存移位后的值,  移位的时候我们要保证小数点第一位左边第一位必须是1,而且左边只有一个1,右边不需要管,尾数部分记录的就是右边部分的值,这样是不是很巧妙,可以节省一位值</p><p>我们可以验证一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a = <span class="number">4.5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> buf = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;buf,&amp;a,<span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">32</span>;k++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((buf&gt;&gt;(<span class="number">32</span>-k))&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span> || k== <span class="number">9</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出:</p><p><img src="/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/../img/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84assets/image-20230224213815725.png" alt="image-20230224213815725"></p><p>我们计算一下:</p><p>符号部分: 正数</p><p>指数部分:  10000001 - 01111111 = 2</p><p>尾数部分: ( 1*(2^0) + 0 * (2^-1) + 0 * (2^-2) + 1 * (2^-3) ) * 2^2 = 4.5   不要忘记还有个1的部分哦</p><h2 id="第七章-运行环境">第七章 运行环境</h2><p>运行环境 = 操作系统 + 硬件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阅读书籍和选择书籍方法总结</title>
      <link href="/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E9%98%85%E8%AF%BB%E9%80%89%E6%8B%A9%E4%B9%A6%E7%B1%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/22/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E9%98%85%E8%AF%BB%E9%80%89%E6%8B%A9%E4%B9%A6%E7%B1%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>作为新手,我通常是通过阅读书籍进行学习的,但是在书籍选择上,我做的并不是很好,比如说我想看操作系统的书,我从一开始就选择了黑皮书,很厚很晦涩,我翻了几页就不想翻了,因为我压根就没兴趣,也看不太懂,这就代表我们选择错了,我们应该先选择一本循序渐进的书籍,而不是一上来就跟我们扯这些理论知识,像这种黑皮书,更像是一个完整的知识体系,是给那种想进一步完善自己知识体系的人学习的,而不是给新手学习的</p><blockquote><p>什么是一本适合自己的书籍?</p><p>就我个人而言,就是能理解它在讲什么,让我产生了不少思考,并且没有让我感到无聊,即使是一些概念</p></blockquote><p>其实我们应该先选择入门书籍,再选择进阶书籍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编码</title>
      <link href="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/"/>
      <url>/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-手电筒的剖析">第四章 手电筒的剖析</h2><p>这章感觉像电路知识,哈哈哈哈</p><p>电池是通过化学反应将电子从正极移动到负极,如果有导线连接正负极的时候,化学反应才会发生的很快,如果电池没有连接导线,那么化学反应会发生的很慢很慢(不代表不发生,因为负极的电子也可能跑掉,正极补充到电子)</p><p>电子是很难直接通过空气流动的,物质的导电能力是由它的核外电子结构决定的,如果最外电子层只有一个电子,那么这个电子是很容易逃逸的</p><p>对于电流能够流通的的物体我们叫做<strong>导体</strong>,对于那些几乎不能导电的物体,我们叫做<strong>绝缘体</strong>,<strong>但是不存在理想绝缘体,这些绝缘体就相当于一个阻值很大很大的电阻罢了,通过他的电流非常小,小到可以忽略不计,当我们有足够大的电压时,也能产生很大的电流</strong></p><p>那些导电性很好的导体也具有阻性,只不过他们的电阻比较小罢了,导线越长,电阻越大,导线越粗,电阻越小,这是为什么呢,导线越粗,电子可以选择的通路就越多</p><p>电子在高速移动的过程中,也会产生摩擦吧,这样是不是就会发热?,如果导线直接连接电视两端,而阻值比较小, 那这样的话,导线就会持续发热,然后就会烧掉</p><p>电流只有有和无,灯泡的也只有发光和不发光,因此这是不是也是二进制的一种体现</p><h2 id="第五章-绕过拐角的通信">第五章 绕过拐角的通信</h2><p>crazying,居然可以用地球当导体,这个跟上一节讲的导线越粗电子越小,只要给足够的电压,任何东西可以导电,那么地球是不是也可以这么理解啊,我去,但是这个电压是需要非常大的</p><h2 id="第十一章-门">第十一章 门</h2><p>我们知道用导线一圈一圈围绕在铁棒上,通电后可以产生磁性跟磁铁一样,断电后又不具有磁性了,这个东西叫继电器,那么我是不是可以用继电器来充当开关,通电代表打开,没电代表关闭</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153002264.png" alt="image-20230220153002264"></p><p>这样我们就能造出很多逻辑门</p><h3 id="与门-and">与门 (AND)</h3><p>只有当所有的输入端都为1时才能输出1,否则就是0,这个就是与门</p><p>用在这个图里解释就是,只有所有通电器通电了,灯泡才能亮</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153843677.png" alt="image-20230220153843677"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153130424.png" alt="image-20230220153130424"></p><p>因此我们可以将上面那张继电器的图表示为</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153208111.png" alt="image-20230220153208111"></p><p>上面只有两个输入端,其实我们可以用多个与门制造多个输入端</p><p>比如这样</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153420235.png" alt="image-20230220153420235"></p><h3 id="或门-or">或门(OR)</h3><p>只要所有的输入端中只要有一个输入为1,输出就是1</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153912809.png" alt="image-20230220153912809"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153730717.png" alt="image-20230220153730717"></p><h3 id="非门-not">非门(NOT)</h3><p>输出和输入端相反</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220153953276.png" alt="image-20230220153953276"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220154113732.png" alt="image-20230220154113732"></p><h3 id="或非门-nor">或非门(NOR)</h3><p>这个可以理解为一个或门串联一个非门,但实际上还是只有两个继电器</p><p>只要输入端中有1,就输出0,否则就输出1</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220154829712.png" alt="image-20230220154829712"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220154849496.png" alt="image-20230220154849496"></p><h3 id="与非门-nand">与非门(NAND)</h3><p>这个可以理解为一个与门与一个或门连接</p><p>只要输入端有0,就输出1,否则就输出0</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220155005433.png" alt="image-20230220155005433"></p><h3 id="异或门">异或门</h3><p>这个就不用说了</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220203044696.png" alt="image-20230220203044696"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220203316541.png" alt="image-20230220203316541"></p><h3 id="缓冲器">缓冲器</h3><p>一个最原始的继电器就是一个缓冲器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220155433114.png" alt="image-20230220155433114"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220155447464.png" alt="image-20230220155447464"></p><p>它的输入跟输出是一样的,当输入信号很微弱的时候,可以使用缓冲器增强信号(因为继电器只需要很小的信号就可以运行,它运行后输入的信号可以强的多),另外,还可以延迟信号</p><h2 id="第十二章-二进制加法器">第十二章 二进制加法器</h2><h3 id="半加器">半加器</h3><p>一位加法 可以产生一个和,一个进位</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220203219564.png" alt="image-20230220203219564"></p><p>我们用下面这种方法表示一位加法器,也叫半加器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220203401903.png" alt="image-20230220203401903"></p><p>叫半加器是因为,对于有两个二进制位的数字相加,第一次相加只有两位数据,而第二次相加有三位数据(两个加法位,一个进位),因此我们还需要一个全加器(三位加法运算)</p><h3 id="全加器">全加器</h3><p>三位加法器被称为全加器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220204200190.png" alt="image-20230220204200190"></p><p>为了方便都用这种方法记做全加器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220204239610.png" alt="image-20230220204239610"></p><h3 id="多位加法器">多位加法器</h3><p>利用全加器,我们可以制作多位加法器</p><p>八位加法器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220204321524.png" alt="image-20230220204321524"></p><p>16位加法器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220204449354.png" alt="image-20230220204449354"></p><blockquote><p>现在我们一般不用继电器了,体积大,噪声大,现在一般使用晶体管,虽然材料不一样,但是原理都是一样的</p></blockquote><h2 id="第十四章-反馈与触发器">第十四章 反馈与触发器</h2><h3 id="振荡器">振荡器</h3><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220214838528.png" alt="image-20230220214838528"></p><p>我去,这个图有点意思,当我们把开关关下去之后,铁棒会带有磁性,然后将金属弹片拉下来</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220214946459.png" alt="image-20230220214946459"></p><p>然后电路断开,金属弹片又会回去</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220215020159.png" alt="image-20230220215020159"></p><p>这样是不是就循环起来了,如果有击打声,那岂不是就是电铃了</p><p>这个其实就是振荡器,它的电子元件图有点看着别扭,不太好理解</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230220215435173.png" alt="image-20230220215435173"></p><p>振荡器输出按某种规律进行,我们可以测出它的周期,进而得到它的频率</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221150627410.png" alt="image-20230221150627410"></p><p>我们使用HZ来当振荡器的频率单位,比如:</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221150820506.png" alt="image-20230221150820506"></p><p>这个振荡器每0.05s就是一个循环,那么它的频率就是 1/0.05 = 20HZ   就是1秒钟循环20次震荡</p><h3 id="锁存器">锁存器</h3><h4 id="rs锁存器">RS锁存器</h4><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221151241427.png" alt="image-20230221151241427"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221160251469.png" alt="image-20230221160251469"></p><p>卧槽这个东西又比较吊了,它居然可以存储状态</p><p>当我们给上边这个开关关上(就是输入1),然后左边这个或非门输出0,下面这个开关没有合上,所以右边这个或非门输出1,所以灯泡亮了,然而,我们会发现这个时候,上面这个开关是否开合都不能影响这个电路的最后输出了,</p><p>可以存储状态的两个或非门电路中，<strong>右边的或非门的继电器的电源开关通常是由左边的或非门的输出控制的</strong>。<strong>这种电路被称为 SR（Set-Reset）或闪存器</strong>。<strong>左边的或非门可以被视为“设置”输入</strong>，<strong>右边的或非门可以被视为“重置”输入</strong>。当左边的或非门的输出为1时，它会将右边的继电器开关置为1，从而存储一个状态。当左边的或非门的输出为0时，它会将右边的继电器开关置为0，从而重置存储的状态。</p><blockquote><p>其实这个R 和 S 是相对的,是要看输出的Q 与 Q’  如果要的输出值是Q,那么R就是reset端,S就是Set端,如果要的输出值是Q’,那么就反过来</p></blockquote><p>需要注意的是，这种电路有可能处于不稳定的状态，即所存储的状态不明确或者不符合预期。因此，在实际应用中，需要使用更加复杂的电路来保证稳定性，比如使用时钟信号来控制存储和读取操作。</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221160456196.png" alt="image-20230221160456196"></p><p>这里就算我们输入1, 1 其实也不会对电路造成任何影响,只不过这样没有任何意义,我们可以简化这个RS触发器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221160710488.png" alt="image-20230221160710488"></p><p><strong>其实这个电路有个缺点,就是我们并不知道这个一开始的输出是什么,它是随机的,因此我们需要一个预设个清零</strong></p><p>通常情况下,我们使用跟好的电路来代替这个触发器,这样可以避免一些误操作</p><blockquote><p>我们要保证R和S 必须相反,所以我们有了如下电路,时钟用来控制可以写入和重置</p></blockquote><h4 id="d锁存器">D锁存器</h4><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221163016241.png" alt="image-20230221163016241"></p><p>这个是一位锁存器,我们平时当然是八位一起的</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221163040420.png" alt="image-20230221163040420"></p><h4 id="d边缘触发器">D边缘触发器</h4><p>这个电路只有当时钟从低电平变到高电平才有效</p><p>因为,在两个D锁存器中**,一次只能设置一个锁存器,而当时钟是低电平的时候,我们只能设置第一个锁存器**,而如果时钟处于高电平的时候,第一个锁存器的数据会变到第二个锁存器中,而此时第一个锁存器的数据也已经无法改变,<strong>所以只有在低电平的时候事先将数据放到数据端,等到时钟从0跳变到1的时候数据会从第一个锁存器中变输入到第二个锁存器中</strong></p><p>时钟低电平:  只能设置第一个锁存器</p><p>时钟高电平: 第一个锁存器不能被设置数据,第二个锁存器被设置成第一个的数据</p><p>如果我们想更改第二个锁存器数据,必须在低电平期间设置数据端</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230228213013864.png" alt="image-20230228213013864"></p><h4 id="更完美的d边缘触发器">更完美的D边缘触发器</h4><p>上面的触发器有个缺点就是,在一开始R-S的输出都是随机的,</p><p>前面我们只有两个输入位,这个有四个输入位,预置和清零都会覆盖时钟和数据的输入</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230222132743446.png" alt="image-20230222132743446"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230222132752233.png" alt="image-20230222132752233"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230222132939580.png" alt="image-20230222132939580"></p><h3 id="分频器-t触发器">分频器(T触发器)</h3><p>这个是由<strong>D边缘触发器</strong>与振荡器相连,时钟从低电平变到高电平的时候才会改变一次状态</p><blockquote><p>这里如果采用锁存器和D触发器就会发生震荡,因为时钟信号会有一段时间处于高电平的状态,这个时间段D可以设置数据的话,那么会飞快的交替0和1</p></blockquote><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221163611415.png" alt="image-20230221163611415"></p><p>这个电路的Q输出端的频率变化是CLK 的一半,因此是不是也就分频了,如果多个分频器相连,就会有分的更小</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221164211210.png" alt="image-20230221164211210"></p><p>我们来看周期图,并且标上0/1</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221164245351.png" alt="image-20230221164245351"></p><p>倒过来看,是不是就是一个二进制的进位表</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221164308431.png" alt="image-20230221164308431"></p><h3 id="计数器">计数器</h3><blockquote><p>我们通过连接多个T触发器的电路可以发现,第一个T触发器从低电平到高电平跳变两次,第二个触发器才跳变一次,这个是不是就是二进制了?,逢二进一</p></blockquote><p>我们将多个分频器相连是不是就变成了计数器</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221164607659.png" alt="image-20230221164607659"></p><p>因此我们可以通过计数器来测试时钟频率,把这些输出全部连上灯泡,打开开关后开始计时,等到下一次灯泡全部熄灭了后 停止计时,然后用2的灯泡个数次幂除以时间就得到频率了</p><h2 id="第十六章-存储器组织">第十六章 存储器组织</h2><h3 id="三八译码器">三八译码器</h3><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221181208801.png" alt="image-20230221181208801"></p><h3 id="八一选择器">八一选择器</h3><p>这个就是在三八译码器的基础上加了一个8端口或门</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221181325769.png" alt="image-20230221181325769"></p><h2 id="第十七章-自动操作">第十七章 自动操作</h2><p>我们来看看自动进行累加操作吧</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230221205745990.png" alt="image-20230221205745990"></p><p>由于这个系统没有硬盘,所以数据必须我们自动提供</p><p>我们需要通过控制面板去手动将数据输入到指定位置</p><p>来说一下这个过程吧</p><p>首先必须合上清零开关,让震荡器一直处于0这个计数位置,那个8位锁存器也全部处于0数据,然后通过控制面板输入数据,最后打开清零开关,这个时候震荡器开始计数,将制定地址输入到RAM中,然后RAM输出指定位置数据到加法器中,然后将加法器中的数据和锁存器的数据相加,然后将输入写会锁存器,以此往复</p><p>这个缺点有点大,它根本不会停止,我们也不知道什么时候要停止</p><p>因此我们需要更加复杂的自动加法器,进而需要设置更复杂的电路来识别我们所给的指令</p><p><strong>硬件</strong>就是实实在在看到东西,开关,显示屏,键盘,而<strong>软件</strong>就是代码和指令,叫做软件主要是因为他们很容易被修改</p><h2 id="第十八章-从算盘到芯片">第十八章 从算盘到芯片</h2><p>在冯洛伊曼提出存储程序之前,人们都是用纸带存储数据</p><h3 id="晶体管">晶体管</h3><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230222140836548.png" alt="image-20230222140836548"></p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230222140903540.png" alt="image-20230222140903540"></p><p>我们来看看晶体管的与门与或门吧</p><p><img src="/2023/02/20/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A0%81/../img/%E7%BC%96%E7%A0%81assets/image-20230222141400611.png" alt="image-20230222141400611"></p><p>使用晶体管可以减少计算机的体积,电量,但是无法简化计算机的结构,相反,晶体管更小,要将这么多晶体管连线起来,也不是件容易事,</p><p>因此我们可以将晶体管先组合成门,然后通过这些门去连接成振荡器,加法器等等,在有这些东西去组成更强大的东西,然后构成集成电路</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>股票基本知识</title>
      <link href="/2023/02/19/%E8%82%A1%E7%A5%A8/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/02/19/%E8%82%A1%E7%A5%A8/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一直想玩玩股票,得亏现在腾地出时间来,好好玩一玩</p><p>玩之前得告诉自己几件事:</p><ul><li>心态要好</li><li>赚不赚钱无所谓,学到东西最重要</li></ul><h2 id="一-炒股要求必懂的基本术语">一、炒股要求必懂的基本术语</h2><p>也许你经常会看到一些股市牛人每天更新大盘，用上的各种术语你是看得一头雾水，这样的话，即使再好再准的股评你也是看不明白的，等于这些信息将于你无关，所以作为新手，一定要入乡随俗把一些基本的股市术语理解了，才能在股市里有更好的交流。下面就全面的给大家讲解一些基本的术语。</p><p><img src="/2023/02/19/%E8%82%A1%E7%A5%A8/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/../img/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86assets/v2-9d40b3f620dcd5b54cf64abda0248e2b_720w.webp" alt="img"></p><p><strong>基本面：</strong><br>基本面包括宏观经济运行态势和上市公司基本情况。宏观经济运行态势反映出上市公司整体经营业绩，也为上市公司进一步的发展确定了背景，因此宏观经济与上市公司及相应的股票价格有密切的关系。上市公司的基本面包括财务状况、盈利状况、市场占有率、经营管理体制、人才构成等各个方面。基本面在长线投资方面的运用较多，基本面分析可以有以下步骤：了解该公司，多花时间，弄清楚这家公司的经营状况。以下是一些获得资料的途径:公司网站；财经网站和股票经纪提供的公司年度报告；新闻报道–有关技术革新和其它方面的发展情况；发展潜力、无形资产、实物资产和生产能力；与竞争对手相比，该公司的经营策略、市场份额如何；资产的账面价值；销售增长率；净资产收益率观察股价走势图；专家的分析；内幕消息(特别要留意这个，内幕消息有真也有假，所以哪怕得到内幕消息了也还是要研究一番，避免被套。)</p><p><img src="/2023/02/19/%E8%82%A1%E7%A5%A8/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/../img/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86assets/v2-37d4b47bd29af36a79d912301b0d655f_720w.webp" alt="img"></p><p><strong>技术面：</strong><br>技术面指反映介变化的技术指标、走势形态以及K线组合等。技术分析有三个前提假设，即市场行为包容一切信息；价格变化有一定的趋势或规律；历史会重演。由于认为市场行为包括了所有信息，那么对于宏观面、政策面等因素都可以忽略，而认为价格变化具有规律和历史会重演，就使得以历史交易数据判断未来趋势变得简单了。当然，它的也有基本的理论依据：道琼斯理论；斐波纳契反驰现象；埃利奥特氏波。</p><p>如果要从技术面分析，以下的内容是必须有的：<br>1、发现趋势——发现整体的趋势是炒股布局的根本依据；<br>2、支撑和阻力——支撑和阻力水准是图表中经受持续向上或向下压力的点。两者是可以相互转换的，如一旦支撑水准被打破，它就会转变成阻力。<br>3、线条和通道——趋势线在识别市场趋势方向方面是简单而实用的工具；<br>4、平均线——移动平均线的不足之一在于它们滞后于市场，因此并不一定能作为趋势转变的标志，无论使用5和20天的移动平均线，还是40和200天的移动平均线，买入信号通常在较短期平均线向上穿过较长期平均线时被查觉。与此相反，卖出信号会在较短期平均线向下穿过较长周期平均线时被提示。</p><p>牛市：牛市也称多头市场，指市场行情普通看涨，延续时间较长的大升市。</p><p>熊市：熊市也称空头市场，指行情普通看淡，延续时间相对较长的大跌市。</p><p>牛皮市：指在所考察交易日里，证券价格上升、下降的幅度很小，价格变化不大，市价像被钉住了似的，如牛皮之坚韧。</p><p>集合竞价：所谓集合竞价就是在当天还没有成交价的时候，根据前一天的收盘价和对当日股市的预测来输入股票价格，而在这段时间里输入计算机主机的所有价格都是平等的，不需要按照时间</p><p>优先和价格优先的原则交易，而是按最大成交量的原则来定出股票的价位，这个价位就被称为集合竞价的价位，而这个过程被称为集合竞价。</p><p>连续竞价：所谓连续竞价，即是指对申报的每一笔买卖委托。</p><p>零股交易：不到一个成交单位(1手=100股)的股票，如1股、10股，称为零股.在卖出股票时，可以用零股进行委托；但买进股票时不能以零股进行委托，最小单位是1手，即100股。</p><p>派息：股票前一日收盘价减去上市公司发放的股息称为派息。</p><p>含权：凡是有股票有权未送配的均称含权。</p><p>除权：除权是由于公司股本增加，每股股票所代表的企业实际价值(每股净资产)有所减少，需要在发生该事实之后从股票市场价格中剔除这部分因素，而形成的剔除行为。</p><p>填权：指除权后该股票价格出现上涨，将除权前后的价格落差部分完全补回的情形。</p><p>贴权：贴权是指在除权除息后的一段时间里，如果多数人不看好该股，交易市价低于除权(除息)基准价，即股价比除权除息前有所下降，则为贴权。</p><p>XR：证券名称前记上XR,表示该股已除权，购买这样的股票后将不再享有分红的权利。当股票名称前出现XR的字样时，表明当日是这只股票的除权日。</p><p>除息：除息由于公司股东分配红利，每股股票所代表的企业实际价值(每股净资产)有所减少，需要在发生该事实之后从股票市场价格中剔除这部分因素，而形成的剔除行为。</p><p>DR：证券代码前标上DR，表示除权除息，购买这样的股票不再享有送股派息的权利。</p><p>XD：证券代码前标上XD，表示股票除息，购买这样的股票后将不再享有派息的权利。</p><p>配股：配股是上市公司根据公司发展的需要，依据有关规定和相应程序，旨在向原股东进一步发行新股、筹集资金的行为。</p><p>分红配股：分红即是上市公司对股东的投资回报；配股是上市公司按照公司发展的需要，根据有关规定和相应程序，向原股东增发新股，进一步筹集资金的行为。</p><p>送红股：送红股是上市公司将本年的利润留在公司里，发放股票作为红利，从而将利润转化为股本。</p><p>转增股本：转增股本是指公司将资本公积转化为股本，转增股本并没有改变股东的权股益，但却增加了股本规模，因而客观结果与送红股相似。</p><p><strong>二、A股、B股、H股、ST股、蓝筹股、红筹股、普通股</strong><br><strong>股票的分类拓扑图：</strong></p><p><img src="/2023/02/19/%E8%82%A1%E7%A5%A8/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/../img/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86assets/v2-2227bb9bf041779faa41d0b2ccb71470_720w.jpeg" alt="img"></p><p><strong>第一、按投资主体分：</strong><br>国有股：指所有权代表国家投资的部门或者机构以国有资产向公司投资形式的股份。<br>法人股：指企业法人或具有法人资格的事业单位和社会团体以其依法可经营的资产向公司非上市流通股权部分投资所形成的股份。<br>社会公众股：指我国境内个人和机构，以其合法财产向公司可上市流通股权部分投资所形成的股份。</p><p><strong>第二、按股票的上市地点和所面对的投资者分：</strong><br>A股：人民币普通股票，它是由我国境内的公司发行，供境内机构、组织或个人（不含台、港、澳投资者）以人民币认购和交易的普通股股票。</p><p>B股：人民币特种股票，它是以人民币标明面值，以外币认购和买卖，在境内（上海、深圳）证券交易所上市交易的。它的投资人限于：外国的自然人、法人和其他组织，香港、澳门、台湾地区的自然人、法人和其他组织，定居在国外的中国公民。B股公司的注册地和上市地都在境内。只不过投资者在境外或在中国香港、澳门以及台湾地区。</p><p>H股：注册地在内地、上市地在香港的外资股。</p><p>N股：在内地注册的股份有限公司，但在美国纽约发行并在纽约证券交易所上市交易的股票。</p><p>S股：在内地注册的股份有限公司，但在新加坡发行并在新加坡证券交易所上市交易的股票。</p><p>L股：在内地注册的股份有限公司，但在英国伦敦发行并在伦敦证券交易所上市交易的股票。</p><p><strong>第三、按海外市场分：</strong><br>蓝筹股：蓝筹股是指稳定的现金股利政策对公司现金流管理有较高的要求，通常将那些经营业绩较好，具有稳定且较高的现金股利支付的公司股票称为“蓝筹股”。蓝筹股多指长期稳定增长的、大型的、传统工业股及金融股。“蓝筹”一词源于西方赌场，在西方赌场中，有三种颜色的筹码、其中蓝色筹码最为值钱。</p><p>红筹股：这一概念诞生于90年代初期的香港股票市场。中华人民共和国在国际上有时被称为红色中国，相应地，香港和国际投资者把在境外注册、在香港上市的那些带有中国大陆概念的股票称为红筹股。</p><p><strong>第四、按股票的基础分类分：</strong><br>普通股：指的是在公司的经营管理和盈利及财产的分配上享有普通权利的股份，代表满足所有债权偿付要求及优先股东的收益权与求偿权要求后对企业盈利和剩余财产的索取权。它构成公司资本的基础，是股票的一种基本形式，也是发行量最大，最为重要的股票。目前在上海和深圳证券交易所上中交易的股票，都是普通股。</p><p>优先股：是相对于普通股而言的。主要指在利润分红及剩余财产分配的权利方面，优先于普通股。</p><p><strong>第五、按公司状况分：</strong><br>ST股：沪深交易所宣布，将对财务状况或其它状况出现异常的上市公司股票交易进行特别处理(Special treatment)，并在简称前冠以“ST”，因此这类股票称为ST股。</p><p>*ST—公司经营连续三年亏损，退市预警。</p><p>ST----公司经营连续二年亏损，特别处理。</p><p>S*ST–公司经营连续三年亏损，退市预警+还没有完成股改。</p><p>SST—公司经营连续二年亏损，特别处理+还没有完成股改。</p><p>S----还没有完成股改。</p><p>PT股：停止任何交易，价格清零，等待退市的股票。PT 是英文Particular Transfer(特别转让）的缩写。依据《公司法》和《证券法》规定，上市公司出现连续三年亏损等情况，其股票将暂停上市。</p><p><strong>三、股票投资的风险和收益计算</strong></p><p><img src="/2023/02/19/%E8%82%A1%E7%A5%A8/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/../img/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86assets/v2-c1c3e7ffa49f0c4edfaebe7e89475e3d_720w.png" alt="img"></p><p>任何一种投资工具都有其风险与报酬。当然，报酬率越高者，风险性也较高。以一般保守的投资人最爱的定存来说，定存每年的报酬率大约都在5%以下，不过却少有风险。至于期货、房地产就属于高报酬高风险的投资工具了。</p><p>买股票与银行储蓄存款及购买债券相比较，它是一种高风险行为，但同时它也能给人们带来更大的收益。</p><p><strong>那么购买股票能带来哪些好处呢？</strong><br>由于现在人们投资股票的主要目的并非在于充当企业的股东，享有股东权利，所以购买股票的好处主要体现在以下几个方面:<br>（1）每年有可能得到上市公司回报，如分红利、送红股。</p><p>（2）能够在股票市场上交易，获取买卖价差收益。</p><p>（3）能够在上市公司业绩增长、经营规模扩大时享有股本扩张收益。这主要是通过上市公司的送股、资本公积金转增股本、配股等来实现。</p><p>（4）投资金额具弹性，相对于房地产与期货，投资股票并不需要太多资金。由于股票价位多样化，投资人可选择自己财力足可负担的股票介入。</p><p>（5）变现性佳。若投资人急需用钱，通常都能在当天卖出股票，则下下一个交易日便可以收到股款。 与房地产相比较，变现性较佳。 但目前中国股票市场上市公司越来越多，也出现了若干流动性不佳的股票，投资人在选择股票的时候，需多加注意。</p><p>（6）在通货膨胀时期，投资好的股票还能避免货币的贬值，有保值的作用。<br>目前国内常见的投资工具包括：定存、股票、基金、债券、期货、房地产…等。这些投资工具各有其报酬与风险状况。<br><strong>四、成交量与换手率详解</strong><br>一般投资者买卖股票采取两种炒做方式：一种是以基本面选股；另一种是以技术面选股。通常基本面选股者注重市场外消息面对股市的影响，技术面选股者注重指标与形态变化。而技术面又分为技术与反技术操作，其实就是庄家利用基本面提示的观点和容易被广大投资者识破的技术趋势进行反向操作，也是股市通常人们称为的“诱多”与“诱空”行情。<br>无论选择基本面还是选择技术面，量在价先已成为当前买卖股票最基本的常识，因为股市出现异动，量放大了还是缩小了，是向上突破还是向下突破都需要量上的配合。因此买卖股票都不会脱离量对个股走势的影响。<br>尤其一些个股受基本面利空或利多产生突发巨量下跌或上涨时，个别投资者总会盲目操作，其实能够出现这种走势往往都是庄家刻意行为，其中骗术成份最大。对于这种现象首先要分清量放在什么价位上，K线出现什么样的形态，不是什么样的放量突发行情投资者都会受益。市场一旦出现巨量大阳和巨量大阴都属不正常行为，而简单冲动的炒做思维往往又被眼前的辉煌套在里面，因此技术分析者比较喜欢利用形态等技术指标共同研判再作定酌。<br>一般成交量大小是查阅个股相对时间内的换手率，由于换手率只对个股而言，所以通常对个股换手率分析还要注重股权结构上的变化。比如有些投资者对新股炒做比较注重上市头几日的换手率，尤其当该股换手率非常高时，都会激发对该股走势的关注，但在之后就不那么敏感了，就是因为通过换手率找到了庄家持仓的比例与成本。因此研判个股成交量大小并不等于换手率的大小，而研判换手率大小是以阶段平均换手率和最高换手率之比的一种研判。通过不同阶段查阅股价出现的换手变化分析，预测该股相对一个时间后将会出现什么样的走势。<br>一、换手率在1%到2%时，股价运行在小阴小阳窄幅波动中，趋势一般处于横盘整理较为多见，操作上也称为散户行情。对于这种调整走势尤其出现短期头部形态后都不建议参与，判断这种行情是否已经出现，除了理解政策面与基本面对市场内生产的影响之外仍然可以利用成交量关系研判。<br><strong>股市操作其中有几种不参与行情：</strong><br>其一、大盘缩量调整不参与，即浪费时间又承担市场风险，每次买入赔率大于90%；<br>其二、大盘或自己持有的个股出现大阳不参与，这种形态往往是庄家出货时机。<br>其三、持有的个股股价在相对高位放巨量不参与，这也是庄家出货表现。<br>其四、公布利多不参与，公布有融资倾向消息不参与。<br>二、换手率提高到3%到6%，股价通常出现较为活跃走势，但不一定会产生突破行情。对于这种换手一般投资者应先适量把握个股不同趋势下的形态变化，再研判换手率放大是否会导致股价是向下还是向上，不能一味只求成交放大了就认为股价该涨了。一般换手率在3%到6%之间的行情多发于个股基本面传出的新消息，比如股权结构出现调整，中报、年报预亏或预喜。<br><strong>五、股票买卖过程中手续费的计算</strong><br>新晋投资者在买股票时会发现，为什么刚买入股票价格还没波动受益立马变成负数。这里就有一个手续费如何计算的问题存在，那么下面我们就来讲解这个问题</p><p><strong>交易时收费项目主要有三个项目：印花税、过户费、券商佣金。</strong><br>印花税：这个税只在卖出股票的时候收取，收费方式为成交金额的千分之一，由国家进行征收。</p><p>过户费：这个只在买卖上海股票的时候收取，收费方式为成交股数的万分之零点二，不足一元按一元收取。而过户费只有在买入上证A股时才会收取。</p><p>与其他人成本最大的不同就在于交易佣金，佣金在不同券商区别较大，有万分之三的也有千分之一的，不足5元的按5元收取。故选择正确的券商进行开户或者跟券商进行佣金的协商是非常必要的。</p><p>**举例说明：**假设我在开户时的券商给出的佣金收费比例也是万分之三，2016年7月30日我以每股6元的价格，购入某A股股票，500股，8月5日时，因股价上涨至6.8元，我将此股票全部卖出，那么在此次交易过程中，一共交纳了多少手续费？<br>计算过程如下：首先，购买时：印花税0元，过户费：500<em>0.02‰=0.01元，因为不足1元按照1元收取；券商佣金，因为3000</em>0.3‰=0.9元，严重小于5元，所以仍然按照5元计算，也就是说购买该股票交纳手续费1+5=6元；<br>其次，卖出时：印花税=6.8<em>500</em>1‰=3.4元，过户费=500*0.02‰=0.01元，不足1元按照1元收取；券商佣金还是低于5元，仍然按照5元收取，即卖出时手续费需要交纳3.4+1+5=9.4元。 因此，在此交易过程中总共交纳的手续费为6+9.4=15.4元。<br><strong>六、分时图上的白线与黄线的含义</strong></p><p><img src="/2023/02/19/%E8%82%A1%E7%A5%A8/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/../img/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86assets/v2-ff94ef36e1061490fc54e6f8b8c3672f_720w.webp" alt="img"></p><p><strong>个股分时图白线与黄线的含义</strong><br>1、黄线：表示该股的均价即平均价格，当天成交总金额除以成交总股数。</p><p>2、白线：表示该票实时成交的价格，即为准确的实盘价格。</p><p><strong>大盘分时图白线与黄线的含义</strong><br>1、黄线：大盘不含加权的指标</p><p>2、白线：表示大盘加权指数，也就是说大盘的实际指数</p><p><strong>大盘黄白线的另外一层含义：</strong><br>当大盘下跌的时候，黄线在白线的上面，意思是中小盘股的跌幅小于大盘股的跌幅。<br>反过来就是：中小盘股跌幅大于大盘股（权重股）。<br>当大盘上涨的时候，黄线在白线的上面，意思是中小盘股涨幅大于大盘股的涨幅；<br>反过来就是：大盘股的涨幅要大于中小盘股的涨幅。<br>七、基础知识散户从哪四个方面研究绩优股<br>投资股票、找对绩优股无疑成功了80%。对于绩优股，并无统一的评价标准。一般来说，主要有这样几种观点：年每股税后利润在0.50元以上；年净资产收益率在20%以上；市盈率在20倍以下。<br>这几种标准都有各自的道理，但未免略显肤浅，考察一个上市公司的业绩如何，应当综合各个方面的情况，除上述几点外还应从以下四个方面研究：<br>1、财务状况。一个公司的财务状况主要涉及资本结构、偿债能力、盈利能力等几方面。<br>2、经营状况。一个业绩好的公司往往有着优良的产品质量、较大的市场占有率和较高的商业信誉。<br>3、管理水平。一个业绩好的公司必定有一个高水平的领导班子，有科学严谨的工作作风和管理办法。<br>4、给股东的回报。一个业绩好的公司每年都会给股东以优厚的回报，比如大比例送红股和派高额现金红利。<br>随着中国股市和投资者的日趋成熟，“投资于绩优、投资于高成长”已经成为市场共识。<br>绩优股为什么受追捧呢?从理论上讲，买股票是为该上市公司出资，出资的目的明显是获取投资收益，而上市公司向股东提供投资回报的高低只能从其业绩(更直接地说是利润)状况来反映，业绩好说明其为股东提供的回报高，业绩差说明回报低，亏损说明投资者不仅得不到回报，还要用本钱去还债。因此，绩优股当然受市场欢迎。<br>但有人会说，绩优股价格高、成本大。绩差股价格低、成本低，一旦有业绩上升，股价上升空间大。这个说法有道理，买股票就是买未来，绩差股业绩能有提高当然意味着股价上涨，投资者获利。但在大多数的交易时间里，上市公司将来的业绩水平是不可预期的。<br>投资者很难判断一个上市公司的业绩水平是否会有变化，这个时候绩优股与绩差股相比，安全性明显，尤其在趋势模糊的市道中，绩优股更显英雄本色。<br>八、什么是股票<br>什么是股票？按照马克思的说法,股票是一种虚拟资本；按照经济学的观点,股票是买卖生产资料所有权的凭证；按照老百姓的说法,股票就是一张资本的选票。老百姓可以根据自己的意愿将手中的货币选票投向某一家或几家企业,以博取股价波动之差或是预期企业的未来收益。<br>由此可见,股票就是股份公司发给股东作为已投资入股的证书与索取股息的凭证。股票像一般的商品一样,有价格,能买卖,可以作抵押品。股份公司借助发行股票来筹集资金。投资者通过购买股票获取一定的股息收入。股票具有以下特性：<br>——权责性。股票作为产权或股权的凭证,是股份的证券表现,代表股东对发行股票的公司所拥有的一定权责。股东的权益与其所持股票占公司股本的比例成正比。<br>——无期性。 股票投资是一种无确定期限的长期投资,只要公司存在,投资者一般不能中途退股。<br>——流通性。股票作为一种有价证券可作为抵押品,并可随时在股票市场上通过转让卖出而换成现金,因而成为一种流通性很强的流动资产和融资工具。<br>——风险性。股票投资者除获取一定的股息外,还可能在股市中赚取买卖差价利润。但投资收益的不确定性又使 股票投资具有较大的风险,其预期收益越高风险也越大。发行股票公司的经营状况欠佳,甚至破产,股市的大幅度波动和投资者自身的决策失误都可能给投资者带来不同程度的风险。<br>——法定性。股票须经有关机构批准和登记注册,进行签证后才能发行,并必须以法定形式,记载法定事项。<br>购买股票是一种金融投资行为,与银行储蓄存款及购买债券相比较,它是一种高风险行为,但同时它也能给人们带来更大的收益。<br>购买股票能带来哪些好处呢？由于现在人们投资股票的主要目的并非在于充当企业的股东,享有股东权利,所以购买股票的好处主要体现在以下几个方面：<br>⑴每年有得到上市公司回报,如分红利、送红股。<br>⑵能够在股票市场上交易,获取买卖价差收益。<br>⑶能够在上市公司业绩增长经营规模扩大时享有股本扩张收益。这主要是通过上市的送股、资本公积金转增股本、配股等来实现。<br>⑷能够在股票市场上随时出售,取得现金,以备一时之急需。<br>⑸在通货膨胀时期,投资好的股票还能避免货币的贬值,有保值的作用。</p><p>九、股票基本概念<br>1.股票概念<br>股票是股份证书的简称,是股份公司为筹集资金而发行给股东作为持股凭证并借以取得股息和红利的一种有价证券。每股股票都代表股东对企业拥有一个基本单位的所有权。股票是股份公司资本的构成部分,可以转让、买卖或作价抵押,是资金市场的主要长期信用工具。<br>2.股票特征<br>股票投资是一种没有期限的长期投资。股票一经买入,只要股票发行公司存在,任何股票持有者都不能退股,即不能向股票发行公司要求抽回本金。同样,股票持有者的股东身份和股东权益就不能改变,但他可以通过股票交易市场将股票卖出,使股份转让给其他投资者,以收回自己原来的投资。<br>3.股票作用<br>(1)股票上市后, 上市公司就成为投资大众的投资对象,因而容易吸收投资大众的储蓄资金,扩大了筹资的来源。<br>(2)股票上市后, 上市公司的股权就分散在千千万万个大小不一的投资者手中,这种股权分散化能有效地避免公司被少数股东单独支配的危险,赋予公司更大的经营自由度。<br>(3)股票交易所对上市公司股票行情及定期会计表册的公告,起了一种广告效果,有效地扩大了上市公司的知名度,提高了上市公司的信誉。<br>4.股票面值<br>股票的面值,是股份公司在所发行的股票票面上标明的票面金额,它以元/股为单位,其作用是用来表明每一张股票所包含的资本数额。在我国上海和深圳证券交易所流通的股票的面值均为壹元,即每股一元。<br>股票面值的作用之一是表明股票的认购者在股份公司的投资中所占的比例,作为确定股东权利的依据。如某上市公司的总股本为1,000,000元,则持有一股股票就表示在该公司占有的股份为1/1,000,000。第二个作用就是在首次发行股票时,将股票的面值作为发行定价的一个依据。一般来说,股票的发行价格都会高于其面值。当股票进入流通市场后,股票的面值就与股票的价格没有什么关系了。股民爱将股价炒到多高,它就有多高。<br>5.股票净值<br>股票的净值又称为帐面价值,也称为每股净资产,是用会计统计的方法计算出来的每股股票所包含的资产净值。其计算方法是用公司的净资产（包括注册资金、各种公积金、累积盈余等,不包括债务）除以总股本,得到的就是每股的净值。股份公司的帐面价值越高,则股东实际拥有的资产就越多。由于帐面价值是财务统计、计算的结果,数据较精确而且可信度很高,所以它是股票投资者评估和分析上市公司实力的的重要依据之一。股民应注意上市公司的这一数据。<br>6.股票发行价<br>当股票上市发行时,上市公司从公司自身利益以及确保股票上市成功等角度出发,对上市的股票不按面值发行,而制订一个较为合理的价格来发行,这个价格就称为股票的发行价。<br>7.股票市价<br>股票的市价,是指股票在交易过程中交易双方达成的成交价,通常所指的股价就是指市价。股票的市价直接反映着股票市场的行情,是股民购买股票的依据。由于受众多因素的影响,股票的市价处于经常性的变化之中。股价是股票市场价值的集中体现,因此这一价格又称为股票行市。<br>8.股票清算价格<br>股票的清算价格是指一旦股份公司破产或倒闭后进行清算时,每股股票所代表的实际价值。从理论上讲,股票的每股清算价格应与股票的帐面价值相一致,但企业在破产清算时,其财产价值是以实际的销售价格来计算的,而在进行财产处置时,其售价一般都会低于实际价值。所以股票的清算价格就会与股票的净值不相一致。股票的清算价格只是在股份公司因破产或其他原因丧失法人资格而进行清算时才被作为确定股价的依据,在股票的发行和流通过程中没有意义。<br>十、什么是股票的面值,市值<br>股票的面值<br>面值是股份公司在发行的股票票面上所标明的金额,即票面金额。股票面值通常以每股为单位,股票上市发行公司将其资本额分为若干股,每一股所代表的资本额,即为每股面值。股票的面值是固定的。亦有某些股票是没有面值的。股票面值的作用之一是可以确定每一股份对股份公司所占有的一定比例。<br>市值<br>市值即为股票的市场价值,亦可以说是股票的市场价格,它包括股票的发行价格和交易买卖价格。股票的市场价格是由市场决定的。股票的面值和市值往往事不一致的。股价可以高于面值,也可以低于面值,但股票第一次发行的价格一般不低于面值。股价主要取决于预期股息的多少,银行利息率的高低,及股票市场的供求关系。其公式为：股价=(预期股息)/银行利息率。<br>股票市场是一个波动的市场,股票市场价格亦是不断波动的。股票的市场交易价格主要有：开市价,收市价,最高价,最低价。收市价是最重要的,是研究分析股市以及抑制股票市场行情图表采用的基本数据。<br>十一、什么是优先股,普通股,后配股<br>1.　优先股<br>优先股是“普通股”的对称。<br>是股份公司发行的在分配红利和剩余财产时比普通股具有优先权的股份。优先股也是一种没有期限的有权凭证,优先股股东一般不能在中途向公司要求退股(少数可赎回的优先股例外)。<br>优先股的主要特征有三：一是优先股通常预先定明股息收益率。由于优先股股息率事先固定,所以优先股的股息一般不会根据公司经营情况而增减,而且一般也不能参与公司的分红,但优先股可以先于普通股获得股息,对公司来说,由于股息固定,它不影响公司的利润分配。二是优先股的权利范围小。优先股股东一般没有选举权和被选举权,对股份公司的重大经营无投票权,但在某些情况下可以享有投票权。<br>如果公司股东大会需要讨论与优先股有关的索偿权,即优先股的索偿权先于普通股,而次于债权人,优先股的优先权主要表现在两个方面：<br>(1)股息领取优先权。 股份公司分派股息的顺序是优先股在前,普通股在后。股份公司不论其盈利多少,只要股东大会决定分派股息,优先股就可按照事先确定的股息率领取股息,即使普遍减少或没有股息,优先股亦应照因分派股息。<br>(2)剩余资产分配优先权。股份公司在解散、破产清算时,优先股具有公司剩余资产的分配优先权,不过,优先股的优先分配权在债权人之后,而在普通股之前。只有还清公司债权人债务之后,有剩余资产时,优先股才具有剩余资产的分配权。只有在优先股索偿之后,普通股才参与分配。<br>优先股的种类很多,为了适应一些专门想获取某些优先好处的投资者的需要,优先肌有各种各样的分类方式。主要分类有以下几种：<br>(1)　累积优先股和非累积优先股。 累积优先股是指在某个营业年度内,如果公司所获的盈利不足以分派规定的股利,日后优先股的股东对往年来付给的股息,有权要求如数补给。对于非累积的优先股,虽然对于公司当年所获得的利润有优先于普通股获得分派股息的权利,但如该年公司所获得的盈利不足以按规定的股利分配时,非累积优先股的股东不能要求公司在以后年度中予以补发。一般来讲,对投资者来说,累积优先股比非累积优先股具有更大的优越性。<br>(2)　参与优先股与非参与优先股。当企业利润增大,除享受既定比率的利息外,还可以跟普通股共同参与利润分配的优先股,称为“参与优先股＂。除了既定股息外,不再参与利润分配的优先股,称为“非参与优先股＂。一般来讲,参与优先股较非参与优先股对投资者更为有利。<br>(3)　可转换优先股与不可转换优先股。 可转换的优先股是指允许优先股持有人在特定条件下把优生股转换成为一定数额的普通股。否则,就是不可转换优先股。可转换优先股是近年来日益流行的一种优先股。<br>(4)　可收回优先股与不可收回优先股。 可收回优先股是指允许发行该类股票的公司,按原来的价格再加上若干补偿金将已发生的优先股收回。当该公司认为能够以较低股利的股票来代替已发生的优先股时,就往往行使这种权利。反之,就是不可收回的优先股。<br>优先股的收回方式有三种：<br>溢价方式<br>公司在赎回优先股时,虽是按事先规定的价格进行,但由于这往往给投资者带来不便,因而发生公司常在优先股面值上再加一笔“溢价＂。<br>公司在发生优先股时, 从所获得的资金中提出一部分款项创立“偿债基金＂,专用于定期地赎回已发出的一部分优先股。 　　 　　&lt;3&gt;转换方式。 即优先股可按规定转换成普通股。虽然可转换的优先股本身构成优先股的一个种类,但在国外投资界,也常把它看成是一种实际上的收回优先股方式,只是这种收回的主动权在投资者而不在公司里,对投资者来说,在普通股的市价上升时这样做是十分有利的。<br>2.普通股<br>普通股是“优先股＂的对称,是随　企业利润变动而变动的一种股份,是公司资本构成中最普通、最基本的股份,是股份企业资金的基础部分。<br>普通股的基本特点是基投资利益(股息和分红)不是在购买时约定,而是事后根据股票发生公司的经营实积来确定,公司的经营实积好,普通股的收益就商；而经营实积差,普通股的收益就低。普通股是股份公司资本构成中最重要、最基本的股份,亦是风险最大的一种股份,但又是股票中最基本、最常见的一种。<br>即能够在一定时期(或永久)内以一定价格购买一定数目普通股份的凭证。一般公司的认股权证是和股票、债券一起发行的,这样可以更多地吸引投资者。<br>综上所述,由普通股的前两个特点不难看出,普通股的股利和残余则产分配可能大起大落,因此,普通股东所担的风险最大。既然如此,普通股东当然也就更关心公司的经营状况和发展前景,而普通股的后两个特性恰恰使这一愿望变成现实即提供和保证了普通股东关心公司经营状况与发展前景的权力的手段。<br>然而还值得注意的是,在投资股和优先股向一般投资者公开发行时,公司应使投资者感到普通股比优先股能获得料高的股利,否则,普通股既在投资上冒风险,又不能在股利上比优先股多得,那么还有谁愿购买普通股呢！一般公司发行优先股,主要是以“保险安全＂型投资者为发行对象,对于那些比较富有“冒险精神＂的投资者,普通股才更具魅力。总之,发行这两种不同性质的股票,目的在于更多地吸引具有不同兴趣的资本。<br>3.　后配股<br>后配股是在利益或利息分红及剩余财产分配时比普通股处于劣势的股票,一般是在普通股分配之后,对剩余利益进行再分配。如果公司的盈利巨大,后配股的发行数量又很有限,则购买后配股的股东可以取得很高的收益。发行后配股,一般所筹措的资金不能立即产生收益,投资者的范围又受限制,因此利用率不高。后配股一般在下列情况下发行：<br>(1)　公司为筹措扩充设备资金而发行新股票时, 为了不减少对旧股的分红,在新设备正式投用前,将新股票作后配股发行；<br>(2)　企业兼并时,为调整合并比北, 向被兼并企业的股东交付一部分后配股；<br>(3)在有政府投资的公司里, 私人持有的股票投息达到一定水平之前,把政府持有的股票作为后配股。<br>十二、什么是ST股和PT股<br>沪深证券交易所在1998年4月22日宣布,根据1998年实施的股票上市规则,将对财务状况或其它状况出现异常的上市公司的股票交易进行特别处理,由于“特别处理”的英文是Special treatment（缩写是“ST”）,因此这些股票就简称为ST股。上述财务状况或其它状况出现异常主要是指两种情况,一是上市公司经审计连续两个会计年度的净利润均为负值,二是上市公司最近一个会计年度经审计的每股净资产低于股票面值。在上市公司的股票交易被实行特别处理期间,其股票交易应遵循下列规则：<br>（1）股票报价日涨跌幅限制为5％；<br>（2）股票名称改为原股票名前加“ST”,例如“ST辽物资”；<br>（3）上市公司的中期报告必须审计。<br>由于对ST股票实行日涨跌幅度限制为5％,也在一定程度上抑制了庄家的刻意炒作。投资者对于特别处理的股票也要区别对待．具体问题具体分析,有些ST股主要是经营性亏损,那么在短期内很难通过加强管理扭亏为盈。有些ST股是由于特殊原因造成的亏损,或者有些ST股正在进行资产重组,则这些股票往往潜力巨大。<br>“PT”的英语 Particular Transfer（意为特别转让）的缩写。这是旨在为暂停上<br>市股票提供流通渠道的“特别转让服务”。对于进行这种&quot;特别转让&quot;的股票,沪深交易所在其简称前冠以“PT”,称之为“PT股” 。<br>根据《公司法》和证券法的规定,上市公司出现连续三年亏损等情况,其股票将暂停上市。沪深交易所从1999年7月9日起,对这类暂停上市的股票实施“特别转让服务”。第一批这类股票有“PT双鹿”,“PT农商社”,“PT苏三山”和“PT渝太白”。<br>特别转让与正常股票交易主要有四点区别：<br>（1）交易时间不同。特别转让仅限于每周五的开市时间内进行,而非逐日持续交易。<br>（2）涨跌幅限制不同。特别转让股票申报价不得超过上一次转让价格的上下5％,与ST股票的日涨跌幅相同。<br>（3）撮合方式不同,特别转让是交易所于收市后一次性对该股票当天所有有效申报按集合竞价方式进行撮合,产生唯一的成交价格,所有符合成交条件的委托盘均按此价格成交。<br>（4）交易性质不同。特别转让股票不是上市交易,因此,这类股票不计入指数计算,成交数不计入市场统计,其转让信息也不在交易所行情中显示,只由指定报刊设专栏在次日公告。<br>推出“特别转让服务”,是依据《公司法》中关于“股份公司的股东持有的股票可以依法转让”的规定而设计的。它的实行,既可为暂停上市的股票提供了合法的交易场所,又可以提示投资风险,有利于保护广大投资者的合法权益。<br>十三、上证指数介绍<br>1上证指数<br>全称“上海证券交易所综合股价指数”,是国内外普遍采用的反映上海股市总体走势的统计指标。<br>上证指数由上海证券交易所编制,于1991年7月15日公开发布,上证提数以&quot;点&quot;为单位,基日定为1990年12月19日。基日提数定为100点。</p><p>随着上海股票市场的不断发展,于1992年2月21日,增设上证A股指数与上证B股指数,以反映不同股票（A股、B股）的各自走势。1993年6月1日,又增设了上证分类指数,即工业类指数、商业类指数、地产业类指数、公用事业类指数、综合业类指数、以反映不同行业股票的各自走势。</p><p>至此,上证指数已发展成为包括综合股价指数、A股指数、B股指数、分类指数在内的股价指数系列。</p><p>2、计算公式<br>上证指数是一个派许公式计算的以报告期发行股数为权数的加权综合股价指数。<br>报告期指数=（报告期采样股的市价总值/基日采样股的市价总值）×100<br>市价总值=Σ（市价×发行股数）<br>其中,基日采样股的市价总值亦称为除数。<br>3、修正方法<br>当市价总值出现非交易因素的变动时,采用“除数修正法”修正原固定除数,以维持指数的连续性,修正公式如下：<br>修正前采样股的市价总值/原除数=修正后采样的市价总值/修正后的除数由此得到修正后的连续性,并据此计算以后的指数。<br>当股票分红派息时,指数不予修正,任其自然回落。</p><p>根据上海股市的实际情况,如遇下列情况之一,须作修正：<br>（1） 新股上市；<br>（2） 股票摘牌；<br>（3） 股本数量变动（送股、配股、减资等等）；<br>（4） 股票撤权（暂时不计入指数）、复权（重新计入指数）<br>（5） 汇率变动</p><p>新股上市：新股上市第二天计入指数,即当天不计入指数,而于当日收盘后修正指数,修正方法为：<br>当日的市价总值/原除数=当日的市价总值+新股的发行股数×当日收盘价/修正后的除数<br>除权：在股票的除权交易日开盘前修正指数：<br>前日的市价总值/原除数=[前日的市价总值+除权股票的发行股数×（除权报价-前日收盘价）]/修正后的除数<br>撤权：在含转配的股票除权基准日,在指数的样本股票中将该股票剔除；<br>复权：在撤权股票的配股部分上市流通后第十一个交易日起,再纳入指数的计算范围。</p><p>4、指数的发布<br>上证指数目前为实时逐笔计算,即每有一笔新的成交,就重新计算一次指数,其中采样股的计算价位（X）根据以下原则确定：<br>（1） 若当日没有成交,则X=前日收盘价<br>（2） 若当日有成交,则X=最新成交价<br>上证指数每天以各种传播方式向国内、国际广泛发布。<br>十四、股市名词术语<br>\1. 成交数量</p><p>指当天成交的股票数量。</p><p>\2. 日最高价</p><p>指当天该股票成交价格中的最高价格。</p><p>\3. 日最低价</p><p>指当天该股票成交价格中的最低价格。</p><p>\4. 跳空</p><p>指受强烈利多或利空消息刺激,股价开始大幅度跳动。跳空通常在股价大变动的开始或结束前出现。</p><p>\5. 成交笔数</p><p>指该股成交的次数。</p><p>\6. 日成交额<br>指当天已成交股票的金额总数。</p><p>\7. 多头<br>　　指股票成交中的买方。<br>\8. 空头</p><p>指股票成交中的卖方。</p><p>\9. 涨跌</p><p>当日股价与前一日收盘价格（或前一日收盘指数）相比的百分比幅度,正值为涨,负值为跌,否则为持平。</p><p>\10. 价位</p><p>指买卖价格的升降单位。价位的高低随股票的每股市价的不同而异。</p><p>\11. 开高</p><p>今日开盘价在昨日收盘价之上。</p><p>\12. 开平</p><p>今日开盘价与昨日收盘价持平。</p><p>\13. 开低<br>　　今日开盘价在昨日收盘价之下。</p><p>\14. 涨势</p><p>股价在一段时间内不断朝新高价方向移动。</p><p>\15. 跌势</p><p>股价在一段时间内不断朝新低价方向移动。</p><p>\16. 盘整</p><p>股价在有限幅度内波动,一般是指上下5%的幅度内的波动。</p><p>\17. 关卡</p><p>一般将整数位或黄金分割位或股民习惯上的心理价位称之为关卡。</p><p>\18. 突破</p><p>股价冲过关卡为突破,一般指向上突破。</p><p>\19. 跌破</p><p>股价冲过关卡向下突破称为跌破。</p><p>\20. 反转</p><p>股价朝原来趋势的相反方向移动分为向上反转和向下反转。</p><p>\21. 探底</p><p>寻找股价最低点过程,探底成功后股价由最低点开始翻升。</p><p>\22. 底部</p><p>股价长期趋势线的最低部分。</p><p>\23. 头部</p><p>股价长期趋势线的最高部分。</p><p>\24. 高价区</p><p>多头市场的末期,此时为中短期投资的最佳卖点。</p><p>\25. 低价区</p><p>多头市场的初期,此时为中短期投资的最佳买点。<br>\26. 买盘强劲</p><p>股市交易中买方的欲望强烈,造成股价上涨。</p><p>\27. 卖压沉重</p><p>股市交易中持股者争相抛售股票,造成股价下跌。</p><p>\28. 骗线</p><p>主力或大户利用市场心理,在趋势线上做手脚,使散户作出错误的决定。</p><p>\29. 超买</p><p>股价持续上升到一定高度,买方力量基本用劲,股价即将下跌。</p><p>\30. 超卖</p><p>股价持续下跌到一定低点,卖方力量基本用劲,股价即将回升。</p><p>\31. 蓝筹股</p><p>指资本雄厚,信誉优良的挂牌公司发行的股票。</p><p>\32. 多头市场</p><p>也称牛市,就是股价普遍上涨的市场。</p><p>\33. 股本</p><p>所有代表企业所有权的股票,包括流通股与非流通股。</p><p>\34. 空头市场</p><p>股价呈长期下降趋势的市场,空头市场中,股价的变动情况是大跌小涨,亦称熊市。</p><p>\35. 多翻空</p><p>原本看好行情的买方,看法改变,变为卖方。</p><p>\36. 空翻多</p><p>原本打算卖出股票的一方,看法改变,变为买方。</p><p>\37. 卖空</p><p>预计股价将下跌,因而卖出股票,在发生实际交割前,将卖出股票如数补进,交割时,只结清差价的投机行为。</p><p>\38. 利空</p><p>指股票市场上有利于空头的消息。</p><p>\39. 利多</p><p>指股票市场上有利于多头的消息。</p><p>\40. 多杀多</p><p>买入股票后又立即卖出股票的作法称为多杀多。</p><p>\41. 死多</p><p>是看好股市前景,买进股票后,如果股价下跌,宁愿放上几年,不赚钱绝不脱手。</p><p>\42. 大户</p><p>指大额投资人,例如拥有大资金的集团或个人。</p><p>\43. 散户</p><p>指买卖股票数量很少的小额投资者。</p><p>\44. 吃货</p><p>指庄家在低价时暗中买进股票,叫做吃货。</p><p>\45. 出货</p><p>指庄家在高价时,不动声色地卖出股票,称为出货。</p><p>\46. 坐轿子</p><p>目光锐利或事先得到信息的投资人,在大户暗中买进或卖出时,或在利多或利空消息公布前,先期买进或卖出股票,待散户大量跟进或跟出,造成股价大幅度上涨或下跌时,再卖出或买回,坐享厚利,这就叫坐轿子。</p><p>\47. 抬轿子</p><p>利多或利空消息公布后,认为股价将大幅度变动,跟着抢进抢出,获利有限,甚至常被套牢的人,就是给别人抬轿子。</p><p>\48. 热门股</p><p>每次行情反弹总有一些板块或股票起着主要拉升的作用,这些股票的交易量大、流通性强、价格变动幅度大称其为热门股。</p><p>\49. 冷门股</p><p>是指交易量小,流通性差,价格变动小的股票。</p><p>\50. 成长股</p><p>指新添的有前途的产业中,利润增长率较高的企业股票。成长股的股价呈不断上涨趋势。<br>\51. 行情</p><p>指股票的价位或股价的走势。</p><p>\52. 技术因素</p><p>许多报纸经济栏内刊登的反映股市特点的各种技术因素,如主、次要趋势和逆向运动等。这些因素可以短期内对股票的卖空数量,零星股和整数股的交易比率,哪些股票上升到新高度,哪些股票下降到新低点等进行有益的分析,这对职业投资者和投机者的好处远大于普通投资者。</p><p>\53. 牛市</p><p>指整个股市价格呈上升趋势。</p><p>\54. 熊市</p><p>指整个股市价格普遍下跌的行情。</p><p>\55. 牛皮市</p><p>指在所考察交易日里,证券价格上升。下降的幅度很小,价格变化不大,市价像被钉住了似的,如牛皮之坚韧。在牛皮市上往往成交量也很小,牛皮市是一种买卖双方在力量均衡时的价格行市表现。</p><p>\56. 崩盘</p><p>崩盘即证券市场上由于某种利空原因,出现了证券大量抛出,导致证券市场价格无限度下跌,不知到什么程度才可以停止。这种接连不断地大量抛出证券的现象也称为卖盘大量涌现。</p><p>\57. 利空出尽</p><p>在证券市场上,证券价格因各种不利消息的影响而下跌,这种趋势持续一段时间,跌到一定的程度,空方的力量开始减弱,投资者须不再被这些利空的因素所影响,证券价格开始反弹上升,这种现象就被称作利空出尽。</p><p>\58. 量价格背离</p><p>当前的量价关系与之前的量价关系发生了改变,一般量价背离会产生一种新的趋势,也可能只是上升中的调整或下跌中的反弹。</p><p>\59. 回档 　　在股市上,股价呈不断上涨趋势,终因股价上涨速度过快而反转回跌到某一价位,这一调整现象称为回档。一般来说,股票的回档幅度要比上涨幅度小,通常是反转回跌到前一次上涨幅度的三分之一左右时又恢复原来上涨趋势。</p><p>\60. 反弹</p><p>在股市上,股价呈不断下跌趋势,终因股价下跌速度过快而反转回升到某一价位的调整现象称为反弹。一般来说,股票的反弹幅度要比下跌幅度小,通常是反弹到前一次下跌幅度的三分之一左右时,又恢复原来的下跌趋势。</p><p>\61. 整理（盘整）</p><p>股市上的股价经过大幅度迅速上涨或下跌后,遇到阻力线或支撑线,原先上涨或下跌趋势明显放</p><p>慢,开始出现幅度为15％左右的上下跳动,并持续一段时间,这种现象称为整理。整理现象的出现通常表示多头和空头激烈互斗而产生了跳动价位,也是下一次股价大变动的前奏。</p><p>\62. 套牢</p><p>是指进行股票交易时所遭遇的交易风险。例如投资者预计股价将上涨,但在买进后股价却一直呈下跌趋势,这种现象称为多头套牢。相反,投资者预计股价将下跌,将所借股票放空卖出,但股价却一直上涨,这种现象称为空头套牢。</p><p>\63. 轧空</p><p>即空头倾轧空头。股市上的股票持有者一致认为当天股票将会大下跌,于是多数人却抢卖空头帽子卖出股票,然而当天股价并没有大幅度下跌,无法低价买进股票。股市结束前,做空头的只好竞相补进,从而出现收盘价大幅度上升的局面。</p><p>\64. 零股交易</p><p>不到一个成交单位(1手=100股)的股票,如1股、10股,称为零股．在卖出股票时,可以用零股进行委托；但买进股票时不能以零股进行委托,最小单位是１手,即１００股。</p><p>\65. 买壳上市</p><p>所谓买壳上市,就是一家优势企业通过收购债权、控股、直接出资、购买股票等收购手段以取得被收购方（上市公司）的所有权、经营权及上市地位。目前,在我国进行买壳、借壳一般都通过二级市场购并或者通过国家股、法人股的协议转让进行的。</p><p>\66. 委比</p><p>委比是衡量一段时间内场内买、卖盘强弱的技术指标。它的计算公式为：委比=(委买手数－委卖手数)/(委买手数＋委卖手数)×100％。从公式中可以看出,委比的取值范围从－100％至＋100％。若委比为正值,说明场内买盘较强,且数值越大,买盘就越强劲。反之,若委比为负值,则说明市道较弱。为及时反映场内的即时买卖盘强弱情况,委买手数是指即时向下三档的委托买入的总手数,委卖手数是指即时向上三档的委托卖出总手数。如：某股即时最高买入委托报价及委托量为15.00元130手,向下两档分别为14.99元150手、14.98元205手；最低卖出委托报价及委托量分别为15.01元270手,向上两档分别为15.02元475手、15.03元655手,则此时的即时委比为－48.54％。显然,此时场内抛压很大。</p><p>\67. 换手率</p><p>换手率是指在一定时间内市场中股票转手买卖的频率,是反映股票流通性的指标之一。计算公式为:换手率=(某一段时间内的成交量/流通股数)×100%。一般来说,当股价处于低位时,当日换手率达到4%左右时应引起投资者的关注,而上升途中换手率达到20%左右时则应引起警惕。</p><p>\68. 洗盘</p><p>指庄家大户为降低拉升成本和阻力,先把股价大幅度杀低,回收散户恐慌抛售的股票,然后抬高股价乘机获取价差利益的行为。一般说,只要能确定股价的波动为庄家洗盘,就应该持筹不动,静待股价上涨。</p><p>\69. 割肉</p><p>指高价买进股票后,大势下跌,为避免继续损失,低价赔本卖出股票。止损是割肉的一种,提前设立好止损价位,防止更大的损失,是短线投资者应灵活运用的方法,新股民使用可防止深度套牢。</p><p>\70. 跌停板</p><p>证券交易当天股价的最低限度称为跌停板,跌停板时的股价称跌停板价。一般说,开市即跌停的股票,于第二日仍有可能惯性下跌,尾盘突然跌停的股票,庄家有骗线的可能,可关注。71. 涨停板证券市场中交易当天股价的最高限度称为涨停板,涨停板时的股价叫涨停板价。一般说,开市即封涨停的股票,势头较猛,只要当天涨停板不被打开,第二日仍然有上冲动力,尾盘突然拉至涨停的股票,庄家有于第二日出货或骗线的嫌疑,应小心。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java 正则表达式</title>
      <link href="/2023/02/18/java/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/02/18/java/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>正则表达式的基础部分已经学习完毕,接下来是学习java提供的正则表达式的库</p><h2 id="库说明">库说明</h2><p>java提供的 java.util.regex 包 主要包含下面三个类:</p><ul><li><strong>Pattern类</strong> 这个是用来设置正则表达式和对正则表达式进行编译,和得到Matcher类对象</li><li><strong>Matcher类</strong> 这个是用匹配数据和存放匹配结果的,我们可以通过这个类获得匹配好的数据和修改数据</li><li><strong>PatternSyntaxException</strong>类 这个看名字就知道是一个异常类,用来表示正则表达式中的语法错误</li></ul><p>我们接下来就是学习这两个类</p><h2 id="pattern类">Pattern类</h2><p>这个类的构造方法是私有的,我们不能通过new的方法来创建对象,只能通过它提供的静态方法compile来创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 基本匹配</span></span><br></pre></td></tr></table></figure><p>我们发现这和标准的正则表达式  / pattern /flag 有些区别,它的匹配模式和标志符不在同一个字符串中, 我们需要使用传递参数的方式去给定标志符</p><p>以下是一些常见的 Pattern 标志：</p><ol><li>CASE_INSENSITIVE：不区分大小写。</li><li>MULTILINE：启用多行模式。</li><li>DOTALL：允许点（.）匹配包括换行符在内的任意字符。</li><li>UNICODE_CASE：启用 Unicode 感知的大小写折叠。</li><li>CANON_EQ：启用规范等价匹配。</li></ol><p>如果需要多个标志位一起使用需要使用 | 连接,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 基本匹配</span></span><br><span class="line"><span class="comment">// 多行匹配,点可以匹配换行符,大小写忽略</span></span><br><span class="line"> <span class="type">Pattern</span> <span class="variable">compile1</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;hello&quot;</span>,Pattern.MULTILINE | Pattern.DOTALL | Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>我们可能会好奇,为什么没有全局匹配呢?,那是因为全局匹配我们不需要去设置,可以在代码中迭代获取所有匹配,在java中它不是一次性把所有的字符串进行匹配,它是需要我们通过代码控制它一次一次往下面进行匹配</strong></p><h2 id="matcher类">Matcher类</h2><p>这个类的构造方法是Default,我们不能使用的时候new 这个类的对象出来,我们可以通过定义好的Pattern类对象去获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> compile1.matcher(<span class="string">&quot;helloworldhelloworld&quot;</span>); </span><br></pre></td></tr></table></figure><p>这样是不是很合理,你得先有了匹配模式,然后用这个匹配模式得到一个匹配类对象</p><h3 id="方法介绍">方法介绍</h3><h4 id="索引">索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">start</span><span class="params">()</span>; <span class="comment">// 返回这次匹配成功字符串的起始位置  如果没有进行匹配或者没有匹配到会抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> group)</span>; <span class="comment">// 返回这次匹配成功字符串中指定捕获分组的起始位置,如果没有进行匹配或者没有匹配到或者分组不存在到会抛出异常</span></span><br><span class="line"><span class="comment">// public int start() 等价于 public int start(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">start</span><span class="params">(String name)</span>; <span class="comment">// 这个是通过名字查找分组的起始位置,如果没有进行匹配或者没有匹配或者分组不存在到会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">end</span><span class="params">()</span>; <span class="comment">// 返回这次匹配成功字符串的最后一个位置+1  如果没有进行匹配或者没有匹配到会抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">end</span><span class="params">(<span class="type">int</span> group)</span>;<span class="comment">// 返回这次匹配成功字符串中指定捕获分组的最后一个位置+1  如果没有进行匹配或者没有匹配到或者分组不存在会抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">end</span><span class="params">(String name)</span>;<span class="comment">//这个是通过名字查找分组的结束位置+1,如果没有进行匹配或者没有匹配或者分组不存在到会抛出异常</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找">查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lookingAt</span><span class="params">()</span>;<span class="comment">//从开头开始查找,查看是否有匹配的字符串,这个方法会将查找区域移动到开头,会影响后面的查找,必须是开头的连续字符串符合要求才能算成功</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">()</span>; <span class="comment">// 从当前位置开始查找,查找到之后,会将查找区域移动到这个匹配字符串后面,然后返回真,如果没有查找到返回false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> start）; // 重置查找区域到此位置,然后进行查找</span></span><br><span class="line"><span class="params"><span class="keyword">public</span> <span class="type">boolean</span> matches()</span>; <span class="comment">// 看整个区域是否满足这个正则表达式,然后也会记录查找结果      </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这些查找方法中,无论查找成功与否,都会向后移动查找区域</p></blockquote><h4 id="分组">分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">group</span><span class="params">()</span>;  <span class="comment">// 返回整个匹配的字符串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">group</span><span class="params">(<span class="type">int</span> group)</span>; <span class="comment">// 返回当前匹配成功字符串中指定的捕获分组  </span></span><br><span class="line"><span class="comment">// group() 等价于 group(0)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">group</span><span class="params">(String name)</span>; <span class="comment">// 返回当前匹配成功字符串中指定名字的分组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">groupCount</span><span class="params">()</span>; <span class="comment">// 返回分组数量,不包括0这个分组</span></span><br></pre></td></tr></table></figure><blockquote><p>如果在没有查找成功的情况下,使用这些方法会抛出异常</p></blockquote><h4 id="替换方法">替换方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在当前匹配到的结果位置的到这次匹配区域开头的所有字符串后拼接在replacement,然后将拼接好的字符串拼接到sb中</span></span><br><span class="line"><span class="comment">// 注意哦, 是当前匹配区域,不是一开始的匹配区域</span></span><br><span class="line"><span class="keyword">public</span> Matcher <span class="title function_">appendReplacement</span><span class="params">(StringBuffer sb, String replacement)</span>;</span><br><span class="line"><span class="keyword">public</span> StringBuffer <span class="title function_">appendTail</span><span class="params">(StringBuffer sb)</span>; <span class="comment">// 将当前匹配区域所有的字符串添加到sb末尾,注意哦是当前区域</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceAll</span><span class="params">(String replacement)</span>; <span class="comment">// 将所有的匹配结果替换为replacement 并返回替换后的字符串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceFirst</span><span class="params">(String replacement)</span>; <span class="comment">// 将第一个匹配结果替换为replacement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// matcher.replaceAll == while(matcher.find())matcher.appendReplacement(sb,replacement); appendTail(sb)</span></span><br><span class="line"><span class="comment">// matcher.replaceFirst == matcher.find();matcher.appendReplacement(sb,replacement); appendTail(sb)</span></span><br><span class="line"><span class="comment">// 所以如果我们想自己定制替换第几个匹配的我们可以这样做</span></span><br><span class="line"><span class="comment">// 这里是将第二个helloworld替换成hhh</span></span><br><span class="line">  <span class="type">Pattern</span> <span class="variable">compile1</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> compile1.matcher(<span class="string">&quot;12helloworld1helloworld12&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                matcher.appendReplacement(sb,<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.appendTail(sb);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="/2023/02/18/java/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230218161948081.png" alt="image-20230218161948081"></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用库</title>
      <link href="/2023/02/17/java/%E5%BA%93%E6%8E%A8%E8%8D%90/"/>
      <url>/2023/02/17/java/%E5%BA%93%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>记录一下java的一些库可以用来处理哪些东西,这里还附上<a href="https://mvnrepository.com/artifact/org.jsoup/jsoup">Maven仓库地址</a></p><h2 id="处理文档">处理文档</h2><p>Java提取文档中的数据的方法取决于文档的类型和数据的格式。下面列出了一些可能用到的Java库和工具以及它们支持的数据类型：</p><ol><li>Apache POI：POI是一种流行的Java库，用于处理Microsoft Office格式的文档，如Word文档（.docx）、Excel文档（.xlsx）和PowerPoint演示文稿（.pptx）。</li><li>PDFBox：PDFBox是一个用于创建和处理PDF文档的Java库。它可以用于提取PDF文档中的文本和元数据。</li><li>jTidy：jTidy是一个用于清理和解析HTML文档的Java库。它可以将HTML文档转换为XHTML格式，从而更容易地提取其中的数据。</li><li><strong>Jsoup</strong>：Jsoup是另一个用于解析HTML文档的Java库。它提供了一种简单的方式来解析HTML文档，并提取其中的数据。</li><li>OpenCSV：OpenCSV是一个Java库，用于读写CSV文件。如果您需要从CSV文件中提取数据，则可以使用OpenCSV。</li><li><strong>JSON</strong>：JSON是一种轻量级数据交换格式，可用于表示复杂的数据结构。Java有很多库可用于解析和处理JSON数据，如Jackson和Gson。</li><li>XML：XML是一种常见的数据格式，可以用于表示各种数据类型。Java有内置的XML解析器，如DOM和SAX，可以用于解析和处理XML数据。</li><li><strong>正则表达式</strong>：如果您需要从文本文件中提取特定的数据，您可以使用Java的正则表达式库。正则表达式是一种强大的模式匹配工具，可用于从文本中提取特定的数据。</li></ol><h2 id="爬虫">爬虫</h2><p>Java 中有很多流行的爬虫库可供选择，以下是其中一些比较好用的爬虫库：</p><ol><li>Jsoup：Jsoup 是一款用于解析 HTML 和 XML 文档的 Java 库，它可以方便地从网页中提取数据，并支持 CSS 选择器语法。</li><li>Apache Nutch：Apache Nutch 是一款基于 Java 的开源网络爬虫，它可以处理大规模的网页抓取任务，并提供了一套强大的数据处理和索引技术。</li><li><strong>WebMagic</strong>：WebMagic 是一款非常强大的开源网络爬虫框架，它基于 Java 实现，使用简单、灵活，可以实现高效的网页抓取和数据解析。</li><li>Crawler4j：Crawler4j 是一款基于 Java 的高效 Web 爬虫框架，它可以在多线程环境下处理大规模的网页抓取任务，并支持多种配置和插件扩展。</li><li>HtmlUnit：HtmlUnit 是一款基于 Java 的无头浏览器库，它可以模拟浏览器的行为并执行 JavaScript，支持多种浏览器标准和 CSS 选择器语法。</li><li>Jaunt：Jaunt 是一款易于使用的 Java 网络爬虫库，它可以模拟浏览器的行为、自动填充表单并提取网页数据，支持 JavaScript 和 AJAX。</li></ol><p>这些爬虫库都有其优点和适用场景，选择哪一个取决于你的具体需求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>以前学过一点点正则表达式,后面又忘记了,又总是遇到这个东西,所以想这次学的明白一点,虽说不用记住,但是也要知道怎么用,这样查资料的时候也能查的明白一些</p><h2 id="介绍">介绍</h2><p>正则表达式(Regular Expression)是一种文本模式，简称Regex,包括普通字符（例如，a 到 z 之间的字母,数字）和特殊字符（称为&quot;元字符&quot;,列如\ . * ^ $),正则表达式可以用来匹配,查找,替换一系列符合规则的字符串</p><h2 id="修饰符">修饰符</h2><p>我觉得很有必要先把这个修饰符先了解了再去了解元字符</p><p>正则表达式一般长这样    /  pattern(匹配字符串) /flags(修饰符)</p><p>修饰符很大程度上影响我们的匹配</p><h3 id="g修饰符">g修饰符</h3><p>代表全局匹配(global),查找所有项,如果不加这个,就只查找第一项</p><h3 id="i修饰符">i修饰符</h3><p>代表忽略大小写(ignore)</p><h3 id="m修饰符">m修饰符</h3><p>代表多行匹配( multi line), 如果不加这个,无论换行与否都是当成一行来处理,这样的话使用 $ 和 ^ 元字符的时候就要注意了</p><h3 id="s修饰符">s修饰符</h3><p>代表 当使用元字符 . 的时候  可以匹配 换行符,如果不加的话, . 是不会匹配 换行符的</p><h2 id="元字符">元字符</h2><p>使用元字符可以让我们使用更简单的正则表达式匹配更加精确的字符串,接下来让我一起去看看吧</p><blockquote><p>当然我们也可以不使用任何元字符,这样就是基本匹配了</p></blockquote><h3 id="点">. 点</h3><p>. 可以匹配任何一个字符</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217175038896.png" alt="image-20230217175038896"></p><blockquote><p>这里所有字符都匹配了的原因就是 g修饰符的原因</p></blockquote><h3 id="字符集">[] 字符集</h3><p>可以匹配字符集里面的任意一个字符</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217180614878.png" alt="image-20230217180614878"></p><p>[aeiou]  可以 匹配 a, e,i,o,u 这五个字符中的任意一个</p><h3 id="否定字符集">[^] 否定字符集</h3><p>可以匹配除了这个字符集以外的任何一个字符</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217201614364.png" alt="image-20230217201614364"></p><p>我们可以看到ber 和 bor 就没有被选中</p><blockquote><p>需要注意的是 ^ 只能写在开头</p></blockquote><h3 id="拓展字符集">拓展字符集</h3><p>这个是我自己命名的哈哈哈哈</p><p>对于上述两个字符集我们还可以拓展一番</p><p>我们可以在字符集和否定字符集的基础上变成范围字符集</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217202130170.png" alt="image-20230217202130170"></p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217202151743.png" alt="image-20230217202151743"></p><p>同样的我们也可以将上述字符集变成否定字符集</p><p>我们还可以使用这种格式的表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[a-z0<span class="number">-9</span>]/g   <span class="comment">// 这个代表a-z和0-9中的任意一个字符</span></span><br></pre></td></tr></table></figure><h3 id="大括号">大括号{}</h3><p>这个代表前一个表达式出现的范围</p><p>{N} 代表前一个表达式出现N次才能匹配</p><p>{N,M} 代表前一个表示式出现N-M次之间才能匹配  {N,} 代表 [N,无穷大)  {,M}代表[0,M]</p><h3 id="重复字符">+ * ? 重复字符</h3><p>我们可以通过+ * ? 元字符来指定前一个子表达式重复出现的次数</p><p>? 代表出现 0 次或者1次 可以匹配</p><p>+ 代表出现 1次或者1次以上 可以匹配</p><p>* 代表出现任意次  可以匹配</p><p>*<em>+ * 都是贪婪匹配,就是匹配的内容越多越好  而 +?  <em>? 就不是贪婪匹配,恰恰相反,匹配的内容越少越好,</em></em></p><h3 id="分组">() 分组</h3><p>我们对一个表达式进行分组,可以引用或者执行一些规则</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217204359242.png" alt="image-20230217204359242"></p><h3 id="引用分组">引用分组</h3><p>我们可以使用 \1 \2  这种格式来引用分组, 有两个作用,一是简化表达式,二是让这里的内容和指定的那个分组的内容要相同</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217204643489.png" alt="image-20230217204643489"></p><h3 id="非捕获分组">非捕获分组(?:)</h3><p>这个呢其实就是为了让这个分组不参与到\1 \2 这里面去,就是这个分组不影响这个计数,就当他不存在</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217204847068.png" alt="image-20230217204847068"></p><p>如果不考虑这个非捕获分组,那么这个\1 应该要匹配ha</p><h3 id="命名分组-p-name">命名分组 (?P&lt;name&gt;)</h3><p>这个其实是对分组进行命名,在代码中获取分组的时候也可以直接使用名字非方式获得分组,而不用使用 1,2 这种索引方式,<strong>这样的分组还是计入到引用分组的计数当中的</strong>,不同的语言对于正则表达式命名分组的做法不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/hello(?P&lt;first&gt;world)(?P=world)/g    <span class="comment">// python  (?P&lt;name&gt; ) 是创建命名分组  (?P=name) 是引用分组  当然 \1 也可以</span></span><br><span class="line">/hello(?&lt;first&gt;world)\k&lt;first&gt;   <span class="comment">// java  (?&lt;first&gt;) 是创建命名分组 \k&lt;first&gt;  是引用分组  当然 /1 也可以</span></span><br></pre></td></tr></table></figure><h3 id="竖线">竖线 |</h3><p>这个其实就是或这样一个逻辑,或上两个表达式,前面的表达式或者后面的表达式任意一个匹配上都行</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217205033283.png" alt="image-20230217205033283"></p><h3 id="转义字符">转义字符 \</h3><p>这个用来将. [] ^ + * ? () 这些元字符进行转义,使得这些字符能够直接参与到匹配中</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217205422153.png" alt="image-20230217205422153"></p><h3 id="插入符">插入符^</h3><p>这个代表开始位置,也就是行首</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217205549107.png" alt="image-20230217205549107"></p><p>如果没开启m修饰符,那么就只有一行了哦</p><h3 id="美元符号">美元符号 $</h3><p>这个代表行尾</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217205651140.png" alt="image-20230217205651140"></p><p>同样的,如果没开启m修饰符,那么就只有一行了哦</p><h3 id="单词边界-b">单词边界 \b</h3><p>这个代表前一个字符已经是单词的最后一个了,我们可以这样理解, 先不看\b这个字符,先将匹配好的字符串全部标出来,看哪些<strong>是单词的末尾</strong>就符合要求</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217210345423.png" alt="image-20230217210345423"></p><h3 id="非单词边界-b">非单词边界 \B</h3><p>这个代表前一个字符还不是单词的最后一个,我们可以这样理解, 先不看\B这个字符,先将匹配好的字符串全部标出来,看哪些<strong>不是单词的末尾</strong>就符合要求</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217210356506.png" alt="image-20230217210356506"></p><h3 id="w-小写w">\w(小写w)</h3><p>用来匹配字符,数字或者下划线</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217210713056.png" alt="image-20230217210713056"></p><h3 id="w-大写w">\W(大写W)</h3><p>用来匹配非字符,数字,下划线的</p><blockquote><p>中文属于 \W</p></blockquote><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217210822385.png" alt="image-20230217210822385"></p><h3 id="d">\d</h3><p>用来匹配数字字符</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217210853497.png" alt="image-20230217210853497"></p><h3 id="d">\D</h3><p>用来匹配非单词字符</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217210931195.png" alt="image-20230217210931195"></p><h3 id="s">\s</h3><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217210949711.png" alt="image-20230217210949711"></p><h3 id="s">\S</h3><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217211002105.png" alt="image-20230217211002105"></p><h3 id="零宽断言">零宽断言</h3><p>说人话就是 希望匹配的字符在某个字符或者多个字符之前或者之后,这种断言也属于非捕获分组</p><p><strong>他们并不参与匹配,只是多了一些限制</strong></p><h3 id="正向先行断言">正向先行断言: (?=)</h3><p>就是<strong>表达式所匹配的字符</strong>后面紧挨着<strong>所给定的字符</strong>才能匹配成功</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217211653600.png" alt="image-20230217211653600"></p><p>这个正则表达式的意思就是 匹配 一个或者多个数字,这些数字的最后一个要紧挨着PM</p><h3 id="负向先行断言">负向先行断言: (?!)</h3><p>就是<strong>表达式所匹配的字符</strong>后面没有紧挨着<strong>所给定的字符</strong>才能匹配成功</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217211937896.png" alt="image-20230217211937896"></p><p>这个正则表达式的意思就是 匹配 一个或者多个数字,这些数字的最后一个不能紧挨着PM</p><h3 id="正向后行断言">正向后行断言: (?&lt;=)</h3><p>就是<strong>所给定的字符</strong>后面紧挨着<strong>表达式所匹配的字符</strong>才能匹配成功</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217212112797.png" alt="image-20230217212112797"></p><p>这个正则表达式的意思就是 匹配 一个或者多个数字,这些数字的第一个要紧挨着$</p><h3 id="负向后行断言">负向后行断言: (?&lt;!)</h3><p>就是<strong>所给定的字符</strong>后面没有紧挨着<strong>表达式所匹配的字符</strong>才能匹配成功</p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217212424069.png" alt="image-20230217212424069"></p><p>这个正则表达式的意思就是 匹配 一个或者多个数字,这些数字的第一个不能紧挨着$</p><h2 id="贪婪与非贪婪匹配">贪婪与非贪婪匹配</h2><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217212631098.png" alt="image-20230217212631098"></p><p><img src="/2023/02/17/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/../img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fassets/image-20230217212646387.png" alt="image-20230217212646387"></p><p>*<em>+ * 都是贪婪匹配,就是匹配的内容越多越好  而 +?  <em>? 就不是贪婪匹配,恰恰相反,匹配的内容越少越好</em></em></p><h2 id="常用正则表达式">常用正则表达式</h2><h3 id="一-校验数字的表达式">一、校验数字的表达式</h3><ul><li>数字：<strong>^[0-9]*$</strong></li><li>n位的数字：<strong>^\d{n}$</strong></li><li>至少n位的数字**：^\d{n,}$**</li><li>m-n位的数字：<strong>^\d{m,n}$</strong></li><li>零和非零开头的数字：<strong>^(0|[1-9][0-9]*)$</strong></li><li>非零开头的最多带两位小数的数字：<strong>^([1-9][0-9]*)+(.[0-9]{1,2})?$</strong></li><li>带1-2位小数的正数或负数：<strong>^(-)?\d+(.\d{1,2})$</strong></li><li>正数、负数、和小数：<strong>^(-|+)?\d+(.\d+)?$</strong></li><li>有两位小数的正实数：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>有1~3位小数的正实数：<strong>^[0-9]+(.[0-9]{1,3})?$</strong></li><li>非零的正整数：<strong>^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$</strong></li><li>非零的负整数：<strong>^-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$</strong></li><li>非负整数：<strong>^\d+$ 或 ^[1-9]\d*|0$</strong></li><li>非正整数：<strong>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</strong></li><li>非负浮点数：<strong>^\d+(.\d+)?$ 或 ^[1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0$</strong></li><li>非正浮点数：<strong>^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d*.\d*|0.\d*[1-9]\d*))|0?.0+|0$</strong></li><li>正浮点数：<strong>^[1-9]\d*.\d*|0.\d*[1-9]\d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$</strong></li><li>负浮点数：<strong>^-([1-9]\d*.\d*|0.\d*[1-9]\d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$</strong></li><li>浮点数：<strong>^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0)$</strong></li></ul><hr><h3 id="二-校验字符的表达式">二.校验字符的表达式</h3><ul><li>汉字：<strong>^[\u4e00-\u9fa5]{0,}$</strong></li><li>英文和数字：<strong>^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</strong></li><li>长度为3-20的所有字符：<strong>^.{3,20}$</strong></li><li>由26个英文字母组成的字符串：<strong>^[A-Za-z]+$</strong></li><li>由26个大写英文字母组成的字符串：<strong>^[A-Z]+$</strong></li><li>由26个小写英文字母组成的字符串：<strong>^[a-z]+$</strong></li><li>由数字和26个英文字母组成的字符串：<strong>^[A-Za-z0-9]+$</strong></li><li>由数字、26个英文字母或者下划线组成的字符串：<strong>^\w+$ 或 ^\w{3,20}$</strong></li><li>中文、英文、数字包括下划线：<strong>^[\u4E00-\u9FA5A-Za-z0-9_]+$</strong></li><li>中文、英文、数字但不包括下划线等符号：<strong>^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</strong></li><li>可以输入含有^%&amp;’,;=?<span class="katex-error" title="ParseError: KaTeX parse error: Can&#039;t use function &#039;\&quot;&#039; in math mode at position 1: \̲&quot;̲等字符：**[^%&amp;&#039;,;=?">\&quot;等字符：**[^%&amp;&#039;,;=?</span>\x22]+**</li><li>禁止输入含有~的字符：<strong>[^~]+</strong></li></ul><hr><h3 id="三-特殊需求表达式">三、特殊需求表达式</h3><ul><li>Email地址：<strong>^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$</strong></li><li>域名：<strong>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.?</strong></li><li>InternetURL：<strong>[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</strong></li><li>手机号码：<strong>^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$</strong></li><li>电话号码(“XXX-XXXXXXX”、“XXXX-XXXXXXXX”、“XXX-XXXXXXX”、“XXX-XXXXXXXX”、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：<strong>^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$</strong></li><li>国内电话号码(0511-4405222、021-87888822)：<strong>\d{3}-\d{8}|\d{4}-\d{7}</strong></li><li>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: <strong>((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)</strong></li><li>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：<strong>(^\d{15}<span class="katex-error" title="ParseError: KaTeX parse error: Undefined control sequence: \d at position 5: )|(^\̲d̲{18}">)|(^\d{18}</span>)|(^\d{17}(\d|X|x)$)</strong></li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<strong>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</strong></li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<strong>^[a-zA-Z]\w{5,17}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</strong></li><li>日期格式：<strong>^\d{4}-\d{1,2}-\d{1,2}</strong></li><li>一年的12个月(01～09和1～12)：<strong>^(0?[1-9]|1[0-2])$</strong></li><li>一个月的31天(01～09和1～31)：<strong>^((0?[1-9])|((1|2)[0-9])|30|31)$</strong></li><li>钱的输入格式：<ol><li>有四种钱的表示形式我们可以接受:“10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<strong>^[1-9][0-9]*$</strong></li><li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：<strong>^(0|[1-9][0-9]*)$</strong></li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<strong>^(0|-?[1-9][0-9]*)$</strong></li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<strong>^[0-9]+(.[0-9]+)?$</strong></li><li>必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 “10” 和 “10.2” 是通过的：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<strong>^[0-9]+(.[0-9]{1,2})?$</strong></li><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<strong>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</strong></li><li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<strong>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</strong></li><li>备注：这就是最终结果了,别忘了&quot;+“可以用”*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li></ol></li><li>xml文件：<strong>^([a-zA-Z]±?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</strong></li><li>中文字符的正则表达式：<strong>[\u4e00-\u9fa5]</strong></li><li>双字节字符：<strong>[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</strong></li><li>空白行的正则表达式：<strong>\n\s*\r (可以用来删除空白行)</strong></li><li>HTML标记的正则表达式：<strong>&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\s*|\s*<span class="katex-error" title="ParseError: KaTeX parse error: Undefined control sequence: \s at position 4: 或(^\̲s̲\*)|(\s\*">或(^\s\*)|(\s\*</span>) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</strong></li><li>腾讯QQ号：<strong>[1-9][0-9]{4,} (腾讯QQ号从10000开始)</strong></li><li>中国邮政编码：<strong>[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)</strong></li><li>IPv4地址：<strong>((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}</strong></li></ul><h2 id="更详细的元字符表-来自菜鸟教程">更详细的元字符表(来自菜鸟教程)</h2><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，‘n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\’ 匹配 “” 而 “(” 则匹配 “(”。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td style="text-align:left">{n}</td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:left">{n,}</td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td style="text-align:left">{n,m}</td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，‘o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像&quot;<strong>(.|\n)</strong>&quot;的模式。</td></tr><tr><td style="text-align:left">(pattern)</td><td style="text-align:left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(’ 或 ‘)’。</td></tr><tr><td style="text-align:left">(?:pattern)</td><td style="text-align:left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td style="text-align:left">(?=pattern)</td><td style="text-align:left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)“能匹配&quot;Windows2000&quot;中的&quot;Windows”，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td style="text-align:left">(?!pattern)</td><td style="text-align:left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&quot;Windows(?!95|98|NT|2000)“能匹配&quot;Windows3.1&quot;中的&quot;Windows”，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td style="text-align:left">(?&lt;=pattern)</td><td style="text-align:left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&quot;<code>(?&lt;=95|98|NT|2000)Windows</code>“能匹配”<code>2000Windows</code>“中的”<code>Windows</code>&quot;，但不能匹配&quot;<code>3.1Windows</code>“中的”<code>Windows</code>&quot;。</td></tr><tr><td style="text-align:left">(?&lt;!pattern)</td><td style="text-align:left">反向否定预查，与正向否定预查类似，只是方向相反。例如&quot;<code>(?&lt;!95|98|NT|2000)Windows</code>“能匹配”<code>3.1Windows</code>“中的”<code>Windows</code>&quot;，但不能匹配&quot;<code>2000Windows</code>“中的”<code>Windows</code>&quot;。</td></tr><tr><td style="text-align:left">x|y</td><td style="text-align:left">匹配 x 或 y。例如，‘z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td style="text-align:left">[xyz]</td><td style="text-align:left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td style="text-align:left">[^xyz]</td><td style="text-align:left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、‘l’、‘i’、‘n’。</td></tr><tr><td style="text-align:left">[a-z]</td><td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td style="text-align:left">[^a-z]</td><td style="text-align:left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配&quot;never&quot; 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">匹配非单词边界。‘er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td style="text-align:left">\cx</td><td style="text-align:left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td style="text-align:left">\d</td><td style="text-align:left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td style="text-align:left">\D</td><td style="text-align:left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td style="text-align:left">\S</td><td style="text-align:left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td style="text-align:left">\w</td><td style="text-align:left">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td style="text-align:left">\W</td><td style="text-align:left">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td style="text-align:left">\xn</td><td style="text-align:left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td style="text-align:left">\num</td><td style="text-align:left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td style="text-align:left">\nm</td><td style="text-align:left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td style="text-align:left">\nml</td><td style="text-align:left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td style="text-align:left">\un</td><td style="text-align:left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java爬虫</title>
      <link href="/2023/02/16/java/java%E7%88%AC%E8%99%AB/"/>
      <url>/2023/02/16/java/java%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Java 有很多好用的爬虫框架可供选择。以下是其中一些流行的爬虫框架：</p><ol><li>Jsoup：Jsoup 是一个 HTML 解析器，可以方便地从 HTML 文档中提取数据。它可以模拟浏览器行为，解析 HTML 标签和属性，并提供了多种方法来选择和操作文档中的元素。</li><li>WebMagic：WebMagic 是一个基于 Java 的开源网络爬虫框架。它提供了强大的抓取和解析功能，支持多线程和分布式部署。WebMagic 还有一个基于注解的简单 API，可以方便地实现自定义的抓取逻辑。</li><li>HttpClient：HttpClient 是一个用于发送 HTTP 请求的 Java 库，可以用来构建爬虫。它提供了对多种 HTTP 协议的支持，可以处理 HTTP 请求和响应，并提供了多种方式来处理响应内容。</li><li>Selenium：Selenium 是一个用于自动化浏览器的工具，可以用来构建爬虫。它可以模拟用户在浏览器中的操作，如点击、滚动、输入等，并提供了多种方式来获取网页内容。</li><li>Spring Batch：Spring Batch 是一个用于批量处理的框架，可以用来构建爬虫。它提供了多线程、分步骤和分布式处理的支持，可以方便地处理大规模的数据抓取和处理任务。</li></ol><p>这些爬虫框架都有其特点和优点，开发者可以根据实际需求选择合适的框架来构建自己的爬虫。</p><p>本文用与总结各种爬虫的使用方法</p><blockquote><p>在此之前,我希望大家已经对计算机网络,Http,正则表达式有了一定的了解</p></blockquote><h2 id="jsoup">Jsoup</h2><p>jsoup是非常简单实用的一个爬虫工具,支持html页面解析,生来就是用来爬html数据的,它能够接受服务器返回的数据类型只有:</p><p>text/*, application/xml, or application/*+xml 这三种</p><h3 id="引入依赖">引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.15.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取html">获取html</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 直接拿到解析好的文档模型</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://www.baidu.com&quot;</span>).get();</span><br><span class="line">      <span class="comment">// 输出html</span></span><br><span class="line">      System.out.println(document.body().html());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="发送post请求">发送post请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="type">Document</span> <span class="variable">post</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://localhost:8888/login&quot;</span>)</span><br><span class="line">              .data(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">              .data(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">              .post();</span><br><span class="line">      System.out.println(post.body().html());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们还可以设置其他类型参数,比如文件,二进制数据,都可以通过data方法设置,而且可以设置多份,它会自己帮我们指定好合适的数据类型</p><h3 id="拿到响应对象">拿到响应对象</h3><p>我们发现上面的方式都是直接获得文档对象了,有时候我们可能需要响应头里面的一些东西比如cookie,我们就可以只拿响应对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      Connection.<span class="type">Response</span> <span class="variable">execute</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://localhost:8888/login&quot;</span>)</span><br><span class="line">              .data(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">              .data(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">              .execute();</span><br><span class="line">      System.out.println(execute.cookies());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="httpclient">HttpClient</h2><p>HttpClient <strong>不是一个浏览器</strong>。它是一个客户端的 <strong>HTTP 通信实现库</strong>。HttpClient 的目标是<strong>发送和接收 HTTP 报文</strong>。HttpClient <strong>不会</strong>去缓存内容，<strong>执行嵌入在 HTML 页面中的 javascript 代码</strong>，猜测内容类型，<strong>重新格式化请求/重定向 URI</strong>，或者其它和 HTTP运输无关的功能。</p><blockquote><p>上面这句话是官方给PDF书籍翻译过来的,但是我在实际用的时候,发现这个版本的HttpClient执行重定向这个东西</p></blockquote><h3 id="引入依赖">引入依赖</h3><p>我用的是5.x的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents.client5<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="一个简单的get请求">一个简单的GET请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="comment">// 为了代码简洁,我把异常都声明在方法上了,没有用try catch包裹</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ParseException &#123;</span><br><span class="line">        <span class="comment">// 创建一个简化版浏览器(只能接受和发送报文)</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">aDefault</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="comment">// 创建一个Http请求,这个链接是一个重定向链接,会重定向到http://localhost:8888/login.html</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://localhost:8888/test1&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">execute</span> <span class="operator">=</span> aDefault.execute(httpGet);</span><br><span class="line">        <span class="comment">// 输出响应状态码</span></span><br><span class="line">        System.out.println(execute.getCode());</span><br><span class="line">        <span class="comment">// 将二进制实体内容变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> EntityUtils.toString(execute.getEntity());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">// 关闭浏览器</span></span><br><span class="line">        aDefault.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><p><img src="/2023/02/16/java/java%E7%88%AC%E8%99%AB/../img/java%E7%88%AC%E8%99%ABassets/image-20230216164236015.png" alt="image-20230216164236015"></p><p>我们发现响应码居然是200,是不是验证了我们上面说的,httpclient执行了重定向请求,不然状态码应该是302的</p><h3 id="往get请求里面放置参数">往GET请求里面放置参数</h3><p>这个简单,get的请求参数一般是跟URI拼接在一起的,我们只需要拼接字符串就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ParseException &#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">aDefault</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该请求返回id的值</span></span><br><span class="line">        <span class="comment">// 直接自己拼接在路径中</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://localhost:8888/test2?id=10&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">execute</span> <span class="operator">=</span> aDefault.execute(httpGet);</span><br><span class="line">        <span class="comment">// 输出响应状态码</span></span><br><span class="line">        System.out.println(execute.getCode());</span><br><span class="line">        <span class="comment">// 将二进制实体内容变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> EntityUtils.toString(execute.getEntity());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        aDefault.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/16/java/java%E7%88%AC%E8%99%AB/../img/java%E7%88%AC%E8%99%ABassets/image-20230216170720228.png" alt="image-20230216170720228"></p><p>我推荐直接使用直接拼接的方式,简单明了,一般get请求也不会有很多参数,参数的变化也不多</p><h3 id="打断一下">打断一下</h3><p>其实啊,上面的那种执行请求的方法已经过时了,我么可以对比一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"> <span class="keyword">public</span> CloseableHttpResponse <span class="title function_">execute</span><span class="params">(ClassicHttpRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.doExecute(determineTarget(request), request, (HttpContext)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(ClassicHttpRequest request, HttpClientResponseHandler&lt;? extends T&gt; responseHandler)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.execute((ClassicHttpRequest)request, (HttpContext)<span class="literal">null</span>, (HttpClientResponseHandler)responseHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种方法的区别在于,第一种是需要我们自己去处理响应体的,第二种是我们可以用现在已经存在的处理响应的类去处理,这样可以解耦代码,而且还不需要我们自己考虑响应是否关闭的问题</span></span><br><span class="line"><span class="comment">// 后续的代码就都是用第二种方法了</span></span><br></pre></td></tr></table></figure><h3 id="发起post请求">发起POST请求</h3><p>模拟表单登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">aDefault</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="comment">//模拟登录请求</span></span><br><span class="line">        <span class="comment">// 向这个地址发送账号密码登录</span></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8888/login&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建请求实体</span></span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> EntityBuilder.create().setContentType(ContentType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                .setParameters(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;123&quot;</span>),<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123&quot;</span>)).build();</span><br><span class="line">        <span class="comment">// 放入请求体</span></span><br><span class="line">        httpPost.setEntity(httpEntity);</span><br><span class="line">        <span class="comment">// 接收响应</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">execute</span> <span class="operator">=</span> aDefault.execute(httpPost, <span class="keyword">new</span> <span class="title class_">BasicHttpClientResponseHandler</span>());</span><br><span class="line">        System.out.println(execute);</span><br><span class="line">        aDefault.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/16/java/java%E7%88%AC%E8%99%AB/../img/java%E7%88%AC%E8%99%ABassets/image-20230216191657397.png" alt="image-20230216191657397"></p><p>其实啊,这里还有点问题的,虽然已经成功登陆,但是我们没有记录cookie值,但是我们还是能够访问index.html页面,但是吧,对于单个页面这样可能没有问题,但是当请求的网址多了,可能就有问题,或者不保险,这个问题我们后面再说</p><h3 id="构建实体">构建实体</h3><p>POST请求一般将请求参数放在请求体里面,这个东西叫做请求实体,在Httpclient中有很多种请求实体,他们对应不同的数据,比如字符串,文件等等,大致就是分为字符串和二进制流两种</p><p>我一般采用构建实体的方法创建实体,而不是使用直接创建对象</p><p>有两个可以构建实体的类: EntityBuilder  和  MultipartEntityBuilder,看名字就知道了,一个是单个部分,一个是多部分,使用第一个,我们就只能上传一个文件或者一个字符串,使用第二个,我们可以上传多个字符串多个文件</p><blockquote><p>其实啊无论是多部分还是单部分,最后都在同一个请求体里面,只不过多部分具有分割记录罢了,用来区分各个部分</p></blockquote><h4 id="entitybuilder">EntityBuilder</h4><p>它是支持链式操作的,它能够操作请求体里面的内容,可以放<strong>字符串,二进制数据,文件,输入流,序列化的对象</strong>,反正呢,这些只能选一个放进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> EntityBuilder.create().setContentType(ContentType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                .setParameters(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;123&quot;</span>),<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123&quot;</span>)).build();</span><br><span class="line"><span class="comment">// 这个内容类型我们其实可以不用设置,它都有默认的,列如字符串实体对应APPLICATION_FORM_URLENCODED,如果我们需要告诉服务器是json格式才需要改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EntityBuilder <span class="title function_">setText</span><span class="params">(String text)</span>; <span class="comment">// 设置字符串</span></span><br><span class="line">EntityBuilder <span class="title function_">setBinary</span><span class="params">(<span class="type">byte</span>[] binary)</span>;  <span class="comment">// 设置二进制数据</span></span><br><span class="line">EntityBuilder <span class="title function_">setStream</span><span class="params">(InputStream stream)</span>;  <span class="comment">// 设置流</span></span><br><span class="line">EntityBuilder <span class="title function_">setParameters</span><span class="params">(List&lt;NameValuePair&gt; parameters)</span>; <span class="comment">// 设置参数</span></span><br><span class="line">EntityBuilder <span class="title function_">setSerializable</span><span class="params">(Serializable serializable)</span>;  <span class="comment">// 设置序列化对象</span></span><br><span class="line">EntityBuilder <span class="title function_">setFile</span><span class="params">(File file)</span>;  <span class="comment">// 设置文件</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h4 id="multipartentitybuilder">MultipartEntityBuilder</h4><p>这个也是支持链式操作的,它支持多部分,就是可以放多个文件啊或者文本进去的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> MultipartEntityBuilder.create().setContentType(ContentType.MULTIPART_FORM_DATA)</span><br><span class="line">                .addTextBody(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">                .addTextBody(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">                .addBinaryBody(<span class="string">&quot;file&quot;</span>,<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test1/src/main/java/com/djm/user.java&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">// 文本数据都用 addTextBody  二进制数据就用 addBinaryBody,它支持文件,输入流,byte</span></span><br></pre></td></tr></table></figure><p>我们来对比一下两种构造器构造出来的实体有什么区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ParseException &#123;</span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">hello_world</span> <span class="operator">=</span> EntityBuilder.create().setText(<span class="string">&quot;hello world&quot;</span>).build();</span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">build</span> <span class="operator">=</span> MultipartEntityBuilder.create().addBinaryBody(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                .addTextBody(<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;hello world&quot;</span>).build();</span><br><span class="line">        System.out.println(EntityUtils.toString(hello_world));</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        System.out.println(EntityUtils.toString(build));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/16/java/java%E7%88%AC%E8%99%AB/../img/java%E7%88%AC%E8%99%ABassets/image-20230217142456772.png" alt="image-20230217142456772"></p><p>我们会发现单部分就只有一条原生字符串,但是多部分会添加很多的分隔部分</p><h3 id="有状态连接">有状态连接</h3><p>还记得我们在POST请求那个部分留下的坑吗,<strong>因为我们根本没有保存上下文</strong>,一般情况下,如果我们登录成功,浏览器会保存后服务器返回下来的cookie这些东西,而我们代码中根本就没有保存上下文,所有我们需要去定义一个上下文,每次请求带上它,虽然httpclient有缓存功能,也能请求页面,但是最保险的做法还是使用上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8888/login&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">build</span> <span class="operator">=</span> EntityBuilder.create().setParameters(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;123&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>)).build();</span><br><span class="line">        httpPost.setEntity(build);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建上下文</span></span><br><span class="line">        <span class="type">HttpClientContext</span> <span class="variable">httpClientContext</span> <span class="operator">=</span> HttpClientContext.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连同上下文一起发送请求,如果请求成功后,对上下文的更改也会同步</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">execute</span> <span class="operator">=</span> httpClient.execute(httpPost, httpClientContext, <span class="keyword">new</span> <span class="title class_">BasicHttpClientResponseHandler</span>());</span><br><span class="line">        System.out.println(execute);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://localhost:8888/index.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 带上上下文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">execute1</span> <span class="operator">=</span> httpClient.execute(httpGet, <span class="keyword">new</span> <span class="title class_">BasicHttpClientResponseHandler</span>());</span><br><span class="line">        System.out.println(execute1);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不带上上下文(因为有缓存原因,也能访问)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">execute2</span> <span class="operator">=</span> httpClient.execute(httpGet, <span class="keyword">new</span> <span class="title class_">BasicHttpClientResponseHandler</span>());</span><br><span class="line">        System.out.println(execute2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序结果</p><p><img src="/2023/02/16/java/java%E7%88%AC%E8%99%AB/../img/java%E7%88%AC%E8%99%ABassets/image-20230217155730978.png" alt="image-20230217155730978"></p><p>上下文有两种,一种是BasicHttpContext,另外一种是HttpClientContext,下面试这两种的区别</p><ul><li><p>BasicHttpContext 是 HttpContext 接口的简单实现，提供了基本的上下文信息存储和获取功能，例如可以通过 setAttribute 和 getAttribute 方法来存储和获取上下文属性</p></li><li><p>httpClientContext 比 BasicHttpContext 更专注于处理 HttpClient 相关的上下文信息，例如可以通过 setCredentialsProvider 方法设置凭据提供程序，通过 setAuthCache 方法设置认证缓存，通过 setRoutePlanner 方法设置路由计划器等</p></li><li><p>BasicHttpContext 没有与 HttpClient 相关的方法，因此不能直接用于 HttpClient 的请求和响应处理过程中。HttpClientContext 可以直接用于 HttpClient 的请求和响应处理过程中，因为它包含了 HttpClient 所需要的上下文信息。</p></li></ul><p>综上所述，如果只需要基本的上下文信息存储和获取功能，可以使用 BasicHttpContext。如果需要与 HttpClient 相关的上下文信息，则应该使用 HttpClientContext。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jsoup </tag>
            
            <tag> HttpClient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webMagic使用详解</title>
      <link href="/2023/02/15/java/webMagic%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/15/java/webMagic%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>webmagic  里面维持了一个请求队列,多个线程就是从这个队列里面请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Spider</span> <span class="variable">spider</span> <span class="operator">=</span> Spider.create(<span class="keyword">new</span> <span class="title class_">test1</span>()).thread(<span class="number">5</span>);  <span class="comment">// 开启五个线程去请求队列里面拿请求,然后请求服务器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            spider.addUrl(<span class="string">&quot;http://localhost:8888/?a=&quot;</span>+i);  <span class="comment">// 请求这个地址会返回参数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        spider.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果如下:</span><br><span class="line"></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=2</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=1</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=3</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=0</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=4</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=8</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=5</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=9</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=6</span></span><br><span class="line">get page: http:<span class="comment">//localhost:8888/?a=7</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>http协议</title>
      <link href="/2023/02/15/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/02/15/%E5%8D%95%E7%8B%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>万维网构想三个部分:</p><ul><li>页面文本标记语言 html  (  怎么表示页面)</li><li>传输数据的协议 http    ( 怎么传输页面)</li><li>统一资源标识符 URI  (资源在哪)</li></ul><p>在所有的HTTP版本中,目前最流行的还是HTTP1.1这个版本</p><h3 id="uri与url">URI与URL</h3><p>URI (统一资源标识符)  和  URL(统一资源定位符的区别)  :</p><p>URI 可以用来标识任何资源(比如ftp,http,talent协议类型的资源),而URL 只能标识特定协议(http)的资源, URI 支持很多种协议,而URL 只支持http协议,URL 是 URI 的一个子集</p><blockquote><p>所以咱们以后就说URI 就不会错啦,哈哈哈哈</p></blockquote><p>后面的总结都是基于HTTP1.1来说的哦</p><h2 id="请求方法">请求方法</h2><p>http协议支持的请求方法:</p><ul><li>GET 主要用于向服务器获取资源</li><li>POST 主要用于向服务器传输资源</li><li>HADE 与GET方法类似,但是只获取响应报文的首部,不返回响应报文的主体</li><li>OPTIONS 询问支持的方法(在响应报文头部的Allow字段里面)</li><li>TRACE</li><li>CONNECT</li><li>PUT 用于上传资源</li><li>DELTE 用于删除资源</li></ul><p>后面两个方法需要后端采用RESTFUL架构</p><blockquote><p>这么多方法在使用的时候应该要尽量遵守规则,这样能避免不少错误, 比如使用GET方法就要做到请求参数放在url中,请求体里面就不要放任何数据,请求参数也尽量只是用来查询,而不是上传</p></blockquote><h2 id="报文">报文</h2><p>HTTP 报文由 报文首部和空行以及报文主体组成</p><p><img src="../../img/http%E5%8D%8F%E8%AE%AEassets/image-20230215182426876.png" alt="image-20230215182426876"></p><h3 id="请求报文"><strong>请求报文</strong></h3><h4 id="请求行">请求行</h4><p>请求行包含请求方法,URI,http版本</p><h4 id="请求首部字段">请求首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言(自然语言)</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记(ETag)</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记(与If-Match相反)</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体Byte的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间(与If-Modified-Since相反)</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中URI的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP客户端程序的信息</td></tr></tbody></table><h3 id="响应报文"><strong>响应报文</strong></h3><h4 id="状态行">状态行</h4><p>状态行包含http版本,响应结果码状态码,原因短语</p><h4 id="响应首部字段">响应首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h3 id="通用首部字段"><strong>通用首部字段</strong></h3><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>逐跳首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h3 id="实体首部字段"><strong>实体首部字段</strong></h3><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的HTTP方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小(单位：字节)</td></tr><tr><td>Content-Location</td><td>替代对应资源的URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><p>对于Content-Type有以下几种:</p><ul><li>application/x-www-form-urlencoded   表单数据类型,报文中的格式为 username=john&amp;password=123456</li><li>application/json  json格式类型数据</li><li>multipart/form-data  二进制类型数据</li><li>application/octet-stream  这个用于响应头里面,用于让浏览器下载文件</li></ul><h3 id="为-cookie-服务的首部字段">为 Cookie 服务的首部字段</h3><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的Cookie信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的Cookie信息</td><td>请求首部字段</td></tr></tbody></table><p><strong>HttpOnly</strong> 属性</p><p>可以在Set-Cookie中设置</p><p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site</p><p>scripting，XSS）对 Cookie 的信息窃取。</p><blockquote><p>当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时</p><p>会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑</p><p>的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的</p><p>首部字段，而有些则会优先处理最后出现的首部字段。</p></blockquote><h2 id="响应状态码">响应状态码</h2><p>HTTP响应状态码是指Web服务器响应客户端请求时返回的状态码，主要用于表示请求的处理结果。以下是HTTP响应状态码及其含义：</p><p><strong>1xx（信息性状态码）</strong>：表示服务器已经接收到请求，正在处理中。</p><ul><li>100 Continue：表示客户端可以继续发送请求。</li><li>101 Switching Protocols：表示服务器已经同意客户端要求的协议变更。</li></ul><p><strong>2xx（成功状态码）</strong>：表示服务器已经成功处理请求。</p><ul><li>200 OK：表示请求已成功，请求所希望的响应头或数据体将随此响应返回。</li><li>201 Created：表示请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。</li><li>204 No Content：表示服务器已经成功处理请求，但没有返回任何内容。</li></ul><p><strong>3xx（重定向状态码）</strong>：表示客户端需要执行一些特殊的操作才能完成请求。</p><ul><li>301 Moved Permanently：表示请求的资源已经被永久移动到新的URI，客户端应该使用新的URI重新发起请求。</li><li>302 Found：表示请求的资源临时被移动到新的URI，客户端应该继续使用原有URI。</li><li>304 Not Modified：表示客户端的缓存资源仍然有效，可以直接使用缓存资源。</li></ul><p><strong>4xx（客户端错误状态码）</strong>：表示客户端发送的请求有错误。</p><ul><li>400 Bad Request：表示请求参数有误，无法被服务器所理解。</li><li>401 Unauthorized：表示请求需要用户认证。</li><li>403 Forbidden：表示服务器拒绝请求,一般是权限不够,比如访问的文件是不可读的。</li><li>404 Not Found：表示请求的资源不存在。</li></ul><p><strong>5xx（服务器错误状态码）</strong>：表示服务器在处理请求时发生了错误。</p><ul><li>500 Internal Server Error：表示服务器在执行请求时发生了未知的错误。</li><li>502 Bad Gateway：表示服务器作为网关或代理，从上游服务器接收到的响应无效。</li><li>503 Service Unavailable：表示服务器暂时无法处理请求，可能是由于过载或维护等原因。</li></ul><h2 id="补充">补充</h2><p>HTTP 主要有这些不足，例举如下。</p><p>通信使用明文（不加密），内容可能会被窃听</p><p>不验证通信方的身份，因此有可能遭遇伪装</p><p>无法证明报文的完整性，所以有可能已遭篡改</p><p>GET 方法主要用于获取资源,而且提交的查询参数一般是以url拼接的方式,并且大小还有限制</p><p>POST 方法主要用于上传数据给服务器, 提交的数据都在请求体中(当然你也可以用url后面接参数的方法),下面是几种数据类型的格式:</p><ul><li>application/x-www-form-urlencoded    这个是表单数据,在请求体中类似这种username=john&amp;password=123456</li><li>application/json    这个是json类型数据,这个在请求体中就不用说明了</li><li>multipart/form-data 这个是用来上传二进制数据的, 一般要配合表单来使用</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电路原理</title>
      <link href="/2023/02/11/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/11/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="电流">电流</h3><p>单位时间通过横截面的电荷  I = dq/dt</p><h3 id="电压">电压</h3><p>电场力移动单位电荷需要做的功等于电压  U = dw/dp</p><h3 id="电位">电位</h3><p>从某点到某点的电压差</p><h3 id="电动势">电动势</h3><p>非电场力将单位正电荷移动做的功,一般只有电池电源有电动势</p>]]></content>
      
      
      <categories>
          
          <category> 基础课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学速成课</title>
      <link href="/2023/02/04/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"/>
      <url>/2023/02/04/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<p>半加器</p><p>全加器</p>]]></content>
      
      
      <categories>
          
          <category> 基础课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实用软件</title>
      <link href="/2023/01/04/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/windows%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/01/04/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/windows%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1>utools</h1><p>强烈推荐, 能够为我们提供很多实用的工具,  基本上能囊括我这里面其他软件了</p><p><a href="https://www.u.tools/">官网地址</a></p><h1>quicker</h1><p>这个也是强烈推荐,  搭配utools使用, 真的好用, 这个偏鼠标操作</p><p><a href="https://getquicker.net/">官网地址</a></p><h1>everything</h1><p>这个软件是用来快速的搜索到某个文件所在的位置,它会将这个文件放进数据库中,然后读取到内存里面,这个可比windows自带的那个搜索功能快多了</p><p><a href="https://www.voidtools.com/zh-cn/downloads/">官网地址</a></p><h1>TreeSize</h1><p>可以查看目录下具体子目录和文件的大小</p><p><a href="https://www.jb51.net/softs/758884.html#downintro2">破解地址</a></p><h1>Typora</h1><p>用于编写md文件</p><p><a href="https://github.com/markyin0707/typora-activation?tab=readme-ov-file">破解地址</a></p><h1>clash</h1><p>代理软件</p><p><a href="https://pan.baidu.com/s/1AK-BcvCYlvvhXp-t21Mg0Q?pwd=ae45">网盘地址</a></p><h1>手心输入法</h1><p>干净无广告, 比较好用</p><h1>窗口顶置</h1><p>帮助其他软件窗口顶置</p><ol><li>windowtop <a href="https://windowtop.info/">下载地址</a>,  <a href="https://www.jb51.net/softs/811136.html">破解地址</a></li><li>deskpins <a href="https://deskpins.en.softonic.com/download">下载地址</a></li></ol><h1>屏幕标记</h1><h1>论文阅读</h1><ol><li>zotero</li><li>readpaper</li></ol><h1>代码编写</h1><ol><li>vscode</li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>idea的使用</title>
      <link href="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>部署项目到远程服务器</h1><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20221230111039455.png" alt="image-20221230111039455"></p><p>点击配置</p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea的使用assets/image-20221230111127959.png" alt="image-20221230111127959"><p>配置好信息</p><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20221230111321068.png" alt="image-20221230111321068"></p><p>配置好路径映射</p><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20221230112531226.png" alt="image-20221230112531226"></p><h1>打jar包</h1><p>点击 <strong>文件-&gt;项目结构-&gt;工件</strong></p><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230426170830833.png" alt="image-20230426170830833"></p><p>然后点击加号</p><h2 id="创建工件">创建工件</h2><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230426170913217.png" alt="image-20230426170913217"></p><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230426171018793.png" alt="image-20230426171018793"></p><h2 id="选择目录">选择目录</h2><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230426171052542.png" alt="image-20230426171052542"></p><h2 id="构建工件">构建工件</h2><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230426171140925.png" alt="image-20230426171140925"></p><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230426171151250.png" alt="image-20230426171151250"></p><h2 id="运行jar包">运行jar包</h2><p><img src="/2022/12/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/idea%E7%9A%84%E4%BD%BF%E7%94%A8/../img/idea%E7%9A%84%E4%BD%BF%E7%94%A8assets/image-20230426171253178.png" alt="image-20230426171253178"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>plantuml</title>
      <link href="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/"/>
      <url>/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/</url>
      
        <content type="html"><![CDATA[<h2 id="时序图">时序图</h2><p>我们可以通过一条一条语句来声明步骤,-&gt; 代表实线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">用户 -&gt; 认证中心: 登录操作</span><br><span class="line">认证中心 -&gt; 缓存: 存放(key=token+ip,value=token)token</span><br><span class="line">用户 &lt;- 认证中心 : 认证成功返回token</span><br><span class="line">用户 -&gt; 认证中心: 下次访问头部携带token认证</span><br><span class="line">认证中心 &lt;- 缓存: key=token+ip获取token</span><br><span class="line">其他服务 &lt;- 认证中心: 存在且校验成功则跳转到用户请求的其他服务</span><br><span class="line">其他服务 -&gt; 用户: 信息</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228095655122.png" alt="image-20221228095655122"></p><h4 id="声明参与者">声明参与者</h4><p>上面那些框框都是可以变换形状的,我们只需要更改参与者的类型就可以了,可以指定的类型有</p><ul><li>actor（角色）</li><li>boundary（边界）</li><li>control（控制）</li><li>entity（实体）</li><li>database（数据库）</li><li>collections（集合）</li><li>queue（队列）</li></ul><p>格式就是:</p><p>participant  “participantname” as participantothername 样式(颜色,顺序)</p><p>participant  participantothername as “participantname” 样式(颜色,顺序)</p><p>取别名的意义就在与,显示的时候显示的是真正的名字,写的时候可以写别名,如果真正的名字很长的话,我们可以通过取别名的方式简化</p><h4 id="箭头样式">箭头样式</h4><ul><li>-&gt; 代表实线大箭头</li><li>-&gt;x 代表X箭头,就是不可达或者丢失</li><li>-\代表只有上箭头</li><li>-/代表只有下箭头</li><li>-&gt;&gt; 代表小(细)箭头</li><li>– 代表虚线</li><li>-&gt;o 箭头末尾加圈</li><li>&lt;-&gt; 双向箭头</li><li>在第一个-后面修改箭头颜色   -[#red]&gt;   红实线    -[#red]-&gt; 红虚线</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">actor actor1 as a1 #red </span><br><span class="line">actor actor2 as a2 #blue </span><br><span class="line">a1 -&gt; a2</span><br><span class="line">a1 -&gt;x a2</span><br><span class="line">a1 -\ a2</span><br><span class="line">a1 -/ a2</span><br><span class="line">a1 -&gt;&gt; a2</span><br><span class="line">a1 --&gt; a2</span><br><span class="line">a1 -&gt;o a2</span><br><span class="line">a1 &lt;-&gt; a2</span><br><span class="line">a1 -[#red]&gt; a2 </span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228102625296.png" alt="image-20221228102625296"></p><h4 id="autonumber">autonumber</h4><p>autonumber 添加这个可以自动对消息编号</p><ul><li><p>autonumber  startno  指定起始编号</p></li><li><p>autonumber startno step 指定起始编号以及递增数量</p></li><li><p>autonumber  样式   这里可以通过html指定编号样式</p></li><li><p>autonumber stop 停止使用自动编号</p></li><li><p>autonumber  resume  继续使用编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">actor actor1 as a1 #red </span><br><span class="line">actor actor2 as a2 #blue </span><br><span class="line"></span><br><span class="line">autonumber 0 1 &quot;&lt;font color=red&gt;message 000&lt;/font&gt;&quot;</span><br><span class="line">a1 -&gt; a2: hello world</span><br><span class="line">a2 -&gt; a1: hello world1</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228103436970.png" alt="image-20221228103436970"></p></li></ul><h4 id="页眉页脚标题">页眉页脚标题</h4><ul><li>title name  指定页面标题</li><li>header name 增加页眉</li><li>footer format 增加页脚</li><li>newpage  用来分割页面,使用一个newpage 分割一个页面变成两个页面  newpage title  指定下一个页面的标题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">header Page Header</span><br><span class="line">footer Page %page% of %lastpage%</span><br><span class="line">title Example Title</span><br><span class="line">Alice -&gt; Bob : message 1</span><br><span class="line">Alice -&gt; Bob : message 2</span><br><span class="line">newpage</span><br><span class="line">Alice -&gt; Bob : message 3</span><br><span class="line">Alice -&gt; Bob : message 4</span><br><span class="line">newpage A title for the\nlast page</span><br><span class="line">Alice -&gt; Bob : message 5</span><br><span class="line">Alice -&gt; Bob : message 6</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228105032729.png" alt="image-20221228105032729"></p><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228105040684.png" alt="image-20221228105040684"></p><p>生成了三张图片</p><h4 id="组合消息">组合消息</h4><ul><li>alt/else  有点像if else的关系</li><li>loop  循环次数    循环</li><li>group  主标签  次标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">a-&gt;b: 给你一个数</span><br><span class="line">group 判断数字 [测试]</span><br><span class="line">    alt 大于0</span><br><span class="line">        b-&gt;a: 正数</span><br><span class="line">    else 小于0</span><br><span class="line">        b-&gt;a: 负数</span><br><span class="line">    else 不是数字</span><br><span class="line">        b-&gt;a: 给定信息非法,重新给我一个数</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228105841574.png" alt="image-20221228105841574"></p><h4 id="给消息添加注释">给消息添加注释</h4><ul><li>note left  在左边添加注释</li><li>note right在右边添加注释</li><li>note left/right   end note  添加多行注释</li><li>note left/right of 参与者 颜色    指定在注释在参与者的哪边</li><li>note over 参与者 … 贯穿参与者</li><li>如果两个备注要在同一行需要使用 /</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">note left of a: 初始化</span><br><span class="line">/ note right of b: 初始化</span><br><span class="line"></span><br><span class="line">note across: 共同协作</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228111411382.png" alt="image-20221228111411382"></p><h4 id="分隔符">分隔符</h4><p>使用分割符,可以将图表分割成多个逻辑步骤</p><ul><li>== ==</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">== 初始化 ==</span><br><span class="line">note left of a: 初始化</span><br><span class="line">/ note right of b: 初始化</span><br><span class="line"></span><br><span class="line">== 开始工作 ==</span><br><span class="line">note across: 共同协作</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228111638737.png" alt="image-20221228111638737"></p><h4 id="引用">引用</h4><ul><li>ref over  参与者…</li><li>ref  over 参与者   …     end ref</li></ul><h4 id="延时">延时</h4><ul><li>…   代表延时操作</li><li>… 5分钟 … 代表具体延时</li></ul><h4 id="增加空间">增加空间</h4><ul><li>|||  增加空间</li><li>|| 45 || 增加指定像素空间</li></ul><h4 id="包裹参与者">包裹参与者</h4><p>声明参与者的时候使用下面形式包裹参与者就可以了</p><ul><li>box title 颜色   …    end box</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">box &quot;Internal Service&quot; #LightBlue</span><br><span class="line">participant Bob</span><br><span class="line">participant Alice</span><br><span class="line">end box</span><br><span class="line">participant Other</span><br><span class="line">Bob -&gt; Alice : hello</span><br><span class="line">Alice -&gt; Other : hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221228114916738.png" alt="image-20221228114916738"></p><h4 id="移除下面的参与者图标">移除下面的参与者图标</h4><ul><li>hide footbox</li></ul><h2 id="用例图">用例图</h2><p>可以使用() 或者usecase关键字定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(firstcase) as f</span><br><span class="line">(secondcase) as s </span><br><span class="line"></span><br><span class="line">usecase thridcase as t</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221229090436835.png" alt="image-20221229090436835"></p><h3 id="角色形象">角色形象</h3><p>声明角色</p><ul><li>: user :</li><li>actor user</li></ul><h4 id="更改头像">更改头像</h4><ul><li>skinparam actorStyle awesome</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">:User: --&gt; (Use)</span><br><span class="line">&quot;Main Admin&quot; as Admin</span><br><span class="line">&quot;Use the application&quot; as (Use)</span><br><span class="line">Admin --&gt; (Admin the application)</span><br><span class="line"></span><br><span class="line">skinparam actorStyle awesome</span><br><span class="line">:User1: --&gt; (Use1)</span><br><span class="line">&quot;Main Admin&quot; as Admin1</span><br><span class="line">&quot;Use the application&quot; as (Use1)</span><br><span class="line">Admin1 --&gt; (Admin the application1)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221229091150538.png" alt="image-20221229091150538"></p><h3 id="用例描述">用例描述</h3><p>使用&quot; &quot; 包裹起来,中间开可以加下面几种分割符</p><ul><li>– 横线</li><li>… 虚线</li><li>== 双横线</li><li>__ 下划线</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">usecase h as &quot;我很好,谢谢你</span><br><span class="line">--</span><br><span class="line">我非常好,谢谢你</span><br><span class="line">== hh ==</span><br><span class="line">我真的很好,谢谢你</span><br><span class="line">..hh..</span><br><span class="line">好的,谢谢你</span><br><span class="line">__</span><br><span class="line">拜拜 &quot;</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221229092004785.png" alt="image-20221229092004785"></p><h3 id="使用包">使用包</h3><p>可以使用包将角色或者用例分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">:djm:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package test&#123;</span><br><span class="line">    usecase test1 as test1</span><br><span class="line">    usecase test2 as test2</span><br><span class="line">    usecase test3 as test3</span><br><span class="line">&#125;</span><br><span class="line">djm -&gt; test1</span><br><span class="line">djm -&gt; test2</span><br><span class="line">djm -&gt; test3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221229092642140.png" alt="image-20221229092642140"></p><blockquote><p>-&gt; 连接两个用例之间的箭头横杠越多,线条越长</p></blockquote><h3 id="继承">继承</h3><p>a 继承 b 可以表示为:   b&lt;|–a</p><h3 id="注释">注释</h3><p>这个和时序图的差不多,只不过这个有四个方位: note left/right/top/bottom of</p><p>注释可以定义一个对象,但是连接的时候必须使用 …</p><h3 id="箭头方向">箭头方向</h3><ul><li>-left/right/up/down-&gt; 这样可以自定义箭头的方向</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">actor :u1:</span><br><span class="line">actor :u2:</span><br><span class="line">actor :u3:</span><br><span class="line"></span><br><span class="line">u1 -up-&gt; u2</span><br><span class="line">u1 -left-&gt; u3</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221229094930809.png" alt="image-20221229094930809"></p><h2 id="类图">类图</h2><h3 id="元素声明">元素声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract         abstract</span><br><span class="line">abstract class   &quot;abstract class&quot;</span><br><span class="line">annotation       annotation</span><br><span class="line">circle           circle</span><br><span class="line">()               circle_short_form</span><br><span class="line">class     class</span><br><span class="line">diamond diamond</span><br><span class="line">&lt;&gt;     diamond_short_form</span><br><span class="line">entity entity</span><br><span class="line">enum enum</span><br><span class="line">interface interface</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230091928994.png" alt="image-20221230091928994"></p><h3 id="类与类之间的关系">类与类之间的关系</h3><ul><li>&lt;| –  继承</li><li>*--  组合</li><li>o-- 聚合</li></ul><h3 id="标签">标签</h3><p>可以通过在箭头两端加上标签列如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class01 &quot;类型1&quot;  &lt;|-- &quot;类型2&quot; class02: 继承</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230092508910.png" alt="image-20221230092508910"></p><h3 id="添加属性和方法">添加属性和方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">Object &lt;|-- Person</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    String name</span><br><span class="line">    int age</span><br><span class="line">    String getName()</span><br><span class="line">    String getAge()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Object&#123;</span><br><span class="line">    boolean equals()</span><br><span class="line">    int hashCode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230093115015.png" alt="image-20221230093115015"></p><h3 id="定义可访问性">定义可访问性</h3><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230093229280.png" alt="image-20221230093229280"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">Object &lt;|-- Person</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    -String name</span><br><span class="line">    -int age</span><br><span class="line">    +String getName()</span><br><span class="line">    +String getAge()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Object&#123;</span><br><span class="line">    +boolean equals()</span><br><span class="line">    +int hashCode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230093329726.png" alt="image-20221230093329726"></p><h3 id="抽象和静态">抽象和静态</h3><p>可以在属性前面加上{abstract}和{static}来表示</p><h3 id="自定义分割线">自定义分割线</h3><p>这个和用例图的差不多</p><h3 id="指定包">指定包</h3><p>我们可以将某些语句写到一个包里面,这样这个语句里面涉及到的类就在同一个包下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">package java.utils&#123;</span><br><span class="line">    interface Collection </span><br><span class="line">    interface list </span><br><span class="line">    interface set</span><br><span class="line">    Collection &lt;|-- list</span><br><span class="line">    Collection &lt;|-- set</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230094523215.png" alt="image-20221230094523215"></p><h2 id="对象图">对象图</h2><p>这个比较简单,其实就是类图,只不过,里面的属性要赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object user &#123;</span><br><span class="line">name = &quot;Dummy&quot;</span><br><span class="line">id = 123</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230095211542.png" alt="image-20221230095211542"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">map &quot;Map&lt;Integer,String&gt;&quot; as map&#123;</span><br><span class="line">    1 =&gt; &quot;1&quot;</span><br><span class="line">    2 =&gt; &quot;2&quot;</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/28/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/plantuml/../img/plantumlassets/image-20221230095330054.png" alt="image-20221230095330054"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node最新版本安装</title>
      <link href="/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/"/>
      <url>/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><blockquote><p>每次安装完了node,下次需要安装的时候有需要Google一下,每次搜到的教程肯定又不一样,肯定会有偏差,那还不如自己总结好</p></blockquote><p><a href="https://nodejs.org/zh-cn/">这个是下载node的官方地址</a></p><h1>安装</h1><h2 id="windows安装node">windows安装node</h2><p>下载msi文件</p><p><img src="/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/../img/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85assets/image-20221224160507117.png" alt="image-20221224160507117"></p><p>下载好后直接打开,中途选择路径的时候放D盘即可,其他直接无脑next,最后点击install就可以了</p><p><img src="/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/../img/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85assets/image-20221224160820974.png" alt="image-20221224160820974"></p><p>安装完后检查是否安装成功</p><p><img src="/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/../img/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85assets/image-20221224161437418.png" alt="image-20221224161437418"></p><p><img src="/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/../img/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85assets/image-20221224161238604.png" alt="image-20221224161238604"></p><p>这个是帮我们配置好环境变量的,当然我们也可以自己通过下载压缩包,然后把环境变量的方式配置上去,这样也可以,其实也没什么区别,看看他们产生的文件夹的区别吧</p><p><img src="/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/../img/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85assets/image-20221224162258468.png" alt="image-20221224162258468"></p><h4 id="none"></h4><h2 id="linux安装-centos7">linux安装(centos7)</h2><p>复制下载链接</p><p><img src="/2022/12/24/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/../img/node%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85assets/image-20221224162759141.png" alt="image-20221224162759141"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载压缩吧到本地</span></span><br><span class="line">wget -c  https://nodejs.org/download/release/v17.5.0/node-v17.5.0-linux-x64.tar.xz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压压缩包</span></span><br><span class="line">tar -xf node-v17.5.0-linux-x64.tar.xz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移动到指定目录,并且更改名字</span></span><br><span class="line">mv node-v17.5.0-linux-x64 /usr/local/lib/nodejs</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加到环境变量</span></span><br><span class="line">ln -s /usr/local/lib/nodejs/bin/node /usr/local/bin</span><br><span class="line">ln -s /usr/local/lib/nodejs/bin/npm /usr/local/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><blockquote><p>这里可能会出现node: /lib64/libm.so.6: version `GLIBC_2.27’ not found (required by node) 这样的错误,我的建议是安装低版本</p></blockquote><h1>配置node</h1><h2 id="设置镜像加速源">设置镜像加速源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局加速</span></span><br><span class="line">npm config set registry https://registry.npmmirror.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时加速</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h2 id="查看全局安装的包">查看全局安装的包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root -g</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaml语法</title>
      <link href="/2022/12/20/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/yaml%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/20/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/yaml%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述">概述</h2><h2 id="基本语法">基本语法</h2><ul><li>使用空格作为缩进</li><li>缩进空格数量不做要求,但是相同层级的左侧元素要对齐</li><li>低版本的不允许使用tab缩进,只能用空格</li><li>使用#做注释符,从字符到行尾,都算注释</li><li>使用 – 表示新的yaml文件开始</li></ul><h2 id="yaml支持的数据结构">yaml支持的数据结构</h2><p>对象</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">djm</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>数组</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">names:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">djm</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">lpb</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">names:</span> [<span class="string">djm</span>, <span class="string">lpb</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s环境搭建</title>
      <link href="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/"/>
      <url>/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/</url>
      
        <content type="html"><![CDATA[<h1>背景</h1><p><strong>传统部署时代：</strong> 早期,是直接将应用程序部署在物理机上，无法对应用程序进行资源限制,如果有多个应用,就会出现资源分配的问题,比如一个应用占据大量资源,使用其他应用性能下降,一种解决方案是单个应用放在单个服务器上,这样的话,虽然做到了资源隔离,但是如果一个应用程序资源利用率不高的时候,剩余的资源又无法分配各其他应用程序,而且物理服务器的维护成本变得很高。</p><p><strong>虚拟化部署时代：</strong> 作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的 CPU 上运行多个虚拟机VM。虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由地访问。</p><p><strong>容器部署时代：</strong> 容器类似于 VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统OS。因此，容器被认为是目前最轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和 OS 分发进行移植。而在容器时代，Docker容器引擎是最流行的一个。</p><p>Kubernetes 为你提供了一个<strong>可弹性运行分布式系统</strong>的框架。 Kubernetes 会满足你的<strong>扩展要求、故障转移你的应用、提供部署模式</strong>等</p><p>k8s提供的功能有:</p><ul><li><strong>服务发现和负载均衡</strong>   使用ip或者dns名称暴露容器ip,让service发现,当service流量过大的时候,会负载均衡到这些容器中</li><li><strong>存储编排</strong>  允许自动挂载选择的存储系统</li><li><strong>自动部署和回滚</strong>   通过更改期望状态,就能够实现容器的自动部署和历史版本回滚</li><li><strong>自动完成装箱计算</strong> 在用户提供了容器需要的资源的基础上,k8s根据容器实际情况分配资源,以最佳方式利用资源</li><li><strong>自我修复</strong>  k8s 可以重新启动失败的容器,或者替换容器,或者杀死不响应的容器</li><li><strong>秘钥和配置管理</strong> Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥</li></ul><h1>核心组件</h1><h2 id="apiserver">APIServer</h2><p>系统管理指令的统一入口,担负着统揽全局的重任,任何对资源的增删改查都得交给它后才能交给etcd</p><p>功能:</p><ul><li>对外提供restful的管理接口,方便对资源对象的增删改查</li><li>配置k8s资源对象,将资源对象的当前状态与期望状态存储在etcd中,供其他组件使用,除了etcd,k8s没有其他的持久化结点</li><li>系统日志收集,并且提供api供访问</li></ul><h2 id="scheduler">scheduler</h2><p>在可用的工作结点列表通过算法选取一个结点与待调度的pod进行绑定</p><p>调度算法:</p><p>首先经历一系列的Predicates判断这个pod能不能在我这个结点上运行,下面列举在default算法中可用的Predicates</p><ul><li>PodFitsHostPorts: 查看pod容器需要用的宿主机端口是否有冲突</li><li>podFitsResources: 检查结点上的资源是否够用,就是检测结点已有pod对资源的需求量+待调度的pod资源需求量 是否超过工作结点的容量</li><li>NoDiskConfict: 检查容器挂在的卷是否有冲突,只对特定的容器卷有效,因为这些容器卷有它们自己的挂载规则,比如禁止两个pod共享同一个容器卷</li><li>NoVolumeZoneConfict: 检查pod的挂载卷的zone限制是否与node对应的zone-lable相匹配</li><li>MatchNodeSelector: 检查工作结点的lables属性是否和pod的结点标签选择器是否一致</li><li>hostname: 如果在pod中指定了宿主机,那么将会调度他到指定的宿主机结点上运行</li></ul><p>经历了上述硬性筛选之后,顺利过关的工作结点就会来到打分流程,下面列举打分策略:</p><ul><li>LeastRequestedPriority: 计算原则是尽可能的将pod调度到资源占用比小的结点上</li><li>BalanceResourceAllocation: 调度时尽可能选取cpu和内存利用率相近的结点</li><li>SelectorSpreadPriority: 对于相同的service的pod在节点上尽可能的分散</li><li>NodeAffinityPriority: 根据用户指定pod的工作结点亲和性进行打分</li><li>ImageLocalityPriorite: 根据pod需要的镜像进行打分,pod需要的镜像大小和越大(pod可以运行多个容器),打分越高</li></ul><p>最后计算加权和,看哪个工作结点分高</p><h2 id="controller-manager">controller manager</h2><p>管理k8s中的各种控制器,<strong>确保这些资源永远保持在用户所预期的状态</strong></p><p>controller manager 控制pod与工作结点等资源正常运行的本质,就是靠这些控制器定时对pod,工作结点等资源进行检查,然后判断实际状态是否与期望状态一直,不一致的话则会通知apiserver进行增删改.</p><p>服务端点控制: **检测pod与service之间的对应关系是否正常,**保证始终运行在用户所期望的状态</p><p>副本管理控制器:  保证实际副本数量与期望数量一致</p><p>垃圾回收控制器: 删除处于终止状态pod的信息,不是删除容器哦</p><p>结点控制器: 检查工作结点是否可用,工作结点通过kubelet定时发送数据给master结点,如果在一段时间内没有发送,则认为工作结点不可以工作</p><p>资源配额控制器:  对一个namespace 的资源进行配置</p><h2 id="kubelet">kubelet</h2><p>kubelet是工作结点中最重要的进程,负责创建和管理容器,还有容器和镜像的垃圾回收</p><h2 id="kube-proxy">kube-proxy</h2><p>实现服务发现与负载均衡,在后端pod的ip发生变化的时候,也能察觉到,并且维护着service与pod之间的对应关系,将发往service的流量正确的导向pod,  可以通过防火墙或者ipvs实现</p><h2 id="etcd">etcd</h2><p>主要用于分布式系统中数据一致性的问题,服务发现</p><h2 id="核心组件协作流程">核心组件协作流程</h2><h3 id="创建pod">创建pod</h3><p>我们通过kubectl发起一个创建pod的请求后,kubectl会先检查命令是否正确,然后解析命令生成的pod资源文件发送给apiserver,apiserver收到请求后,进行用户认证,授权,和资源配额控制,验证通过后,apiserver调用etcd的存储接口在后台数据库创建一个pod对象,scheduler通过apiserve监听到需要创建pod,然后从etcd获取可用工作结点列表和待调度的pod,在发现有待调度的pod且有工作结点的时候,会通过筛选结点,给结点打分,选出最优结点,然后调用apiserver提供的api在etcd中创建一个binding对象,描述在一个工作结点绑定运行的所有pod信息,kubelet监听到apiserver上要创建pod,然后在本地创建对应的pod</p><h1>基础环境部署</h1><h2 id="前期准备">前期准备</h2><p>用了三台虚拟机,都是centos7</p><p>192.168.100.3  master结点</p><p>192.168.100.4  work1结点</p><p>192.168.100.5  work2结点</p><h3 id="修改hostname">修改hostname</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master上执行</span></span><br><span class="line">hostnamectl set-hostname master</span><br><span class="line">exec bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work1 上执行</span></span><br><span class="line">hostnamectl set-hostname work1</span><br><span class="line">exec bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work2 上执行</span></span><br><span class="line">hostnamectl set-hostname work2</span><br></pre></td></tr></table></figure><h3 id="配置hosts文件-所有结点">配置hosts文件(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两台机器都执行</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.100.3  master</span><br><span class="line">192.168.100.4  work1</span><br><span class="line">192.168.100.5  work2</span><br><span class="line">192.168.100.3  cluster-endpoint</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="配置ssh互信-所有结点">配置ssh互信(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有机器都执行</span></span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一直回车得到秘钥</span></span><br><span class="line"></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@master</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@work1</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@work2</span><br></pre></td></tr></table></figure><h3 id="设置时间同步-所有结点">设置时间同步(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install chrony -y</span><br><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br><span class="line">chronyc sources</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙-所有结点">关闭防火墙(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭交换区-所有结点">关闭交换区(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h3 id="禁用seninux-所有结点">禁用seninux(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure><h3 id="允许-iptables-检查桥接流量-所有结点">允许 iptables 检查桥接流量(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">overlay</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">modprobe overlay</span><br><span class="line">modprobe br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置所需的 sysctl 参数，参数在重新启动后保持不变</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用 sysctl 参数而不重新启动</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h3 id="安装docker-所有结点">安装docker(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置yum源</span></span><br><span class="line">cd /etc/yum.repos.d ; mkdir bak; mv CentOS-Base.repo bak/</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo (这个是centos8的源)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装yum-config-manager配置工具</span></span><br><span class="line">yum -y install yum-utils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置yum源</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker-ce版本</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本号</span></span><br><span class="line">docker --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker镜像源设置</span></span><br><span class="line">cat &gt;/etc/docker/daemon.json&lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载</span></span><br><span class="line">systemctl reload docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置k8s源-所有结点">配置k8s源(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[k8s]</span><br><span class="line">name=k8s</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="将-sandbox-image-镜像源设置为阿里云-google-containers-镜像源-一条一条命令来哦-所有结点">将 sandbox_image 镜像源设置为阿里云 google_containers 镜像源(一条一条命令来哦)(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出默认配置，config.toml这个文件默认是不存在的</span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line">grep sandbox_image  /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把 sandbox_image = <span class="string">&quot;registry.k8s.io/pause:3.6&quot;</span>(不同版本对应的可能不同)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改成 sandbox_image = <span class="string">&quot;registry.aliyuncs.com/google_containers/pause/pause:3.6&quot;</span></span></span><br><span class="line">sed -i &quot;s#registry.k8s.io/pause#registry.aliyuncs.com/google_containers/pause#g&quot;   /etc/containerd/config.toml</span><br><span class="line">grep sandbox_image  /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211155339486.png" alt="image-20221211155339486"></p><h3 id="配置container国内镜像源">配置container国内镜像源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 打开配置文件</span><br><span class="line">vim /etc/containerd/config.toml </span><br><span class="line"></span><br><span class="line"># 改成下面这种格式</span><br><span class="line"> [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span><br><span class="line">      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span><br><span class="line">         endpoint = [&quot;https://o13jbvy6.mirror.aliyuncs.com&quot;]</span><br><span class="line"></span><br><span class="line"># 重启containerd</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart containerd</span><br><span class="line">systemctl status containerd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212204732132.png" alt="image-20221212204732132"></p><p>得一层一层来,<a href="https://blog.csdn.net/cyxinda/article/details/124999938">https://blog.csdn.net/cyxinda/article/details/124999938</a> (可以参考这个博客)</p><h3 id="配置-containerd-cgroup-驱动程序-systemd-所有结点">配置 containerd cgroup 驱动程序 systemd(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s#SystemdCgroup = false#SystemdCgroup = true#g&#x27; /etc/containerd/config.toml</span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h3 id="安装-kubeadm-kubelet-和-kubectl-所有结点">安装 kubeadm，kubelet 和 kubectl(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不指定版本就是最新版本，当前最新版就是1.24.1</span></span><br><span class="line">yum install -y kubelet-1.24.1  kubeadm-1.24.1  kubectl-1.24.1 --disableexcludes=kubernetes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">disableexcludes=kubernetes：禁掉除了这个kubernetes之外的别的仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置为开机自启并现在立刻启动服务 --now：立刻启动服务</span></span><br><span class="line">systemctl enable --now kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态，这里需要等待一段时间再查看服务状态，启动会有点慢</span></span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><h3 id="使用kubeadm初始化集群-master">使用kubeadm初始化集群(master)</h3><p>下载好镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/pause:3.7</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/etcd:3.5.3-0</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/coredns:v1.8.6</span><br></pre></td></tr></table></figure><p>设置kubectl 自动补全</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">来到家目录</span></span><br><span class="line">cd ~</span><br><span class="line">echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt;~/.bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载bash</span></span><br><span class="line">exec bash</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.100.3 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --control-plane-endpoint=cluster-endpoint \</span><br><span class="line">  --kubernetes-version v1.24.1 \</span><br><span class="line">  --service-cidr=10.1.0.0/16 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --v=5</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">–image-repository string：    这个用于指定从什么位置来拉取镜像（1.13版本才有的），默认值是k8s.gcr.io，我们将其指定为国内镜像地址：registry.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–kubernetes-version string：  指定kubenets版本号，默认值是stable-1，会导致从https://dl.k8s.io/release/stable-1.txt下载最新的版本号，我们可以将其指定为固定版本（v1.22.1）来跳过网络请求。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–apiserver-advertise-address  指明用 Master 的哪个 interface 与 Cluster 的其他节点通信。如果 Master 有多个 interface，建议明确指定，如果不指定，kubeadm 会自动选择有默认网关的 interface。这里的ip为master节点ip，记得更换。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–pod-network-cidr             指定 Pod 网络的范围。Kubernetes 支持多种网络方案，而且不同网络方案对  –pod-network-cidr有自己的要求，这里设置为10.244.0.0/16 是因为我们将使用 flannel 网络方案，必须设置成这个 CIDR。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--control-plane-endpoint     cluster-endpoint 是映射到该 IP 的自定义 DNS 名称，这里配置hosts映射：192.168.0.113   cluster-endpoint。 这将允许你将 --control-plane-endpoint=cluster-endpoint 传递给 kubeadm init，并将相同的 DNS 名称传递给 kubeadm <span class="built_in">join</span>。 稍后你可以修改 cluster-endpoint 以指向高可用性方案中的负载均衡器的地址。</span></span><br></pre></td></tr></table></figure><p>执行提示出来的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>此时master结点还是notready的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes </span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211162528752.png" alt="image-20221211162528752"></p><p>需要安装一个网络插件</p><h3 id="安装网络插件-master结点">安装网络插件(master结点)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#提前下载好镜像</span><br><span class="line">docker pull quay.io/coreos/flannel:v0.14.0</span><br><span class="line"># 这里可能不成功,最好是下载好这个文件然后上传到虚拟机,在执行这个命令</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有pod的状态</span><br><span class="line">kubectl get pods -A </span><br></pre></td></tr></table></figure><p>当所有pod都在running的时候,主节点就准备好了</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211163314011.png" alt="image-20221211163314011"></p><h3 id="work结点加入集群">work结点加入集群</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在master结点上面执行下面命令得到加入主节点的命令</span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211163647701.png" alt="image-20221211163647701"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在work1结点中输入这个命令</span><br><span class="line">kubeadm join cluster-endpoint:6443 --token 6z9ttd.gi5caxzuargatfy9 --discovery-token-ca-cert-hash sha256:05c589ead7b690359fc1a6208be07390ce40894939c29d025e04477442bfc4d8 </span><br></pre></td></tr></table></figure><p>等待一段时间后,在主节点中查看所有结点是否都准备好了</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211164817076.png" alt="image-20221211164817076"></p><h2 id="安装dashboard">安装dashboard</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.0/aio/deploy/recommended.yaml</span><br><span class="line"># 可能会下载不下来,建议本地用梯子下载好后,传到虚拟机上</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211172019706.png" alt="image-20221211172019706"></p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221213092810050.png" alt="image-20221213092810050"></p><p>需要等到kubernetes-dashboard的所有pod都在running后才能访问哦,有可能会出现镜像拉取失败</p><p>通过端口访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line">#上面命令会打开一个文件,我们需要修改一些配置</span><br><span class="line"># 输入 /type 搜索到目标位置</span><br><span class="line"></span><br><span class="line">#   type: ClusterIP   将这个东西变成</span><br><span class="line">#   type: NodePort   </span><br><span class="line">#  要注意yaml的语法哦,空格</span><br><span class="line"># 然后保存退出</span><br><span class="line"></span><br><span class="line"># 看dashboard 运行在哪个端口</span><br><span class="line">kubectl get svc -A |grep kubernetes-dashboard </span><br></pre></td></tr></table></figure><blockquote><p>如果在Google浏览器里面输入 <a href="https://ip">https://ip</a>:端口显示不安全,而且不让进去的话,就在键盘直接输入 thisisunsafe 然后就可以进去了</p></blockquote><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211171537087.png" alt="image-20221211171537087"></p><h4 id="创建账户">创建账户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;ServiceAccount.yaml&lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">EOF</span><br><span class="line">kubectl apply -f ServiceAccount.yaml</span><br></pre></td></tr></table></figure><h4 id="获取token">获取token</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard create token admin-user</span><br></pre></td></tr></table></figure><h2 id="安装ingress">安装ingress</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.7.1/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure><h1>nfs安装</h1><p>我们如果使用本地容器卷的模式,当主机挂掉了之后,k8s转移pod到其他主机上,但是其他主机上没有这个容器卷,因此我们要整一个共享的存储空间</p><h2 id="环境准备">环境准备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils  # 所有结点安装</span><br></pre></td></tr></table></figure><p>主节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nfs主节点</span></span><br><span class="line">echo &quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot; &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl enable rpcbind --now</span><br><span class="line">systemctl enable nfs-server --now</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure><p>工作结点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showmount -e 192.168.100.3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line">mount -t nfs 192.168.100.3:/nfs/data /nfs/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入一个测试文件</span></span><br><span class="line">echo &quot;hello nfs server&quot; &gt; /nfs/data/test.txt</span><br></pre></td></tr></table></figure><h1>创建资源YAML详解</h1><p>定义k8s的资源对象配置文件yaml一般包含四个部分</p><ul><li>apiVersion 这个表示版本 不同的api版本创建的资源对象可能不一样</li><li>kind 资源类型,表示你要创建什么样的资源,一般有 Pod Deployment Service Ingress 等等</li><li>metadata 表示元数据,资源名称,所属namespace 标签</li><li>spec 资源规范字段,比如用什么容器,重启策略</li></ul><h2 id="创建pod">创建pod</h2><p>总结</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>       <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       <span class="comment">#必选，Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       <span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>       <span class="comment">#必选，Pod名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>    <span class="comment">#必选，Pod所属的命名空间</span></span><br><span class="line">  <span class="attr">labels:</span>      <span class="comment">#自定义标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#自定义标签名字</span></span><br><span class="line">  <span class="attr">annotations:</span>       <span class="comment">#自定义注释列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>         <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>      <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>    <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">IfNotPresent</span>] <span class="comment">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]    <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]     <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>     <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>    <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span>    <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span>    <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span>       <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#端口号名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>   <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>    <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>     <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>       <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span>    <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span>       <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>      <span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>     <span class="comment">#内存限制，单位可以为Ei, Pi, Ti, Gi, Mi , Ki ，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span>      <span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>     <span class="comment">#内存清楚，容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>     <span class="comment">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class="line">      <span class="attr">exec:</span>      <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span>   <span class="comment"># 请求路径</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span>   <span class="comment"># 端口</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span>   <span class="comment"># 地址</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span>  <span class="comment"># 协议</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>  <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">0</span>   <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">0</span>    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">securityContext:</span></span><br><span class="line">         <span class="string">privileged:false</span></span><br><span class="line">    <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>]<span class="comment">#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class="line">    <span class="attr">nodeSelector:</span> <span class="string">obeject</span>  <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class="line">    <span class="attr">imagePullSecrets:</span>    <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">    <span class="string">hostNetwork:false</span>      <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">   <span class="attr">volumes:</span>       <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;     <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">      <span class="attr">hostPath:</span> <span class="string">string</span>     <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span>     <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">      <span class="attr">secret:</span>      <span class="comment">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class="line">        <span class="attr">scretname:</span> <span class="string">string</span>  </span><br><span class="line">        <span class="attr">items:</span>     </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">configMap:</span>     <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 指定api版本 必选</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>   <span class="comment"># 指定资源类型 必选</span></span><br><span class="line"><span class="attr">metadata:</span>   <span class="comment"># 元数据 必选</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span>   <span class="comment"># 设置pod名称 必选</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="comment"># 指定命名空间 必选</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment"># 自定义标签,这个标签可以在选择pod的时候起作用</span></span><br><span class="line">   <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 描述pod里面的容器 必选</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器列表 必选</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mynginx</span> <span class="comment"># 容器名字</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span> <span class="comment"># 容器镜像</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>  <span class="comment"># 镜像拉取策略,Always 总是下载镜像  IfNotPresent 本地不存在再下载 Never 仅使用本地镜像</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">/docker-entrypoint.sh</span>] <span class="comment"># 指定容器启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [ <span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span> ]  <span class="comment"># 指定参数</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 容器卷的配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span>  <span class="comment"># 指定容器卷名字</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># 挂在到容器的目录</span></span><br><span class="line">    <span class="attr">ports:</span>   <span class="comment"># 需要暴露端口的配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span>   </span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span>  <span class="comment"># 容器需要暴露的端口</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">80</span>  <span class="comment"># 宿主机需要暴露的端口</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span>  <span class="comment"># 使用协议</span></span><br><span class="line">    <span class="attr">env:</span>  <span class="comment"># 指定容器环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">djm</span>  <span class="comment"># 变量名字</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">nb</span>  <span class="comment"># 变量值</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment"># 资源限制和请求设置</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment"># 资源限制</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="number">1</span> <span class="comment"># 限制CPU的核数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">200Mi</span>  <span class="comment"># 限制内存 </span></span><br><span class="line">    <span class="attr">livenessProbe:</span> <span class="comment">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class="line">       <span class="attr">httpGet:</span> <span class="comment"># 进行http请求检查容器健康状态</span></span><br><span class="line">         <span class="attr">path:</span> <span class="string">/</span>  <span class="comment"># 请求路径</span></span><br><span class="line">         <span class="attr">port:</span> <span class="number">80</span>   <span class="comment"># 端口</span></span><br><span class="line">         <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># 主机</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">1</span>  <span class="comment"># 启动后一秒检查  单位都是秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">1</span>  <span class="comment"># 超时时间</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">10</span>  <span class="comment"># 检查周期</span></span><br><span class="line">     <span class="attr">restartPolicy:</span> <span class="string">Always</span>  <span class="comment"># 重启策略 Always 只要容器挂了,就重启, OnFailure pod以非0 表示退出才容器 Never 表示不重启</span></span><br><span class="line">  <span class="attr">volumes:</span>       <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span>     <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">    <span class="attr">nfs:</span>  <span class="comment"># 使用nfs</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.3</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/nfs/data/nginx</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>检测我们的健康检查生效,失败的原因是没有文件,我们需要在宿主机上放一个文件,在宿主机上</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221220163407801.png" alt="image-20221220163407801"></p><p>验证环境变量</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221220163806526.png" alt="image-20221220163806526"></p><h2 id="创建deployment">创建Deployment</h2><p>总结</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  <span class="comment"># 指定api版本，此值必须在kubectl api-versions中 </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  <span class="comment"># 指定创建资源的角色/类型  </span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 资源的元数据/属性</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span>  <span class="comment"># 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 部署在哪个namespace中</span></span><br><span class="line">  <span class="attr">labels:</span>  <span class="comment"># 设定资源的标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 资源规范字段</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 声明副本数目</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 匹配标签</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模版</span></span><br><span class="line">  <span class="comment">## 后面就是创建pod的yaml代码了,没有kind和apiVersion两个模块</span></span><br><span class="line">    <span class="attr">metadata:</span> <span class="comment"># 资源的元数据/属性</span></span><br><span class="line">      <span class="attr">annotations:</span> <span class="comment"># 自定义注解列表</span></span><br><span class="line">        <span class="attr">sidecar.istio.io/inject:</span> <span class="string">&quot;false&quot;</span> <span class="comment"># 自定义注解名字</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 设定资源的标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">stable</span></span><br><span class="line">    <span class="attr">spec:</span> <span class="comment"># 资源规范字段</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span> <span class="comment"># 容器的名字  </span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">demo:v1</span> <span class="comment"># 容器使用的镜像地址  </span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span></span><br><span class="line">                                      <span class="comment"># Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="comment"># 资源管理</span></span><br><span class="line">          <span class="attr">limits:</span> <span class="comment"># 最大使用</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">300m</span> <span class="comment"># CPU，1核心 = 1000m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">500Mi</span> <span class="comment"># 内存，1G = 1024Mi</span></span><br><span class="line">          <span class="attr">requests:</span>  <span class="comment"># 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">livenessProbe:</span> <span class="comment"># pod 内部健康检查的设置</span></span><br><span class="line">          <span class="attr">httpGet:</span> <span class="comment"># 通过httpget检查健康，返回200-399之间，则认为容器正常</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/healthCheck</span> <span class="comment"># URI地址</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment"># 协议</span></span><br><span class="line">            <span class="comment"># host: 127.0.0.1 # 主机地址</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment"># 表明第一次检测在容器启动后多长时间后开始</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span> <span class="comment"># 检测的超时时间</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">30</span> <span class="comment"># 检查间隔时间</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span> <span class="comment"># 成功门槛</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span> <span class="comment"># 失败门槛，连接失败5次，pod杀掉，重启一个新的pod</span></span><br><span class="line">        <span class="attr">readinessProbe:</span> <span class="comment"># Pod 准备服务健康检查设置</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/healthCheck</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment">#也可以用这种方法  </span></span><br><span class="line">        <span class="comment">#exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常  </span></span><br><span class="line">        <span class="comment">#  command:  </span></span><br><span class="line">        <span class="comment">#    - cat  </span></span><br><span class="line">        <span class="comment">#    - /tmp/health  </span></span><br><span class="line">        <span class="comment">#也可以用这种方法  </span></span><br><span class="line">        <span class="comment">#tcpSocket: # 通过tcpSocket检查健康 </span></span><br><span class="line">        <span class="comment">#  port: number</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 名称</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">8080</span> <span class="comment"># 容器开发对外的端口</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 协议</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span> <span class="comment"># 镜像仓库拉取密钥</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor-certification</span></span><br><span class="line">      <span class="attr">affinity:</span> <span class="comment"># 亲和性调试</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span> <span class="comment"># 节点亲和力</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># pod 必须部署到满足条件的节点上</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点满足任何一个条件就可以</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">beta.kubernetes.io/arch</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">amd64</span></span><br></pre></td></tr></table></figure><p>尝试</p><h1>删除</h1><h2 id="删除单个工作结点">删除单个工作结点</h2><p>master 结点上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让资源对象不会往这个结点上调度</span></span><br><span class="line">kubectl cordon nodename</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在master结点上执行,驱逐一个结点,最好在这这个命令之前把在这个结点上的pod删掉</span></span><br><span class="line">kubectl drain nodename</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除节点</span></span><br><span class="line">kubectl delete node nodename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果没有删掉结点上的pod,其实这个时候结点上的pod在其他地方还能访问到,那些规则还存在,等过一段时间后,k8s发现这个结点删除了,会让这些pod转移到其他机器上</span></span><br></pre></td></tr></table></figure><p>node结点上执行(为了下次加入集群方便,不报错)(这个时候所有的iptables的规则,以及虚拟网卡,还都存在,我们必须手动清除)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除旧的信息</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">能重启一下最好</span></span><br></pre></td></tr></table></figure><h2 id="删除整个集群">删除整个集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有结点</span></span><br><span class="line">kubectl delete node --all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理主节点</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line">rm -fr ~/.kube/  /etc/kubernetes/*  /var/lib/etcd/*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理工作结点</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启一下,或者手动删除iptables规则和网卡</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不想使用了,可以把服务也停了</span></span><br><span class="line">systemctl enable kubelet --now</span><br></pre></td></tr></table></figure><blockquote><p>删除定义好的那些规则(这个是全部删除)</p><p>iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</p></blockquote><h1>额外补充</h1><h3 id="自动补全">自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl</span> </span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">kubectl completion bash &gt;/etc/bash_completion.d/kubectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span> &lt;(helm completion bash)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">helm completion bash &gt;/etc/bash_completion.d/helm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">crictl (containered)</span></span><br><span class="line">source &lt;(crictl completion bash)</span><br><span class="line">crictl completion bash &gt;/etc/bash_completion.d/crictl</span><br></pre></td></tr></table></figure><h3 id="不会写yaml配置文件怎么办">不会写yaml配置文件怎么办</h3><p>我们只要记得kubectl的命令可以,可以用这个命令来生成yaml文件(不过会有冗余内容哦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个depolyment资源对象的yaml</span></span><br><span class="line">kubectl create deploy mydep --image=nginx --replicas 5  -o yaml --dry-run=client &gt; depoly.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个service 的 yaml</span></span><br><span class="line">kubectl expose deploy mydep --port=8080 --target-port=80 --type=NodePort -o yaml --dry-run=client &gt; depoly.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果当前资源对象已经存在(这种方式产生的冗余东西会更多)</span></span><br><span class="line">kubectl get deploy mydep -o wide &gt; depoly.yaml  </span><br><span class="line">kubectl get svc mydep -o wide &gt; depoly.yaml</span><br></pre></td></tr></table></figure><h3 id="pod创建流程">pod创建流程</h3><p>kubectl 一次pod创建流程中,各个组件干的活:</p><p>kubectl 将命令解析成生成创建pod的参数,通过apiserver提供的接口传递过去</p><p>apiserver 收到后,先进行上下文和pod元数据验证两者的namespace是否匹配,不匹配则创建失败,成功则将一些系统元数据(创建时间,uid)注入到pod中,然后检测元数据中系统必须项是否存在,如果为空则抛出异常,终止创建.如果一切顺利,在etcd中持久化pod信息,然后将创建pod的工作交给kube-scheduler和kubelet</p><p>kube-scheduler 根据待调度的pod以及可用的工作结点根据算法选取一个最优的绑定策略,然后告诉apiserve选取哪个结点部署pod,apiserve收到后发送请求给结点上的kubelet</p><p>kubelet 根据要求只会容器运行时创建容器就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2022/12/19/java/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/12/19/java/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="math">Math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>; <span class="comment">// 计算a^b 注意返回值是double</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 四舍五入 注意返回值是long</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span>; <span class="comment">// 返回[0,1) 的随机小数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 计算根号a, 注意返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> a)</span> ; <span class="comment">// 计算log以e为底 a 的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 以10为底</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><h2 id="数组">数组</h2><h3 id="初始化">初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// int[] nums = new int[3]&#123;1,3,4&#125; 这种是不行的哦,不能指定长度又赋值</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; </span><br><span class="line"><span class="comment">// 二维,也不能指定长度又赋值</span></span><br><span class="line"><span class="type">int</span>[][] intss = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数组具有Object 的所有方法,以及一个length属性</p><h3 id="遍历数组">遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;....&#125; <span class="comment">// i 代表索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;....&#125; <span class="comment">// i 代表nums里面的数值</span></span><br></pre></td></tr></table></figure><h2 id="arrays">Arrays</h2><p>这个是java提供操作数组的工具类,对于需要使用到排序的地方,基本数据类型只能从小到大,引用数据类型要么实现Comparable接口,要么提供Comparator的实现类</p><h3 id="sort">sort</h3><p>有很多关于sort的重载方法,参数可以是基本数据类型,也可以是Object类型(因此可以为其他任何类型的数组排序,但是记得要实现Comparable接口或者提供Comparator的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T[] nums = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; <span class="comment">// 这里T代表基本数据类型</span></span><br><span class="line">Arrays.sort(nums);  <span class="comment">//从小到大排序 </span></span><br><span class="line">Arrays.sort(nums,<span class="number">1</span>,<span class="number">3</span>) <span class="comment">// 只排序[1,3) 这个区间里面的数据</span></span><br><span class="line"><span class="comment">// 基本数据类型使用sort方法就只能实现升序,不能实现降序</span></span><br><span class="line">   <span class="comment">//因为泛型它不支持基本数据类型,因此无法提供一个关于int泛型的Comparator接口</span></span><br><span class="line"></span><br><span class="line">T[] nums = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; <span class="comment">//这里T代表引用数据类型</span></span><br><span class="line">Arrays.sort(nums)  <span class="comment">//如果要这么写,那么这个类必须实现了Comparable接口</span></span><br><span class="line">   Arrays.sort(nums,(a,b)-&gt;&#123;</span><br><span class="line">       ..... <span class="comment">// 你的判断逻辑,如果返回大于0的数则代表b应该和a换位置,否则就不换(b在后,a在前)</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h3 id="parallelsort">parallelSort</h3><p>这个方法和sort的用法是一样的,但是当数据量超过某一个值的时候,这个方法会采用并行的方式排序,在多核处理下优势就明显了,如果数据量少于某个值,依然使用sort方法排序,这个值是2^13 8192</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallelSort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length, p, g;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">            (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">            DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArraysParallelSortHelpers</span>.FJInt.Sorter</span><br><span class="line">                (<span class="literal">null</span>, a, <span class="keyword">new</span> <span class="title class_">int</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">                 ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="binarysearch">binarySearch</h3><p>必须是排序好的数组,利用二分查找找到值所在的位置,如果值不存在,返回它应该在的下标+1的相反数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(nums,<span class="number">3</span>)); <span class="comment">//输出 1</span></span><br><span class="line">System.out.println(Arrays.binarySearch(nums,<span class="number">4</span>)); <span class="comment">// 输出 -3</span></span><br><span class="line">System.out.println(Arrays.binarySearch(nums,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">//从[1,3) 这个数组区间去找</span></span><br></pre></td></tr></table></figure><blockquote><p>这个方法无法像c++ 的 lower_bound 和 upper_bound 一样找到第一个等于某个值的位置,和第一个大于某个值的位置,需要我们自己去写二分查找</p></blockquote><h3 id="equals">equals</h3><p>比较两个数组元素是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object[] a, Object[] a2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (a==a2)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (a==<span class="literal">null</span> || a2==<span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;</span><br><span class="line">       <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> a[i];</span><br><span class="line">           <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> a2[i];</span><br><span class="line">           <span class="keyword">if</span> (!(o1==<span class="literal">null</span> ? o2==<span class="literal">null</span> : o1.equals(o2)))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="fill">fill</h3><p>填充数组的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(nums,<span class="number">1</span>); <span class="comment">// 全部填充成1 </span></span><br><span class="line">Arrays.fill(num,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>); <span class="comment">// [2,5) 填充成2</span></span><br></pre></td></tr></table></figure><h3 id="copyof">copyOf</h3><p>复制数组的值变成另外一个一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="copyofrange">copyOfRange</h3><p>复制某个区间的值变成另外一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span class="type">int</span> from, <span class="type">int</span> to) &#123;</span><br><span class="line">        <span class="keyword">return</span> copyOfRange(original, from, to, (Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt;) original.getClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="aslist">asList</h3><p>将可变参数变成list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//这里参数可以写任意多</span></span><br><span class="line"><span class="comment">// Arrays.asList(new int[]&#123;1,3,4&#125;) ,这种方法只能得到一个元素的列表,泛型还是 int[],所有这个方法是不能将数组变成List的</span></span><br></pre></td></tr></table></figure><blockquote><p>class java.util.Arrays$ArrayList 是这个方法产生的list对应的类,并不是ArrayList 哦</p></blockquote><h3 id="tostring">toString</h3><p>将数组内容变成字符串,如果是基本数据类型就是拼接字符串,如果是引用数据类型就是执行元素里面的toString 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(nums)); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure><h3 id="deeptostring">deepToString</h3><p>如果是多维数组,那么toString 是没有办法将他们都转化成字符串的,显示的是地址值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][][] ints = &#123; &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;,&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(ints)) <span class="comment">// [[[I@61bbe9ba, [[I@610455d6]</span></span><br><span class="line">System.out.println(Arrays.deepToString(ints)); <span class="comment">//[[[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [2, 3, 4]]]</span></span><br></pre></td></tr></table></figure><h3 id="setall">setAll</h3><p>根据元素的下标设置元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.setAll(nums,a-&gt;a*a);</span><br><span class="line">System.out.println(Arrays.toString(nums)); <span class="comment">// [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><h3 id="stream">stream</h3><p>返回数组的流式数据,这个后面还会再总结</p><h2 id="collection">Collection</h2><p>Collection 接口中定义了set接口以及list接口通用的方法,掌握这里面的方法,就不用重复看他们的子接口,实现类的方法了</p><h3 id="提供方法">提供方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;  <span class="comment">//返回 集合中元素个数</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">// 集合是否为空</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>; <span class="comment">// 集合中是否包含某个元素,这里的形参不需要是泛型,因为这个方法肯定是通过比较两个对象的equals方法</span></span><br><span class="line"> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>; <span class="comment">// 返回可以迭代整个集合的迭代器</span></span><br><span class="line"> &lt;T&gt; T[] toArray(T[] a); <span class="comment">// 将集合变成指定类型的数组,基本数据类型数组是不行的哦,int[]-&gt;T[] T=int 但是基本数据类型没有泛型</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>; <span class="comment">// 添加一个元素 </span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>; <span class="comment">// 删除一个元素</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>; <span class="comment">// 是否包含另外一个集合的全部元素</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>; <span class="comment">// 添加一个集合的所有元素,这个集合的泛型对应的类必须跟我一样或者是我的子类</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>; <span class="comment">// 移除集合c中包含的所有元素</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>; <span class="comment">// 移除不在c中的元素</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">// 清空集合</span></span><br><span class="line">Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span>; <span class="comment">// 用来得到Stream对象,后面会说</span></span><br><span class="line">Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span>; <span class="comment">// 并行流</span></span><br></pre></td></tr></table></figure><blockquote><p>这个接口就是站在一个很抽象的层面,不管你用何种数据结构,这些方法都是能够实现的,比如删掉某个元素,增加一个元素,是否包含某个元素等等</p></blockquote><h3 id="list接口">List接口</h3><p>list接口是collection的子接口,因此它拥有collection的方法,list接口本身定义了很多方法,因此在它的子类中都会有实现,掌握list中的方法,就不用重复看其子类中的方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">//获取某个位置的元素</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>; <span class="comment">// 设置某个位置的元素,返回原先位置的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>; <span class="comment">// 在某个位置添加一个元素,这个位置及其后面的元素往后移动一个位置</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">// 删除一个位置的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>; <span class="comment">// 元素o 第一次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>; <span class="comment">// 元素o 最后一次出现的位置</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>; <span class="comment">// 获得子列表</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/java/java%E5%9F%BA%E7%A1%80/../img/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84assets/image-20221219102945322.png" alt="image-20221219102945322"></p><blockquote><p>对比一下 E remove(int index);  boolean remove(Object o);  这两个方法,如果我们的泛型是Integer类型,那么就得格外小心了,你用Integer类型参数,调用的肯定是 boolean remove(Object o);你用的是int类型参数调用的肯定是E remove(int index);,如果你有一个Integer类型的参数,你又想删除它对应的下标,你必须将它变成int类型</p></blockquote><p>ArrayList 和 linkedList 的区别在于底层实现</p><p>ArrayList 和 Vector 的区别在于 线程安全不安全, ArrayList是线程不安全的,Vector是线程安全的</p><blockquote><p>这个接口感觉就具体些些了,我底层是按**“顺序”**(逻辑上一个元素紧挨一个元素),来存储数据的,因此肯定就有下标这么一说,那么就应该要提供关于下标的方法</p></blockquote><h3 id="set接口">Set接口</h3><p>Set也是collection的子接口,这个接口并没有额外的定义方法,全部都是collection接口里面的方法,set接口的规定所有的数据必须唯一</p><p><img src="/2022/12/19/java/java%E5%9F%BA%E7%A1%80/../img/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84assets/image-20221219105205189.png" alt="image-20221219105205189"></p><h4 id="sortedset接口">SortedSet接口</h4><p>实现了这个接口的类,里面的数据都是会排序的,输出里面数据的时候一定是按顺序来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;? <span class="built_in">super</span> E&gt; comparator(); <span class="comment">// 返回排序规则</span></span><br><span class="line"><span class="comment">// 返回 [fromElement,toElement) 这个区间里面的数据(是按照排序规则来的哦),返回结果也是SortedSet类型</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span>; </span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span>; <span class="comment">//返回小于toElement的数据</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>; <span class="comment">// 返回大于等于fromElement的数据 </span></span><br><span class="line">E <span class="title function_">first</span><span class="params">()</span>; <span class="comment">//返回最小的数据</span></span><br><span class="line">E <span class="title function_">last</span><span class="params">()</span>; <span class="comment">// 返回最大的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里面的最小与最大都是相对于排序规则而言</span></span><br></pre></td></tr></table></figure><p>我们可以通过这个接口来找第一个大于等于某个数,大于某个数,最后小于等于某个数,或者小于某个数的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        SortedSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">7</span>);</span><br><span class="line">        set.add(<span class="number">5</span>);</span><br><span class="line">        set.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//第一个大于等于5的数</span></span><br><span class="line">        System.out.println(set.tailSet(<span class="number">5</span>).first());</span><br><span class="line">        <span class="comment">// 第一个大于5的数</span></span><br><span class="line">        System.out.println(set.tailSet(<span class="number">6</span>).first());</span><br><span class="line">        <span class="comment">// 第最后一个小于5的数</span></span><br><span class="line">        System.out.println(set.headSet(<span class="number">5</span>).last());</span><br><span class="line">        <span class="comment">// 第最后小于等于5的数</span></span><br><span class="line">        System.out.println(set.headSet(<span class="number">6</span>).last());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="navigableset接口">NavigableSet接口</h5><p>这个是soreted的子接口,它多出来的功能,其实就是上面我们那段代码实现的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">lower</span><span class="params">(E e)</span>; <span class="comment">// 找到最后一个小于e的元素,也就是小于e的最大值</span></span><br><span class="line">E <span class="title function_">floor</span><span class="params">(E e)</span>; <span class="comment">// 找到最后一个小于等于e的元素</span></span><br><span class="line">E <span class="title function_">ceiling</span><span class="params">(E e)</span>; <span class="comment">// 找到第一个大于等于e的元素</span></span><br><span class="line">E <span class="title function_">higher</span><span class="params">(E e)</span>; <span class="comment">// 找到第一个大于e的元素</span></span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>; <span class="comment">//删掉最小的</span></span><br><span class="line">E <span class="title function_">pollLast</span><span class="params">()</span>; <span class="comment">// 删掉最大的</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><blockquote><p>set的底层就是map, HashSet 是 对 HashMap对象的封装,TreeSet 是对 TreeMap的封装</p></blockquote><h6 id="treeset-实现类">TreeSet 实现类</h6><p>这个是上面接口的实现类,它具有上面接口的所有方法,自己还提供了一些去实现这些接口的方法,因此记住了上面set,SortedSet,NavigableSet接口定义的方法,那么TreeSet也就差不多了</p><h3 id="queue接口">Queue接口</h3><p>这个也是collection的子接口,拥有collection的全部方法,还自己提供了一些额外的方法哦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>; <span class="comment">// 这个是重写collection里面的方法,往队列里面插入一个元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>; <span class="comment">// 这个也是往队列里面插入一个元素,跟add的区别在于,如果容器不够了,add会抛出异常,offer只会返回false</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">()</span>;  <span class="comment">// 拿出队首元素</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span>;  <span class="comment">// 拿出队首元素  和 remove的区别在于, 如果队列为空,poll返回null,remove 抛出异常</span></span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span>; <span class="comment">// 查看队首元素</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>; <span class="comment">// 查看队首元素, 和 element 的区别在于 如果队列为空,peek 返回null,element抛出异常</span></span><br></pre></td></tr></table></figure><blockquote><p>刷题的时候推荐使用 offer,poll,peek</p></blockquote><p><img src="/2022/12/19/java/java%E5%9F%BA%E7%A1%80/../img/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84assets/image-20221219100054193.png" alt="image-20221219100054193"></p><h4 id="deque接口">Deque接口</h4><p>这个是queue接口的子接口,这个是双向队列,在单向队列的基础上额外提供了在头部插入,尾部删除的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个接口的方法就是在Queue提供的方法上,加上Last,First</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>; <span class="comment">// 队首添加</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>; <span class="comment">// 队尾添加</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>; <span class="comment">// 队首添加</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;  <span class="comment">// 队尾添加  offer和add的区别还是和queue中的一样</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>;  <span class="comment">// 删除队首</span></span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>;  <span class="comment">// 删除队尾</span></span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>;<span class="comment">// 删除队首</span></span><br><span class="line">E <span class="title function_">pollLast</span><span class="params">()</span>;<span class="comment">// 删除队尾  </span></span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>; <span class="comment">// 查看队首元素 这个和 element的功能一样</span></span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>;  <span class="comment">// 查看队尾元素 </span></span><br><span class="line">E <span class="title function_">peekFirst</span><span class="params">()</span>; <span class="comment">// 查看队首</span></span><br><span class="line">E <span class="title function_">peekLast</span><span class="params">()</span>;  <span class="comment">// 查看队尾  这个和 get的区别就跟他和 element区别一样</span></span><br><span class="line"><span class="comment">// 下面这个几个方法,就和栈一样了,我们以后就用Deque的子类代替栈的使用了</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>; <span class="comment">// 往栈顶添加一个元素  等同于 addFirst</span></span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span>; <span class="comment">// 弹出栈顶元素  ==  removeFirst</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>; <span class="comment">// 查看栈顶元素  == getFirst</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>就不用java提供的stack的类了,它是继承了vector这个类再做的操作,我们可以直接使用双向队列替代</p></blockquote><p>它的子实现类中 LinkedList底层用链表实现,ArrayDeque用数组实现</p><h3 id="子实现类">子实现类</h3><p>在所有的子实现类中,一定有无参构造函数,和 只有一个参数,并且类型为collection的构造函数,其他的构造函数,要看具体的实现类的功能</p><p>下面举几个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span>; <span class="comment">// 因为底层是数组,可以设置大小</span></span><br><span class="line"><span class="comment">// PriorityQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span>; <span class="comment">// 需要排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span>; <span class="comment">// 如果这个c属于排序类型的接口,那么会使用它的排序规则</span></span><br></pre></td></tr></table></figure><h2 id="map">Map</h2><p>map 是一种具有映射关系的数据结构,一个key对应一个value</p><h3 id="提供方法">提供方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; <span class="comment">// 返回元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>; <span class="comment">// 是否包含某个key</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>; <span class="comment">// 是否包含某个值</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span>; <span class="comment">// 根据key 找到对应的value</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>; <span class="comment">// 更改key的value,并且返回原先的value</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>; <span class="comment">// 删除某个key,并且返回它的value值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>; <span class="comment">// 将某个map的元素加入到当前容器中,相当于取出m的每个key,value 执行put操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">//清除所有的元素</span></span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>; <span class="comment">// 获得所有key的set集合</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>; <span class="comment">// 获得所有值的集合</span></span><br><span class="line"><span class="comment">// 为什么key 要用set来装,value用collection来装呢? 因为key必须唯一,value不需要</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); <span class="comment">// 获得实体对象集合</span></span><br><span class="line"><span class="keyword">default</span> v <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span>; <span class="comment">// 如果key存在,则返回对应的value,否则返回给定的value</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>; <span class="comment">//如果key值不存在才放入元素,否则不放入,返回key最终对应的value</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span>; <span class="comment">//当k,v都等于给定值时,才移除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="提供的内部接口entry">提供的内部接口Entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> K <span class="title function_">getKey</span><span class="params">()</span>; <span class="comment">// 获取key</span></span><br><span class="line"> V <span class="title function_">getValue</span><span class="params">()</span>; <span class="comment">// 获取value</span></span><br><span class="line"> V <span class="title function_">setValue</span><span class="params">(V value)</span>; <span class="comment">// 设置value (这个不推荐使用,因为有的实现类,不支持这个方法)</span></span><br><span class="line"><span class="comment">// 你可能会问,问什么没有setKey, 这个其实也好说,Entry通常不是我们自己new出来的,而是我们通过调用map的方法获得的,我们当然不能随意更改它的key值</span></span><br></pre></td></tr></table></figure><h3 id="sortedmap接口">SortedMap接口</h3><p>这个接口的定义就是里面的数据是按照key值来排序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;? <span class="built_in">super</span> K&gt; comparator(); <span class="comment">//返回key的比较规则</span></span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>; <span class="comment">// 返回[fromKey,toKey) 这个区间的子map数据</span></span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>; <span class="comment">//返回key小于toKey的子map</span></span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>; <span class="comment">// 返回大于等于fromKey的子map</span></span><br><span class="line">K <span class="title function_">firstKey</span><span class="params">()</span>; <span class="comment">// 返回最下的key</span></span><br><span class="line">K <span class="title function_">lastKey</span><span class="params">()</span>; <span class="comment">// 返回最大的key</span></span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>; <span class="comment">// 返回已经排好序的set,其实也就是实现了NavigableSet 接口的类</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>; <span class="comment">// 返回按照key值排序对应的value的集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); <span class="comment">// 返回排好序的(k,v)键值对</span></span><br></pre></td></tr></table></figure><h4 id="navigablemap接口">NavigableMap接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">lowerEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">lowerKey</span><span class="params">(K key)</span>;</span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">floorEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">floorKey</span><span class="params">(K key)</span>;</span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">ceilingEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">ceilingKey</span><span class="params">(K key)</span>; </span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">higherEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">higherKey</span><span class="params">(K key)</span>;</span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">firstEntry</span><span class="params">()</span>;</span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">lastEntry</span><span class="params">()</span>;</span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">pollFirstEntry</span><span class="params">()</span>;</span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">pollLastEntry</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 这些方法是不是都很眼熟了,和上面NavigableSet 的是不是很像,不对,应该是说NavigableSet和这个很像</span></span><br></pre></td></tr></table></figure><h2 id="collections">collections</h2><p>这个是操作map,collection类型的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span>; <span class="comment">// 对list进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>; <span class="comment">// 对list排序,指定排序规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> ; <span class="comment">// 查找key在list中的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends T&gt; list, T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>; <span class="comment">// 指定规则查找key在list中的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span>; <span class="comment">// 翻转list</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span>; <span class="comment">// 随机打乱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span>; <span class="comment">// 交换list中两个位置的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list, T obj)</span>; <span class="comment">// 填充list</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span>; <span class="comment">//复制src到dest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">min</span><span class="params">(Collection&lt;? extends T&gt; coll)</span>; <span class="comment">// 查找集合中的最下值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">min</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span>; <span class="comment">// 按照指定的规则查找最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll)</span>; <span class="comment">// 查找集合中最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span>; <span class="comment">// 按照指定规则查找集合中的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span>; <span class="comment">// 就是将列表整体向后挪distance的距离,多出来的跑到前面去,这个distance可正可负</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List&lt;T&gt; list, T oldVal, T newVal)</span>; <span class="comment">// 替换oldval为newval</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span>;<span class="comment">// 查找source子列表包含target的第一个位置,如果不包含返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastIndexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span>; <span class="comment">// 查找source子列表包含target的最后一个位置,如果不包含返回-1</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">unmodifiableSet</span><span class="params">(Set&lt;? extends T&gt; s)</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title function_">unmodifiableSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; NavigableSet&lt;T&gt; <span class="title function_">unmodifiableNavigableSet</span><span class="params">(NavigableSet&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">unmodifiableList</span><span class="params">(List&lt;? extends T&gt; list)</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title function_">unmodifiableSortedMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; NavigableMap&lt;K,V&gt; <span class="title function_">unmodifiableNavigableMap</span><span class="params">(NavigableMap&lt;K, ? extends V&gt; m)</span>;</span><br><span class="line"><span class="comment">//上述方法就是封装原来的对象,修改对应方法,让其不能修改</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title function_">synchronizedSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; NavigableSet&lt;T&gt; <span class="title function_">synchronizedNavigableSet</span><span class="params">(NavigableSet&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title function_">synchronizedSortedMap</span><span class="params">(SortedMap&lt;K,V&gt; m)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; NavigableMap&lt;K,V&gt; <span class="title function_">synchronizedNavigableMap</span><span class="params">(NavigableMap&lt;K,V&gt; m)</span>;</span><br><span class="line"><span class="comment">// 上述方法就是重写接口方法然后加上synchronized关键字,然后再方法体里面调用所给对象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection&lt;?&gt; c, Object o)</span> ; <span class="comment">//某个元素出现次数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Collection&lt;E&gt; <span class="title function_">checkedXXXXX</span><span class="params">()</span>;<span class="comment">//这种方法就是为没有声明泛型的容器,限制只能往它这里面插入指定的数据类型</span></span><br><span class="line"><span class="comment">// 比如</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span>  <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  <span class="comment">//定义一个这样的列表,我们是可以添加任何数据类型进去的</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="string">&quot;111&quot;</span>); <span class="comment">// 不会报错</span></span><br><span class="line">list = Collections.checkedList(list,Integer.class); <span class="comment">// 限制他以后的数据类型,其实就是重写list的方法,插入数据的时候做检查</span></span><br><span class="line"> list.add(<span class="string">&quot;111&quot;</span>);<span class="comment">// 会抛出类型转化异常</span></span><br></pre></td></tr></table></figure><h2 id="lambda">Lambda</h2><p>Lambda 可以简化代码,用<strong>一个函数</strong>就能替代一个<strong>函数式接口</strong>实现并<strong>生成一个匿名类的对象</strong>的代码,对比一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原先使用runnable创建进程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 使用Lambda</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感受到魅力了么</p><h3 id="语法">语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123; 执行语句; &#125;</span><br><span class="line"><span class="comment">// 如果只有一个参数,可以省略中括号()</span></span><br><span class="line"><span class="comment">// 如果函数体只有一条return 返回值 的语句 可以省略return 以及&#123;&#125;</span></span><br><span class="line"><span class="comment">// 如果函数接口里面的抽象方法没有返回值,并且函数体里面只有一条语句,而且这条语句还没有返回值,也能够省略&#123;&#125;</span></span><br><span class="line"><span class="comment">// 其他情况一律不可以省略</span></span><br><span class="line">Consumer&lt;String&gt; consumer = s-&gt; System.out.println(s); <span class="comment">// 注意哦,这个Consumer只是一个接口,这个操作是不是相当于生成了一个匿名类的对象</span></span><br><span class="line"><span class="comment">// 我们不需要去写参数类型,返回值类型,因为这些都已经在函数式接口里面声明好了</span></span><br></pre></td></tr></table></figure><h3 id="方法引用">方法引用</h3><p>如果一个类已经存在的方法和函数式接口中定义的抽象方法返回值相同,参数相同,且接口中的方法能访问到这个引用方法,这样就能够直接使用这个类或者这个类的对象的方法应用充当Lambda</p><blockquote><p>我们可以理解成,传进来的参数我们可以找到哪个现成的方法能帮我们做,我们就用这个方法就行</p></blockquote><h4 id="通过类引用静态方法">通过类引用静态方法</h4><p>这个就很简单了,就是引用一个类的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String,Integer&gt; function = Integer::valueOf;</span><br><span class="line"><span class="type">int</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line"><span class="comment">// 有没有感觉这种方式很巧妙,你需要将一个字符串变成整数,你只要使用我这个接口就行,我这个接口上的东西是可以拔插的</span></span><br><span class="line"><span class="comment">//我这次用的是Integer中的方法,我下一次可能就用别的方法了呢,是不就只要改一下引用的方法就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的方法引用相当于(为了方便理解,没有简化Lambda)</span></span><br><span class="line">Function&lt;String,Integer&gt; function = (a)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueof(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过对象引用实列方法">通过对象引用实列方法</h4><p>这个也简单就是new一个对象然后使用它的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> System.out::println;</span><br><span class="line"><span class="comment">// 相当于下面这种格式(为了方便理解,没有简化Lambda)</span></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> (p) -&gt; &#123;</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法引用">构造方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,List&lt;Integer&gt;&gt; function = ArrayList&lt;Integer&gt;::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 相当于下面这种格式(为了方便理解,没有简化Lambda)</span></span><br><span class="line">Function&lt;Integer,List&lt;Integer&gt;&gt; function = (a)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面这几种其实都比较好理解,可以将方法引用写成Lambda的正常格式</p><p>像不像就是把传进来的参数给引用方法去执行,然后将引用方法非返回值返回去就OK了,可以理解成c++里面的函数指针</p></blockquote><h4 id="通过类引用实例方法">通过类引用实例方法</h4><p>比如Object::toString,toString 明明是对象里面才能用的方法,为什么可以直接使用类名引用呢,其实编译器会将第一个参数作为对象调用这个方法,并且把后面的参数放入这个引用参数的后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Object,String&gt; function1 = Object::toString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况就等价于(为了方便理解,没有简化Lambda)</span></span><br><span class="line">Function&lt;Object,String&gt; function1 = (o)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> o.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote></blockquote><h2 id="函数式接口">函数式接口</h2><p>函数式接口就是,接口中只能有一个抽象方法,这样就方便我们使用Lambda了,不过接口中还能有多个静态方法和default方法哦,不要被这个名字吓到哦,它其实也是一个接口,只不过只有一个抽象方法</p><h3 id="常用函数式接口">常用函数式接口</h3><h4 id="consumer">Consumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>; <span class="comment">// 接收一个指定的数据</span></span><br></pre></td></tr></table></figure><blockquote><p>消费者</p></blockquote><h4 id="supplier">Supplier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">get</span><span class="params">()</span>; <span class="comment">// 返回一个值</span></span><br></pre></td></tr></table></figure><blockquote><p>生产者</p></blockquote><h4 id="function">Function</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>; <span class="comment">// 接收一个参数,返回一个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是泛型函数,可以对t参数先加工,然后再根据加工的值去得到R类型的参数</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 也是泛型函数,对返回的值再一次进行加工,</span></span><br><span class="line"> <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>加工者</p></blockquote><h4 id="predicate">Predicate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>; <span class="comment">// 根据参数返回一个bool值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个测试做与操作</span></span><br><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 取反</span></span><br><span class="line"> <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"> <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 得到一个对象的测试者对象,用来检测其他对象是否跟我相等</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>检测者/测试者</p></blockquote><h2 id="stream">Stream</h2><p>steam 并不是一个容器,它只是对容器的增强功能,添加了很多便利的操作,列如查找,过滤,分组,排序等操作,而且还支持串行与并行两种模式,在并行的情况下能充分利用多核CPU的优势,总而言之stream 就是提供了搞笑且易于使用的数据处理方式</p><p>Stream的特点:</p><ul><li>Stream不会自己存储数据</li><li>Stream的操作不会改变原对象,他们会产生一个新的Stream对象</li><li>Stream的操作是有延时的,它会等到需要结果的时候才会运行,也就是终端操作</li></ul><p>Stream分为两个步骤,一个是中间操作,另外一个是终止操作,中间操作用来对数据加工,终止操作用来打印数据或者提取数据</p><blockquote><p>使用stream刷题的时候,一定要引入Stream,像力扣这种默认只引入了java.util.*</p><p>我们需要手动引入: import java.util.stream.*</p></blockquote><h4 id="通过数组创建">通过数组创建</h4><p>可以通过Arrays的stream方法对组创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">stream1</span> <span class="operator">=</span> Arrays.stream(ints);</span><br></pre></td></tr></table></figure><h4 id="通过集合创建">通过集合创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;Integer&gt; stream2 = collection.stream();</span><br><span class="line">Stream&lt;Integer&gt; integerStream = collection.parallelStream();</span><br></pre></td></tr></table></figure><h4 id="通过stream提供的方法创建">通过Stream提供的方法创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以通过of创建</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream1 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//下面这两个是无限流 (要注意使用limit限制哦)</span></span><br><span class="line">Stream.generate(Math::random);  <span class="comment">// 根据supplier接口的方法创建数据</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>,a-&gt;a+<span class="number">1</span>);   <span class="comment">// 迭代创建数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="中间操作">中间操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>; <span class="comment">// 过滤元素,返回true代表通过,将元素放到新的流中</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>; <span class="comment">// 将元素 进行一次加工</span></span><br><span class="line">IntStream <span class="title function_">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line">LongStream <span class="title function_">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line">DoubleStream <span class="title function_">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 上面几个方法是将流转化为基本(数据类型流</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>; <span class="comment">// 将多个流合并,有时候我们的数据可能是多维集合或者数组,我们希望将他们合并成一个流</span></span><br><span class="line"> IntStream <span class="title function_">flatMapToInt</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends IntStream&gt; mapper)</span>;</span><br><span class="line"> LongStream <span class="title function_">flatMapToLong</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends LongStream&gt; mapper)</span>;</span><br><span class="line"> DoubleStream <span class="title function_">flatMapToDouble</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends DoubleStream&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 将多个流合并成基本数据类型的流</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>; <span class="comment">// 去重,利用hashcode 与 equals方法</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>; <span class="comment">// 排序</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>; <span class="comment">// 按照指定规则排序</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>; <span class="comment">// 查看一遍元素,但是不对数据做任何改变(除非你要自己改变对象里面的属性),可以用于debug</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>; <span class="comment">// 限制元素个数</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>; <span class="comment">// 跳过前n个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="终端操作">终端操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;<span class="comment">//循环遍历全部</span></span><br><span class="line">Object[] toArray();<span class="comment">//将元素变成数组</span></span><br><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;<span class="comment">// 规约操作,给定一个初始值,然后进行规约操作,比如可以求和</span></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;<span class="comment">// 没有初始值的规约操作,比如求最大值,最小值</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>; <span class="comment">// 收集元素可选的有Colletctors.toList() toMap(function接口) toSet()</span></span><br><span class="line"> Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>; <span class="comment">// 求最小值</span></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>; <span class="comment">// 求最大值</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>; <span class="comment">// 元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;<span class="comment">// 是否有一个满足要求</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;<span class="comment">//是否全部满足要求</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;<span class="comment">//是不是全部没有满足要求</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>像基本数据类型的流并不是Stream的子类,而是他的兄弟类,有时候我们需要将IntStream这个样的流变成Stream流使用他的方法,比如collect,可以使用boxed方法进行转变</p></blockquote><h3 id="实战">实战</h3><p>学完了这么些东西,有没有种蠢蠢欲动的感觉,什么?,迎面走来的你让我蠢蠢欲动(hahahahah)</p><h4 id="数组变list">数组变list</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们一起是不是要先new 好list 然后循环去添加啊,那是真的烦人</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList())</span><br></pre></td></tr></table></figure><h4 id="list变数组">list变数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ints1 = list.stream().mapToInt(a -&gt; a).toArray();  <span class="comment">// 这里的a-&gt;a是什么意思呢,无奖竞猜</span></span><br></pre></td></tr></table></figure><blockquote><p>其实这里利用的是java的自动装箱拆箱机制</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int fun(Integer a)&#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer fun(int a)&#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> System.out.println(fun(1));</span><br><span class="line"> System.out.println(fun(Integer.valueOf(2)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="optional">Optional</h2><p><strong>Optional 是为了清晰地表达返回值中没有结果的可能性</strong></p><p>这个能减少我们对null值的判断,就能减少不少的ifelse,配合上Lambda和函数式接口,简直可以起飞,而且感觉逻辑也比较清晰吧</p><ul><li>不要过度使用 Optional 避免降低代码可读性和性能</li><li>调用了返回值为Optional的方法后，一定要做空值检查</li><li>用来在某些地方替代if - else 我觉得很不错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span>; <span class="comment">//返回一个空的Optional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span>; <span class="comment">// 将一个非空的元素包装到optional中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span>; <span class="comment">// 允许值为空</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>; <span class="comment">// 获取值 但是如果值为空会抛出异常,不推荐直接使用这个方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span>; <span class="comment">//检查值是否为空</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> ; <span class="comment">// 如果值不为空,我们可以使用这个值</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>; <span class="comment">// 检查这个值是否符合要求,符合继续返回这个optional对象,不符合返回空值对象</span></span><br><span class="line"> <span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span>; <span class="comment">//将包装的值送到mapper里面返回一个包装了新的值的optional</span></span><br><span class="line"> <span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span>; <span class="comment">// 与上面这个方法很像,但是创建optional的方式交给了mapper</span></span><br><span class="line"> <span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span>; <span class="comment">// 值不为null返回值,否则返回我们给定的值</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span>; <span class="comment">// 值不为null返回值,否则返回提供者提供的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举个例子吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (optional.isPresent()) &#123;   </span><br><span class="line">            System.out.println(optional.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        optional.ifPresent(System.out::println);  <span class="comment">// 这个就省事了一下</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">nullSafeValue</span> <span class="operator">=</span> optional.orElse(<span class="string">&quot;Default value&quot;</span>);</span><br><span class="line">        System.out.println(nullSafeValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using Optional with a method that might return null</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mightBeNull</span> <span class="operator">=</span> methodThatMightReturnNull();</span><br><span class="line">        Optional&lt;String&gt; optional2 = Optional.ofNullable(mightBeNull);</span><br><span class="line">        optional2.ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">methodThatMightReturnNull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.random() &lt; <span class="number">0.5</span>) ? <span class="string">&quot;Hello world&quot;</span> : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然省事,但是吧,咱们平常好像用的也不多</p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任务清单</title>
      <link href="/2022/12/19/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/index/"/>
      <url>/2022/12/19/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/index/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">想干/学的事情</th><th style="text-align:center">有想法的日期</th><th style="text-align:center">开始的日期</th><th style="text-align:center">做完的日期</th></tr></thead><tbody><tr><td style="text-align:center">正则表达式</td><td style="text-align:center">2022/12/5</td><td style="text-align:center">2023/2/17</td><td style="text-align:center">2023/2/18</td></tr><tr><td style="text-align:center">PlantUML</td><td style="text-align:center">2022/12/10</td><td style="text-align:center">2022/12/28</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">java基础</td><td style="text-align:center">2022/12/18</td><td style="text-align:center">2022/12/19</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">51单片机</td><td style="text-align:center">2023/1/4</td><td style="text-align:center">2023/1/4</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">电路原理</td><td style="text-align:center">2023/2/11</td><td style="text-align:center">2023/2/11</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">计算机组成原理</td><td style="text-align:center">2023/2/11</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">spring/springboot</td><td style="text-align:center">2023/2/18</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">test</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> tasks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这个是跟哔哩哔哩<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=5&amp;vd_source=25bfa760964880528c6259566561afed">湖科大教书匠</a>的视频做的笔记,以及自己的思考与总结</p><h2 id="什么是计算机网络">什么是计算机网络</h2><p>计算机网络是由通信介质将地理位置不同的且相互独立的计算机连接起来，实现数据通信与资源共享。</p><p>个人觉得,计算机网络就是<strong>实现如何将数据可靠,快速</strong>的从一个设备传输到另一个设备</p><h3 id="专用术语">专用术语</h3><h4 id="实体">实体</h4><p>实体是指任何可发送或接受信息的硬件或者软件</p><p>对等实体是指位于同一个层次的实体</p><h3 id="协议">协议</h3><p>协议是控制两个对等实体进行<strong>逻辑通信</strong>的规则的集合</p><p>三个要素:</p><ul><li><strong>语法</strong>:定义交换信息的格式(头部)</li><li><strong>语义</strong>:通信双方需要完成的操作(报文)</li><li><strong>同步</strong>:定义收发双方的时序关系(tcp建立连接的过程)</li></ul><h3 id="服务">服务</h3><p>在协议的控制下,两个对等实体间的逻辑通信使得本层能够向上一层提供服务</p><p>协议是水平的,服务是垂直的</p><p>每层之间的数据类型:传输层的报文,网络层的分组,数据链路层的帧,物理层的比特流</p><h2 id="计算机网络体系结构">计算机网络体系结构</h2><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218140005626.png" alt="image-20221218140005626"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218171039441.png" alt="image-20221218171039441"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218171100169.png" alt="image-20221218171100169"></p><p>体系结构的作用:</p><ul><li>分层</li><li>每一层必须要完成的功能</li><li>每一层使用的协议(TCP/IP体系结构)</li></ul><h3 id="分层的必要性">分层的必要性</h3><p>计算机网络是个非常复杂的系统,分层可以将庞大而复杂的问题,转化为若干个较小的局部问题,而这些较小的局部问题比较容易研究和处理</p><p><strong>两个设备之间需要考虑的问题(物理层的问题)</strong>:</p><ul><li>采用什么传输介质</li><li>使用什么样的物理接口</li><li>使用怎么样的信号表示比特0和1</li></ul><p>这个就交给物理层去解决(传输介质严格来说不属于物理层)</p><p><strong>在一个网络上,需要考虑的问题(数据链路层的问题)</strong>:</p><ul><li>如何标识网络中的各个主机(如何得知数据发给谁,主机如何判断是不是发给我的),可以采用mac地址</li><li>解决上面的问题后,如何从信号所表示的比特流中区分地址和数据</li><li>如何解决线路的冲突的问题(线路争用)(<strong>总线型链路,现在已经淘汰了,采用交换机来替代</strong>)</li></ul><p><strong>在多个网络上,需要考虑的问题(网络层的问题)</strong>:</p><ul><li>如何标识网络以及网络中的各个主机</li><li>路由器如何转发分组,如何进行路由选择</li></ul><p><strong>在不同的主机上,需要考虑的问题(传输层的问题)</strong>:</p><ul><li>如何解决进程之间的网络通信问题</li><li>出现传输错误时,如何处理</li></ul><h2 id="因特网">因特网</h2><h3 id="名词解释">名词解释</h3><p><strong>网络</strong>是由若干个结点以及连接这个结点的链路构成(这个一般指的是本地通过交换机连接起来的结点)</p><p><strong>互联网</strong>是由多个网络通过路由器连接起来的,构成一个覆盖范围更大的网络 (网络的网络)</p><p><strong>因特网</strong>是世界上最大的互联网</p><p><strong>internet</strong> 是一个通用名词,泛指多个计算机网络互连而成,网络之间的通信协议可以任意</p><p><strong>Internet</strong> 是一个专有名词,特指因特网,采用TCP/IP 协议簇作为通信规则,前身是ARPANET</p><h3 id="因特网发展阶段">因特网发展阶段</h3><p>1969 第一个分组交换网<strong>ARPANET</strong></p><p>70年代中期,研究多种网络之间的互连</p><p>1983年,TCP/IP协议成为ARPANET的标准协议,这个也是因特网的诞生时间</p><p>1983年,NSF 围绕六个大型计算机中心建设NSFNET(主干网,地区网,校园网),三级结构</p><p>1990年 ARPANET 任务完成,正式关闭</p><p>1991年 美国政府将因特网主干网交给私人公司经营</p><p>1993年 NSFNET 逐渐被若干个商用主干网替代,政府机构不在负责运营,让各种因特网服务提供商ISP 来运营</p><p>1994年 万维网www技术促使因特网迅猛发展</p><p>1995年 NSFNET 停止运作,因特网彻底商业化</p><h3 id="因特网的标准化工作">因特网的标准化工作</h3><p>因特网的标准化工作对因特网的发展起到了非常重要的作用</p><p>因特网在制定其标准上的一个很大的特点是面向公众</p><ul><li>因特网的所有RFC 技术文档都可以从因特网上免费下载</li><li>任何人都可以随时发电子邮件发表对某个文档的建议和意见</li></ul><h3 id="因特网的组成">因特网的组成</h3><p>边缘部分: 由所有连接在因特网上的主机组成</p><p>核心部分: 由大量网络和连接这些网络的路由器组成 ,为边缘部分提供连通性和交换服务</p><h2 id="交换方式">交换方式</h2><h3 id="电路交换">电路交换</h3><p>电路交换机接通电话线的方式称为电路交换</p><p>电路的三个步骤:</p><ul><li>建立物理连接(分配通信资源)</li><li>通话(一直占用通信资源)</li><li>释放物理连接(归还资源)</li></ul><h3 id="分组交换">分组交换</h3><p>发送方构造报文成分组,发送分组</p><p>路由器 缓存分组,转发分组 (存储转发)</p><p>接收方 接收分组,还原分组成报文</p><p>分组交换有两种方式:<strong>数据报和虚电路</strong></p><p>虚电路是一种逻辑电路,就是每一次分组都和上一次分组的路径一样,这样到达接收端的顺序是一样的,不会失序,也不会重复分组</p><h3 id="报文交换">报文交换</h3><p><strong>不限制数据报大小</strong>,也是存储转发,跟分组交换差不多,分组交换就是多次的固定长度的报文交换,因为分组就是报文分割而成,<strong>现在报文交换基本被分组交换取代</strong></p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/计算机网络-tempassets/image-20221217210801358.png" alt="image-20221217210801358"><p>三个交换方式对比:</p><table><thead><tr><th style="text-align:center">交换方式</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">电路交换</td><td style="text-align:center">1.通信时延小(数据直达),2.有序传输,3.没有冲突(不争用物理线道),4.适用范围广(适用模拟信号和电路信号),5.实时性强,6.控制简单</td><td style="text-align:center">1.建立连接时间长,2.线路独占,使用效率低,3.灵活性差(只要线路坏了,就要重新建立连接),4.难以规格化</td></tr><tr><td style="text-align:center">报文交换</td><td style="text-align:center">1.无需建立连接,2.动态分配线路(选择合适的线路),3.提高线路可靠性(出现故障,重新选择路线),4提高线路利用率(不固定占用线路,只有发送的时候占用),5.提供多目标服务(一个结点可以发往多个目的地址)</td><td style="text-align:center">1.引起了转发时延(需要存储转发),2.需要较大的存储缓存空间(不限制报文大小),3.需要额外的信息量(报文头部)</td></tr><tr><td style="text-align:center">分组交换</td><td style="text-align:center">1.无需建立连接,2.线路利用率高,3.简化了存储管理(相对报文而言,分组的大小固定),4.加速传输(后一个分组的存储与前一个分组转发可以同时进行),5.减少出错概率和重发数据量(分组比报文小,出错概率会低一些,即使出错了,重发的数据量就会变少,只需要重传分组)</td><td style="text-align:center">1.引起转发时延(存储转发),2.需要额外的信息量(分组头部),3.对于数据报服务,存在失序,丢失,重复分组的问题,还原原始报文比较麻烦,对于虚电路服务,存在呼叫建立,数据传输,虚电路释放的三个过程</td></tr></tbody></table><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/计算机网络-tempassets/image-20221217215149123.png" alt="image-20221217215149123"><h2 id="计算机网络性能指标">计算机网络性能指标</h2><h3 id="速率">速率</h3><p>单位时间内能传输的比特数量</p><p>速率中的单位k代表10^3,M代表10^6,G代表10^9</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218161558853.png" alt="image-20221218161558853"></p><p>这道题应该这么算:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100*2^20*8/100*10^6 = 2^23/10^6 = 8.388608s</span><br><span class="line">我们其实也可以直接约掉M,这样就只有8s 其实也差别不大</span><br></pre></td></tr></table></figure><h3 id="带宽">带宽</h3><p>在模拟信号系统中,它表示信号所包含的各种不同频率成分所占据的频率范围 ,单位:Hz</p><p>在计算机网络中,用来表示网络的<strong>通信线路</strong>所能传输数据的能力,带宽是一个线路的最高速率</p><h3 id="吞吐量">吞吐量</h3><p>表示单位时间内,通过某个网络,信道,接口的数据量</p><h3 id="时延">时延</h3><p>表示一个分组到达目的主机需要的时间,从主机到发送地址,一般需要经历以下几个时延</p><p>发送时延(由网卡的发送速率,信道带宽,接口速率决定,取其中的最小值),分组长度(b)/发送速率(b/s)</p><p><strong>传播时延</strong> 信道长度(m)/电磁波传播速率(m/s)</p><p>常用传输媒体的电磁波传播速率</p><ul><li>自由空间: 3*10^8 m/s</li><li>铜线: 2.3*10^8 m/s</li><li>光纤: 2.0*10^8 m/s</li></ul><p>处理时延(多个路由器要处理) 这个很难通过计算公式计算,(包括排队时延和处理时延)</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218164009177.png" alt="image-20221218164009177"></p><p>我们单纯的认为发送时延占主导还是传播时延占主导,得具体情况具体分析</p><blockquote><p>增加数据量只增加发送时延,不影响传播时延,传播时延永远是<strong>最后一个比特的信号发送完</strong>到<strong>所有比特信号到目的地址</strong>的间隔</p></blockquote><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218174727515.png" alt="image-20221218174727515"></p><p>时延就是最后一个比特到终点的时间,甭管你多少个分组,在多段链路上(按顺序来发送),计算公式就是:  n代表分组数量,m代表链路数量</p><p><strong>单个分组发送时延*N(相当于发送最后一个报文的时延)</strong>+<strong>发送时延*m-1(最后一个分组的后续结点总发送时延)</strong>+<strong>每段链路的传播时延*m(最后一个分组的传播时延)</strong></p><h3 id="时延带宽积">时延带宽积</h3><p>时延带宽积 = 传播时延 * 带宽, 意思就是,当发送的第一个比特到达目的地后,发送端就发送了时延带宽积个比特的数据了</p><h3 id="往返时间-rtt">往返时间(RTT)</h3><p>我们有时候需要知道双向交互一次需要的时间,因此RTT也是一个重要的性能指标</p><h3 id="利用率">利用率</h3><p>信道利用率: 表示某个信道有百分之几的时间是被利用的</p><p>网络利用率: 表示全网络的信道利用率的加权平均</p><p>信道利用率不是越高越好,根据排队论,当某个信道的利用率增大时,排队的分组也会越多,引起的时延也会迅速增加</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218170051379.png" alt="image-20221218170051379"></p><h3 id="丢包率">丢包率</h3><p>即分组丢失率,指在一定时间范围内,传输过程中丢失分组数量与总分组数量的比率</p><p>丢包率分为接口丢包率,结点丢包率,链路丢包率,路径丢包率,网络丢包率</p><p>分组丢失主要两种情况:</p><ul><li>分组在传输过程中出现误码</li><li>分组到达队里已满的分组交换机(路由器)时就会被丢弃</li></ul><p>丢包率能够反映网络的拥塞情况</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218170508256.png" alt="image-20221218170508256"></p><h2 id="物理层">物理层</h2><p>物理层考虑的是<strong>怎样才能在连接各种计算机的传输媒体上传输比特流</strong></p><p>物理层为数据链路层屏蔽了各种传输媒体的差异,是的数据链路层只需要考虑如何完成本层协议和服务,而不必考虑网络的具体传输媒体是什么</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218195803348.png" alt="image-20221218195803348"></p><h3 id="传输媒体">传输媒体</h3><p>导引型(有硬件传输): 双绞线,同轴电缆,光纤,电力线</p><p>非导引型(自由空间): 微波通信(2~40GHz)</p><h3 id="传输方式">传输方式</h3><p>串行传输,并行传输</p><p>同步传输:字节紧凑传输,需要双方时钟同步(外同步:增加一条时钟信号线,内容部,将同步信号编码到发送数据中一起传输)</p><p>异步传输: 字节之间可以不用紧凑传输,字节内需要同步</p><p>单向通信(单工): 广播</p><p>双向交替通信(半双工):对讲机</p><p>双向同时通信(全双工): 电话</p><h3 id="编码与调制">编码与调制</h3><p>数据是运送消息的实体</p><p>码元:构成信号的一段波形</p><p>不归零编码(不采用): 一个码元正电平代表1,负电平代表0,额外还需要一个同步信号同步接收码元,不然怎么区分多个相同的码元</p><p>归零编码: 这个其实就是将同步信号写在了数据里面,正电平代表1,负电平代表0,0电平代表码元结束,缺点是编码效率低,相当于传输一个比特就得多搞一个比特</p><p>曼彻斯特编码: 跳变就表示数据,负跳变代表1,正跳变代表0,跳变是在中间位置,所以对方主机能够知道一个一个码元的时间是多少</p><p>差分曼彻斯特编码:如果在最初信号的时候，即第一个信号时：如果中间位电平从低到高，则表示0；如果中间位电平从高到低，则表示1；否则就看当前码元开始的位置与上一次码元的结束部分电压是否相同,相同则表示0,不同则表示1</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218212001631.png" alt="image-20221218212001631"></p><p>就是通过中间跳变来告诉对方主机,我的一个码元时间周期是多长</p><p>模拟信号:</p><p>通过模拟信号,可以产生很多种码元,这样的话,一个码元就可以表示多个比特</p><h3 id="信道的极限容量">信道的极限容量</h3><p>影响失真的因素有: 码元传输速率,信号传输距离,噪声干扰,传输媒体质量</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218213752561.png" alt="image-20221218213752561"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218215857564.png" alt="image-20221218215857564"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218220759980.png" alt="image-20221218220759980"></p><p>这几个公式不要搞混了:</p><p>理想低通信道的最高码元传输速率 = 2*<strong>带宽</strong>(这里是带宽,而不是数据传输速率)</p><p>传输速率 = 码元传输速率或者叫波特率 * 码元能携带的比特数量</p><h2 id="数据链路层">数据链路层</h2><p>链路: 就是从一个结点到相邻结点的一段物理线路,而中间没有任何其他交换结点</p><p>数据链路: 指把实现通信协议的软件和硬件加到链路上,就构成了数据链路</p><h3 id="封装成帧">封装成帧</h3><p>将上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li>帧头和帧尾中包含有重要的控制信息</li><li>帧头和帧尾的作用之一就是帧定界</li></ul><p>透明传输是指<strong>数据链路层对上层的交付的传输数据没有任何限制</strong>,就好像数据链路层不存在一样.</p><p>当上层传输的数据与帧头和帧尾定界符冲突的时候,有下面方法可以解决:</p><ul><li>如果是面向字节的物理链路,可以使用字节填充,增加转移字符的方式实现</li><li>如果是面向比特的物理链路,使用比特填充的方法, 可以每五个1就添加一个0的方法实现(这个要看具体协议对应的帧头和帧尾长什么样,我这里只是举个例子)</li></ul><p>考虑到差错控制等因素,每一种数据链路层协议都规定了帧的数据部分的长度上限,即最大传送单元<strong>MTU</strong></p><h3 id="差错检测">差错检测</h3><p>实际的通信链路是不理想的,比特在传输的过程中,可能会产生差错,1可能变成0,0也可能变成1,这被称为比特差错</p><h4 id="奇偶校验">奇偶校验</h4><p>在待发送的数据后面添加<strong>一位奇偶校验位</strong>,使得整个数据(包含校验位)中1的个数为<strong>奇数(奇校验)<strong>或者偶数</strong>(偶校验)</strong></p><p>这个校验方法是有缺陷的,如果同一个种差错出现偶数次,这样就检测不出来差错</p><h4 id="循环冗余校验">循环冗余校验</h4><ul><li>收发双方约定好一个<strong>生成多项式</strong></li><li>发送方基于发送的数据和生成多项式计算出<strong>差错检测码(冗余码)</strong>,将其添加到戴传输数据后面一起传输</li><li>接收方通过生成多项式计算收到的数据是否产生了误码</li></ul><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220192803464.png" alt="image-20221220192803464"></p><p>计算过程如上图所示</p><p>做个练习吧</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220192928601.png" alt="image-20221220192928601"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220194017633.png" alt="image-20221220194017633"></p><p>再来个题吧</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220194102553.png" alt="image-20221220194102553"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220194124925.png" alt="image-20221220194124925"></p><blockquote><p>字有点丑哦,不要介意</p></blockquote><p>检错码只能检测帧在传输过程中出现了差错,并不能定位错误,因此无法纠正错误,要想纠正传输中的差错,可以使用冗余信息更多的纠错码进行向前检错,但是纠错码的开销大,在计算机网络中<strong>较少使用</strong>(也不是不使用)</p><p>循环冗余校验CRC有很好的的检错能力(<strong>漏检率非常低</strong>),虽然计算比较复杂,但是<strong>硬件易于实现</strong>,因此被广泛用于数据链路层</p><p>如果检测到数据出现了错误,是告诉对方<strong>重传</strong>还是<strong>丢弃</strong>该帧,取决于数据链路层向上层提供的是可靠传输还是不可靠传输</p><h3 id="可靠传输">可靠传输</h3><p>一般情况下,<strong>有线链路</strong>的误码率比较低,为了减小开销,<strong>并不要求</strong>数据链路层向上提供可靠传输服务,即使出现了误码,可靠传输的问题可以交给上层处理,比如<strong>以太网</strong></p><p><strong>无线链路</strong>易受干扰,误码率比较高,因此要求数据链路层<strong>必须项上层提供可靠传输</strong>,比如<strong>802.11无线局域网</strong></p><p>比特差错只是传输差错中的一种,还有网络层的分组呢,比如分组丢失,分组失序,分组重复</p><p>可靠传输不只在数据链路层,而是贯穿整个体系</p><h4 id="实现机制">实现机制</h4><h5 id="停止-等待协议-sw">停止-等待协议(SW)</h5><p>等接收方确认接收分组后才发送 下一个分组</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220202040638.png" alt="image-20221220202040638"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220201153224.png" alt="image-20221220201153224"></p><p>停止等待的信道利用率比较低</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220201410189.png" alt="image-20221220201410189"></p><p><strong>这题我有点蒙,这个传输时延居然指的是确认帧的发送时延,做题的时候,还是按公式来吧</strong></p><h5 id="回退n帧-gbn-go-back-n">回退N帧(GBN GO-Back-N)</h5><blockquote><p>也可以叫做滑动窗口协议吧,嘿嘿,这个算是对sw协议的一种改进,sw必须等待上一个分组被确认了,才能继续发送下一个分组,而gbn可以一次发送多个分组,如果某个分组超时了,那么再重传这个分组后面的所有分组,所以这里是不是又有改进啊,嘿嘿,这是后面的选择重传</p></blockquote><p>维持一个发送窗口,可以连续发送这个窗口里面的分组,接收方只能依次接收分组,如果出现当前待接收分组序号与收到的序号不同,则会丢到分组,并向发送端发送前一个分组的确认分组.如果一个分组发生了超时重传,那么这个分组后面已经发送的分组也要重新发送,这就是回退N帧协议</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220203936775.png" alt="image-20221220203936775"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220204318147.png" alt="image-20221220204318147"></p><blockquote><p>只要接收方确认了某个序号,那么说明这个序号之前的分组,它都收到了</p></blockquote><h5 id="选择重传协议-sr-selective-request">选择重传协议(SR selective Request)</h5><p>发送方维持一个发送窗口,可以依次将窗口内的数据全部发送出去,接收方可以不按顺序接收,每接收一个分组,就回传一个确认分组,发送方只有当最前面的分组收到确认分组后,才能向后挪动窗口</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221220211148861.png" alt="image-20221220211148861"></p><blockquote><p>注意回退N帧的最大窗口值是2^n -1 而 选择重传的最大窗口值是2^(n-1)</p></blockquote><h3 id="点对点协议ppp-point-to-point-protocol">点对点协议ppp(Point-to-Point Protocol)</h3><p>ppp 协议为在点对点链路传输各种协议数据报提供了一个标准方法</p><ul><li>对各种协议数据报的封装方法(封装成帧)</li><li>链路控制协议LCP,用于建立,配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs 其中的每一个协议支持不同的网络层协议</li></ul><p>向上层提供的是不可靠的服务</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221228193108549.png" alt="image-20221228193108549"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221228193127410.png" alt="image-20221228193127410"></p><h3 id="媒体接入控制">媒体接入控制</h3><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用,即媒体接入控制MAC</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221228193658962.png" alt="image-20221228193658962"></p><h4 id="csma-cd-协议">CSMA/CD 协议</h4><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221228195550399.png" alt="image-20221228195550399"></p><h4 id="csma-ca协议">CSMA/CA协议</h4><p>数据包在传输的过程中,不经过nat,源ip不会发生变化,不经过dnat 目的ip不会发生变化,而物理层每转化一次就变化一次</p><h4 id="arp协议">ARP协议</h4><p>这个协议通过对方ip地址找到对方的mac地址,这个协议有什么用呢?,在网络与网络之间,这个协议没什么用(没什么主要作用,还是要通过这个协议通过ip找到mac地址),这个协议主要用在网络内部,网络与网络之间传递的时候,我们并不需要关心mac地址,如果目的地址的ip与相邻的某个路由器的ip在同一个网段,那我只要把数据给他就行了,然后数据到了某个网络后,需要通过ip找到对方的mac地址(这个就是ARP协议),然后在链路上传播</p><blockquote><p>使用集线器的以太网在逻辑上仍然是一个总线网,各站共享总线资源,使用的还是CSMA/CD协议</p><p>集线器只工作在物理层,它的每个接口仅简单的转发比特,不进行碰撞检测,还是由主机网卡自行检测</p></blockquote><p>集线器就类似主线结构,主机发送单播帧的时候,会传递到这个以太网下的所有设备</p><p>交换机只会将单播帧转发给对应设备(需要建立在已经通过ARP学习好了的情况)</p><h3 id="交换机自学习和转发帧">交换机自学习和转发帧</h3><ul><li>交换机工作在数据链路层</li><li>交换机收到帧后,在帧交换表中查找帧的目的Mac地址所对应的接口号,然后通过该接口转发帧</li><li>交换机是一种即插即用设备,刚上电启动时内部的帧交换表是空的,随着网络中的主机间的通信,交换机通过自学习算法自动主键建立起帧交换表</li></ul><p>帧转发的流程:</p><ul><li>登记,先记录自己的Mac地址与接口的对应关系</li><li>转发, 如果有目的Mac地址,就明确的准发给对应的接口,如果没有目的Mac地址就全部转发,</li></ul><p>交换机丢弃帧的情况:</p><ul><li>如果入口接口与出口接口相同,交换机会丢弃这个帧</li></ul><p>做道题吧</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231151147084.png" alt="image-20221231151147084"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231151726359.png" alt="image-20221231151726359"></p><h3 id="以太网交换机的生成树协议stp">以太网交换机的生成树协议STP</h3><p>思考一个问题,我们如何提高以太网的可靠性?</p><p>答案就是增加冗余链路,如果只有单一的连通链路,那么其中任意一条链路坏了,那么就会有主机无法通信,如果怎加了冗余链路,可以保证如果坏了一段链路也能保证网络的连通.</p><p>冗余链路会带来负面效应,比如网络环路,网络环路会造成以下问题:</p><ul><li>广播风暴,多个广播帧(这些帧是相同的)在链路里面循环传播,不会停止,会大量消耗网络资源,是的网络无法正常发送其他数据帧,而且会导致交换机的帧交换表震荡,就是这个帧的源Mac地址对应的接口号一直在变</li></ul><p>使用交换机的生成树协议可以避免这种网络环路带来的各种问题</p><p>这种协议可以构建一个<strong>逻辑上</strong>没有环路的网络,就是物理连接上有环路,但是可以让某些链路不使用,等到这个生成树上的某些链路坏掉后,在把这些不用的链路拿出来重新计算,生成逻辑上没有环路的网络</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231153435015.png" alt="image-20221231153435015"></p><h3 id="虚拟局域网vlan">虚拟局域网VLAN</h3><p>是一种将局域网内的设备划分成与物理位置无光的逻辑组技术,这些逻辑组具有某些共同的需求</p><p>属于同一个VLAN的设备才能广播通信,不同的VLAN的设备不能广播通信</p><p>这样肯定就需要交换机具有更多的功能了</p><ul><li>支持IEE 802.1Q帧</li><li>交换机的需要支持更多的端口类型</li></ul><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231155144867.png" alt="image-20221231155144867"></p><p>acces端口:用于主机与交换机的连接</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231155525327.png" alt="image-20221231155525327"></p><p>Trunk端口: 用于交换机之间或者交换机与路由器互联,可以属于多个VLAN</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231160753254.png" alt="image-20221231160753254"></p><p>Hybrid端口: 可以任意设备互联</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231161117800.png" alt="image-20221231161117800"></p><h2 id="网络层">网络层</h2><p>网络层的主要任务是实现网络互连,进而实现数据包在网络之间的传输</p><p>需要解决两个问题:</p><ul><li>网络向运输层提供什么样的服务</li><li>网络层寻址问题</li><li>路由选择问题</li></ul><h3 id="面向连接的虚电路服务">面向连接的虚电路服务</h3><p>先建立网络层的连接,也就是虚电路,双反沿着已建立的虚电路发送分组,每个分组发送经历的路径都一样.如果再配上可靠传输的网络协议,那么分组就能正确的到达接收方(分组按序到达,没有差错)</p><h3 id="无连接的数据报服务">无连接的数据报服务</h3><ul><li>可靠通信应当由用户主机来保证</li><li>不需要建立网络层的连接</li><li>每个分组可走不同的路径</li><li>每个分组的首部必须携带目的主机的完整地址</li><li>这种通信传送的分组可能误码,丢失,重复,失序</li></ul><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231164114062.png" alt="image-20221231164114062"></p><h3 id="ipv4地址概述">IPv4地址概述</h3><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231164538526.png" alt="image-20221231164538526"></p><h4 id="分类编制">分类编制</h4><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221231164955854.png" alt="image-20221231164955854"></p><p>注意啊,主机号是全0和全1的才不能分配给主机和路由器</p><p>他这个分类是按照网络号位数来分配的</p><ul><li>A类: 网络号8位  0开头  网络号 00000001 - 01111110   1-126 01111111不能取,这个是回环地址,  可分配的ip地址  (2^8 -2)*(2^24-2)</li><li>B类: 网络号16位 10开头  网络号 128.0 - 191.255 可分配的ip 2^(16-2)*(2^16-2)</li><li>C类: 网络号 24 为 110开头  网络号  192.0.0 - 223.255.255 可分配ip地址  2^(24-3)*(2^8-2)</li><li>D类: 多播地址  1110开头</li><li>E类: 保留地址 1111开头</li></ul><h4 id="划分子网的ip地址">划分子网的ip地址</h4><p>借用一些主机号部分用来划分子网</p><ul><li>32比特的子网掩码可以表明分类ip地址主机号部分被借用了几个比特作为子网号</li></ul><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104123644667.png" alt="image-20230104123644667"></p><p>划分的子网为2^2 = 4</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104124644750.png" alt="image-20230104124644750"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104124738264.png" alt="image-20230104124738264"></p><p>默认子网掩码就是网络号全取1,主机号全取0</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104125117563.png" alt="image-20230104125117563"></p><h4 id="无分类编制的ipv4地址">无分类编制的IPv4地址</h4><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104132138768.png" alt="image-20230104132138768"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104130003330.png" alt="image-20230104130003330"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104130431290.png" alt="image-20230104130431290"></p><h5 id="路由聚合">路由聚合</h5><p>将自己知道的路由信息,将这些ip分别对应的共同前缀告诉其他路由器</p><ul><li>网络前缀越长,地址块越小,路由越具体</li><li>路由器查表分组转发分组的时候发现有多条路由可选,则选择网络前缀最长的那条,这称为最长前缀匹配</li></ul><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104131321980.png" alt="image-20230104131321980"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104131345551.png" alt="image-20230104131345551"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104132019986.png" alt="image-20230104132019986"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104132031156.png" alt="image-20230104132031156"></p><h3 id="ipv4地址的应用规划">IPv4地址的应用规划</h3><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104140219612.png" alt="image-20230104140219612"></p><h5 id="定长子网掩码">定长子网掩码</h5><p>划分子网的时候,用定长的子网掩码,每个子网划分的ip数量一样多,这样容易浪费ip</p><h5 id="变长的子网掩码">变长的子网掩码</h5><p>划分子网的时候,可以使用变长的子网掩码,按需分配,这样不容易浪费ip或者浪费的ip数量比较少</p><ul><li>划分块的时候,尽量先给大的块分配ip地址</li></ul><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104134627147.png" alt="image-20230104134627147"></p><p>题目</p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104140137568.png" alt="image-20230104140137568"></p><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104140155215.png" alt="image-20230104140155215"></p><h3 id="ip数据报的发送与转发过程">IP数据报的发送与转发过程</h3><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104143647626.png" alt="image-20230104143647626"></p><p>主机ip数据报发送流程:  首先通过路由表查找到目的地址应该走的路由,如果找不到,则会丢弃ip数据报,并且提示不可到达,如果找到了对应的路由信息,如果目的地址跟自己在同一个网络,则通过ARP协议直接找到目的地址的Mac地址,然后将帧发送给交换机,交换机根据Mac地址与接口的对应关系表,将帧转发给对应的接口,如果目的地址跟自己不在同一个网络,则需要通过ARP协议找到<strong>下一跳的Mac地址</strong>(而不是目的地址的Mac地址),然后通过交换机将这个数据报发送给它</p><p>路由器转发流程:  首先检查数据报首部是否出错,如果出错则丢弃数据报,然后通告源主机,如果没有出错,就根据目的地址在路由表中查找匹配的条目,如果找到匹配条目(<strong>将目的地址与路由表中的子网掩码做与,看是否符合路由表中的目的网络地址</strong>,<strong>如果有多个匹配的,则选择网络前缀最长的路由</strong>),则通过ARP协议找到Mac地址然后通过交换机发送帧给他,如果找不到就丢弃ip数据报并且告知源主机</p><p>为了防止ip数据报在路由环路中永久兜圈,在ip数据报首部设有生存时间TTL字段.ip数据报进入路由器后,TTL字段的值减一,若TTL的值大于0则被路由器转发,否则就丢弃</p><h3 id="路由选择">路由选择</h3><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230104154219706.png" alt="image-20230104154219706"></p><p>因特网采用的路由选择协议的主要特点:</p><ul><li>自适应: 动态路由选择,能够较好地适应网络状态的变化</li><li>分布式: 路由器之间交换路由信息</li><li>分层次: 将整个因特网分为许多较小的自治系统</li></ul><h3 id="路由器结构">路由器结构</h3><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230131151138307.png" alt="image-20230131151138307"></p><h3 id="路由信息协议rip">路由信息协议RIP</h3><blockquote><p>基于距离向量</p></blockquote><ul><li>路由器刚开始工作的时候,只知道自己到直连网络的距离为1</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息</li><li>若干次交换和更新后,每个路由器都知道到达本AS内各网络的最短距离和下一跳地址,称为收敛</li></ul><p>距离超过16代表不可达</p><h4 id="更新规则">更新规则</h4><p><img src="/2022/12/18/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20230131153652720.png" alt="image-20230131153652720"></p><h3 id="开放最短路径优先ospf">开放最短路径优先OSPF</h3><blockquote><p>基于链路状态</p></blockquote><p>链路状态是指本路由器都和哪些路由器相邻,以及相应链路的代价</p><p>思科路由器中OSPF计算代价方法:100Mbps/链路带宽</p><h2 id="传输层">传输层</h2><h2 id="应用层">应用层</h2><h4 id="协议">协议</h4><h5 id="ppp">ppp</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决帧的区分的问题,物理层可看不懂哪里是一帧一帧,它只知道这是个比特流,所以我们用协议规定,哪里是一帧</span><br></pre></td></tr></table></figure><h5 id="arp">ARP</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过ip找到mac地址</span><br></pre></td></tr></table></figure><p>交换机,会记录每个物理地址对应的接口,每一个主动发起数据的接口对应的物理地址才会被记录在表中,如果找不到目的物理地址,则会全端口转发</p><p>为了增加网络的可靠性,一般会使用冗余链路,但是冗余链路具有环状,会导致广播风暴,交换机的帧交换表震荡,这个时候可以使用生成树协议,交换机自动关闭某些端口,形成树状结构,这样就没有环路,当某一条链路不能够用的时候,又将重新计算,生成一个新的树状结构</p><p>因特网网络层用的就是数据报的方式</p><p>A类网络 拥有网段 126 个  每个网段可分配主机数量2^24 - 2 = 16777214</p><p>B类网络 拥有网段 16384 个 每个网段可分配主机数量2^16 -2 = 65534</p><p>C类网络 拥有网段 2097152 个  每个网段可分配主机数量 2^8 -2 = 254</p><p>D类网络 是广播地址 不区分网络号与主机号  以 1110 开头的都是</p><h3 id="局域网ip">局域网ip</h3><table><thead><tr><th style="text-align:center">网络类别</th><th style="text-align:center">IP 地址范围</th><th style="text-align:center">网络数</th><th style="text-align:center">可分配ip个数</th></tr></thead><tbody><tr><td style="text-align:center">A 类网</td><td style="text-align:center">10.0.0.0~10.255.255.255</td><td style="text-align:center">1</td><td style="text-align:center">2^24</td></tr><tr><td style="text-align:center">B 类网</td><td style="text-align:center">172.16.0.0~172.31.255.255</td><td style="text-align:center">16</td><td style="text-align:center">16*2^16</td></tr><tr><td style="text-align:center">C 类网</td><td style="text-align:center">192.168.0.0~192.168.255.255</td><td style="text-align:center">255</td><td style="text-align:center">255*2^8</td></tr></tbody></table><p>判断一个ip地址与自己是不是在同一网络下,只需要将ip与子网掩码做与运算,看得到的ip是否相同就行</p><p>路由器也成为默认网关</p><p>传输层的端口,是逻辑端口,只是为了区分服务而存在的…</p><p>几个概念:</p><p>​发送窗口:</p><p>​拥塞窗口:</p><p>​慢开始门限值:</p><p>tcp:</p><ul><li><p>滑动窗口: 发送端一开始发送几个连续的tcp报文,接收端每接收一个报文时,会向客户端发送确认报文,以及窗口大小,然后发送端根据窗口大小,跳整自己的发送窗口大小,如果接收端接收窗口为0,则停止发送,过一段时间后,会发送询问窗口大小的报文,如果还是0则重复这个操作,否则就发送tcp报文</p></li><li><p>拥塞控制算法:</p><p>慢开始算法: 每次拥塞窗口的值,都变成原来的两倍</p><p>拥塞避免算法: 每次拥塞窗口的值,只加一</p><p>快重传: 1.接收方接收到tcp报文时,立即发送确认报文  2. 接收方接收到失序的报文时,就要说明自己接收到了报文,要说明重复确认,以前的报文没收到. 3 接收方接收到了三次确认报文后,就要重发以前的报文,而不是等到重传时间到了再重传</p></li></ul><p>流量控制,拥塞控制,超时重传,(通过滑动窗口实现可靠传输)</p><p>三次握手的过程:   客户端主动发起请求  <strong>设置一个同步位 syn = 1(表示要建立连接),然后给定一个随机值seq=x</strong> 发送给服务器端,服务器接收到后 响应 同步为 <strong>syn = 1,ACK = 1 表明接收到了数据 然后也给定一个随机值 seq=y,并且还设置ack=x+1(接收序号数+1)</strong>,然后客户端再次发送数据过来,<strong>ACK=1,seq=x+1(发送序号数+1),ack = y+1 (序号数加+1)</strong>  (第三次握手并不是多余的,如果因为网络原因,第一次发送的请求数据报在网络中滞留,然后客户端又发起超时重传,然后服务器端开始与客户端正式开始三次握手,建立连接后,并且传输完数据,然后断开连接,这个时候 那个网络中滞留的数据包可能又到了,这个时候服务器端以为客户端又来了,如果我们使用两次握手,那么会直接进入连接,而客户端并没有连接,这个时候会浪费服务器资源)</p><p>四次挥手: 客户端主动发起断开连接 <strong>数据包内容为 FIN = 1(表明结束),ACK=1(表明收到上一个报文),seq=u(已发送的序号数+1),ack=v(已接收序号数+1)</strong>,服务器端收到后回传数据报内容  <strong>seq=v(已经发送的字节数+1 ,与客户端发来的ack一致),ack=u+1(因为已经多接受了客户端的上一个报文,所以是u+1)</strong>,这个时候,客户端向服务器端的发送的通道连接断开了,因为客户端已经没有数据要发了,但是服务器端可能还有数据要发给客户端,客户端还是要接收,并且回复确认, 服务器发送断开连接  <strong>FIN=1,ACK=1(表明这是断开连接报文),seq = w(这个中间,服务器可能又发了很多数据),ack=u+1(接收到客户端发送报文序号数)</strong>,客户端收到后,还需要发送确认报文(如果你不确认,那么服务器以为你没收到,会一直发送重传报文,等超过重传次数后,便会断开连接)  <strong>ACK=1 (确认收到),seq=u+1(已发送的序号数),ack=w+1(已经接受序号数+1)</strong>,至此服务器端断开连接,进入关闭状态,<strong>但是客户端还需要有个等待时间段(如果客户端的最后一个报文服务器端没有收到,那么服务器端会以为客户端没有收到,会发送超时重传,如果客户端直接关闭了,那么服务器就会一直重传到次数结束)</strong></p><p>c/s : 客户端与服务器端   客户发起请求服务,服务器为其提供服务</p><p>p2p: 没有客户端与服务器端一说,每个计算机既是请求者,也是服务者</p><p>DHCP:</p><p>客户端广播发起申请ip的请求,源ip为0.0.0.0,目的地址为255.255.255.255:68,dhcp监听68才能处理这个请求,然后分配ip,通过广播的方式</p><h2 id="额外补充">额外补充</h2><h2 id="自我思考">自我思考</h2>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词本</title>
      <link href="/2022/12/17/English/%E5%8D%95%E8%AF%8D%E6%9C%AC/"/>
      <url>/2022/12/17/English/%E5%8D%95%E8%AF%8D%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">word</th></tr></thead><tbody><tr><td style="text-align:center">ref</td></tr><tr><td style="text-align:center">stack</td></tr><tr><td style="text-align:center">dose</td></tr><tr><td style="text-align:center">notion</td></tr><tr><td style="text-align:center">formula</td></tr><tr><td style="text-align:center">bubble</td></tr><tr><td style="text-align:center">faculty</td></tr><tr><td style="text-align:center">harnerss</td></tr><tr><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络基础</title>
      <link href="/2022/12/12/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2022/12/12/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="文章一">文章一</h2><h3 id="基础知识">基础知识</h3><h4 id="向外发送一个数据包">向外发送一个数据包</h4><ul><li>查找目的地址的路由信息,如果是直连路由,则在邻居表中找到他的Mac地址,然后把数据包直接发给他</li><li>如果不是直连路由,则在邻居表中找默认路由的Mac地址,把数据包发给默认路由对应的设备</li><li>如果找不到路由信息,那么就是不可达</li><li>如果邻居表中找不到Mac地址,就发起ARP请求询问</li><li>发出去的数据帧,Mac地址一直在变,但是只要不经历nat(snat和dnat),那么ip地址是全程不会变的</li></ul><h4 id="接收到一个数据包">接收到一个数据包</h4><ul><li>如果数据帧的目标Mac地址不是自己的Mac地址,而且也不是广播Mac地址(ff:ff:ff:ff),且网卡没有开启混杂模式,则拒绝收包,混杂模式就是所有的帧我都接受</li><li>如果是目标地址是广播Mac地址,那就进入ARP请求处理</li><li>如果目标Mac地址就是自己的Mac地址,也要分几种情况讨论</li><li><ul><li>目标ip地址是本机,则上送到上一层协议继续处理</li><li>如果目标ip不在本机,如果开启了路由转发,则转发这个分组,否则就丢弃这个分组</li></ul></li></ul><p>对于一台linux主机来说，影响网络方面的配置主要有以下几个:</p><ul><li>网卡,网卡的配置,ip地址啊,是否开启,也可以虚拟出一张网卡</li><li>端口: 1-65535 所有进程共用</li><li>iptabels 规则,配置主机的防火墙策略和NAT规则</li><li>路由表</li><li>邻居表,就是跟主机在同一个交换机下的ip与Mac地址的对应关系表</li></ul><p>拥有一个网络隔离空间,就相当于拥有了一台新的主机,它的网络都是全新的</p><h3 id="pod与主机互通">pod与主机互通</h3><p>模拟一个pod出来</p><blockquote><p>主机ip为192.168.100.100</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个ns</span></span><br><span class="line">ip netns add ns1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看这个ns的网卡信息</span></span><br><span class="line">ip netns exec ns1 ip link show</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加两张互连的虚拟网卡</span></span><br><span class="line">ip link add ns1-eth0 type veth peer name veth-ns1 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将其中一张网卡插到ns1中</span></span><br><span class="line">ip link set ns1-eth0 netns ns1 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动ns1中的网卡</span></span><br><span class="line">ip netns exec ns1 ip link set ns1-eth0 up</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动留在主机中的网卡</span></span><br><span class="line">ip link set veth-ns1 up </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给ns1中的网卡添加ip地址</span></span><br><span class="line">ip netns exec ns1 ip addr add 172.20.1.10/24 dev ns1-eth0  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时还是无法ping通主机的,会显示网络不可达(找不到路由信息,就会出现不可达,验证了前面我们说的),因为我们还没有配置路由表,数据包不知道往哪里发送</span></span><br><span class="line">ip netns exec ns1 ping -c 3 192.168.100.100 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们需要配置ns1中的路由表,增加一条默认路由,这下就能找到路由信息了</span></span><br><span class="line">ip netns exec ns1 ip route add default via 172.20.1.1 dev ns1-eth0 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在去ping已经不是不可达了,而是一直等待,没有响应,这是为什么呢?,我们填的网关地址是不存在的,当然找不到他的物理地址,我们有两种方式,一种是给另一端的网卡(也就是我们的网关)设置这个ip地址,还有就是给另一端的网卡的ARP开启一切都应答,不管什么ip地址,我都答复)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一,给对端网卡这是ip</span></span><br><span class="line">ip addr add 172.20.1.1/24 dev veth-ns1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二,开启一切应答模式</span></span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth-ns1/proxy_arp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在查看邻居表中有没有对端网卡的Mac地址</span></span><br><span class="line">ip netns exec ns1 ip neigh </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果使用了方式一,那么直接就能ping通主机了,因为添加ip的时候,会自带添加一条路由信息,如果使用方式二,我们还得自己添加路由信息,不然主机不知道数据包往哪发送,我们得告诉主句,来自172.20.1.10的数据都忘veth-ns1这个网卡发送</span></span><br><span class="line">ip route add 172.20.1.10 dev veth-ns1</span><br></pre></td></tr></table></figure><h3 id="pod访问外网">pod访问外网</h3><p>如果pod需要访问外网,我们需要开启主机的转发功能,不然是无法访问外网的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>然后还要开启snat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A POSTROUTING -t nat -s 172.20.1.10 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>我们现在进入ns1 ping 百度就可以啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip netns exec ns1 ping -c 4  www.baidu.com</span><br><span class="line">PING www.baidu.com (198.18.0.74) 56(84) bytes of data.</span><br><span class="line">64 bytes from 198.18.0.74 (198.18.0.74): icmp_seq=1 ttl=127 time=0.452 ms</span><br><span class="line">64 bytes from 198.18.0.74 (198.18.0.74): icmp_seq=2 ttl=127 time=1.01 ms</span><br><span class="line">64 bytes from 198.18.0.74 (198.18.0.74): icmp_seq=3 ttl=127 time=0.788 ms</span><br><span class="line">^C</span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2003ms</span><br><span class="line">rtt min/avg/max/mdev = 0.452/0.750/1.012/0.232 ms</span><br></pre></td></tr></table></figure><h2 id="文章二">文章二</h2><h3 id="基础知识">基础知识</h3><h4 id="netfilter">netfilter</h4><p>linux的收发包是非常复杂的,为了让用户可以在收发包的过程中对数据包进行修改和过滤,linux引入了netfilter子系统,在收发包的过程中,添加了五个扩展点:</p><ul><li><p>NF_INET_PRE_ROUTING（PREROUTING,数据包刚到达的时候会经过这个点,<strong>主要用来做DNAT</strong></p></li><li><p>NF_INET_LOCAL_IN（INPUT） 数据要经过本机的传输层的时候会经过这个点,通常用于完成防火墙的入站检测</p></li><li><p>NF_INET_FORWARD（FORWARD） 数据包要经过本机转发的时候会经过这个点,通常用于防火墙的转发过滤</p></li><li><p>NF_INET_LOCAL_OUT（OUTPUT） 从本机发送的数据包都要经过这个点,通常用来做DNAT和防火墙出站检测</p></li><li><p>NF_INET_POST_ROUTING（POSTROUTING） 数据包离开本机的时候要经过的点,通常用来做<strong>SNAT</strong>,注意和上面这个OUTPUT的区别,output是从本机发送的数据,POSTROUTING还包括转发的数据包</p></li></ul><p>几个关键流程:</p><ul><li>主机应用程序发送数据到外部会经过的点:  OUTPUT-&gt;POSTROUTING</li><li>主机应用程序接受外部数据会经历的点: POSTROUTING-&gt;INPUT</li><li>主机上的其他pod(可以理解为其他虚拟机器)发送数据到外部,也就是转发数据: PREROUTING-&gt;FORWARD-&gt;POSTROUTING</li></ul><blockquote><p>pod虽然是主机的一个进程,但是在收发包的流程却和普通的进程大不相同,pod相当于一台虚拟主机</p></blockquote><h4 id="iptables">iptables</h4><p>虽然linux为我们预留了5个扩展点,但是扩展函数编写起来非常困难,我们可以通过iptables简化(但是我也觉得比较麻烦)</p><p><img src="/2022/12/12/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87/../img/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87assets/1620.jpeg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -t filter -s 192.168.1.10 -j DROP</span><br></pre></td></tr></table></figure><p>固定前缀参数</p><ul><li>-A 追加一条规则到后面</li><li>-I 前面插入一条规则,让它的优先级更高</li><li>-D 删除规则</li><li>-N 删除链</li><li>-F 清空所有规则或者链</li><li>-X 删除一条用户自定义链</li><li>-P 更改链的默认策略</li><li>-L 展示这条链的规则</li></ul><p>五条链(就是对应的五个拓展点):</p><ul><li>PREROUTING</li><li>INPUT</li><li>FORWORD</li><li>OUTPUT</li><li>POSTROUTING</li></ul><p>-t 后面表示要操作的表:</p><ul><li>filter 表  用于拦截或者放行,不修改包,如果不指定,模式是filter表</li><li>nat表 用于修改ip数据包的源/目地址</li><li>mangle表 主要用于给数据打标记</li></ul><p>数据包的匹配规则:</p><ul><li>-s 代表匹配源ip地址</li><li>–sport 代表匹配源端口</li><li>-dport 代表匹配目标端口</li><li>-p 代表匹配协议类型</li><li>-d 代表匹配目标地址</li></ul><p>-j 后面接动作:</p><ul><li>DROP 丢弃这个数据包</li><li>ACCEPT 接收这个数据包</li><li>RETURN 返回上一条数据链</li><li>SNAT 源地址转换 后面要跟 转换的地址</li><li>DNAT 目标地址转化,后面要跟指定的目标地址</li><li>MASQUERADE 对进入该链的包进行数据源地址转换,但是不需要指定源地址,会自动根据发送网卡的源地址作为转化源地址</li></ul><p>举几个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 增加一条规则: 将本机应用程序待发送到10.96.0.100 的包的目标地址变成10.244.3.10 ( OUTPUT 代表发送出去的数据包, -t表示要进行nat转化,-j代表DNAT转化)</span><br><span class="line">iptables -A OUTPUT -t nat -d 10.96.0.100 -j DNAT --to-destination 10.244.3.10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将来到本机的数据包的目标地址为10.96.0.100变成10.244.3.10</span><br><span class="line">iptables -A PREROUTING -t nat -d 10.96.0.100 -j DNAT --to-destination 10.244.3.10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将源地址是172.20.1.10 的数据包进行snat转化,并且自动选取网卡ip为源ip</span><br><span class="line">iptables -A POSTROUTING -t nat -s 172.20.1.10 -j MASQUERADE</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 本机应用接收来自192.168.8.166:80协议是tcp的数据包</span><br><span class="line">iptables -A INPUT -t filter -s 192.168.8.166 -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87/../img/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87assets/image-20221230154925783.png" alt="image-20221230154925783"></p><p>这个就是</p><h3 id="主机间的pod进行通信">主机间的pod进行通信</h3><p>创建pod-a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a  </span><br><span class="line">ip link set eth0 netns pod-a  </span><br><span class="line">ip link set veth-pod-a up </span><br><span class="line">ip netns exec pod-a ip addr add 10.244.1.10/24 dev eth0 </span><br><span class="line">ip netns exec pod-a ip link set eth0 up </span><br><span class="line"></span><br><span class="line">ip netns exec pod-a ip route add default via 169.254.10.24 dev eth0 onlink</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth-pod-a/proxy_arp</span><br><span class="line">ip route add 10.244.1.10 dev veth-pod-a</span><br></pre></td></tr></table></figure><p>创建pod-b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-b</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-b  </span><br><span class="line">ip link set eth0 netns pod-b  </span><br><span class="line">ip link set veth-pod-b up </span><br><span class="line">ip netns exec pod-b ip addr add 10.244.1.11/24 dev eth0 </span><br><span class="line">ip netns exec pod-b ip link set eth0 up </span><br><span class="line"></span><br><span class="line">ip netns exec pod-b ip route add default via 169.254.10.24 dev eth0 onlink</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth-pod-b/proxy_arp</span><br><span class="line">ip route add 10.244.1.11 dev veth-pod-b</span><br></pre></td></tr></table></figure><p>主机进行的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"># 这个代表允许转发源网络地址是10.244.1开头的目标地址是10.244开头的数据包</span><br><span class="line">iptables -I FORWARD -s 10.244.1.0/24 -d 10.244.1.0/24 -j ACCEPT </span><br></pre></td></tr></table></figure><p>测试能不能ping通</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a  ping 10.244.1.11 -c 3</span><br><span class="line">ip netns exec pod-b  ping 10.244.1.10 -c 3</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87/../img/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87assets/image-20221230162040636.png" alt="image-20221230162040636"></p><p>没问题的</p><h3 id="用iptables-模拟k8s的service">用iptables 模拟k8s的service</h3><p>其实我们只需要将service对应的ip做dnat转换,转换到对应的pod就OK了,用10.96.0.10 代替service的ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A PREROUTING -t nat -d 10.96.0.100 -j DNAT --to-destination 10.244.1.11</span><br><span class="line"># 将请求10.96.0.100的流量转发给pod-b就可以了</span><br></pre></td></tr></table></figure><h4 id="pod-a-ping-service">pod-a ping  service</h4><p>这个时候我们用pod-a ping 10.96.0.100那肯定是没问题的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a ping -c 5 10.96.0.100</span><br></pre></td></tr></table></figure><h4 id="主机ping-service">主机ping service</h4><p>我们这个时候用主机ping这个ip地址应该是不可以的,但是我的虚拟机不知道为啥就可以,很神奇,按照流程来说,我们应该要在output这个链上加上DNAT才行,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -t nat -d 10.96.0.100 -j DNAT --to-destination 10.244.1.11</span><br></pre></td></tr></table></figure><h4 id="pod-b-ping-service">pod-b ping service</h4><p>我们用pod-b 去ping service,这个能不能ping通呢? 答案是不可以哦,因为经过了DNAT转化后,pod-b发送的数据包的源ip和目的ip都是自己的ip地址了,一般连接外面的网卡默认都不会接收源ip是自己的数据包</p><p>查看开关情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b sysctl net.ipv4.conf.eth0.accept_local</span><br></pre></td></tr></table></figure><blockquote><p>ip netns exec pod-b sysctl -w net.ipv4.conf.eth0.accept_local=1 按理说我把这个值变成1是不是就行了,但是我测试后发现不行</p></blockquote><p>我们可以通过修改源ip地址的方式,做一次snat就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># iptables -d POSTROUTING -t nat -s 10.244.1.11 -j MASQUERADE  这种方式其实不太好,这是将所有源地址是10.244.1.11都变成本机ip了,这样有缺陷的,我们需要将源地址与目的地址都是10.244.1.11 做一次转化</span><br><span class="line">iptables -A POSTROUTING -t nat -d 10.244.1.11 -s 10.244.1.11 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>我们可以发现使用podip 和 clusterip 的区别就在与clusterip 仅仅多做了了一次地址转换在PREROUTING这条链上做了dnat转换,走的转发路径也都是一样的</p><h2 id="文章三">文章三</h2><h3 id="跨主机pod通信">跨主机pod通信</h3><p>准备两台结点</p><p>node1: 192.168.100.100</p><p>node2: 192.168.100.101</p><h4 id="node1创建pod-a-192-168-10-10">node1创建pod-a(192.168.10.10)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a</span><br><span class="line">ip link set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add 192.168.10.10/24 dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add default via 169.254.10.24 dev eth0 onlink</span><br><span class="line">ip link set veth-pod-a up</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth-pod-a/proxy_arp</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/16 -d 192.168.0.0/16 -j ACCEPT</span><br><span class="line">ip route add 192.168.10.10 dev veth-pod-a scope link</span><br></pre></td></tr></table></figure><h4 id="node2创建pod-b-192-168-11-10">node2创建pod-b(192.168.11.10)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-b</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-b</span><br><span class="line">ip link set eth0 netns pod-b</span><br><span class="line">ip netns exec pod-b ip addr add 192.168.11.10/24 dev eth0</span><br><span class="line">ip netns exec pod-b ip link set eth0 up</span><br><span class="line">ip netns exec pod-b ip route add default via 169.254.10.24 dev eth0 onlink</span><br><span class="line">ip link set veth-pod-b up</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth-pod-b/proxy_arp</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables -I FORWARD -s 192.168.0.0/16 -d 192.168.0.0/16 -j ACCEPT</span><br><span class="line">ip route add 192.168.11.10 dev veth-pod-b scope link</span><br></pre></td></tr></table></figure><p>此时pod与各自主机是能够ping 通的, 但是pod与pod之间还是无法ping通的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add 192.168.11.0/24 via 192.168.100.101 dev ens33 onlink </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add 192.168.10.0/24 via 192.168.100.100 dev ens onlink </span><br></pre></td></tr></table></figure><p>我们可以在主机一种的pod-a中开一个服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a nohup socat TCP4-LISTEN:80,fork exec:cat 2&gt;&amp;1 &amp;   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go总结</title>
      <link href="/2022/12/09/go/go/"/>
      <url>/2022/12/09/go/go/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建">环境搭建</h2><p>Go设置国内镜像源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,direct</span></span><br></pre></td></tr></table></figure><h2 id="基础教程">基础教程</h2><p>go.mod 是用来管理我们引入模块的信息,里面记录了我们当前模块的模块名,以及需要的模块的信息</p><p>go mod init 名字  用来创建一个模块</p><p>go mod tydy 加载模块(本地,或者远程)</p><p>init 函数会最先执行,早于main函数</p><p>go中**{**不能单独一行</p><p>一行代表一个语句结束,如果要多个语句写一起,就必须使用;分隔,但是并不推荐这样做</p><h3 id="数据类型">数据类型</h3><p>注意一下不同的数据类型就行了</p><ul><li><em>int   这个和c语言不同哦,c语言是int</em> ,不过使用起来是一样的,只是声明的时候不同</li><li>函数类型 声明的时候,是可以直接用变量接收一个函数的哦</li></ul><h3 id="变量声明方式">变量声明方式</h3><p>方式1  var 名字1,名字2 … type (没有赋值,默认值代替)</p><p>方式二 var 名字1,名字2 类型 = 值1,值2  (值类型必须一致</p><p>方式三 var 名字 1,名字2= 值1,值2  (根据类型推断)</p><p>方式四(局部变量才可以用) 名字1,名字2:=值  相当于  var 名字1 type,var 名字2 type   名字1 = 值1 名字2 = 值2   (这么写方便啊,少写很多东西,哈哈哈哈)  这种方式只能用在函数内部,全局是不可以的,因为函数外面的全局只能写声明然后直接赋值,而不能声明后,再单独写个语句赋值</p><p>方式五</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var(</span><br><span class="line">a,b</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>比如说</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//可行</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span>;</span><br><span class="line">b = <span class="number">10</span>  <span class="comment">//不可行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 语言中如果声明变量而不使用的话,则会报错,我们可以使用 _ = 变量 , 消除这个报错, _ 是一个只写变量,而不能读它, 有人就说了,这不是搞笑么,我不声明不就行了嘛, 可是有时候,你不得不声明,比如一个函数可以返回多个值,你只想要其中某一部分的值,但是那些不要的值你也得接收啊,所有_就派上用场了(全局变量可以只声明而不使用哦)</p><h3 id="常量声明方式">常量声明方式</h3><p>方式一  const name1,name2 =val1,val2   (必须为每个变量赋值)</p><p>方式二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 这种方式的话 如果不赋值,默认跟前一个&quot;赋值方式一样&quot;所有第一个必须赋值</span></span><br><span class="line"><span class="comment">// iota 特殊常量</span></span><br><span class="line"><span class="comment">// 在这种常量赋值的方法中,iota会被赋值为0,每增加一个常量,iota的值就加一,我们是不能自己去修改的哦</span></span><br></pre></td></tr></table></figure><p>常量可以只声明而不使用的哦</p><h3 id="运算符">运算符</h3><p>go的运算符跟c++ 差不多,就简单说点不同的地方</p><blockquote><p>go  不支持 三目运算符哦</p></blockquote><p>go 提倡的是 一个语句占一行,像 a++ 这种已经就是一个语句了,所以我们这种写法会报错  sum += a++  这个相当于两条语句,所有go是不允许的</p><h3 id="流程控制语句">流程控制语句</h3><h4 id="if">if</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> ( 逻辑表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> 逻辑表达式&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="swtich">swtich</h4><p>这个与c语言还是有点区别的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要进入了case的分支,就不会再进入其他case分支了(这里是与c语言不同的),不过可以通过fallthrough 强制执行后面分支</span></span><br><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for">for</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//与c语言的一样但是不能加()</span><br><span class="line">for a:=1;a&lt;=10;a++&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//与c的while差不多</span><br><span class="line">a := true</span><br><span class="line">for a&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 与c的for(;;)一样</span><br><span class="line">for&#123;&#125;</span><br><span class="line">// 与 c++的for(int i : num) 差不多</span><br><span class="line">for k,v = range map</span><br></pre></td></tr></table></figure><p>go 里面没有while语句哦,for可以替代它的</p><h3 id="函数">函数</h3><p>这个基本是所有语言都有的,只不过格式不同罢了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcname</span> <span class="params">(parameter list)</span></span> return_types &#123;&#125;</span><br></pre></td></tr></table></figure><p>go的函数可以返回多个值,每个值的类型都必须声明好</p><p>这个参数是可以传递函数的哦,其实也没什么奇怪得啦,c语言里面传递函数是通过指针传递,用起来比较麻烦,但是go里面可以直接传递</p><h4 id="闭包">闭包</h4><p>go里面的函数还可以闭包哦,就是一个函数的返回值也是一个函数,闭包的优势就在与,返回来的函数直接使用产生它的函数的变量,举个列子</p><p>求素数的列子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPrimeFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">j := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; j &lt;= i/j; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%j == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt; i/j &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> getPrime = getPrimeFunc()</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用闭包,我们可以使的逻辑变的清晰,</p><h4 id="方法">方法</h4><p>方法与函数的声明有点区别,前面加了接受者类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (variable_name variable_data_type) funcname(paremeter list) (return_type)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="变量作用域">变量作用域</h3><ul><li>函数类定义的是局部变量,只能在函数内使用,所谓的函数内是指当前函数,以及这个函数产生的匿名函数也能够使用</li><li>函数外定义的是全局函数</li><li>函数定义中的变量是形参变量</li></ul><h3 id="数组">数组</h3><p>定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">10</span>] <span class="type">int</span>  <span class="comment">//一维 </span></span><br><span class="line"><span class="keyword">var</span> nums [<span class="number">10</span>][<span class="number">10</span>] <span class="type">int</span> <span class="comment">//二维  go的二维数组跟java很类似,第二维可以长度不一样,c++不行</span></span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">10</span>] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//定义的时候初始化</span></span><br><span class="line"><span class="keyword">var</span> nums = [...] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">//自动推断数组长度</span></span><br><span class="line">nums := [<span class="number">10</span>] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//这种就自然不用说了</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//定义完后赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go的数组跟java的很像,就是一个引用类型罢了,不过需要注意的是,java数组的引用是不需要长度一样的,而go是严格要求引用长度得一样</span></span><br><span class="line">nums := [<span class="number">10</span>] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">nums = [<span class="number">10</span>] <span class="type">int</span> &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; <span class="comment">//ok</span></span><br><span class="line">nums = [<span class="number">3</span>] <span class="type">int</span> &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; <span class="comment">// no</span></span><br></pre></td></tr></table></figure><h3 id="指针">指针</h3><p>看到这个我就不陌生了,c和c++里面再熟悉不过了</p><p>定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point *<span class="type">int</span></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">point = &amp;a</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">*point</span><br></pre></td></tr></table></figure><p>go里面的空指针是nil,地址值就是0</p><h3 id="结构体">结构体</h3><p>回来了,都回来了,大一学的C语言和c++,后面被迫转java,java是很好,但是我觉得还是有点笨重,当然他的出现也是为了解决问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span>&#123;</span><br><span class="line">age <span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个传入参数也是值类型哦,不是引用类型,和c++是一样的,主要跟java的区别</p><h3 id="range关键字">Range关键字</h3><p>用于 for 循环中迭代数组,切片,通道,集合中的元素,并以k-v的方式返回</p><h3 id="数据结构">数据结构</h3><p>让我们来感受一下go提供的数据结构吧</p><h4 id="切片">切片</h4><p>哎呦我去,这不就是java的list,c++的vector,python里面的切片么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//注意跟数组定义的区别哦,中括号里面是没有东西的哦</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>) <span class="comment">//或者这样哦</span></span><br></pre></td></tr></table></figure><p>切片是可以动态增长的哦,不像数组.既然叫切片,那让我们来看看它怎么切吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// len 是数组的长度</span></span><br><span class="line">s := arr[:] <span class="comment">//切片是整个数组[0,len)</span></span><br><span class="line">s := arr[start:] <span class="comment">//从start到整个数组后面 [start,len)</span></span><br><span class="line">s := arr[:end] <span class="comment">//从0到end-1 [0,end)</span></span><br></pre></td></tr></table></figure><h5 id="切片常用函数">切片常用函数</h5><p>len() 计算当前数据长度,cap() 计算最大可达长度</p><p>append(slice,val) 向切片追加数据 ,copy(destnation,src) 复制一个切片到另一个切片</p><p>make(slicetype,len,cap)  定义一个切片当前大小为len,总容量为cap的切片</p><h3 id="map">map</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinking in java</title>
      <link href="/2022/12/03/java/thinking%20in%20java/"/>
      <url>/2022/12/03/java/thinking%20in%20java/</url>
      
        <content type="html"><![CDATA[<h1>第一章 对象入门</h1><p>拟出一个计划</p><p>首先我们应该要明白我们的程序需要做什么,而不是考虑程序要怎么做,我们应该将重心放到这一阶段的核心问题上,不要纠结与一些细枝末节,同时也不要过分在意系统的**“完美”**,否则容易产生挫败感和焦虑情绪</p><p>对自己的系统做一些**“名词&quot;<strong>和</strong>&quot;动词”**的描述,名词成为自然对象,动词成为对象接口中的方法</p><p>根据自己的经验与直觉,对一个项目进行日程估计,然后在这个时间上再加上百分之十,如果按时完成了,那么这个百分之十的时间,可以用来完善项目</p><p><strong>java的包名命名规范一般是域名倒着来,首先,我们是想包名唯一,正好域名是唯一的,但是域名后两个是固定的,前面又可以随便变化,所以域名符合要求</strong>,而且我们为了方便管理,还要把域名倒过来才行,假如我有个域名 <a href="http://djm.com">djm.com</a>  那么 <a href="http://ww.djm.com">ww.djm.com</a>,<a href="http://abc.djm.com">abc.djm.com</a>  不都是我的子域名么,如果正着来,不好管理啊,反着来,前面都一样,好管理</p><p>@Override 是重写  发生在子父类之间(同名,同参数,而且子类访问权限不能小于父亲,子类异常也要是父类的异常的子类)</p><p>@Overload 是重载  发生在本类中(同名,不同参数)</p><h1>第二章 一切都是对象</h1><p>堆里面存放对象句柄,也就是对象的内存地址, 而堆里面存放对象</p><h2 id="堆和栈">堆和栈</h2><p>在 Java 中，堆（Heap）和栈（Stack）是两种不同的内存区域，它们在内存分配和数据存储方面有着本质的区别。下面是它们之间的一些主要差异：</p><ol><li><p>存储内容：<br>堆：主要存储对象实例和数组。<br>栈：主要存储基本类型变量（如 int、float、boolean 等）及对象引用变量。</p></li><li><p>内存分配：<br>堆：<strong>在运行时动态分配内存</strong>，根据需要申请和释放内存空间。内存分配速度相对较慢。<br>栈：<strong>在编译时静态分配内存</strong>，随着方法的调用和返回而自动分配和释放内存空间。内存分配速度较快。</p></li><li><p>生命周期：<br>堆：堆中的对象实例的生命周期取决于垃圾回收器。当对象不再被引用时，垃圾回收器会自动回收其占用的内存。<br>栈：栈中的数据的生命周期与方法调用和返回的生命周期相对应。当方法返回时，其栈帧（包含局部变量和引用变量）会自动销毁。</p></li><li><p>访问速度：<br>堆：相对较慢，因为堆是在运行时动态分配内存。<br>栈：相对较快，因为栈是在编译时静态分配内存。</p></li><li><p>内存管理：<br>堆：由垃圾回收器负责管理内存，对于不再使用的对象实例进行回收。<br>栈：内存管理相对简单，随着方法的调用和返回自动分配和释放内存空间。</p></li><li><p>容量大小：<br>堆：堆的容量通常比栈大得多，因为它需要存储所有创建的对象实例和数组。<br>栈：栈的容量相对较小，通常只存储局部变量和引用变量。</p></li></ol><p>总之，堆和栈在 Java 中扮演着不同的角色，它们各自负责存储不同类型的数据和管理内存。了解它们的区别有助于编写更高效、更可靠的 Java 程序。</p><blockquote><p>堆就是堆,而不是树,我总是将堆跟树联系起来</p></blockquote><h2 id="基本数据类型">基本数据类型</h2><p>Java 中有 8 种基本数据类型，它们的大小如下：</p><ol><li>byte（字节）：占用 8 位（1 字节），取值范围为 -128 到 127。</li><li>short（短整型）：占用 16 位（2 字节），取值范围为 -32,768 到 32,767。</li><li>int（整型）：占用 32 位（4 字节），取值范围为 -2,147,483,648 到 2,147,483,647。</li><li>long（长整型）：占用 64 位（8 字节），取值范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</li><li>float（单精度浮点型）：占用 32 位（4 字节），取值范围约为 -3.4e38 到 3.4e38，精度约为 7 位小数。</li><li>double（双精度浮点型）：占用 64 位（8 字节），取值范围约为 -1.8e308 到 1.8e308，精度约为 16 位小数。</li><li>char（字符型）：占用 16 位（2 字节），取值范围为 0 到 65,535，用于表示 Unicode 字符。</li><li>boolean（布尔型）：占用的位数在不同的 Java 虚拟机实现中可能不同，通常为 8 位（1 字节）或 32 位（4 字节），只有两个取值：true 和 false。</li></ol><p>这些基本数据类型直接存储在栈内存中，它们不是对象，因此不需要通过引用访问。在 Java 中，基本数据类型的大小是固定的，不会因为操作系统或硬件平台的不同而发生变化。</p><h2 id="内存泄漏的情况">内存泄漏的情况</h2><p>在 Java 中，内存泄漏是指一些不再需要的对象占用的内存无法被<strong>垃圾回收器回收，导致内存资源无法释放</strong>。以下是一些可能导致内存泄漏的常见情况：</p><ol><li><p><strong>长生命周期对象持有短生命周期对象的引用</strong>：如果一个长生命周期的对象（例如静态变量、单例对象）持有一个短生命周期对象的引用，即使短生命周期对象不再使用，垃圾回收器也无法回收它，因为仍然存在对它的引用。</p></li><li><p>集合类对象：集合类（如 ArrayList、HashMap 等）可能会导致内存泄漏，特别是在长生命周期对象中。如果不及时清理集合中不再使用的对象，它们会一直占用内存。</p></li><li><p>监听器和回调：当一个对象注册为另一个对象的监听器或回调时，它可能会导致内存泄漏。如果在不再需要监听或回调时没有取消注册，这些对象将继续存在并占用内存。</p></li><li><p>内部类和外部类之间的引用：非静态内部类会隐式持有一个对其外部类的引用。如果外部类的生命周期比内部类长，且内部类对象长时间存在，可能会导致内存泄漏。可以考虑将内部类更改为静态内部类以避免此问题。</p></li><li><p>资源未关闭：在 Java 应用中，使用到的一些资源（如文件流、数据库连接等）需要在使用完毕后显式关闭。如果没有正确关闭这些资源，它们可能会导致内存泄漏。</p></li><li><p>线程泄漏：线程本身也会占用内存资源，特别是线程的栈内存。如果线程没有正确终止，可能导致内存泄漏。线程池的不当使用也可能导致线程泄漏，因此要确保合理配置线程池，并在任务完成后正确释放线程。</p></li></ol><p>要避免内存泄漏，需要密切关注程序中的对象引用、资源管理和线程管理等方面。在开发过程中，可以使用一些内存分析工具（如 VisualVM、MAT 等）来检测和分析内存泄漏。</p><p>java只会为<strong>类的属性自动初始化(基本数据类型有其默认值,对象为空),而不会为局部变量进行初始化</strong>,因此局部变量如果没有初始化,便会报错,这里是跟c++的区别,这种思想也合理吧,局部变量你不初始化说明你压根用不着,又何必定义,但是也不太合理,如果我是在一个条件里面初始化,那么外界又拿不到,外界初始化的话就得给一个值先冒充着</p><h2 id="总结">总结</h2><p>本章的话大致讲了一些基础东西,比如栈,堆,类的基本定义啊,文档注释这些</p><h1>第三章 控制程序流程</h1><blockquote><p>就象任何有感知的生物一样，程序必须能操纵自己的世界，在执行过程中作出判断与选择。</p></blockquote><h2 id="运算符">运算符</h2><p>Java 中有许多运算符，可以根据功能和优先级分为以下类别：</p><ol><li><p>后缀运算符：</p><ul><li><code>expr++</code>：后缀递增</li><li><code>expr--</code>：后缀递减</li></ul></li><li><p>一元运算符：</p><ul><li><code>++expr</code>：前缀递增</li><li><code>--expr</code>：前缀递减</li><li><code>+expr</code>：正号</li><li><code>-expr</code>：负号</li><li><code>!expr</code>：逻辑非（布尔取反）</li><li><code>~expr</code>：按位非（按位取反）</li></ul></li><li><p>类型转换运算符：</p><ul><li><code>(type) expr</code>：类型转换（强制类型转换）</li></ul></li><li><p>算术运算符：</p><ul><li><code>*</code>：乘法</li><li><code>/</code>：除法</li><li><code>%</code>：取模（求余数）</li><li><code>+</code>：加法</li><li><code>-</code>：减法</li></ul></li><li><p>移位运算符：</p><ul><li><code>&lt;&lt;</code>：左移</li><li><code>&gt;&gt;</code>：右移（带符号）</li><li><code>&gt;&gt;&gt;</code>：无符号右移</li></ul></li><li><p>关系运算符：</p><ul><li><code>&lt;</code>：小于</li><li><code>&lt;=</code>：小于等于</li><li><code>&gt;</code>：大于</li><li><code>&gt;=</code>：大于等于</li><li><code>instanceof</code>：类型检查</li></ul></li><li><p>相等运算符：</p><ul><li><code>==</code>：相等</li><li><code>!=</code>：不等</li></ul></li><li><p>位运算符：</p><ul><li><code>&amp;</code>：按位与</li><li><code>^</code>：按位异或</li><li><code>|</code>：按位或</li></ul></li><li><p>短路逻辑运算符：</p><ul><li><code>&amp;&amp;</code>：逻辑与（短路）</li><li><code>||</code>：逻辑或（短路）</li></ul></li><li><p>条件运算符（三元运算符）：</p><ul><li><code>expr1 ? expr2 : expr3</code>：条件表达式</li></ul></li><li><p>赋值运算符：</p><ul><li><code>=</code>：赋值</li><li><code>+=</code>：加法赋值</li><li><code>-=</code>：减法赋值</li><li><code>*=</code>：乘法赋值</li><li><code>/=</code>：除法赋值</li><li><code>%=</code>：取模赋值</li><li><code>&lt;&lt;=</code>：左移赋值</li><li><code>&gt;&gt;=</code>：右移赋值</li><li><code>&gt;&gt;&gt;=</code>：无符号右移赋值</li><li><code>&amp;=</code>：按位与赋值</li><li><code>^=</code>：按位异或赋值</li><li><code>|=</code>：按位或赋值</li></ul></li></ol><p>运算符优先级（从高到低）：</p><ol><li>后缀运算符</li><li>一元运算符</li><li>类型转换运算符</li><li>算术运算符（<code>*</code>、<code>/</code>、<code>%</code> 优先于 <code>+</code>、<code>-</code>）</li><li>移位运算符</li><li>关系运算符</li><li>相等运算符</li><li>位运算符（<code>&amp;</code> 优先于 <code>^</code>,^<code>优先于</code>|)</li><li><code>短路逻辑运算符（</code>&amp;&amp;<code>优先于</code>||`）</li><li>条件运算符（三元运算符）</li><li>赋值运算符</li></ol><p>请注意，在表达式中使用多个运算符时，优先级相同的运算符将根据其结合性从左到右（或从右到左）进行求值。大多数运算符（如算术、关系、位运算等）具有从左到右的结合性，而一元运算符、赋值运算符和条件运算符则具有从右到左的结合性。</p><p>为了提高代码的可读性和可维护性，建议使用括号明确地指定运算符的优先级，而不是仅依赖于运算符的默认优先级。这可以帮助避免因误解优先级而导致的错误。</p><h2 id="java-为什么没有sizeof">java 为什么没有sizeof ?</h2><p>因为他不需要,c++和c有sizeof 是因为在不同的平台里面,有些数据类型的大小是不一样的,new 数据的时候就得通过sizeof去控制</p><h2 id="流程控制">流程控制</h2><p>Java 中的流程控制结构可以分为三大类：顺序结构、分支结构和循环结构</p><h3 id="顺序结构">顺序结构</h3><p>顺序结构中的代码会按照它们在源文件中的顺序自上而下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">statement1;</span><br><span class="line">statement2;</span><br><span class="line">statement3;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="分支结构">分支结构</h3><h4 id="if-语句">if 语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 当条件为真时执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if-else 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 当条件为真时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当条件为假时执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if-else if-else 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// 当条件1为真时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// 当条件1为假，且条件2为真时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当所有条件均为假时执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch-语句">switch 语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 当 expression 等于 value1 时执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 当 expression 等于 value2 时执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 当 expression 与所有 case 值都不匹配时执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>expression</code>：用于与 <code>case</code> 语句中的值进行比较的表达式。在 Java 7 之前，该表达式只能是整型（byte、short、char、int）或枚举类型；从 Java 7 开始，还可以是字符串类型。</li><li><code>case</code>：定义了一个与 <code>expression</code> 进行比较的值,这个值必须与expression的返回值类型相同。如果 <code>expression</code> 等于 <code>case</code> 后的值，那么将执行该 <code>case</code> 语句下的代码块。</li><li><code>break</code>：用于跳出 <code>switch</code> 语句。如果不使用 <code>break</code>，则代码将继续执行下一个 <code>case</code> 语句，直到遇到 <code>break</code> 或 <code>switch</code> 结构结束。</li><li><code>default</code>：当 <code>expression</code> 与所有 <code>case</code> 值都不匹配时执行的代码块。<code>default</code> 语句是可选的，可以省略。</li></ul><p>注意点</p><ol><li>唯一的 case 值：确保每个 <code>case</code> 语句的值都是唯一的，以避免产生歧义。具有相同值的多个 <code>case</code> 语句会导致编译错误。</li></ol><h3 id="循环结构">循环结构</h3><ul><li>for 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; update) &#123;</span><br><span class="line">    <span class="comment">// 当条件为真时执行的代码块，每次迭代后执行更新操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 当条件为真时执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>do-while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 代码块至少执行一次，然后在条件为真时继续执行</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><p>请注意，这些格式只是通用模板。在实际编程中，您可能需要根据具体需求对这些结构进行适当的修改。同时，为了提高代码的可读性，建议在复杂的逻辑中使用括号和适当的缩进。</p><blockquote><p>对于condition,必须是bool表达式</p></blockquote><h2 id="总结">总结</h2><p>本小结主要讲述了java中的运算符,计算,类型转换,还有流程控制,中规中矩</p><h1>第四章 初始化与清除</h1><h2 id="初始化">初始化</h2><h3 id="类的初始化">类的初始化</h3><p>类的初始化是指在类首次加载到 JVM（Java 虚拟机）时执行的过程。类的初始化主要包括静态变量的赋值和静态代码块的执行。这些操作仅在类加载时执行一次。类初始化如下：</p><ul><li>静态变量赋值：按照它们在类中出现的顺序为静态变量分配内存并赋初值。</li><li>静态代码块执行：按照它们在类中出现的顺序执行静态代码块。</li></ul><blockquote><p>会按照static关键字的定义顺序来依次执行,静态变量和静态代码块的初始化顺序取决于它们在类中的出现顺序。为了避免在静态代码块中访问尚未初始化的静态变量，确保在静态代码块之前对静态变量进行初始化。</p></blockquote><h3 id="对象初始化">对象初始化</h3><p>对象的初始化是指创建对象实例并为实例变量分配内存和初始值的过程。对象初始化如下：</p><ul><li>分配内存：为对象分配内存空间。</li><li>实例变量赋值：按照它们在类中出现的顺序为实例变量分配内存并赋初值。</li><li>实例初始化块执行：按照它们在类中出现的顺序执行实例初始化块。</li><li>构造函数执行：调用相应的构造函数以进一步初始化对象。</li></ul><blockquote><p>同理,实例变量和实例代码块的初始化顺序取决于它们在类中的出现顺序</p></blockquote><p>综上所述，类的初始化和对象的初始化是 Java 中创建和使用对象的两个关键步骤。类的初始化负责静态变量的赋值和静态代码块的执行，而对象的初始化则涉及实例变量的赋值、实例初始化块的执行和构造函数的调用。类的初始化只在类加载时执行一次，而对象的初始化在每次创建新对象时执行。</p><h2 id="资源问题">资源问题</h2><p>如果程序结束了,那么它占用的资源都会归还给操作系统,比如你打开一个文件流,忘记关闭了,程序结束后,还是会归回给操作系统,不过这样并不是一个好习惯,如果我们的程序是要一直执行的,那么这样会浪费系统资源., 但是即使是一次执行的程序,不关闭文件也会存在一些潜在问题:</p><ol><li><p>文件锁定：在程序运行期间，如果文件没有被正确关闭，其他程序可能无法访问或修改该文件。这可能导致数据不一致或协同工作问题。</p></li><li><p>程序行为不稳定：当打开的文件数量达到系统允许的最大值时，操作系统可能会拒绝打开新文件。这可能导致程序行为不稳定，甚至崩溃。</p></li><li><p>不良编程习惯：不养成正确关闭资源的习惯可能导致在其他项目或长时间运行的程序中出现问题。遵循最佳实践，始终确保在使用完资源后正确关闭它们。</p></li></ol><p>因此，尽管在一次性执行的程序中，未关闭的文件流可能不会导致长期问题，但仍然建议采用诸如 try-with-resources 语句等方法来确保文件流在使用完毕后被正确关闭。这有助于避免潜在问题，提高代码质量和可维护性。</p><h2 id="总结">总结</h2><p>这章主要讲了一些类的初始化,垃圾回收器,方法重载的东西</p><h1>第五章 隐藏实施过程</h1><ul><li><p><strong>进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开</strong></p></li><li><p><strong>创建自己的包时，要求 package 语句必须是文件中的第一个“非注释”代码</strong></p></li><li><p><strong>编译器遇到 import 语句后，它会搜索由CLASSPATH 指定的目录,然后查找名称适当的已编译文件(.class文件)</strong></p></li><li><p><strong>为导入的类首次创建一个对象时（或者访问一个类的static 成员时）</strong>，编译器会在适当的目录里寻找同名的.class 文件（所以如果创建类 X 的一个对象，就应该是 X.class）。若只发现X.class，它就是必须使用的那一个类。然而，如果它在相同的目录中还发现了一个 X.java，编译器就会比较两个文件的日期标记。如果X.java 比X.class 新，<strong>就会自动编译 X.java，生成一个最新的 X.class。</strong></p></li></ul><h2 id="访问修饰符">访问修饰符</h2><p>Java 中有四种访问修饰符，用于限制类、方法、变量和内部类的可见性和访问范围。它们是：public, private, protected 和默认（即不使用任何修饰符，有时也称为“包私有”或“默认访问”）。</p><ol><li><p>public：</p><ul><li>描述：被 public 修饰的<strong>类、方法或变量</strong>可以在任何地方被访问。</li><li>类：public 类可以被任何其他类访问。</li><li>方法和变量：public 方法和变量可以被该类的所有对象和任何其他类访问。</li><li>内部类：public 内部类可以在任何地方被访问。</li></ul></li><li><p>private：</p><ul><li>描述：被 private 修饰的<strong>方法或变量</strong>只能在声明它们的类中被访问。</li><li>类：<strong>private 不能修饰顶级类，但可以修饰内部类</strong>。</li><li>方法和变量：private 方法和变量只能在声明它们的类中被访问，不能在该类的子类或其他类中访问。</li><li>内部类：private 内部类只能在声明它的类中被访问。</li></ul></li><li><p>protected：</p><ul><li>描述：被 protected 修饰的方法或变量可以在声明它们的类中、该类的子类以及同一包中的其他类中被访问。</li><li>类：<strong>protected 不能修饰顶级类，但可以修饰内部类。</strong></li><li>方法和变量：protected 方法和变量可以在声明它们的类中、该类的子类以及同一包中的其他类中被访问。</li><li>内部类：protected 内部类可以在声明它的类中、该类的子类以及同一包中的其他类中被访问。</li></ul></li><li><p>默认（包私有）：</p><ul><li>描述：不使用任何访问修饰符的<strong>类、方法或变量</strong>只能在同一包中被访问。</li><li>类：默认访问的类只能在同一包中的其他类访问。</li><li>方法和变量：默认访问的方法和变量可以在声明它们的类中以及同一包中的其他类中被访问。</li><li>内部类：<strong>默认访问的内部类可以在声明它的类中以及同一包中的其他类中被访问</strong>。</li></ul></li></ol><p>总结：</p><ul><li>public：最开放的访问级别，可以在任何地方被访问。</li><li>private：最严格的访问级别，只能在声明它的类中访问。</li><li>protected：可以在声明它的类中、该类的子类以及同一包中的其他类中访问。</li><li>默认（包私有）：只能在同一包中的类访问。</li></ul><blockquote><p>private &gt; 默认 &gt; protected &gt; public</p></blockquote><p>选择适当的访问修饰符有助于保护数据和保护数据和实现封装。通过限制对类、方法和变量的访问，可以确保它们的正确使用，并防止意外修改或错误的操作。</p><p>在实际编程中，通常遵循以下原则：</p><ol><li><p>最小权限原则：总是尽量使用最严格的访问修饰符。这有助于保护数据和实现封装，确保类的内部实现不会被外部错误地访问或修改。例如，如果一个变量只在类内部使用，那么将其声明为 private。</p></li><li><p>面向接口编程：对外暴露接口，隐藏实现细节。通过使用 public 访问修饰符为类提供公共接口，<strong>同时将内部实现细节封装在 private 和 protected 成员中</strong>。</p></li><li><p>适当使用包和模块：通过将相关的类组织在同一个包或模块中，可以使用默认（包私有）访问修饰符来限制它们的可见性范围。这可以使代码结构更加清晰，并减少错误的可能性。</p></li><li><p>保护继承：对于需要子类访问的成员，可以使用 protected 访问修饰符。这允许子类访问和重写这些成员，同时仍然限制其他类的访问。</p></li></ol><p>总之，合理地使用访问修饰符有助于保护数据和实现封装，确保类的正确使用和扩展。要充分理解每种访问修饰符的特点，并在实际编程中灵活运用。</p><blockquote></blockquote><h2 id="总结">总结</h2><p>本章主要讲了包和访问修饰符(public protected default private)</p><h1>第六章 类的派生</h1><h2 id="继承">继承</h2><p>好的，让我们详细了解一下Java中的类继承。</p><ol><li><p>继承的概念<br>继承是面向对象编程中的一个核心概念，它允许一个类从另一个类继承属性和方法。继承的主要目的是实现代码的复用和扩展。在Java中，继承使用关键字 <code>extends</code> 表示。</p></li><li><p>基类（父类）与子类</p><ul><li>父类（也称为基类或超类）：被其他类继承的类。父类包含的属性和方法可以被子类继承。</li><li>子类：从父类继承属性和方法的类。子类可以扩展和修改从父类继承的属性和方法。</li></ul></li><li><p>继承的语法<br>子类使用关键字 <code>extends</code> 继承父类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 父类的属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问控制与继承</p><ul><li><strong>private成员（属性和方法）不能被子类直接访问。</strong></li><li><strong>默认访问权限（没有访问修饰符）的成员可以被同一个包中的子类访问。</strong></li><li>protected成员可以被同一个包中的子类以及不同包中的子类访问。</li><li>public成员可以被任何地方的子类访问。</li></ul></li><li><p>方法重写（覆盖）<br>子类可以重写从父类继承的方法，以提供新的实现。重写方法的要求：</p><ul><li>方法名、参数列表和返回类型必须与父类方法相同。</li><li>访问修饰符不能比父类方法更严格。</li><li>重写方法不能抛出比父类方法更多的受检异常。</li></ul></li><li><p>super关键字<br>子类可以使用super关键字引用父类的成员（属性和方法）。</p><ul><li>super调用父类的构造方法：<code>super()</code> 必须是子类构造方法中的第一个语句。</li><li>super访问父类的属性：<code>super.attribute</code></li><li>super调用父类的方法：<code>super.method()</code></li></ul></li><li><p>final关键字与继承</p><ul><li>如果一个类用final修饰，那么它不能被继承。例如：<code>final class A &#123;&#125;</code></li><li>如果一个方法用final修饰，那么它不能被子类重写。例如：<code>final void method() &#123;&#125;</code></li><li>如果一个变量被final修饰,那么它不能被修改这里的修改指的是修改它对应的地址值</li></ul></li><li><p>抽象类与抽象方法</p><ul><li>抽象类：使用关键字 <code>abstract</code> 定义的类，不能被实例化。抽象类可以包含抽象方法和具体方法。</li><li>抽象方法：使用关键字 <code>abstract</code> 定义的方法，没有方法体。抽象方法必须在抽象类中定义，子类需要提供实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>; <span class="comment">// 抽象方法，没有方法体</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 具体方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is moving&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 子类必须实现抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>接口与继承 接口是Java中的一种特殊类型，它包含了一组<strong>抽象方法（Java 8引入了默认方法和静态方法）</strong>。实现接口的类必须提供接口中所有方法的实现。一个类可以实现多个接口，使用关键字 <code>implements</code>。</p><p>语法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">csharpCopy codeinterface Flyable &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimmable &#123;</span><br><span class="line">    <span class="comment">// 实现接口中的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird flies&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird swims&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多重继承与接口 <strong>Java不支持多重继承</strong>（一个类继承多个类），但可以通过实现多个接口来实现多重继承的效果。一个类可以同时实现多个接口，从而继承接口中的方法。</p></li><li><p>构造器与继承 子类构造方法默认调用父类的无参构造方法。如果父类没有提供无参构造方法，那么子类必须使用super关键字显式调用父类的构造方法。<strong>(必须是方法体的第一条语句)</strong></p><p>语法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass Parent &#123;</span><br><span class="line">    Parent(<span class="type">int</span> a) &#123;</span><br><span class="line">        <span class="comment">// 父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Child(<span class="type">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">super</span>(a); <span class="comment">// 显式调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="属性冲突">属性冲突</h3><p>在 Java 继承和接口实现中，属性冲突主要包括以下两种情况：</p><ol><li><p>类继承中的属性冲突：</p><p>当子类和父类中具有相同名称的属性时，子类中的属性会遮蔽父类中具有相同名称的属性。也就是说，当在子类中访问该属性时，将访问子类中的属性，而不是父类中的属性。但是可以通过 <code>super</code> 关键字显式地访问父类中的属性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    String name = &quot;Parent&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    String name = &quot;Child&quot;;</span><br><span class="line"></span><br><span class="line">    void printNames() &#123;</span><br><span class="line">        System.out.println(name);         // 输出 &quot;Child&quot;</span><br><span class="line">        System.out.println(super.name);    // 输出 &quot;Parent&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口实现中的属性冲突：</p><p>接口可以定义属性（默认为 <code>public static final</code>），当一个类实现多个接口，且这些接口具有相同名称的属性时，可能会出现冲突。在这种情况下，实现类需要显式指定访问哪个接口的属性，否则会出现编译错误。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;InterfaceA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceB</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;InterfaceB&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementor</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>, InterfaceB &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printNames</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(InterfaceA.name); <span class="comment">// 输出 &quot;InterfaceA&quot;</span></span><br><span class="line">        System.out.println(InterfaceB.name); <span class="comment">// 输出 &quot;InterfaceB&quot;</span></span><br><span class="line">        <span class="comment">//System.out.println(name);         // 编译错误，因为不明确是访问 InterfaceA 还是 InterfaceB 的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>综上所述，要避免属性冲突，最佳实践是：</p><ul><li>尽量避免在子类和父类、接口之间使用相同名称的属性。</li><li>如果确实需要访问父类或接口中的同名属性，可以使用 <code>super</code> 关键字（对于父类属性）或显式指定接口名称（对于接口属性）进行访问。</li></ul><blockquote><p>如果父类和接口属性冲突了的话,那么父类属性变量优先,如果遇到了冲突想要使用父类或者接口中的值的话,得指定类名或者接口名字,而且必须在类中才能这样,比如在某个方法里面使用 super.变量 或者 接口名字.变量</p></blockquote><h2 id="总结">总结</h2><p>本章主要讲了继承的相关知识点,以及final的用法</p><h1>第七章 多态性</h1><h2 id="抽象类">抽象类</h2><p>抽象类（Abstract Class）是 Java 中一个重要的面向对象编程概念。它是一种特殊的类，主要用于表示一组相关对象的共同特征。抽象类<strong>不能直接实例化，需要通过继承来创建具体的子类实例</strong>。以下是关于 Java 抽象类的一些关键知识点：</p><ol><li><p>抽象类的定义：使用 <code>abstract</code> 关键字来定义抽象类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 类的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象方法：抽象类中可以包含抽象方法，也可以包含具体的方法。抽象方法没有方法体，只有方法签名，使用 <code>abstract</code> 关键字定义。子类必须实现抽象方法，否则子类也需要被声明为抽象类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 具体方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承抽象类：当一个类继承了抽象类，它需要实现抽象类中的所有抽象方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例化子类：抽象类不能直接实例化，但可以通过实例化其子类来创建对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 创建 Dog 类的实例</span></span><br><span class="line">myDog.makeSound();        <span class="comment">// 调用子类实现的抽象方法</span></span><br><span class="line">myDog.breathe();          <span class="comment">// 调用抽象类中的具体方法</span></span><br></pre></td></tr></table></figure></li><li><p>抽象类的目的：抽象类的主要目的是为了提供一个公共接口和基本实现，以便其他类可以从抽象类继承并<strong>共享相同的方法和属性</strong>。这有助于实现代码复用和多态。</p></li><li><p>抽象类与接口：抽象类和接口都是用于定义对象的共同特征和行为。但是，<strong>抽象类可以包含具体方法和属性</strong>，而<strong>接口只能包含抽象方法和常量</strong>。此外，一个类可以实现多个接口，但只能继承一个抽象类。</p></li></ol><p>这些是 Java 抽象类的主要知识点。在实际编程过程中，了解抽象类的概念和用法对于实现高质量、可维护的面向对象程序非常重要。</p><h2 id="接口">接口</h2><p>接口（Interface）是 Java 中另一个重要的面向对象编程概念。接口定义了一组方法的签名，规定了实现接口的类必须具备哪些行为。接口不能直接实例化，需要通过实现接口的类来创建具体对象。以下是关于 Java 接口的一些关键知识点：</p><ol><li><p>接口的定义：使用 <code>interface</code> 关键字来定义接口。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="comment">// 接口的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口方法：在 Java 8 之前，接口中只能包含抽象方法（方法签名，没有方法体）。从 Java 8 开始，接口中<strong>可以包含默认方法（具有默认实现的方法）和静态方法</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="comment">// 默认方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现接口：一个类可以通过 <code>implements</code> 关键字来实现一个或多个接口。实现接口的类必须实现接口中的所有抽象方法（除非它是抽象类）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多接口实现：一个类可以实现多个接口。在这种情况下，类必须实现所有接口中的抽象方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span>, Resizable &#123;</span><br><span class="line">    <span class="comment">// 实现 Drawable 接口的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 Resizable 接口的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">double</span> factor)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口继承：接口可以通过 <code>extends</code> 关键字继承其他接口。继承接口的接口将包含所有父接口的抽象方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MovableDrawable</span> <span class="keyword">extends</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口的目的：<strong>接口的主要目的是为了提供一种约定，规定实现接口的类应该具备哪些行为。这有助于实现多态和提高代码的可维护性。</strong></p></li><li><p>接口与抽象类的区别：接口和抽象类都是用于定义对象的共同特征和行为。但是，抽象类可以包含具体方法和属性，而接口只能包含抽象方法和常量。此外，一个类可以实现多个接口，但只能继承一个抽象类。</p></li></ol><p>这些是 Java 接口的主要知识点。了解接口的概念和用法对于实现高质量、可维护的面向对象程序非常重要。</p><h2 id="多态">多态</h2><p>Java 中的多态是面向对象编程的一个核心特性，它允许在运行时根据对象的实际类型来执行特定的实现，而非仅根据引用类型。多态实现了代码的灵活性和可扩展性，使得我们可以编写更加通用且易于维护的代码。</p><p>多态的主要特点如下：</p><ol><li><p>继承：多态的基础是继承。子类继承父类，从而可以拥有父类的属性和方法。这为多态提供了基本的条件。</p></li><li><p>方法重写（Override）：子类可以重写父类的方法，以提供自己的实现。<strong>当我们使用子类对象调用该方法时，将执行子类的实现，而非父类的实现。</strong></p></li><li><p>向上转型（Upcasting）：<strong>子类的对象可以隐式地转换为父类类型。这意味着我们可以使用父类类型的引用来指向子类的对象</strong>。向上转型在运行时不会<strong>丢失对象的类型信息</strong>。</p></li><li><p>动态方法分派：<strong>多态的核心在于在运行时根据对象的实际类型动态地决定调用哪个方法实现。也就是说，当我们使用父类类型的引用调用一个被子类重写的方法时，Java 虚拟机会在运行时确定执行的具体方法。</strong></p></li></ol><p>这里有一个多态的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The animal speaks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        myAnimal.speak(); <span class="comment">// 输出：The dog barks.</span></span><br><span class="line"></span><br><span class="line">        myAnimal = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        myAnimal.speak(); <span class="comment">// 输出：The cat meows.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接使用父类类型的引用</span></span><br><span class="line">        makeAnimalSpeak(<span class="keyword">new</span> <span class="title class_">Dog</span>()); <span class="comment">// 输出：The dog barks.</span></span><br><span class="line">        makeAnimalSpeak(<span class="keyword">new</span> <span class="title class_">Cat</span>()); <span class="comment">// 输出：The cat meows.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多态的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeAnimalSpeak</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 和 <code>Cat</code> 类都继承自 <code>Animal</code> 类并重写了 <code>speak</code> 方法。我们可以看到，当我们使用 <code>Animal</code> 类型的引用调用 <code>speak</code> 方法时，实际执行的方法取决于对象的实际类型。这就是多态的体现。</p><p>总之，Java 中的多态允许我们编写更加灵活且易于维护的代码。多态主要涉及到继承、方法重写、向上转型、动态方法分配.</p><h3 id="多态的优点">多态的优点</h3><p>多态在 Java 和其他面向对象编程语言中具有很多优势，以下是一些主要优势：</p><ol><li><p>代码重用：多态允许子类继承父类的属性和方法，从而减少了代码的重复。同时，子类可以根据需求重写或扩展父类的方法，使得代码更加灵活。</p></li><li><p>解耦：多态可以降低代码之间的耦合度。当我们编写一个方法时，<strong>只需要关注该方法所需的接口或父类，而不必关心具体的实现类</strong>。这使得我们可以在不修改方法的情况下，替换或扩展实现类。</p></li><li><p>提高可扩展性：多态使得我们可以轻松地扩展程序的功能。例如，<strong>我们可以添加新的子类来扩展程序的功能，而不需要修改已有的代码</strong>。</p></li><li><p>提高代码的可维护性：由于多态降低了代码之间的耦合度，使得代码结构更加清晰，这有助于提高代码的可维护性。</p></li><li><p>接口抽象：<strong>多态允许我们将接口与实现分离，使得我们可以专注于设计接口，而不必关心具体的实现</strong>。这有助于提高代码的可读性和可维护性。</p></li><li><p>更灵活的代码组织：通过多态，我们可以使用父类或接口类型的引用来引用子类的对象。这使得我们可以在运行时动态地决定使用哪个对象，从而实现更加灵活的代码组织。</p></li></ol><p>总之，多态是面向对象编程的一个核心特性，它为我们提供了代码重用、解耦、可扩展性、可维护性等诸多优势。通过掌握多态，我们可以编写更加优雅、灵活且易于维护的代码。</p><h2 id="内部类">内部类</h2><h3 id="定义">定义</h3><p>Java 中的内部类是指在一个类的内部定义的类。内部类主要用于<strong>组织和封装代码</strong>，使代码结构更加清晰。根据其声明位置和特点，内部类可以分为以下四种类型：</p><ol><li><p>成员内部类（Member Inner Class）：</p><ul><li>成员内部类是在一个类的内部声明的<strong>非静态类</strong>。</li><li><strong>成员内部类可以访问外部类的所有成员（包括私有成员）</strong>。</li><li><strong>要创建成员内部类的实例，需要先创建外部类的实例</strong>。</li><li><strong>成员内部类不能包含静态成员（除非是编译时常量）。</strong></li><li>成员内部类可以使用外部类的访问修饰符（public, private, protected, 默认）。</li></ul></li><li><p>静态内部类（Static Inner Class）：</p><ul><li>静态内部类是在一个类的内部声明的静态类。</li><li><strong>静态内部类可以访问外部类的静态成员（包括私有静态成员），但不能访问外部类的非静态成员。</strong></li><li>创建静态内部类的实例<strong>不需要先创建外部类的实例。</strong></li><li>静态内部类可以包含静态成员和非静态成员。</li><li>静态内部类可以使用外部类的访问修饰符（public, private, protected, 默认）。</li></ul></li><li><p>局部内部类（Local Inner Class）：</p><ul><li><strong>局部内部类是在一个方法或代码块内部声明的类。</strong></li><li>局部内部类只能访问所在方法中被声明为 final 或者是 effectively final 的局部变量（从 Java 8 开始）。</li><li>局部内部类不能使用访问修饰符，其可见性仅限于声明它的方法或代码块。</li><li>局部内部类不能包含静态成员（除非是编译时常量）。</li><li>创建局部内部类的实例需要在其所在方法或代码块内部进行。</li></ul></li><li><p>匿名内部类（Anonymous Inner Class）：</p><ul><li>匿名内部类是一种没有类名的内部类，通常用于创建临时的类实例。</li><li>匿名内部类可以继承一个类或实现一个接口，但不能同时继承多个类或接口。</li><li><strong>匿名内部类只能访问所在方法中被声明为 final 或者是 effectively final 的局部变量（从 Java 8 开始）</strong>。</li><li>匿名内部类不能包含静态成员（除非是编译时常量）。</li><li>创建匿名内部类的实例需要在其所在方法或代码块内部进行，通常通过 new 操作符实现。</li></ul></li></ol><p>总结：内部类是 Java <strong>提供的一种强大的代码组织和封装机制</strong>。了解不同类型的内部类及其特点，可以帮助您在实际编程中更加灵活地运用内部类来实现代码的封装和模块化。以下是一些内部类的典型用途和注意事项：</p><ol><li><p>封装：内部类可以访问外部类的成员，这使得它们成为实现封装的理想选择。通过将与外部类密切相关的功能实现在内部类中，可以使外部类更加简洁，更易于理解和维护。</p></li><li><p>实现回调和事件处理：匿名内部类通常用于实现回调和事件处理，因为它们可以直接访问所在方法的局部变量和外部类的成员。这在实现图形用户界面（GUI）等事件驱动程序时特别有用。</p></li><li><p>实现多重继承：虽然 Java 不支持多重继承，但可以通过使用内部类来实现类似的功能。外部类可以包含多个内部类，每个内部类分别继承或实现不同的类或接口。</p></li><li><p>静态内部类和单例模式：静态内部类可以用于实现单例模式，因为它们不依赖于外部类的实例。这可以确保类在整个应用程序中只有一个实例，从而节省资源并提高性能。</p></li></ol><p>注意事项：</p><ol><li><p>避免内部类和外部类之间的过度耦合。虽然内部类可以访问外部类的成员，但过度使用这种关系可能导致代码难以理解和维护。尽量让内部类和外部类之间的关系清晰，遵循单一职责原则。</p></li><li><p>谨慎使用匿名内部类。匿名内部类在某些场景下非常有用，但它们的可读性较差。在需要实现复杂逻辑的情况下，考虑使用具名的内部类或外部类。</p></li><li><p>考虑性能影响。成员内部类、局部内部类和匿名内部类都需要隐式地持有对外部类实例的引用。这可能导致内存泄漏和性能问题。在这种情况下，可以考虑使用静态内部类，因为它们不持有对外部类实例的引用。</p></li></ol><p>通过了解和掌握内部类的特点和用法，您可以更有效地利用 Java 语言的特性，编写出更加清晰、易于维护的代码。</p><h3 id="使用例子">使用例子</h3><p>以下是几种内部类的示例，包括正确和错误的用法。</p><ol><li>成员内部类：</li></ol><p>正确用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Inner!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(message); <span class="comment">// 访问外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 创建内部类实例</span></span><br><span class="line">        inner.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Inner!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticMessage</span> <span class="operator">=</span> <span class="string">&quot;Static message&quot;</span>; <span class="comment">// 成员内部类不能有静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>静态内部类：</li></ol><p>正确用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Static Inner!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(message); <span class="comment">// 访问外部类的静态成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner(); <span class="comment">// 创建静态内部类实例</span></span><br><span class="line">        inner.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Static Inner!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(message); <span class="comment">// 静态内部类不能访问外部类的非静态成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>局部内部类：</li></ol><p>正确用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createLocalInner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Local Inner!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(message); <span class="comment">// 访问所在方法的局部变量（必须是 final 或 effectively final）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        localInner.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.createLocalInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createLocalInner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Local Inner!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">changeMessage</span><span class="params">()</span> &#123;</span><br><span class="line">                message = <span class="string">&quot;New message&quot;</span>; <span class="comment">// 局部内部类不能修改所在方法的局部变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>匿名内部类：</li></ol><p>正确用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createAnonymousInner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        printer.printMessage(<span class="string">&quot;Hello, Anonymous Inner!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.createAnonymousInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createAnonymousInner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, Anonymous Inner!&quot;</span>;</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String newMessage)</span> &#123;</span><br><span class="line">                message = newMessage; <span class="comment">// 匿名内部类不能修改所在方法的局部变量（除非变量是 final 或 effectively final</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.createAnonymousInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上述列子是在jdk8中使用的,其实在jdk15以后,就有些区别了,比如成员内部类允许有静态变量,局部内部类和匿名内部类可以访问非final变量</p></blockquote><h3 id="内部类的用处">内部类的用处</h3><p>内部类在 Java 编程中有很多用途，主要包括以下几点：</p><ol><li><strong>封装</strong>：内部类可以帮助将类的实现细节隐藏起来，使得外部类更简洁。它使得与外部类关系紧密的类能够被组织在一起，而不需要暴露给外部其他类。</li><li><strong>增强可读性和维护性</strong>：将与某个类紧密相关的辅助类或逻辑组织在一起，可以提高代码的可读性和维护性。这样，相关代码可以在一个地方进行修改和维护，而不是分散在多个地方。</li><li><strong>访问外部类成员</strong>：非静态内部类可以访问外部类的所有成员（包括私有成员），而无需显式传递引用。这使得编写能够访问外部类成员的方法更简单和高效。</li><li><strong>实现多重继承</strong>：Java 不支持多重继承，但可以通过内部类实现一种形式的多重继承。你可以创建一个内部类，使其继承自另一个类，这样外部类就可以间接地继承内部类的父类。</li><li><strong>用于回调和事件处理</strong>：内部类常用于回调和事件处理。例如，在图形用户界面（GUI）编程中，匿名内部类通常用于实现事件监听器。这样可以将事件处理逻辑与其他代码分离，提高代码的组织和可读性。</li></ol><p>我们来看一段代码吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class MyList implements Iterable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int[] array = &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">    class MyIterator implements java.util.Iterator&lt;Integer&gt;&#123;</span><br><span class="line">        private int index = 0;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return index &lt; array.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer next() &#123;</span><br><span class="line">            return array[index++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator&lt;Integer&gt; iterator() &#123;</span><br><span class="line">        return new MyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyList myList = new MyList();</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br><span class="line">        for (Integer integer : myList) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们自己定义了一个迭代器,这个迭代器就能很方便的访问数据,如果我们不使用内部类的的话,我们需要迭代器显示持有我们的对象,这样是比较麻烦的</p><h2 id="总结">总结</h2><p>本章主要讲述了抽象类,接口,还有多态的相关概念,内部类(静态内部类 成员内部类 局部内部类 匿名内部类), 内部类这里在不同版本有不同的表现,在jdk16开始就有了一些变化</p><blockquote><p>多态是针对方法的,而不是属性</p></blockquote><h1>第九章 异常</h1><h2 id="error">Error</h2><p>在 Java 中，<code>Error</code> 是一个继承自 <code>Throwable</code> 类的子类，表示程序运行过程中可能遇到的严重问题。<strong>这些问题通常与 JVM（Java 虚拟机）或系统相关，如内存溢出、虚拟机错误、类加载错误等。<code>Error</code> 表示的问题通常是无法预期或无法恢复的，程序员通常无法处理这些错误。</strong></p><p><code>Error</code> 的作用是在程序运行时提供一种表示严重问题的机制，以便于开发者了解发生的问题并进行调试。当一个 <code>Error</code> 发生时，程序通常会终止执行，因为这些错误通常意味着程序无法继续运行。然而，在实际开发过程中，程序员通常不需要处理 <code>Error</code>，因为这些错误往往是无法恢复的。</p><p>一些常见的 <code>Error</code> 子类包括：</p><ul><li><code>OutOfMemoryError</code>：表示 JVM 中没有足够的内存来分配对象。</li><li><code>StackOverflowError</code>：表示线程的栈空间已满，无法继续执行。</li><li><code>LinkageError</code>：表示类的加载或链接过程中发生错误，例如 <code>NoClassDefFoundError</code> 或 <code>ClassNotFoundException</code>。</li><li><code>VirtualMachineError</code>：表示 JVM 发生内部错误，例如 <code>InternalError</code> 或 <code>UnknownError</code>。</li></ul><p>尽管 <code>Error</code> 及其子类表示程序中的严重问题，但请注意，这些类并不是用于表示程序逻辑错误或可预期的异常情况。对于这些情况，应使用 <code>Exception</code> 类及其子类。</p><h2 id="exception">Exception</h2><p>Java 异常是程序执行过程中发生的错误或异常情况。Java 提供了一套异常处理机制，帮助程序员在出现异常时捕获和处理它们，以保证程序的正常运行。以下是 Java 异常的一些关键知识点：</p><ol><li><p>异常分类：Java 异常主要分为两类：<strong>受检异常（Checked Exceptions）<strong>和</strong>非受检异常（Unchecked Exceptions）</strong>。受检异常继承自 <code>java.lang.Exception</code> 类，需要显式处理（捕获或声明抛出）。<strong>非受检异常继承自 <code>java.lang.RuntimeException</code> 类，不强制处理，可以选择性捕获。</strong></p></li><li><p>常见的异常类：</p><ul><li>受检异常：<code>IOException</code>（输入输出异常）、<code>FileNotFoundException</code>（找不到文件异常）、<code>ClassNotFoundException</code>（找不到类异常）等。</li><li>非受检异常：<code>NullPointerException</code>（空指针异常）、<code>IndexOutOfBoundsException</code>（数组越界异常）、<code>ArithmeticException</code>（算术异常，如除以零）等。</li></ul></li><li><p>异常处理：Java 使用 <code>try-catch</code> 语句块来捕获和处理异常。<code>try</code> 块包含可能抛出异常的代码，<code>catch</code> 块用于捕获特定类型的异常并处理。例如：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType1 的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType2 的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>finally</code> 块：<code>finally</code> 块是一个可选的代码块，它在 <code>try-catch</code> 语句块之后执行。无论 <code>try</code> 块中是否发生异常，<code>finally</code> 块的代码都会执行。通常用于关闭资源，如文件、数据库连接等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 总是执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>异常传播</strong>：当方法内部发生异常，且未在方法内部处理时，异常会传播到调用方法的地方。如果调用方法也没有处理异常，异常会继续传播，直到被捕获或导致程序终止。可以使用 <code>throws</code> 关键字声明方法可能抛出的异常类型，将异常传播给调用者处理。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 可能抛出 FileNotFoundException 的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>自定义异常：可以通过继承 <code>Exception</code> 类或其子类来创建自定义异常。自定义异常可以为特定问题提供更具体的信息。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易错点：</p><ol><li>不要捕获所有异常：尽量避免使用 <code>catch (Exception e)</code> 来捕获所有类型的异常，因为这样会使得代码难以维护和调试。应该尽量捕获和处理具体的异常类型，以便更好地了解和处理问题。</li><li>不要忽略异常：捕获异常后，应该对异常进行处理，例如记录日志、通知用户或尝试恢复。不要只是简单地捕获异常而不进行处理，这样可能会掩盖潜在的问题。</li><li>适当地处理异常：在捕获异常时，应尽量采取适当的措施来处理异常。例如，可以关闭资源、释放内存、进行回滚操作等。此外，需要确保资源在出现异常时能够正确关闭，可以在 <code>finally</code> 块中执行这些操作。</li><li><strong>优先使用非受检异常</strong>：在自定义异常时，如果异常是由编程错误导致的（例如空指针、数组越界等），优先使用非受检异常。如果异常是由外部因素导致的（例如 I/O 错误、网络问题等），则使用受检异常。</li><li>不要过度使用异常：异常处理会导致程序运行效率降低，因此应该谨慎使用。在可以避免使用异常的情况下，尽量使用其他方式来处理错误。</li><li>使用异常链：当捕获到一个异常，并需要抛出另一个异常时，可以使用异常链将原始异常作为新异常的一个属性，从而保留原始异常的信息。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出 IOException 的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;Failed to perform operation&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>细化异常捕获顺序：<code>catch</code> 块是按照顺序执行的，所以应该从最具体的异常类型开始捕获，然后逐渐向上捕获更一般的异常类型。否则，具体的异常类型可能会被更一般的异常类型捕获，从而导致处理逻辑出错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// 处理 FileNotFoundException 的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 处理 IOException 的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理更一般的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解 Java 异常的知识点、易错点以及如何正确地使用异常处理机制对于编写健壮、可维护的代码至关重要</p><h2 id="error和exception的区别">Error和Exception的区别</h2><p>在 Java 中，<code>Error</code> 和 <code>Exception</code> 都是继承自 <code>Throwable</code> 类的子类，它们表示程序运行过程中可能遇到的问题。尽管它们都表示程序中的错误或异常情况，但它们之间存在一些关键区别：</p><ol><li><p>用途：</p><ul><li><p><code>Error</code>：表示程序运行过程中遇到的严重问题，<strong>这些问题通常是 JVM（Java 虚拟机）或系统相关的，如内存溢出、虚拟机错误等。<code>Error</code> 表示的问题通常是无法预期或无法恢复的，程序员通常无法处理这些错误</strong>。</p></li><li><p><code>Exception</code>：表示程序运行过程中可能遇到的问题，这些问题通常是由程序逻辑错误或外部资源（如文件、网络连接等）引起的。<code>Exception</code> 表示的问题可以是预期的，程序员可以通过编写适当的代码来处理这些异常。</p></li></ul></li><li><p>处理方式：</p><ul><li><p><code>Error</code>：由于 <code>Error</code> 表示的问题通常是严重的且无法恢复的，因此程序员不需要（也通常无法）处理这些错误。当遇到 <code>Error</code> 时，程序通常会终止执行。</p></li><li><p><code>Exception</code>：程序员可以使用 try-catch-finally 语句处理 <code>Exception</code>。Java 异常分为两种类型：受检异常（checked exceptions）和非受检异常（unchecked exceptions）。受检异常需要显式处理（使用 try-catch 语句或在方法声明中使用 <code>throws</code> 关键字），而非受检异常可以选择性处理。</p></li></ul></li><li><p>类层次结构：</p><ul><li><p><code>Error</code>：<code>Error</code> 类及其子类位于 Java 类层次结构中的 <code>java.lang</code> 包下。一些常见的 <code>Error</code> 子类包括 <code>OutOfMemoryError</code>、<code>StackOverflowError</code>、<code>LinkageError</code> 等。</p></li><li><p><code>Exception</code>：<code>Exception</code> 类及其子类位于 Java 类层次结构中的 <code>java.lang</code> 包下。<code>Exception</code> 有很多子类，如 <code>IOException</code>、<code>SQLException</code>、<code>NullPointerException</code>、<code>IllegalArgumentException</code> 等。其中，<code>RuntimeException</code> 类是非受检异常的基类。</p></li></ul></li></ol><p>总之，<code>Error</code> 和 <code>Exception</code> 在 Java 中都表示程序运行过程中可能遇到的问题，但它们的用途、处理方式和类层次结构存在一些关键区别。<code>Error</code> 表示严重的、无法恢复的问题，通常无法处理；而 <code>Exception</code> 表示可以预期和处理的问题。</p><h2 id="总结">总结</h2><p>本章主要讲了java异常的一些知识点,包括异常的定义,如果使用异常,捕获异常,自定义异常</p><h1>第十章  IO 系统</h1><h2 id="io流">IO流</h2><p>Java I/O（输入/输出）库提供了许多类来处理数据流。这些类可以分为字节流和字符流。以下是 Java I/O 流的用法、注意点和特点的总结。</p><ol><li><p>字节流（Byte Streams）：</p><p>字节流用于处理原始二进制数据。它们的主要类是 InputStream 和 OutputStream。字节流的主要子类有：</p><ul><li><strong>FileInputStream</strong>：用于从文件中读取字节。</li><li>FileOutputStream：用于将字节写入文件。</li><li>ByteArrayInputStream：用于从字节数组中读取字节。</li><li>ByteArrayOutputStream：用于将字节写入字节数组。</li><li>BufferedInputStream：用于缓冲从其他输入流中读取的字节，以提高性能。</li><li>BufferedOutputStream：用于缓冲要写入其他输出流的字节，以提高性能。</li></ul><p>注意点和特点：</p><ul><li>字节流不处理字符编码，因此可能导致字符数据在读取或写入时出现乱码。</li><li>在处理文本数据时，推荐使用字符流，因为它们能够更好地处理字符编码问题。</li><li>为了避免资源泄漏，确保在使用完 I/O 流后正确地关闭它们。</li></ul></li><li><p>字符流（Character Streams）：</p><p>字符流用于处理字符数据。它们的主要类是 Reader 和 Writer。字符流的主要子类有：</p><ul><li>FileReader：用于从文件中读取字符。</li><li>FileWriter：用于将字符写入文件。</li><li>InputStreamReader：用于将字节流转换为字符流，可以指定字符编码。</li><li>OutputStreamWriter：用于将字符流转换为字节流，可以指定字符编码。</li><li>BufferedReader：用于缓冲从其他 Reader 中读取的字符，以提高性能。</li><li>BufferedWriter：用于缓冲要写入其他 Writer 的字符，以提高性能。</li><li>StringReader：用于从字符串中读取字符。</li><li>StringWriter：用于将字符写入字符串。</li></ul><p>注意点和特点：</p><ul><li>字符流可以处理字符编码，因此更适合处理文本数据。</li><li>InputStreamReader 和 OutputStreamWriter 类允许指定字符编码，以便在不同平台之间正确处理文本数据。</li><li>为了避免资源泄漏，确保在使用完 I/O 流后正确地关闭它们。</li></ul></li></ol><p>除了上述基本的字节流和字符流类之外，Java I/O 还提供了许多实用的过滤器和适配器类，如 DataInputStream、DataOutputStream、PrintStream、PrintWriter 等，它们为特定类型的数据提供了更高级的功能。</p><p>在使用 Java I/O 流时，注意选择合适的流类型，并确保在使用完流后正确地关闭它们以避免资源泄漏。</p><h2 id="file类">File类</h2><p><code>File</code> 类是 Java I/O 库中用于表示文件和目录路径名的抽象表示。以下是 <code>File</code> 类的主要用法：</p><ol><li><p>创建文件和目录：</p><ul><li><code>createNewFile()</code>：创建一个新的空文件，如果文件不存在。</li><li><code>mkdir()</code>：创建一个新的目录，如果目录不存在。</li><li><code>mkdirs()</code>：创建一个新的目录及其所有必需的父目录。</li></ul></li><li><p>文件和目录操作：</p><ul><li><code>renameTo(File dest)</code>：重命名文件或目录。</li><li><code>delete()</code>：删除文件或目录。</li><li><code>deleteOnExit()</code>：请求在 JVM 退出时删除文件或目录。</li></ul></li><li><p>获取文件和目录属性：</p><ul><li><code>exists()</code>：判断文件或目录是否存在。</li><li><code>isFile()</code>：判断是否是文件。</li><li><code>isDirectory()</code>：判断是否是目录。</li><li><code>length()</code>：获取文件的长度（字节数）。</li><li><code>getName()</code>：获取文件或目录的名称。</li><li><code>getAbsolutePath()</code>：获取文件或目录的绝对路径。</li><li><code>getPath()</code>：获取文件或目录的相对路径。</li><li><code>getParent()</code>：获取文件或目录的父目录。</li><li><code>lastModified()</code>：获取文件或目录的最后修改时间。</li><li><code>list()</code>：获取目录中的文件和目录名列表。</li><li><code>listFiles()</code>：获取目录中的 <code>File</code> 对象列表。</li><li><code>list(FilenameFilter filter)</code>：使用指定的过滤器获取目录中的文件和目录名列表。</li><li><code>listFiles(FileFilter filter)</code>：使用指定的过滤器获取目录中的 <code>File</code> 对象列表。</li></ul></li><li><p>设置文件和目录属性：</p><ul><li><code>setLastModified(long time)</code>：设置文件或目录的最后修改时间。</li><li><code>setReadOnly()</code>：设置文件或目录为只读。</li><li><code>setWritable(boolean writable)</code>：设置文件或目录的可写属性。</li><li><code>setExecutable(boolean executable)</code>：设置文件或目录的可执行属性。</li></ul></li><li><p>检查文件权限：</p><ul><li><code>canRead()</code>：检查文件或目录是否可读。</li><li><code>canWrite()</code>：检查文件或目录是否可写。</li><li><code>canExecute()</code>：检查文件是否可执行。</li></ul></li></ol><p>这是 <code>File</code> 类的主要用法。在使用 <code>File</code> 类时，请注意正确处理异常（如 <code>IOException</code>），并在操作完成后关闭文件和释放资源。注意，虽然 <code>File</code> 类提供了许多文件和目录操作的方法，但在 Java NIO 的 <code>Path</code> 和 <code>Files</code> 类中，也提供了更现代且推荐使用的 API 来处理文件和目录。</p><h1>第十一章 反射</h1><h2 id="class对象">Class对象</h2><p>在 Java 中，<code>Class</code> 对象是一个特殊的对象，用于表示加载到 Java 虚拟机 (JVM) 中的类的<strong>元数据</strong>。<strong><code>Class</code> 对象包含了与类相关的信息，如类名、类的父类、类实现的接口、类的字段、构造函数、方法等。每个加载到 JVM 中的类都有一个对应的 <code>Class</code> 对象。</strong></p><p>当 JVM 加载一个类时，它会创建一个 <code>Class</code> 对象来表示这个类。之后，您可以使用这个 <code>Class</code> 对象来获取有关该类的信息，实例化该类的对象，以及执行其他与类相关的操作。</p><p>要获取一个类的 <code>Class</code> 对象，可以使用以下方法之一：</p><ol><li><p>对于已知的类，可以使用 <code>.class</code> 语法获取其对应的 <code>Class</code> 对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; stringClass = String.class;</span><br></pre></td></tr></table></figure></li><li><p>如果您有一个对象实例，可以调用该对象的 <code>getClass()</code> 方法来获取其对应的 <code>Class</code> 对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">Class&lt;?&gt; objClass = str.getClass();</span><br></pre></td></tr></table></figure></li><li><p>如果您知道类的完全限定名（包括包名和类名），可以使用 <code>Class.forName()</code> 方法获取其 <code>Class</code> 对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>获取到 <code>Class</code> 对象后，可以使用它的方法来获取类的信息，实例化对象，以及执行其他操作。一些常用的 <code>Class</code> 对象方法包括：</p><ul><li><code>getName()</code>：获取类的完全限定名。</li><li><code>getSimpleName()</code>：获取类的简单名称。</li><li><code>getSuperclass()</code>：获取类的父类。</li><li><code>getInterfaces()</code>：获取类实现的接口。</li><li><code>getFields()</code>、<code>getMethods()</code>、<code>getConstructors()</code> 等：获取类的字段、方法、构造函数等。</li><li><code>newInstance()</code>：（已弃用）创建类的实例。建议使用 <code>getConstructor()</code> 方法获取构造函数，然后调用 <code>newInstance()</code> 方法创建对象。</li><li><code>isInstance(Object obj)</code>：检查指定的对象是否是当前 <code>Class</code> 对象表示的类的实例。</li><li><code>cast(Object obj)</code>：将指定对象强制转换为当前 <code>Class</code> 对象表示的类的类型。</li><li><code>isInstance(Object obj)</code>：如果指定的对象是该类的实例，则返回true。</li><li><code>isInterface()</code>：如果此类对象表示一个接口，则返回true。</li><li><code>isArray()</code>：如果此类对象表示一个数组类，则返回true。</li><li><code>isPrimitive()</code>：如果此类对象表示一个基本类型（如int，float，char等），则返回true。</li><li><code>isAnnotation()</code>：如果此类对象表示一个注解，则返回true。</li><li><code>isSynthetic()</code>：如果此类对象是合成的，则返回true。一个合成类或成员是由Java编译器引入到代码中的类或成员，它并非由源代码直接产生。</li><li><code>isEnum()</code>：如果此类对象表示一个枚举，则返回true。</li><li><code>isAssignableFrom(Class&lt;?&gt; cls)</code>：<strong>如果传入的类对象可以被当前类对象赋值，即传入的类是当前类或其子类，那么返回true。</strong></li><li><code>isLocalClass()</code>：如果此类对象表示一个局部类（在方法内部定义的类），则返回true。</li><li><code>isMemberClass()</code>：如果此类对象表示一个成员类（在另一个类内部定义的类），则返回true。</li><li><code>isAnonymousClass()</code>：如果此类对象表示一个匿名类，则返回true。</li></ul><p>这些方法使您能够在运行时获取和操作类的信息。这种能力在编写通用代码、实现框架或执行动态操作时非常有用。</p><h2 id="反射">反射</h2><p>Java 反射（Reflection）是一个强大的特性，允许在运行时检查和操作类、接口、字段和方法的信息。通过反射，您可以动态地创建对象、调用方法、获取和设置字段值等。这种能力在编写通用代码、实现框架或执行动态操作时非常有用。</p><p>以下是 Java 反射的一些主要用途：</p><ol><li><p>动态创建对象：通过反射，您可以在运行时动态地创建对象，而无需在编译时知道类的确切类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getConstructor().newInstance();</span><br></pre></td></tr></table></figure></li><li><p>获取和调用方法：您可以使用反射来获取类的方法，并在运行时动态地调用它们。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>, String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, <span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取和设置字段值：反射允许您获取类的字段，并在运行时获取和设置它们的值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;myField&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">fieldValue</span> <span class="operator">=</span> field.get(obj);</span><br><span class="line">field.set(obj, <span class="string">&quot;New Value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取注解:</p><p>在 Java 中，注解（Annotation）的值在编译时确定，并存储在类文件中。在运行时，您可以使用反射来访问注解的值，但不能修改它们。注解的值被视为不可变，因此在运行时尝试更改它们将不起作用。</p><p>要访问注解的值，您可以通过以下方法：</p><ol><li><p>获取类上的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (myAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">    System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取方法上的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>, String.class);</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (myAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">    System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取字段上的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;myField&quot;</span>);</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> field.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (myAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">    System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取构造函数上的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> constructor.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (myAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">    System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>动态代理：Java 反射还允许您在运行时动态地创建代理对象，以便在不修改原始类的情况下拦截和修改方法调用。例如，您可以使用 <code>java.lang.reflect.Proxy</code> 类来创建动态代理。</p></li></ol><p>以下是使用 Java 反射时需要注意的一些事项：</p><ol><li><p>性能：反射操作通常比非反射操作慢，因为它们涉及到运行时类型检查和其他开销。因此，在关注性能的场景中，谨慎使用反射。</p></li><li><p>安全：反射可能会破坏封装，因为它允许您访问和修改私有字段和方法。在使用反射时，请确保您遵循最佳实践，以防止意外地暴露敏感信息或破坏对象状态。</p></li><li><p>兼容性：反射代码可能会更加脆弱，因为它依赖于在运行时确定的类型信息。如果类的结构发生变化（例如，字段或方法被重命名、移除或更改），反射代码可能会出现错误。在使用反射时，请确保您的代码能够适应这些变化，或者使用其他机制（如接口或依赖注入）来减小耦合度。</p></li></ol><p>尽管 Java 反射具有一定的复杂性和潜在风险，但在许多场景下，它为您提供了强大的动态编程能力</p><h2 id="总结">总结</h2><p>本章主要讲了元类与元类提供的方法, 元类是对一个类的描述,我们可以通过元类获取类定义的一些信息,比如注解,字段,方法,从而可以动态的对一个对象做一些事情</p><h1>第十二章 克隆</h1><p>在 Java 里面，克隆（Clone）是一种创建对象副本的过程。在 Java 中，克隆主要通过实现 <code>java.lang.Cloneable</code> 接口和覆盖 <code>clone()</code> 方法来实现。</p><p>克隆的主要作用是在以下场景中：</p><ol><li><p><strong>创建独立副本</strong>：当你需要创建一个对象的副本，与原对象相互独立，以便在不影响原对象的情况下对副本进行修改。</p></li><li><p><strong>优化性能</strong>：如果创建一个对象的过程非常耗时，可以通过克隆已有的对象来节省时间和资源。</p></li><li><p><strong>保护对象状态</strong>：当一个对象需要与其他对象共享，但又不希望其他对象更改其状态时，<strong>可以提供一个副本供其他对象使用</strong>。</p></li></ol><p>Java 的克隆分为浅克隆（Shallow Clone）和深克隆（Deep Clone）：</p><ul><li><p>浅克隆：只复制对象本身，不复制对象内部引用的其他对象。这意味着原对象和克隆对象共享同一个引用类型的成员变量。</p></li><li><p>深克隆：复制对象及其内部引用的所有对象。这样，原对象和克隆对象不会共享任何引用类型的成员变量。</p></li></ul><h2 id="浅克隆">浅克隆</h2><p>要使用克隆功能，请实现 <code>Cloneable</code> 接口，并覆盖 <code>clone()</code> 方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 类成员和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，可以通过调用 <code>clone()</code> 方法创建对象的副本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> (MyClass) original.clone();</span><br></pre></td></tr></table></figure><h2 id="深度克隆">深度克隆</h2><p>在 Java 中，深克隆（Deep Clone）是指创建一个对象的副本，同时复制该对象及其所有引用的对象。实现深克隆有多种方法，以下是两种常见的方法：</p><p>方法一：使用序列化和反序列化</p><p>要使用这种方法，首先需要让你的类实现 <code>java.io.Serializable</code> 接口。然后，通过将对象序列化到字节流中，再从字节流中反序列化回对象，实现深克隆。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">deepClone</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">            oos.writeObject(object);</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">clonedObject</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clonedObject;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Deep clone failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归克隆</p><p>对于每个引用类型的成员变量，实现它们各自的深克隆方法。然后，在覆盖的 <code>clone()</code> 方法中递归地调用这些方法。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AnotherClass anotherClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(AnotherClass anotherClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherClass = anotherClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.anotherClass = (AnotherClass) <span class="built_in">this</span>.anotherClass.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 类成员和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code> 类包含一个引用类型的成员变量 <code>anotherClass</code>。我们分别在 <code>MyClass</code> 和 <code>AnotherClass</code> 中覆盖了 <code>clone()</code> 方法，以实现深克隆。当调用 <code>MyClass</code> 类的 <code>clone()</code> 方法时，它会递归地调用 <code>AnotherClass</code> 类的 <code>clone()</code> 方法，从而实现深克隆。</p><p>注意：深克隆可能会引发性能问题，特别是在处理大型对象图时。在使用深克隆时，请务必权衡好性能与功能之间的平衡。</p><p>注意：克隆功能需要谨慎使用，因为它可能导致不可预期的副作用，例如多余的对象创建、内存泄漏等问题。有时，可以考虑使用其他设计模式（如原型模式、工厂模式等）替代克隆。</p><h1>第十四章 多线程</h1><p>Java 线程是 Java 平台提供的一种基本的并发编程单元。线程允许您在同一个程序中同时执行多个任务。以下是一些关于 Java 线程的核心知识点：</p><ol><li><p>线程的创建和启动</p><p>在 Java 中，有两种主要的方法来创建线程：</p><ul><li>继承 <code>java.lang.Thread</code> 类并覆盖其 <code>run()</code> 方法。创建该类的实例并调用 <code>start()</code> 方法启动线程。</li><li>实现 <code>java.lang.Runnable</code> 接口并实现其 <code>run()</code> 方法。将实现 <code>Runnable</code> 的类的实例传递给 <code>Thread</code> 类的构造函数，然后调用 <code>start()</code> 方法启动线程。</li></ul></li><li><p>线程的生命周期</p><p>Java 线程有以下几种状态：</p><ul><li>新建（New）：线程对象已创建，但尚未启动。</li><li>可运行（Runnable）：线程已启动，正在等待操作系统分配 CPU 时间片进行执行。</li><li>阻塞（Blocked）：线程正在等待获取对象的监视器锁，以进入同步块或同步方法。</li><li>等待（Waiting）：线程处于无限期等待状态，直到满足某个条件。例如，调用了 <code>wait()</code>、<code>join()</code> 或 <code>LockSupport.park()</code> 方法。</li><li>超时等待（Timed Waiting）：线程处于有时间限制的等待状态。例如，调用了 <code>sleep()</code>、<code>wait(long)</code> 或 <code>join(long)</code> 方法。</li><li>终止（Terminated）：线程执行完成或因异常而终止。</li></ul></li><li><p>线程的优先级</p><p>Java 线程具有优先级，范围从 1（最低）到 10（最高）。默认情况下，线程的优先级设置为 5（普通优先级）。可以使用 <code>Thread.setPriority(int)</code> 方法设置线程的优先级。操作系统将根据线程的优先级分配 CPU 时间片。但<strong>是这个不是一定的,不是说优先级越高,你就一定先获得CPU的时间片</strong></p></li><li><p>同步和锁</p><p>当多个线程需要访问共享资源时，可能会导致竞态条件和数据不一致。要解决这个问题，可以使用同步来确保同一时间只有一个线程能访问特定资源。Java 提供了以下同步机制：</p><ul><li>同步方法：使用 <code>synchronized</code> 关键字修饰方法。当线程调用同步方法时，需要获得该方法所属对象的监视器锁。</li><li>同步块：使用 <code>synchronized</code> 关键字和一个锁对象来创建同步块。进入同步块时，线程需要获得锁对象的监视器锁。</li></ul></li><li><p>线程间通信</p><p>Java 提供了以下机制来实现线程间通信：</p><ul><li><code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>：这些方法用于线程间的协作，让一个线程等待特定条件，而另一个线程在条件满足时唤醒等待的线程。这些方法必须在同步块或同步方法中使用。</li></ul></li><li><p>线程局部变量</p><p><code>java.lang.ThreadLocal</code> 类允许每个线程拥有自己的变量副本。当多个线程需要访问相同的变量，但又需要独立副本时，可以使用线程局部变量。这有助于减少竞态条件和同步的需求。</p></li><li><p>线程安全的集合</p><p>Java 提供了线程安全的集合类，如 <code>java.util.concurrent.ConcurrentHashMap</code>、<code>java.util.concurrent.CopyOnWriteArrayList</code> 等。这些集合在内部实现了同步和其他并发控制机制，以确保在多线程环境下的安全使用。</p></li><li><p>线程池和 Executor 框架</p><p>使用线程池可以有效地控制并发线程的数量，并在需要时重用线程。<code>java.util.concurrent.Executor</code> 和 <code>java.util.concurrent.ExecutorService</code> 接口提供了一个框架来管理和控制线程池。<code>java.util.concurrent.Executors</code> 类提供了工厂方法来创建不同类型的线程池，如固定大小的线程池、缓存的线程池等。</p></li><li><p>并发工具类</p><p>Java 并发库提供了许多高级并发工具类，如信号量（<code>java.util.concurrent.Semaphore</code>）、倒计时闩（<code>java.util.concurrent.CountDownLatch</code>）、循环屏障（<code>java.util.concurrent.CyclicBarrier</code>）等。这些类提供了强大的功能，以帮助解决复杂的多线程问题。</p></li><li><p>CompletableFuture</p><p><code>java.util.concurrent.CompletableFuture</code> 类提供了一种基于回调的异步编程模型。它允许您使用非阻塞操作来编写并发代码，并在操作完成时获得通知。</p></li><li><p>并行流</p><p>Java 8 引入了 Stream API，该 API 提供了一种简洁的方式来处理集合和数据流。Java 8 还提供了并行流（Parallel Stream），它允许您轻松地将顺序流转换为并行流，以便利用多核处理器并行处理数据。</p></li></ol><h1>第十五章 网络编程</h1><p>Java 网络编程主要关注如何在 Java 应用程序中实现数据的传输和通信。以下是 Java 网络编程的主要知识点：</p><ol><li><p>OSI 参考模型和 TCP/IP 协议栈：了解网络通信的基本原理和各层协议是学习 Java 网络编程的基础。</p></li><li><p>InetAddress 类：该类用于表示互联网协议（IP）地址。它提供了用于解析主机名和 IP 地址的方法。</p></li><li><p>套接字（Socket）：Java 网络编程的核心是套接字，它是网络通信的端点。Java 提供了以下套接字类：</p><ul><li>Socket：用于实现客户端的 TCP 套接字。它允许您建立到远程服务器的连接并发送/接收数据。</li><li>ServerSocket：用于实现服务器端的 TCP 套接字。它允许您监听来自客户端的连接并接收/发送数据。</li><li>DatagramSocket：用于实现基于 UDP 的无连接通信。它允许您发送/接收数据报文。</li></ul></li><li><p>Java I/O 流：在 Java 网络编程中，常使用 I/O 流进行数据的读取和发送。以下是常用的 I/O 流：</p><ul><li>InputStream 和 OutputStream：基本的字节流，用于读取和写入原始字节数据。</li><li>InputStreamReader 和 OutputStreamWriter：用于处理字符数据的字符流，将字节流转换为字符流。</li><li>BufferedReader 和 BufferedWriter：带缓冲的字符流，提高 I/O 性能。</li><li>DataInputStream 和 DataOutputStream：用于处理基本数据类型和字符串的数据流。</li></ul></li><li><p>URL 和 HttpURLConnection：用于处理 HTTP 协议的类。URL 类表示统一资源定位符，可以用于访问网络资源。HttpURLConnection 类提供了发送 HTTP 请求和接收 HTTP 响应的功能。</p></li><li><p>多线程：在网络编程中，通常需要使用多线程来处理并发连接和请求。了解如何在 Java 中创建和管理线程是网络编程的重要知识点。</p></li><li><p>Java NIO：Java 新输入输出（NIO）框架提供了高性能、非阻塞的 I/O 操作。Java NIO 主要包括 Channel、Buffer 和 Selector 等组件，它们允许您实现高效的网络通信。</p></li></ol><p>以下是使用 Java 编程实现 TCP 和 UDP 通信的简单示例。</p><h2 id="tcp-示例：">TCP 示例：</h2><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接到指定服务器和端口的套接字</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取输出流以发送数据到服务器</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream, <span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送消息到服务器</span></span><br><span class="line">        writer.println(<span class="string">&quot;Hello, server!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取输入流以接收服务器的响应</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取并输出服务器的响应</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server response: &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个在指定端口监听的 ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待客户端连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for a client...&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;Client connected.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取输入流以接收客户端发送的数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> clientSocket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取客户端发送的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;Client message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取输出流以向客户端发送响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> clientSocket.getOutputStream();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向客户端发送响应</span></span><br><span class="line">        writer.println(<span class="string">&quot;Hello, client!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">        clientSocket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="udp-示例：">UDP 示例：</h2><p>发送方（客户端）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 DatagramSocket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备发送的数据和目标地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, receiver!&quot;</span>;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据转换为字节数组并创建一个 DatagramPacket</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = message.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length, address, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据报</span></span><br><span class="line">        datagramSocket.send(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;Message sent.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备接收响应</span></span><br><span class="line">        <span class="type">byte</span>[] responseBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">responsePacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(responseBuffer, responseBuffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收响应数据报</span></span><br><span class="line">        datagramSocket.receive(responsePacket);</span><br><span class="line">        System.out.println(<span class="string">&quot;Response received.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从响应数据报中提取数据并转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(responsePacket.getData(), <span class="number">0</span>, responsePacket.getLength());</span><br><span class="line">        System.out.println(<span class="string">&quot;Response content: &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收方（服务器）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个在指定端口监听的 DatagramSocket</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备接收数据报的缓冲区和 DatagramPacket</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据报</span></span><br><span class="line">        datagramSocket.receive(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;Message received.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据报中提取数据并转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">        System.out.println(<span class="string">&quot;Message content: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备发送响应</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;Hello, sender!&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] responseBuffer = response.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">senderAddress</span> <span class="operator">=</span> packet.getAddress();</span><br><span class="line">        <span class="type">int</span> <span class="variable">senderPort</span> <span class="operator">=</span> packet.getPort();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">responsePacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(responseBuffer, responseBuffer.length, senderAddress, senderPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送响应数据报</span></span><br><span class="line">        datagramSocket.send(responsePacket);</span><br><span class="line">        System.out.println(<span class="string">&quot;Response sent.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br></pre></td></tr></table></figure><h1>补充</h1><h2 id="注解">注解</h2><p>Java 注解（Annotation）是一种为代码添加元数据的机制。它们可以用于提供额外的信息，<strong>以便在编译时或运行时进行处理。注解可以应用于类、方法、字段、参数和其他代码元素</strong>。以下是关于 Java 注解的一些关键概念和用法：</p><ol><li><p>定义注解：</p><p>要定义注解，需要使用 <code>@interface</code> 关键字。注解可以具有属性（也称为元素），这些属性看起来像方法，但实际上是定义了注解的一部分。属性可以具有默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default_value&quot;</span>;</span><br><span class="line">    String[] tags() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">priority</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码定义了一个名为 <code>MyAnnotation</code> 的注解，具有 <code>value</code>、<code>tags</code> 和 <code>priority</code> 属性。</p></li><li><p>应用注解：</p><p>一旦定义了注解，就可以将其应用于代码元素（如类、方法、字段等）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;example&quot;, tags = &#123;&quot;tag1&quot;, &quot;tag2&quot;&#125;, priority = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;field_annotation&quot;)</span>  <span class="comment">// 默认赋值给value</span></span><br><span class="line">    <span class="keyword">private</span> String myField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元注解</p><ol><li><p><code>@Retention</code>：指定注解的保留策略。可能的取值包括：</p><ul><li><code>RetentionPolicy.SOURCE</code>：注解仅在源代码中可用，编译器会在编译时丢弃它。</li><li><code>RetentionPolicy.CLASS</code>：注解在编译后的类文件中可用，但 JVM 在运行时不保留它。这是默认保留策略。</li><li><code>RetentionPolicy.RUNTIME</code>：<strong>注解在运行时可用，因此可以通过反射访问。</strong></li></ul></li><li><p><code>@Target</code>：限制注解可以应用的 Java 元素类型。可能的取值包括：</p><ul><li><code>ElementType.TYPE</code>：类、接口、枚举或注解。</li><li><code>ElementType.FIELD</code>：字段。</li><li><code>ElementType.METHOD</code>：方法。</li><li><code>ElementType.PARAMETER</code>：方法参数。</li><li><code>ElementType.CONSTRUCTOR</code>：构造函数。</li><li><code>ElementType.LOCAL_VARIABLE</code>：局部变量。</li><li><code>ElementType.ANNOTATION_TYPE</code>：注解类型。</li><li><code>ElementType.PACKAGE</code>：包。</li><li><code>ElementType.TYPE_PARAMETER</code>：类型参数（Java 8 及更高版本）。</li><li><code>ElementType.TYPE_USE</code>：类型使用（Java 8 及更高版本）。</li></ul></li><li><p><code>@Documented</code>：将注解信息包含在 Javadoc 文档中。此元注解没有取值。</p></li><li><p><code>@Inherited</code>：表示注解可从父类继承。此元注解没有取值。请注意，<code>@Inherited</code> 仅对类注解有效，对方法、字段和构造函数注解无效。</p></li><li><p><code>@Repeatable</code>：表示注解可以在同一个元素上多次使用。它的取值是一个容器注解，该容器注解用于存储重复注解。</p></li></ol></li></ol><h2 id="泛型">泛型</h2><p>泛型（Generics）是 Java 5 引入的一项功能，<strong>它允许在编译时进行类型检查。泛型的主要目标是提高代码的类型安全性和可重用性</strong>。在这里，我们将全面了解泛型的概念、优点和使用方法。</p><ol><li>什么是泛型？</li></ol><p>泛型允许开发人员在类、接口和方法中使用类型参数。类型参数是一个占位符，可以在实例化或调用泛型类型时指定具体类型。这样，可以编写一次代码，然后在不同情况下重用它，而无需修改源代码。</p><ol start="2"><li>泛型类和泛型接口：</li></ol><p>泛型类和泛型接口是使用类型参数定义的类和接口。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItem</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericComparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T a, T b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>泛型方法：</li></ol><p>泛型方法是在方法签名中使用类型参数定义的方法。泛型方法可以在泛型类、泛型接口或普通类中定义。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getFirst</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>类型擦除：</li></ol><p>为了确保与没有使用泛型的旧代码兼容，<strong>Java 编译器在编译泛型代码时会执行类型擦除</strong>。<strong>类型擦除意味着编译器将泛型类型参数替换为其限定类型（通常是 Object）或限定类型的上界。因此，在运行时，泛型信息被擦除，不能在运行时查询泛型类型信息</strong>。</p><ol start="5"><li>有界类型参数：</li></ol><p>有时，我们希望限制泛型类型参数可以使用的类型。可以通过在类型参数后面添加 extends 关键字和相应的限定类型来实现这一目标。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericBox</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里表示T必须是Comparable的子类型 也就是说T得是Comparable的子类或者接口实现</p></blockquote><ol start="6"><li>通配符：</li></ol><p>通配符是一种特殊的类型参数，用于表示未知类型。通配符在泛型类型中表示为问号（?）。通配符分为三类：</p><ul><li>无限制通配符：<code>&lt;?&gt;</code>，表示任何类型。</li><li>上界通配符：<code>&lt;? extends T&gt;</code>，表示 T 或其子类。</li><li>下界通配符：<code>&lt;? super T&gt;</code>，表示 T 或其超类。</li></ul><ol start="7"><li><p>泛型的优势：</p><ul><li><p>类型安全：泛型在编译时进行类型检查，从而减少了在运行时由于类型不匹配引发的错误。</p></li><li><p>代码重用：可以使用泛型编写一段代码，然后在不同的类型场景中重用它。</p><ul><li>提高代码可读性：泛型使代码更具可读性，因为它明确地指定了类型，有助于理解代码的预期行为和功能。</li></ul></li></ul></li><li><p>泛型限制：</p></li></ol><p>虽然泛型提供了许多优势，但它也有一些限制：</p><ul><li>由于类型擦除，泛型类型参数在运行时不可用。这意味着不能在运行时查询泛型类型信息。</li><li>不能实例化泛型类型参数。例如，不能使用 <code>new T()</code>。</li><li>不能创建泛型数组。例如，不能创建 <code>T[]</code> 类型的数组。</li><li>不能将基本类型用作泛型类型参数。必须使用相应的包装类，如 <code>Integer</code>、<code>Double</code> 等。</li></ul><ol start="9"><li>PECS（Producer Extends Consumer Super）原则：</li></ol><p>PECS 原则是一种关于如何使用通配符的经验法则。它表示：</p><ul><li>当你需要从泛型类型中获取（生产）数据时，使用 <code>extends</code>（上界通配符）。</li><li>当你需要将数据放入（消费）泛型类型中时，使用 <code>super</code>（下界通配符）。</li></ul><p>这个原则有助于确保泛型类型在生产和消费数据时的类型安全性。</p><p>总结一下，泛型是 Java 中非常重要的特性，它提高了代码的类型安全性、可重用性和可读性。通过掌握泛型类、泛型接口、泛型方法、类型擦除、有界类型参数、通配符、泛型的优势和限制，以及 PECS 原则，你将能够更有效地使用泛型来编写高质量的 Java 代码。</p><h2 id="类的加载">类的加载</h2><p>类的加载是 Java 运行时环境在执行 Java 程序时将类加载到 Java 虚拟机（JVM）中的过程。类的加载包括以下几个阶段：</p><ol><li><p>加载（Loading）：JVM 从文件系统、网络或其他资源中加载类的二进制数据（字节码文件），并根据这些数据在 JVM 内存中创建一个 java.lang.Class 对象。这个阶段主要由类加载器（Class Loader）完成。仅导入类（使用 import 语句）不会触发类加载，类加载发生在实际使用类时，如创建对象、访问静态变量或方法等。</p></li><li><p>验证（Verification）：在加载阶段之后，JVM 对字节码文件进行验证，确保它符合 Java 语言规范，不包含非法指令，保证其正确性和安全性。</p></li><li><p>准备（Preparation）：在验证阶段之后，JVM 为类的静态变量分配内存并设置默认值。例如，对于基本类型的静态变量，整数型变量会被设置为 0，浮点型变量会被设置为 0.0，布尔型变量会被设置为 false，引用类型变量会被设置为 null。</p></li><li><p>解析（Resolution）：在准备阶段之后，JVM 对类中的符号引用进行解析，将其替换为直接引用。符号引用是指用类、字段或方法的名字和描述符来表示，而直接引用是指用内存地址或偏移量来表示。解析阶段保证了类、字段和方法的使用可以被正确地定位。</p></li><li><p>初始化（Initialization）：在解析阶段之后，JVM 对类进行初始化，执行类的静态代码块和静态变量赋值操作。这些操作按照它们在类中出现的顺序执行。</p></li></ol><p>在 Java 中，<strong>类的加载通常是惰性的（按需加载）。这意味着类在实际使用之前不会被加载。仅导入类（使用 import 语句）不会触发类的加载</strong>。类加载发生在以下情况：</p><ul><li>创建类的实例（使用 new 关键字）。</li><li><strong>访问类的静态变量</strong>。</li><li><strong>调用类的静态方法</strong>。</li><li><strong>使用反射来创建实例、访问变量或调用方法。</strong></li><li><strong>初始化子类时，父类会先被加载</strong>。</li></ul><p>当类被加载到 JVM 时，只有在实际使用类的过程中，类的加载才被认为已经完成。所以我们<strong>通过类名.class这种方式也不会加载类</strong></p><h2 id="jar包">jar包</h2><p>要将 Java 程序打包成 JAR 文件，您可以使用 JDK 提供的 <code>jar</code> 命令。以下是一个简单的步骤：</p><ol><li><p>确保您已经编译了 Java 源代码，生成了 <code>.class</code> 文件。</p></li><li><p>创建一个名为 <code>manifest.txt</code> 的清单文件，其中包含一个 <code>Main-Class</code> 项，指定应用程序的入口类。例如，如果您的程序入口类为 <code>com.example.Main</code>，则 <code>manifest.txt</code> 文件的内容应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: com.example.Main</span><br></pre></td></tr></table></figure><blockquote><p>文件内容可以没有,但是文件一定要有</p></blockquote></li><li><p>使用 <code>jar</code> 命令创建 JAR 文件。将 <code>-c</code>（创建新的 JAR 文件）、<code>-v</code>（详细输出）和 <code>-f</code>（指定 JAR 文件名）选项与清单文件和要打包的 <code>.class</code> 文件一起传递。 <strong>可以传递多个文件,不限于.class文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvfm myprogram.jar manifest.txt com/example/*.class test.txt</span><br></pre></td></tr></table></figure><p>这个命令将创建一个名为 <code>myprogram.jar</code> 的 JAR 文件，包含 <code>manifest.txt</code> 清单文件和 <code>com/example</code> 目录下的所有 <code>.class</code> 文件。</p></li><li><p>确认 JAR 文件已成功创建。可以使用 <code>jar</code> 命令的 <code>-t</code>（列出 JAR 文件内容）选项查看 JAR 文件中的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tvf myprogram.jar</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>java</code> 命令运行 JAR 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myprogram.jar</span><br></pre></td></tr></table></figure><p>这个命令将启动 Java 虚拟机并运行 <code>myprogram.jar</code> 中指定的 <code>Main-Class</code>。</p></li></ol><p>注意：如果您的应用程序依赖于其他 JAR 文件或类文件，需要在运行 JAR 文件时通过 <code>-classpath</code> 或 <code>-cp</code> 参数指定这些依赖项。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath library.jar -jar myprogram.jar</span><br></pre></td></tr></table></figure><h2 id="命令用法">命令用法</h2><p><code>java</code> 和 <code>javac</code> 是 Java 开发者在命令行中经常使用的两个命令。<code>javac</code> 是 Java 编译器，用于将 Java 源代码文件编译成 Java 字节码文件（<code>.class</code> 文件）。<code>java</code> 命令用于启动 Java 虚拟机（JVM），加载和执行 Java 程序。</p><p>下面是一些<code>java</code> 和 <code>javac</code> 命令常用用法：</p><p><strong>javac 命令：</strong></p><ol><li><p>编译单个 Java 源文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure><p>这个命令将 <code>Main.java</code> 源文件编译成 <code>Main.class</code> 字节码文件。</p></li><li><p>编译多个 Java 源文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java Test.java</span><br></pre></td></tr></table></figure><p>这个命令将同时编译 <code>Main.java</code> 和 <code>Test.java</code> 源文件。</p></li><li><p>编译指定目录下的所有 Java 源文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -sourcepath ./src -d ./bin ./src/**/*.java</span><br></pre></td></tr></table></figure><p>这个命令将编译 <code>src</code> 目录下的所有 Java 源文件，并将生成的 <code>.class</code> 文件存放到 <code>bin</code> 目录下。</p></li><li><p>指定编译时的类路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -classpath lib/* Main.java</span><br></pre></td></tr></table></figure><p>这个命令将在编译 <code>Main.java</code> 时使用 <code>lib</code> 目录下的所有 JAR 文件作为类路径。<strong>如果用了这个命令我们在执行java的时候也要指定classpath路径</strong></p></li></ol><blockquote><p>使用javac的时候,依赖的库只需要是.class文件, 但是他会去对比.class文件与.java文件的日期,如果.class文件旧与.java文件,他会把java文件也编译了</p></blockquote><p><strong>java 命令：</strong></p><ol><li><p>执行 Java 程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Main</span><br></pre></td></tr></table></figure><p>这个命令将运行 <code>Main.class</code> 文件中的 <code>main</code> 方法。</p></li><li><p>指定运行时的类路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath lib/* Main</span><br></pre></td></tr></table></figure><p>这个命令将在执行 <code>Main</code> 类时使用 <code>lib</code> 目录下的所有 JAR 文件作为类路径。</p></li><li><p>设置 Java 虚拟机启动参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms128m -Xmx512m Main</span><br></pre></td></tr></table></figure><p>这个命令将在启动 Java 虚拟机时设置初始堆内存为 128 MB，最大堆内存为 512 MB。</p></li><li><p>启动带有命令行参数的 Java 程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Main arg1 arg2 arg3</span><br></pre></td></tr></table></figure><p>这个命令将把 <code>arg1</code>、<code>arg2</code> 和 <code>arg3</code> 作为命令行参数传递给 <code>Main</code> 类的 <code>main</code> 方法。</p></li><li><p><strong>更改当前工作目录</strong>：<strong>这样的话可以更改文件读写的位置,不会影响类路径</strong>,这可以通过设置 JVM 参数 <code>user.dir</code> 来实现。例如，在启动 Java 程序时，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Duser.dir=/path/to/your/directory YourMainClass</span><br></pre></td></tr></table></figure><p>请注意，这种方法在程序运行时更改当前工作目录的能力有限，因为它取决于 JVM 的实现。</p></li></ol><p>这些是 <code>java</code> 和 <code>javac</code> 命令的一些常用选项。实际上，这两个命令还有许多其他选项和功能，您可以在官方文档中找到更详细的信息。</p><h2 id="相关概念">相关概念</h2><p>让我们详细讨论 Java 中的包、类路径和执行机制。</p><ol><li><p>包（Package）：</p><p><strong>包是 Java 中用于组织和分类类的一种方式。包名的目的是为了避免命名冲突和提高代码的可读性</strong>。<strong>Java 包名通常遵循域名的反序</strong>，例如：<code>com.example.myapp</code>。包名对应的目录结构是以点（<code>.</code>）分隔的子目录，如：<code>com/example/myapp</code>。</p></li><li><p>Java 源文件和类文件的组织：</p><p>在 Java 项目中，源文件（<code>.java</code>）和类文件（<code>.class</code>）通常按照包名的目录结构进行组织。例如，包名为 <code>com.djm.test</code> 的源文件应位于 <code>src/com/djm/test</code> 目录下。编译后的类文件通常放在一个单独的目录中，如 <code>out/com/djm/test</code>。</p></li><li><p>类路径（Classpath）：</p><p>类路径是 Java 运行时用于查找类文件的路径设置。Java 运行时会根据类路径的设置在文件系统或其他位置查找 <code>.class</code> 文件。类路径可以通过设置环境变量 <code>CLASSPATH</code> 或使用命令行选项 <code>-cp</code> 或 <code>-classpath</code> 来指定。</p><p>默认情况下，类路径包含当前目录（<code>.</code>）。这意味着，如果没有指定类路径，Java 运行时会从当前目录开始查找类文件。</p></li><li><p>执行 Java 程序：</p><p>当使用 <code>java</code> 命令执行 Java 程序时，需要提供主类的全名（包括包名和类名）。例如，如果主类 <code>Main</code> 位于 <code>com.djm.test</code> 包中，执行命令应该是 <code>java com.djm.test.Main</code>。</p><p>如果类路径设置正确，Java 运行时会在类路径中查找主类的 <code>.class</code> 文件。如果找不到主类，会报错。</p></li></ol><p><strong>所以我们在执行java命令的时候 一定要指明包名和类名</strong>, 根据包名我们就应该要知道我们要在哪个位置执行java命令,比如我有个java文件,设置包名为 com.djm.test  那么我门就要在这个文件的上4层目录下执行,这个目录还具有com/djm/test子目录,所以我们不要随便设置包名,而是要根据项目所在位置下面 的目录文件命名,然后再项目目录下执行文件</p><h2 id="关于classpath">关于classpath</h2><p><code>classpath</code>（类路径）是 Java 运行时环境用来查找类和其他资源的一个参数。当 Java 运行时环境需要加载类或资源时，它会根据 <code>classpath</code> 中的设置在文件系统或其他位置查找对应的文件。<code>classpath</code> 可以包含目录、JAR 文件或其他资源。以下是 Java 会选择的几个默认类路径：</p><ol><li><p><strong>当前目录</strong>：默认情况下，Java 运行时环境会将当前目录（<code>.</code>）包含在类路径中。这意味着 Java 会在运行程序的当前目录中查找类和资源。</p></li><li><p><strong>Java 标准库</strong>：Java 运行时环境还会在 Java 标准库（JRE 或 JDK 中的 <code>lib</code> 目录）中查找类和资源。这些库包含 Java 标准类，如 <code>java.util.ArrayList</code>、<code>java.lang.String</code> 等。</p></li><li><p><strong>用户定义的类路径</strong>：用户可以通过设置 <code>CLASSPATH</code> 环境变量或使用命令行选项 <code>-cp</code> 或 <code>-classpath</code> 来定义自己的类路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp /path/to/my/classes:/path/to/my/libs/mylib.jar MyMainClass</span><br></pre></td></tr></table></figure><p>在这个例子中，Java 会在 <code>/path/to/my/classes</code> 目录和 <code>/path/to/my/libs/mylib.jar</code> JAR 文件中查找类和资源。<strong>使用了自定义的类路径后,当前目录就不会被加入到类路径中</strong></p><blockquote><p>java标准库的优先级是高于默认和自定义的类路径的,只要在最前面找到了class文件,就不会继续往后面找</p></blockquote></li></ol><p>需要注意的是，不同操作系统中，类路径的分隔符可能不同。在 Windows 中，类路径的分隔符是分号（<code>;</code>），而在 Unix 和类 Unix 系统（如 Linux 和 macOS）中，类路径的分隔符是冒号（<code>:</code>）。</p><p>总之，Java 会根据当前目录、Java 标准库和用户定义的类路径设置来确定类路径。当需要加载类或资源时，Java 会根据这些设置在文件系统或其他位置查找对应的文件。</p><h2 id="java-命令执行流程">java 命令执行流程</h2><p>当使用 <code>java</code> 命令执行 Java 程序时，Java 运行时会执行以下步骤：</p><ol><li>加载 Java 虚拟机（JVM）：首先，Java 运行时会加载 Java 虚拟机，它负责执行 Java 字节码。</li><li>设置类路径：Java 运行时会设置类路径（classpath），这是一个包含 Java 类文件（如 <code>.class</code> 文件）的目录和文件列表。类路径是 Java 运行时用于查找类文件的路径设置。</li><li>加载主类：Java 运行时会尝试在类路径中查找指定的主类（包括包名和类名）。例如，如果执行的命令是 <code>java com.djm.test.Main</code>，Java 运行时将在类路径中查找 <code>com.djm.test.Main</code> 类,也就是 <strong>在类路径下com/djm/test/下找到 Main.class</strong>,如果找不到就会报错,<strong>找到后会验证Main.class的包名是否跟执行包名一样</strong>,不一样也会报错</li><li>链接：链接过程包括验证、准备和解析三个阶段。验证确保类文件的结构和约束符合 Java 虚拟机规范；准备阶段为类变量分配内存并设置默认初始值；解析阶段将类中的符号引用解析为直接引用。</li><li>初始化：Java 运行时会初始化类，这包括执行类的静态初始化代码（例如静态变量的初始化和静态代码块）。</li><li>执行主方法：Java 运行时会找到主类中的 <code>main</code> 方法（它必须具有 <code>public static void main(String[] args)</code> 的签名），并执行它。这是 Java 程序的入口点。</li><li>执行程序：<code>main</code> 方法开始执行，程序按照您编写的代码逻辑进行运行。</li><li>垃圾回收：Java 程序在运行过程中，Java 虚拟机会自动进行垃圾回收，回收不再使用的对象占用的内存。</li><li>程序结束：当 <code>main</code> 方法执行完毕或者调用了 <code>System.exit()</code> 方法，Java 程序结束，Java 虚拟机关闭，释放相关资源。</li></ol><p>这些步骤概括了使用 <code>java</code> 命令执行 Java 程序的整个过程。在这个过程中，Java 运行时负责管理内存、执行字节码和处理异常等任务。</p><h2 id="jdk-jre-jvm">jdk jre jvm</h2><p>JDK（Java Development Kit）、JRE（Java Runtime Environment）和 JVM（Java Virtual Machine）是 Java 平台的三个核心组成部分。它们之间存在联系，但也有区别。下面我们详细讨论这三个组件：</p><ol><li><p>JVM（Java Virtual Machine）：</p><ul><li>Java 虚拟机是 Java 平台的基础，它为 Java 字节码提供了一个运行时环境。JVM 负责将 Java 字节码（.class 文件）翻译成与特定硬件和操作系统相对应的本地机器代码。</li><li>JVM 是平台无关的，不同的操作系统和硬件平台都有相应的 JVM 实现。这使得 Java 应用程序能够跨平台运行（“一次编写，到处运行”）。</li><li>JVM 还负责管理 Java 程序的内存分配和垃圾回收。</li></ul></li><li><p>JRE（Java Runtime Environment）：</p><ul><li>Java 运行时环境包括 JVM 以及 Java 类库（java.util、java.lang、<a href="http://java.io">java.io</a> 等）和其他运行 Java 应用程序所需的文件。</li><li>JRE 允许用户在没有安装 JDK 的情况下运行 Java 程序。这意味着用户只需要 JRE 就可以运行 Java 应用程序，而无需 JDK。</li><li>JRE 不包括开发工具，如编译器（javac）或调试器。因此，如果要开发 Java 程序，需要 JDK。</li></ul></li><li><p>JDK（Java Development Kit）：</p><ul><li>Java 开发工具包是 Java 开发人员使用的完整软件开发包，包括 JRE、编译器（javac）、调试器、文档生成器（javadoc）以及其他开发和调试 Java 程序所需的工具。</li><li>JDK 是开发 Java 应用程序所需的最低要求。它包含了 JRE，因此安装 JDK 时，无需单独安装 JRE。</li></ul></li></ol><p>总结一下：</p><ul><li>JVM 是 Java 虚拟机，提供了运行 Java 字节码的环境，并负责内存管理和垃圾回收。</li><li>JRE 是 Java 运行时环境，包括 JVM 和 Java 类库，用于运行 Java 程序。</li><li>JDK 是 Java 开发工具包，包括 JRE 和开发工具（编译器、调试器等），用于开发 Java 程序。</li></ul><p>JDK、JRE 和 JVM 之间的关系是：JDK 包含 JRE，JRE 包含 JVM。在 Java 开发和运行过程中，这三者共同协作，使得 Java 程序能够跨平台运行。</p><h2 id="路径问题">路径问题</h2><h3 id="相对路径">相对路径</h3><p>当我们使用OutputSream 和 InputStream 的时候,如果是相对路径的话,默认是从<strong>java执行命令下路径下读写文件</strong>,在idea中它自己帮我们重新设置了user.dir,<strong>因此就是相对项目路径</strong></p><blockquote><p>如果是以/开头比如 /a 是绝对路径 一般表示c盘的根目录</p></blockquote><h3 id="类路径">类路径</h3><p>类路径（Classpath）：类路径是 JVM 用来<strong>搜索类和资源文件</strong>的路径。类路径可以包含目录、JAR 文件和其他资源。可以使用 <code>System.getProperty(&quot;java.class.path&quot;)</code> 获取当前的类路径。</p><p>要从类路径加载资源文件，可以使用 <code>ClassLoader</code> 类的 <code>getResource()</code> 或 <code>getResourceAsStream()</code> 方法。这些方法将从类路径中查找资源，而不依赖于当前工作目录。例如，以下代码将尝试从类路径中加载一个名为 <code>config.properties</code> 的文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p>当使用类路径加载资源时，请确保资源文件已被包含在类路径中。对于 Java 项目，通常将资源文件放在 <code>src/main/resources</code> 目录下，以便它们在构建过程中被正确地处理。</p><h2 id="自定义注解处理器">自定义注解处理器</h2><p>在编译期间处理注解的一种方法是使用注解处理器（Annotation Processors）。注解处理器是一个工具，它在编译时扫描和处理源代码中的注解。它们通常用于生成额外的源代码、修改现有代码或验证代码约束等。Lombok 就是通过注解处理器实现的，它在编译期间生成 getter、setter 等方法。</p><p>要创建一个注解处理器，你需要遵循以下步骤：</p><ol><li>创建一个自定义注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们将保留策略设置为 <code>RetentionPolicy.SOURCE</code>，因为我们只需要在编译期间处理此注解。</p><ol start="2"><li>创建一个注解处理器：</li></ol><p>创建一个类，继承 <code>javax.annotation.processing.AbstractProcessor</code> 类，并覆盖 <code>process</code> 方法。此方法将在编译期间处理指定的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;com.example.CustomAnnotation&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAnnotationProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(CustomAnnotation.class)) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;Found @CustomAnnotation at &quot;</span> + element);</span><br><span class="line">            <span class="comment">// 在这里处理注解，例如生成源代码、修改代码或验证代码约束等</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>注册注解处理器：</li></ol><p><strong>在项目的 <code>resources/META-INF/services</code> 目录下</strong>，创建一个名为 <code>javax.annotation.processing.Processor</code> 的文件。在该文件中，写入注解处理器的完全限定类名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.CustomAnnotationProcessor</span><br></pre></td></tr></table></figure><ol start="4"><li>将注解应用于代码：</li></ol><p>在项目的其他部分，使用自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CustomAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当你编译项目时，<code>CustomAnnotationProcessor</code> 将处理 <code>@CustomAnnotation</code> 注解。在 <code>process</code> 方法中，你可以实现任何操作，如生成源代码、修改代码或验证代码约束等。</p><p>注意：要使用注解处理器，你需要将它们添加到编译器的类路径中。对于 Maven 项目，你需要将注解处理器作为依赖添加到 <code>pom.xml</code> 文件中，并在 <code>maven-compiler-plugin</code> 中启用注解处理。对于 Gradle 项目，需要将注解处理器添加到 <code>annotationProcessor</code> 配置中。不同的构建工具可能需要不同的配置方式。</p><h2 id="动态代理">动态代理</h2><h3 id="jdk动态代理">jdk动态代理</h3><p>JDK 动态代理的原理是在运行时动态地生成一个代理类，该代理类实现了目标类的接口，并将方法调用转发到一个处理器（<code>InvocationHandler</code>）。处理器负责执行实际的代理逻辑，例如在目标方法执行前后添加日志、性能监控等功能。</p><p>以下是 JDK 动态代理的主要步骤：</p><ol><li>定义一个处理器（<code>InvocationHandler</code>）实现类。这个类需要实现 <code>java.lang.reflect.InvocationHandler</code> 接口，并重写 <code>invoke</code> 方法。<code>invoke</code> 方法负责处理代理类中的方法调用，并实现需要的代理逻辑。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前执行的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在目标方法执行后执行的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用 <code>java.lang.reflect.Proxy</code> 类的 <code>newProxyInstance</code> 方法动态地创建一个代理类实例。这个方法需要三个参数：</p><ul><li>类加载器（<code>ClassLoader</code>）：用于加载生成的代理类。</li><li>代理类需要实现的接口列表：代理类将实现这些接口。</li><li>处理器（<code>InvocationHandler</code>）实例：当代理类的方法被调用时，将调用处理器的 <code>invoke</code> 方法。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyInterface</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>();</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">    target.getClass().getClassLoader(),</span><br><span class="line">    target.getClass().getInterfaces(),</span><br><span class="line">    handler</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>proxy</code> 是一个动态生成的代理类实例，它实现了 <code>MyInterface</code> 接口。当 <code>proxy</code> 的方法被调用时，会转发到 <code>MyInvocationHandler</code> 的 <code>invoke</code> 方法。<code>invoke</code> 方法中可以实现需要的代理逻辑，例如在目标方法执行前后添加日志。</p><p>总之，JDK 动态代理的原理是在运行时动态地生成代理类，并将方法调用转发到处理器（<code>InvocationHandler</code>）。处理器负责实现代理逻辑。</p><h2 id="object里面的方法">Object里面的方法</h2><p><code>java.lang.Object</code> 是 Java 中所有类的父类。当创建一个新的类时，如果没有显式地继承其他类，那么这个类将默认继承 <code>Object</code> 类。<code>Object</code> 类中的方法在任何 Java 类中都可以使用。以下是 <code>Object</code> 类中的一些主要方法及其作用：</p><ol><li><p><code>public String toString()</code>: 返回对象的字符串表示。通常需要在自定义类中覆盖此方法，以便为对象提供有意义的字符串表示。</p></li><li><p><code>public boolean equals(Object obj)</code>: 比较两个对象是否相等。通常需要在自定义类中覆盖此方法，以便根据类的属性来判断对象是否相等。</p></li><li><p><code>public int hashCode()</code>: 返回对象的哈希码值。当覆盖 <code>equals()</code> 方法时，通常也需要覆盖 <code>hashCode()</code> 方法，以便满足“相等的对象必须具有相等的哈希码”的约定。</p></li><li><p><code>protected Object clone() throws CloneNotSupportedException</code>: 创建并返回当前对象的副本。<strong>为了实现克隆功能，需要实现 <code>Cloneable</code> 接口并覆盖此方法。</strong></p></li><li><p><code>public final Class&lt;?&gt; getClass()</code>: 返回对象的运行时类。此方法可用于获取对象的类信息，如类名、接口、父类等。</p></li><li><p><code>protected void finalize() throws Throwable</code>: <strong>当对象被垃圾回收器回收时，将调用此方法。在 Java 9 中，此方法已被弃用，因为使用 <code>finalize()</code> 方法可能导致性能问题和资源泄漏。建议使用其他清理资源的方法，如 <code>try-with-resources</code> 语句或 <code>AutoCloseable</code> 接口。</strong></p></li><li><p><code>public final void wait() throws InterruptedException</code>: 使当前线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法。这个方法常用于多线程编程中的线程间同步。</p></li><li><p><code>public final void notify()</code>: 唤醒在此对象监视器上等待的单个线程。这个方法也常用于多线程编程中的线程间同步。</p></li><li><p><code>public final void notifyAll()</code>: 唤醒在此对象监视器上等待的所有线程。这个方法同样常用于多线程编程中的线程间同步。</p></li></ol><p>在自定义类中，可以根据需要覆盖这些方法，以实现特定的功能和行为。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/02/%E4%BA%91%E5%8E%9F%E7%94%9F/docker%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/12/02/%E4%BA%91%E5%8E%9F%E7%94%9F/docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>什么是docker</h1><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术(虚拟机是属于软件层面的虚拟化技术)。由于隔离的进程独立于宿主和其它的隔离的进程(既然是一个进程,当然能够直接使用系统资源)，因此也称其为容器</p><blockquote><p>以下所有操作均在CentOS Linux release 7.6.1810 (Core)中进行,仅供参考哦,不同版本可能会有区别</p></blockquote><h1>为什么要用docker</h1><p>传统的虚拟技术是利用软件虚拟出一套硬件环境,而且还需要再跑一个操作系统,所以无论执行速度,内存损耗,文件存储,都比传统的虚拟技术,而且一套dockerfile可以保证相同的环境,一次创建,到处可以运行,Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单,因此docker有以下几个优势</p><ul><li>更高效的利用系统资源</li><li>更快的启动速度</li><li>一致运行环境</li><li>更轻松的迁移</li><li>更轻松的拓展与维护</li></ul><h1>搭建与卸载</h1><h2 id="安装">安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载包管理工具</span></span><br><span class="line">yum install -y yum-utils </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置docker下载源为清华源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker</span>   </span><br><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动docker服务">启动docker服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动docker 并且设置开机自启动</span></span><br><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure><h3 id="配置docker镜像加速源">配置docker镜像加速源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;:[&quot;https://o13jbvy6.mirror.aliyuncs.com&quot;,&quot;https://docker.mirrors.ustc.edu.cn/&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docker.mirrors.ustc.edu.cn/</span><br></pre></td></tr></table></figure><h2 id="卸载">卸载</h2><p>要在 Linux 系统上彻底卸载 Docker，请按照以下步骤操作：</p><ol><li>停止 Docker 服务：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop docker.service</span><br></pre></td></tr></table></figure><ol start="2"><li>禁用 Docker 服务：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl disable docker.service</span><br></pre></td></tr></table></figure><ol start="3"><li>删除 Docker 包。根据您的系统和安装方式，命令可能略有不同。</li></ol><p>对于基于 Debian/Ubuntu 的系统，使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>对于基于 RHEL/CentOS/Fedora 的系统，使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="4"><li>删除 Docker 相关的目录和文件。以下命令将删除 Docker 的数据、配置文件和缓存文件。<strong>请注意，这将删除所有 Docker 容器和镜像，以及任何 Docker 生成的数据。在执行这些命令之前，请确保您已备份所有重要数据。</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line">sudo rm -rf /etc/docker</span><br><span class="line">sudo rm -rf /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><ol start="5"><li><p>如果您在 <code>/etc/docker/daemon.json</code> 中添加了自定义配置，请手动删除该文件。</p></li><li><p>删除所有 Docker 网络接口。这通常不是必需的，但如果您创建了自定义网络，可能需要执行此操作。首先，使用以下命令列出所有 Docker 网络接口：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link show | grep docker</span><br></pre></td></tr></table></figure><p>然后，使用以下命令删除每个接口，将 <code>INTERFACE_NAME</code> 替换为实际的接口名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link delete INTERFACE_NAME</span><br></pre></td></tr></table></figure><ol start="7"><li><p>如果您之前添加了任何 Docker 相关的环境变量或配置，请检查 <code>~/.bashrc</code>、<code>~/.bash_profile</code> 或 <code>/etc/environment</code> 文件，并删除这些设置。</p></li><li><p>最后，重新启动您的系统：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>现在，Docker 应该已从您的系统上彻底卸载。如果需要，您可以随时重新安装 Docker。</p><h1>镜像</h1><p>Docker的镜像是一个特殊的文件系统,提供容器运行时所需要的程序,库,资源,配置,以及运行时准备的参数(环境变量,用户)等等,镜像不包含动态数据,构建好后,镜像的内容也不会发生改变</p><h2 id="分层存储">分层存储</h2><p>docker的镜像是由基础镜像一层一层构建过来的,每一层的内容都只可读不可以更改,<strong>这么设计的好处是可以共享镜像</strong>,如果需要更改只能在容器层记录哪些文件被更改了,所有我们尽量把那些需要更改的文件通过容器卷的方式传递给容器,因为容器卷里面的东西不属于镜像,属于宿主机,</p><h2 id="registry">registry</h2><p>这个就代表镜像所在的仓库</p><h2 id="repository">repository</h2><p>这个是一组镜像的集合,比如centos镜像的所有版本,所以,repository是镜像的集合,registry是repository的集合</p><h2 id="manifest">manifest</h2><p>主要存在与registry中作为docker镜像的元数据文件,在pull,push,save,load中作为镜像结构与基础信息的描述文件</p><h1>容器</h1><p>容器其实就是一个进程,但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全</p><p>容器启动时,在镜像的基础上加了一层<strong>容器存储层</strong>,所有的更改操作都进行在这一层,当容器死亡的时候,这一层也将消失</p><h1>常用命令</h1><h2 id="pull">pull</h2><p>拉取一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull (地址/仓库/)镜像名字:版本号(没有版本号默认拉取最新版)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure><h2 id="images">images</h2><p>查看所有镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="image">image</h2><p><code>docker image</code> 是 Docker 中用来管理镜像的命令。以下是一些常用的子命令和参数：</p><ol><li><p><code>docker image ls</code> 或 <code>docker images</code>：列出所有本地镜像。</p><ul><li><code>-a</code>：显示所有镜像（默认隐藏中间镜像层）。</li><li><code>--digests</code>：显示摘要信息。</li><li><code>-f</code> 或 <code>--filter</code>：基于给定的条件过滤镜像。</li><li><code>--format</code>：以指定的格式输出镜像信息。</li><li><code>--no-trunc</code>：不截断输出。</li><li><code>-q</code> 或 <code>--quiet</code>：仅显示镜像ID。</li></ul></li><li><p><code>docker image pull</code>：从远程仓库拉取镜像。</p><ul><li><code>--all-tags</code> 或 <code>-a</code>：下载仓库中所有标记的镜像。</li><li><code>--disable-content-trust</code>：跳过镜像的验证。</li><li><code>--platform</code>：设置平台如果服务器是多平台的。</li></ul></li><li><p><code>docker image push</code>：将本地镜像推送到远程仓库。</p></li><li><p><code>docker image rm</code> 或 <code>docker rmi</code>：删除一个或多个镜像。</p><ul><li><code>-f</code> 或 <code>--force</code>：强制删除镜像。</li><li><code>-noprune</code>：不删除未被使用的父镜像。</li></ul></li><li><p><code>docker image build</code>：构建一个新的镜像。</p></li><li><p><code>docker image inspect</code>：显示一个或多个镜像的详细信息。</p></li><li><p><code>docker image history</code>：显示镜像的历史记录。</p></li></ol><p>以上就是 <code>docker image</code> 的一些常用命令和参数，更详细的列表可以通过 <code>docker image --help</code> 命令查看。具体使用哪个参数会根据你的实际需求和使用的镜像而有所不同。</p><h2 id="rmi">rmi</h2><p>删除镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名字或者id</span><br><span class="line">docker rmi $(docker images -q)  # 删除所有镜像</span><br></pre></td></tr></table></figure><h2 id="run">run</h2><p>基于镜像启动一个容器</p><ul><li>-i 开启交互式</li><li>-t 分配一个终端</li><li>-d 后台运行</li><li>-p 本地端口:容器端口 做端口映射</li><li>–privileged 在容器内真正的拥有root权限</li><li>-v 设置容器卷</li><li>-w 设置进入容器的工作目录</li><li>–rm 容器退出后,删除容器</li><li>–name 设置名字</li><li>–network 设置要连接到网络名字</li><li>–entrypoint 设置容器启动时执行的命令,如果用了这个参数,后面输入的shell命令会当成参数</li></ul><blockquote><p>如果镜像不存在,会去自动拉取</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name centostest centos:7</span><br></pre></td></tr></table></figure><h2 id="exec">exec</h2><p>在运行的容器中执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名字/id bash</span><br><span class="line">docker exec -it centostest bash</span><br><span class="line">docker exec centostest ls /</span><br></pre></td></tr></table></figure><ul><li>-i 将当前终端输入流给容器</li><li>-t 分配一个终端</li><li>-w 指定工作目录</li><li>-e 指定环境变量</li><li>-u 指定用户</li></ul><h2 id="logs">logs</h2><p>查看容器后台输出的信息,方便我们纠错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs centostest</span><br><span class="line">docker logs -f centostest # 实时日志</span><br></pre></td></tr></table></figure><h2 id="stop">stop</h2><p>关闭一个容器  docker stop  id或者名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop centostest</span><br></pre></td></tr></table></figure><h2 id="restart">restart</h2><p>重启一个容器 docker restart id 或者名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart centostest</span><br></pre></td></tr></table></figure><h2 id="rm">rm</h2><p>删掉一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f id或者名字</span><br><span class="line">docker rm -f $(docker ps -aq) #删除所有容器</span><br></pre></td></tr></table></figure><h2 id="rename">rename</h2><p>更改容器的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename centostest centos7</span><br></pre></td></tr></table></figure><h2 id="ps">ps</h2><p>与linux的ps功能差不多</p><ul><li>docker ps 查看运行的容器</li><li>docker ps -a 查看运行和停止的容器</li></ul><h2 id="commit">commit</h2><p>将容器打包成镜像(不推荐使用,建议使用build),这个</p><ul><li>–message 打包说明</li><li>–author 作者</li><li>docker commit 容器  (仓库名字)镜像:标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit nginx mynginx:v1</span><br></pre></td></tr></table></figure><h2 id="cp">cp</h2><p>在容器和本地文件系统之间复制文件或文件夹</p><ul><li>docker cp &lt;container_id&gt;:&lt;container_path&gt;  &lt;local_path&gt;  将容器中的内容复制到本地</li><li>docker cp &lt;local_path&gt;  &lt;container_id&gt;:&lt;container_path&gt; 将本地内容复制到容器中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp centos7:/root ./test</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ./test centos7:/root/test</span><br></pre></td></tr></table></figure><h2 id="diff">diff</h2><p>拿容器层与镜像层做对比,看多了哪些,修改了哪些,删除了哪些东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff centos7</span><br></pre></td></tr></table></figure><h2 id="inspect">inspect</h2><p>查看容器,网络,镜像,容器卷,网络的详细信息或者说元信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect </span><br></pre></td></tr></table></figure><h2 id="network">network</h2><ul><li>create -d 类型(一般用bridge,也是默认值) 网络名字 创建一个网络</li><li>rm 删除一个网络</li><li>prune 删除未使用的网络</li><li>connect 将容器加入到某个网络当中去</li><li>disconnect  将容器从某个网络中移除</li></ul><h4 id="示例">示例</h4><p>创建一个网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-network</span><br></pre></td></tr></table></figure><p>创建两个容器,使用两种不同的方式加入网络吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name container1 --network my-network busybox  # 创建的时候就加入网络</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name container2  busybox</span><br><span class="line">docker network connect my-network container2  # 后面再加入网络</span><br></pre></td></tr></table></figure><p>进入到container1中ping container2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it container1 sh</span><br><span class="line">ping container2</span><br></pre></td></tr></table></figure><p>会发现是可以ping 通的</p><p>删除网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f container1 container2  # 得先删除属于这个网络的容器,或者移除 </span><br><span class="line">docker network rm my-network</span><br></pre></td></tr></table></figure><h4 id="答疑">答疑</h4><p>Docker 不会在 <code>/etc/hosts</code> 文件中为每个容器添加条目。相反，Docker 使用内置的 DNS 服务器来实现容器之间的名称解析。当您将容器连接到用户定义的网络（如本示例中的 <code>my-network</code>）时，Docker 会自动为该网络配置一个内置 DNS 服务器。容器可以使用这个 DNS 服务器来解析其他容器的名称。</p><p>在我们的示例中，<code>container1</code> 和 <code>container2</code> 都连接到了 <code>my-network</code>。当您从 <code>container1</code> 尝试 ping <code>container2</code> 时，<code>container1</code> 会向 Docker 内置的 DNS 服务器发送一个 DNS 请求，以解析 <code>container2</code> 的 IP 地址。DNS 服务器会返回 <code>container2</code> 的 IP 地址，然后 <code>container1</code> 可以通过 IP 地址与 <code>container2</code> 进行通信。</p><p>请注意，这种名称解析功能仅在用户定义的网络中可用。对于默认的桥接网络（<code>bridge</code>），容器需要使用 IP 地址进行通信，或者您需要手动更新 <code>/etc/hosts</code> 文件以添加容器名称和 IP 地址的映射。这就是为什么建议在需要容器间通信时使用用户定义的网络。</p><p>我们可以查看这个网络的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-network</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-network&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aaa94bd17fe571805aa60cdf4ca5dc2ef7252b3ac26b45c4f97861c5303e63aa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-05-03T01:35:46.849865799-07:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EnableIPv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Internal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Attachable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Ingress&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigFrom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConfigOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;0425b460b23ab302a321987e57f80c0c22ec8d212261fcea2cc1023b62aa44e9&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;container1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;EndpointID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;857cca4d333a6989f47a107677e47f720410c3888c098d4f952e0ccb6797f6d2&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;MacAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02:42:ac:12:00:02&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.2/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;IPv6Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;48bcbe65a098ea7d96feebd0a72a4f731ea8cf475872e0ebaf983ac225af0aa2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;container2&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;EndpointID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1db1fd068f327f11f1df3bc1339b266d030938e95411a8f2bef3db826c3290a9&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;MacAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02:42:ac:12:00:03&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.3/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;IPv6Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="volume">volume</h2><ul><li>create name 创建一个容器卷</li><li>rm name/id 删除一个容器</li><li>ls 列出容器卷</li><li>inspect name/id 查看容器卷的元信息</li><li>prune 删除没有在使用的容器卷(只要有容器挂载,不管是运行的容器,还是停止的容器,都算在使用)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-volume # 创建一个容器卷</span><br><span class="line"></span><br><span class="line">docker volume rm my-volume # 删除,如果有容器挂载了,那么无法删除</span><br><span class="line"></span><br><span class="line">docker inspect my-volume # 查看容器卷信息</span><br><span class="line"></span><br><span class="line">docker volume ls #列出容器卷</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="build">build</h2><p>基于dockerfile构建一个镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><ul><li><code>OPTIONS</code>：构建镜像时使用的选项。</li><li><code>PATH</code>：Dockerfile 所在的本地路径。通常为当前目录（<code>.</code>）。 这个目录就是上下文路径</li><li><code>URL</code>：从远程仓库（如 GitHub）获取 Dockerfile 的 URL。</li><li><code>-</code>：从标准输入（stdin）读取 Dockerfile。</li></ul><p>常用的 <code>docker build</code> 选项：</p><ol><li><code>-t</code> 或 <code>--tag</code>：为构建的镜像指定一个名称和可选的标签（格式为 <code>name:tag</code>）。如果没有指定标签，将使用 <code>latest</code> 作为默认标签。示例：<code>-t myimage:1.0</code>。</li><li><code>--build-arg</code>：设置构建参数。这些参数可以在 Dockerfile 中使用 <code>ARG</code> 指令定义。示例：<code>--build-arg API_KEY=myapikey</code>。</li><li><code>--no-cache</code>：在构建过程中不使用缓存。默认情况下，Docker 会使用缓存以加速构建过程。</li><li><code>--file</code> 或 <code>-f</code>：指定一个非默认名称或位置的 Dockerfile。<strong>默认情况下，Docker 会在构建上下文路径中查找名为 <code>Dockerfile</code> 的文件</strong>。示例：<code>-f mydockerfile</code>。</li><li><code>--rm</code>：在构建过程完成后删除中间容器。默认为 true。</li><li><code>--pull</code>：尝试从远程仓库拉取基础镜像的新版本，即使本地已经存在该镜像。默认为 false。</li></ol><p>示例：</p><ol><li><p><strong>使用当前目录下的 <code>Dockerfile</code> 构建一个名为 <code>myapp</code> 的镜像</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myapp .</span><br></pre></td></tr></table></figure></li><li><p><strong>从 GitHub 仓库中的 <code>Dockerfile</code> 构建镜像</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myapp https://github.com/user/repo.git</span><br></pre></td></tr></table></figure></li><li><p>使用名为 <code>custom.dockerfile</code> 的文件构建镜像，并设置构建参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myapp --build-arg API_KEY=myapikey -f custom.dockerfile .</span><br></pre></td></tr></table></figure></li></ol><p>在构建过程中，Docker 会按照 Dockerfile 中的指令逐步执行，并为每个指令创建一个新的层。当所有指令执行完成后，Docker 将构建出一个新的镜像。如果在构建过程中遇到错误，Docker 将返回错误信息，您可以根据错误信息修改 Dockerfile 并重新尝试构建。</p><h2 id="history">history</h2><p>查看镜像的构建历史命令</p><ul><li>–no-trunc 查看完整命令(默认只能看到前几个字符)</li></ul><h2 id="tag">tag</h2><p>可以改变一个镜像的仓库名字,镜像名字,版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest mynginx:v1</span><br></pre></td></tr></table></figure><h2 id="export">export</h2><p>将一个容器导出成一个文件,但是这么打包出来的镜像,它只会包含一层了,所以不会保存所有的commit记录,比如说你的CMD命令,entrypoint的这些都不会保存,因此在打出的镜像执行的时候需要去重新输入CMD命令才能保证容器继续运行</p><blockquote><p>export 只能打包容器</p></blockquote><p>格式:  docker export 容器名字或者id -o 打包的名字.tar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export nginx -o mynginx.tar</span><br></pre></td></tr></table></figure><h2 id="import">import</h2><p>将本地或者远程文件导入成镜像</p><p>格式:  docker import  打包镜像名字 镜像名字:版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import ./my-nginx.tar my-nginx:v2</span><br></pre></td></tr></table></figure><p>这样的镜像直接是运行不了的,需要我们手动输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mynginx nginx /docker-entrypoint.sh &quot;nginx&quot; &quot;-g&quot; &quot;daemon off;&quot; </span><br></pre></td></tr></table></figure><h2 id="save-和-load">save 和 load</h2><p><code>docker save</code> 和 <code>docker load</code> 是 Docker 中<strong>用来进行镜像备份和恢复的命令</strong>。</p><ol><li><p><code>docker save</code> 命令可以将一个或多个镜像保存为一个 tar 文件，这个 tar 文件可以被传输到其他系统或作为备份存在。其基本的用法如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;path <span class="keyword">for</span> generated tar file&gt; &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>例如，如果你想将名为 <code>my_image:latest</code> 的镜像保存到当前目录下的 <code>my_image.tar</code> 文件中，你可以运行以下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o my_image.tar my_image:latest</span><br></pre></td></tr></table></figure></li><li><p><code>docker load</code> 命令可以从一个 tar 文件中加载一个或多个镜像。其基本的用法如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i &lt;path to image tar file&gt;</span><br></pre></td></tr></table></figure><p>例如，如果你想从 <code>my_image.tar</code> 文件中加载镜像，你可以运行以下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i my_image.tar</span><br></pre></td></tr></table></figure></li></ol><p>这样，你就可以很容易地将 Docker 镜像从一个系统传输到另一个系统，或者在需要时恢复备份的镜像了。如果需要打包容器的话,那还得先commit</p><h2 id="tag">tag</h2><p><code>docker tag</code> 命令主要用于给 Docker 镜像添加标签。<strong>每个 Docker 镜像可以有多个标签，这些标签用于识别镜像的不同版本或者不同用途。</strong>, 比如如果要上传镜像到服务器, 有时候就要给镜像</p><h1>容器卷</h1><p>Docker 中的容器卷（Volume）是一种用于<strong>持久化和共享容器数据的机制</strong>。<strong>容器卷独立于容器生命周期，即使容器被删除，卷中的数据仍然存在。容器卷可以被一个或多个容器挂载，以便在容器之间共享数据。</strong></p><p>与直接将宿主机的目录挂载到容器相比，使用容器卷具有以下优点：</p><ol><li>数据持久化：容器卷可以在容器之间持久化数据，即使容器被删除，数据仍然存在。</li><li>数据共享：容器卷可以被多个容器同时挂载，从而实现数据共享。</li><li>容器迁移：容器卷可以方便地在不同的宿主机之间迁移，使得数据迁移变得更加容易。</li><li>性能：容器卷通常具有更好的性能，因为它们直接由 Docker 管理。</li><li>隔离：容器卷可以提供更好的隔离，因为它们不依赖于宿主机的文件系统结构。</li></ol><h2 id="容器卷类型">容器卷类型</h2><ol><li><p><strong>匿名卷（Anonymous volume）：</strong></p><p>使用 <code>-v</code> 时，如果仅提供容器内的路径，Docker 会在宿主机上为卷自动生成一个唯一的 ID，而不是指定的名称。这被称为匿名卷。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /container/path your_image</span><br></pre></td></tr></table></figure><p>在这种情况下，Docker 将在容器的 <code>/container/path</code> 目录下创建一个匿名卷。由于未指定卷名称，数据将存储在宿主机的 Docker 卷目录下的一个随机目录中。</p></li><li><p><strong>命名卷（Named volume）：</strong></p><p>如果同时指定卷名称和容器内路径，就可以创建一个命名卷。命名卷允许您更轻松地引用和管理数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v volume_name:/container/path your_image</span><br></pre></td></tr></table></figure><p>在这种情况下，Docker 将在容器的 <code>/container/path</code> 目录下创建一个名为 <code>volume_name</code> 的卷。数据将存储在宿主机的 Docker 卷目录下的一个子目录中，该子目录的名称与指定的卷名称相同。</p></li><li><p><strong>绑定挂载（Bind mount）：</strong></p><p>如果提供宿主机上的一个路径和容器内的一个路径，就可以创建一个绑定挂载。绑定挂载将容器内的路径映射到宿主机上的路径，从而允许对宿主机上的文件和目录进行读写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /host/path:/container/path your_image</span><br></pre></td></tr></table></figure><p>在这种情况下，Docker 将宿主机上的 <code>/host/path</code> 目录映射到容器的 <code>/container/path</code> 目录。这意味着在容器内对 <code>/container/path</code> 目录的任何更改都会直接反映到宿主机上的 <code>/host/path</code> 目录中，反之亦然。</p></li></ol><blockquote><p>不论哪边路径不存在,默认都会创建一个这样的路径,而且宿主机的目录会挂载到容器上,所以,容器对应路径里面的内容是不可见的,不是覆盖了</p></blockquote><h2 id="挂在多个容器卷">挂在多个容器卷</h2><p>一个容器可以挂载多个卷，并且可以为每个卷指定权限。您可以使用 <code>:ro</code>（read-only，只读）或 <code>:rw</code>（read-write，读写）标志为卷指定权限。默认情况下，卷是以读写模式挂载的。</p><p>例如，假设您有两个卷：<code>volume1</code> 和 <code>volume2</code>，您希望将 <code>volume1</code> 以只读模式挂载到容器的 <code>/data1</code> 目录，将 <code>volume2</code> 以读写模式挂载到容器的 <code>/data2</code> 目录。您可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v volume1:/data1:ro -v volume2:/data2:rw your_image</span><br></pre></td></tr></table></figure><p>权限问题,当我们使用容器卷的时候,会发现里面的数据我们居然没办法查看,也没有办法创建文件,这个时候,我们需要使用  --privileged=true 创建容器</p><h2 id="容器卷的迁移">容器卷的迁移</h2><p>如果您需要在不同机器之间迁移容器卷，可以使用以下方法之一来实现：</p><p><strong>方法一：使用 <code>docker cp</code> 命令备份和恢复容器卷数据</strong></p><ol><li><p>首先，创建一个临时容器，并将要迁移的卷挂载到该容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name temp_container -v my_volume:/data busybox sleep infinity</span><br></pre></td></tr></table></figure><p>这里，我们使用了一个名为 <code>my_volume</code> 的卷，并将其挂载到了 <code>/data</code> 目录。</p></li><li><p>使用 <code>docker cp</code> 命令从临时容器中复制卷数据到宿主机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp temp_container:/data /path/to/backup</span><br></pre></td></tr></table></figure><p>这将把卷数据复制到宿主机的 <code>/path/to/backup</code> 目录。</p></li><li><p>将备份数据传输到目标机器。您可以使用 <code>scp</code>、<code>rsync</code> 或其他文件传输工具来实现这一步。</p></li><li><p>在目标机器上创建一个新的卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_new_volume</span><br></pre></td></tr></table></figure></li><li><p>在目标机器上创建一个新的临时容器，并将新卷挂载到该容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name new_temp_container -v my_new_volume:/data busybox sleep infinity</span><br></pre></td></tr></table></figure></li><li><p>将备份数据从目标机器的宿主机复制到新的临时容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /path/to/backup new_temp_container:/data</span><br></pre></td></tr></table></figure></li><li><p>最后，删除两个临时容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f temp_container new_temp_container</span><br></pre></td></tr></table></figure></li></ol><p><strong>方法二：使用 <code>docker save</code> 和 <code>docker load</code> 命令备份和恢复带有卷数据的镜像</strong></p><p>此方法适用于卷数据和应用程序代码一起打包在 Docker 镜像中的场景。</p><ol><li><p>使用 <code>docker save</code> 命令将镜像导出为 <code>.tar</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o my_image.tar my_image</span><br></pre></td></tr></table></figure></li><li><p>将 <code>.tar</code> 文件传输到目标机器。</p></li><li><p>在目标机器上使用 <code>docker load</code> 命令导入镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i my_image.tar</span><br></pre></td></tr></table></figure></li></ol><p>注意：这两种方法都需要手动备份和恢复容器卷数据。在迁移过程中，务必确保不会丢失任何数据。根据您的需求和环境，选择最适合您的方法。</p><h1>构建镜像</h1><h2 id="commit">commit</h2><p>当我们使用commit 之后,是将<strong>当前容器的存储层+原来的镜像打包成一个新的镜像</strong>,这样容器的存储层就会被保留下来,后面也无法再更改,如果我们使用了卷的话,这个东西并不属于存储层,自然不会被保存</p><p>启动一个nginx的容器,并且修改它的index页面,然后commit打包成一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个容器,并设置端口映射</span></span><br><span class="line">docker run -d --name nginx -p 8080:80 nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入这个容器</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改默认页面</span></span><br><span class="line">echo &quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器 <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问虚拟机8080 端口</span> </span><br><span class="line">curl localhost:8080 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出&lt;h1&gt;hello world&lt;/h1&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将容器做成镜像</span></span><br><span class="line">docker commit --author &quot;djm&quot; --message &quot;修改了默认网页&quot; nginx mynginx:v1 </span><br><span class="line"></span><br><span class="line">docker images #查看我们自己的镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过打包好的镜像启动容器</span></span><br><span class="line">docker run -d --name nginx1  -p 8081:80 mynginx:v1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问ip:8081就能访问到我们修改的页面</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">尽量不要使用docker commit 来制作镜像,这样不利于我们使用分层镜像,而且也不利于修改镜像,每一次commit都要在原有的基础上新增,而如果使用build的话,可以充分利用以前的镜像分层, 还有就是commit的话是不知道我们在容器的基础上干了些什么的</span></span><br></pre></td></tr></table></figure><h3 id="注意点">注意点</h3><ul><li><code>docker commit</code> <strong>不会保存容器的运行状态，只会保存文件系统状态和部分配置</strong>，比如环境变量等。</li><li>默认情况下，新镜像会保留原始镜像的 <code>CMD</code> 和 <code>ENTRYPOINT</code> 指令。如果需要，可以使用 <code>-c</code> 或 <code>--change</code> 选项来修改这些指令。</li><li><code>docker commit</code> 不会保留镜像的构建历史和构建上下文。<strong>也就是说看不到对容器执行了哪些命令,影响了哪些文件</strong></li></ul><h2 id="dockerfile">dockerfile</h2><h3 id="常用配置项">常用配置项</h3><p>抱歉刚刚没有详细列出 Dockerfile 的所有配置项。以下是 Dockerfile 中的一些主要指令及其用途：</p><ol><li><code>FROM</code>: 指定基础镜像。例如：<code>FROM ubuntu:20.04</code>。</li><li><code>LABEL</code>: 添加元数据标签，如维护者信息。例如：<code>LABEL maintainer=&quot;your_name &lt;your_email@example.com&gt;&quot;</code>。</li><li><code>RUN</code>: 执行命令，用于安装软件包、更新配置文件等。例如：<code>RUN apt-get update &amp;&amp; apt-get install -y nginx</code>。</li><li><code>CMD</code>: 设置容器启动时运行的默认命令。如果在 <code>docker run</code> 时传递了参数，<code>CMD</code> 中的命令将被覆盖。例如：<code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code>。</li><li><code>ENTRYPOINT</code>: 设置容器启动时运行的命令，与 <code>CMD</code> 类似，但不会被 <code>docker run</code> 时传递的参数覆盖。例如：<code>ENTRYPOINT [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code>。</li><li><code>COPY</code>: 将本地文件复制到镜像中。例如：<code>COPY index.html /var/www/html/</code>。<strong>这里本地文件可以使用相对路径,相对上下文路径来说</strong></li><li><code>ADD</code>: 与 <code>COPY</code> 类似，但可以在复制之前执行解压操作。例如：<code>ADD myapp.tar.gz /app/</code>。</li><li><code>WORKDIR</code>: 设置镜像中的工作目录。例如：<code>WORKDIR /app</code>。</li><li><code>ENV</code>: 设置环境变量。例如：<code>ENV MY_VAR=my_value</code>。</li><li><code>EXPOSE</code>: 声明容器需要监听的端口。例如：<code>EXPOSE 8080</code>。<strong>告诉别人我内部使用了什么端口,好让别人运行这个容器的时候做端口映射</strong></li><li><code>USER</code>: 设置运行容器的用户。例如：<code>USER myuser</code>。</li><li><code>VOLUME</code>: 定义匿名卷，用于数据持久化和共享。例如：<code>VOLUME /var/lib/mysql</code>。<strong>告诉别人我内部有哪里的数据是可以使用容器卷的,让别人指定容器卷,然后保留容器运行产生的数据</strong></li><li><code>ARG</code>: 定义构建时变量，可以在 <code>docker build</code> 命令中使用 <code>--build-arg</code> 参数设置。例如：<code>ARG MY_BUILD_ARG</code>。</li><li><code>ONBUILD</code>: 为基础镜像添加触发器，在其他镜像中使用该基础镜像时触发。例如：<code>ONBUILD RUN echo &quot;Hello from base image&quot;</code>。</li><li><code>STOPSIGNAL</code>: 设置停止容器时发送的信号。例如：<code>STOPSIGNAL SIGQUIT</code>。</li><li><code>SHELL</code>: 设置运行 <code>RUN</code>, <code>CMD</code> 和 <code>ENTRYPOINT</code> 指令时使用的默认 shell。例如：<code>SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;]</code>。</li></ol><h3 id="注意点">注意点</h3><p>Dockerfile 是一个文本文件，其中包含了一系列用于构建 Docker 镜像的指令。编写 Dockerfile 时，需要注意以下几点：</p><ol><li>从基础镜像开始：使用 <code>FROM</code> 指令来指定基础镜像。例如：<code>FROM ubuntu:20.04</code>。</li><li>标签：为了便于维护和版本控制，尽量使用具体的基础镜像标签，而不是 <code>latest</code>。</li><li>维护者信息：使用 <code>LABEL</code> 指令添加维护者信息。例如：<code>LABEL maintainer=&quot;your_name &lt;your_email@example.com&gt;&quot;</code>。</li><li>运行命令：使用 <code>RUN</code> 指令来执行安装软件包、更新配置文件等操作。避免在一个 <code>RUN</code> 指令中执行过多操作，以免产生过大的镜像层。另外，可以使用反斜杠（<code>\</code>）在多行书写这些命令以提高可读性。</li><li>分层：<strong>合理安排 Dockerfile 中的指令顺序，将经常变动的部分放在底部，以便充分利用镜像缓存</strong>。</li><li>复制文件：使用 <code>COPY</code> 和 <code>ADD</code> 指令将本地文件复制到镜像中。尽量使用 <code>COPY</code>，因为它更简单，只复制文件；而 <code>ADD</code> 在复制文件之前还可以执行解压操作。</li><li>工作目录：使用 <code>WORKDIR</code> 指令设置镜像中的工作目录。这会影响后续指令的相对路径。</li><li>设置环境变量：使用 <code>ENV</code> 指令设置环境变量。例如：<code>ENV MY_VAR=my_value</code>。</li><li>暴露端口：使用 <code>EXPOSE</code> 指令声明容器需要监听的端口。例如：<code>EXPOSE 8080</code>。</li><li>设置用户：使用 <code>USER</code> 指令设置运行容器的用户，以避免使用 root 用户运行应用程序。例如：<code>USER myuser</code>。</li><li>容器启动命令：使用 <code>CMD</code> 或 <code>ENTRYPOINT</code> 指令设置容器启动时运行的命令。<code>CMD</code> 可以被 <code>docker run</code> 时传递的参数覆盖，而 <code>ENTRYPOINT</code> 则不会。</li></ol><p>为了更好地编写 Dockerfile，请注意以下几点：</p><ul><li><strong>保持 Dockerfile 简洁：删除不必要的指令，减少镜像层数</strong>。</li><li>使用多阶段构建：通过使用多个 <code>FROM</code> 指令，可以将构建过程分为多个阶段，以减小最终镜像的大小。</li><li>避免使用 <code>sudo</code>：Dockerfile 中的指令默认以 root 用户身份运行，因此不需要使用 <code>sudo</code>。</li><li>**清理缓存：**在安装软件包或执行其他操作时，确保在同一个 <code>RUN</code> 指令中清理不必要的缓存文件，以减小镜像大小。例如，在使用 <code>apt-get</code> 安装软件包后，可以运行 <code>apt-get clean</code> 和 <code>rm -rf /var/lib/apt/lists/*</code> 来清理缓存。</li><li><strong>避免在容器中运行 SSH</strong>：尽量不要在容器中运行 SSH 服务，因为这会增加安全风险。取而代之的是，使用 <code>docker exec</code> 命令来进入正在运行的容器。</li><li><strong>使用 <code>.dockerignore</code> 文件</strong>：创建一个 <code>.dockerignore</code> 文件以排除不需要复制到镜像中的文件，从而减小镜像大小。</li><li>文档和注释：在 Dockerfile 中添加必要的注释和文档，以提高可读性和可维护性。</li><li>定期更新和审查：定期更新基础镜像、软件包和配置，以确保容器始终运行在最新且安全的环境中。同时，定期审查 Dockerfile，以确保其符合最佳实践。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dockerfile 的编写</span></span><br><span class="line"></span><br><span class="line">ARG 设置环境变量(放在FROM前面,变量只能在所有FROM里面使用,放在其他指令前面,只有那一个指令能用)</span><br><span class="line">FROM 基础镜像(名字:版本号)  (scratch 空镜像)</span><br><span class="line">ENV 设置环境变量(到时候容器里面会存在这个变量哦)</span><br><span class="line">RUN 命令   </span><br><span class="line">CP 源路径(相对于上下文来说) 目标路径(可以相对于容器来说,也可以相对于容器里面的工作目录(通过WORKDIR指定来说)</span><br><span class="line">ADD 压缩包路径(相对于上下文) 目录路径(同上)  add 可以做其他的事(和cp一样的功能,下载文件),但是推荐只做这个事情</span><br><span class="line">CMD [&quot;可执行文件&quot;,&quot;参数&quot;] 容器启动时默认执行命令,当然我们自己写的命令会替换掉这个,CMD里面的命令会最终被替换成sh -c &quot;可执行文件&quot;,&quot;参数&quot;</span><br><span class="line">ENTRYPOINT [&quot;可执行文件&quot;,&quot;参数&quot;,CMD] 这个命令和CMD命令的目的都是一样的,让容器启动的时候执行一些命令,但是如果这个命令与CMD</span><br><span class="line">一起使用的时候,CMD里面的东西会被当成参数,默认这个命令是不会被替换掉的,我们需要使用--entrypoint来指定</span><br><span class="line">VOLUME 定义一个匿名卷,如果用户没有指定容器卷,我们也能挂在一个匿名卷,把动态数据放在容器卷中,这样就能防止一些动态数据的写操作发生在容器层</span><br><span class="line">WORKDIR 指定容器的工作目录,可以使用绝对路径和相对路径,相对路径是相对于上次的WORKDIR来说的,最初始的WORKDIR在/ (这个是会影响到后面的层的)</span><br><span class="line">USER 切换用户 ,这个用户必须事先存在(这个也会影响到后面的层</span><br><span class="line">HEALTHCHECK 健康检查,检查容器有没有出什么异常,通过返回值判断</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s CMD curl -fs http://localhost/ || exit 1  </span><br><span class="line">每5秒执行一次,如果超过这个时间没有返回数据,则说明出异常,返回0代表正常,1代表异常</span><br><span class="line">ONBUILD 为子镜像执行的命令,后面可以跟RUN,CMD这些</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dockerfile 的流程解释</span><br><span class="line"></span><br><span class="line">要想明白dockerfile 咱们就得知道docker commit 制作镜像,dockerfile 其实也就是使用了它做镜像</span><br><span class="line"></span><br><span class="line">FROM -&gt; 启动一个容器</span><br><span class="line">ENV -&gt; 定义一些变量供下面的命令使用</span><br><span class="line">RUN  -&gt; 进入容器更改文件或者安装东西然后 commit  所以我们不要写很多run(如果有很多命令,我们可以使用&amp;&amp;连接起来) </span><br><span class="line">不然就会commit很多次,这样的镜像很臃肿 </span><br><span class="line">(我们最好写一组清理工作的命令,将那些没有用的文件给删掉)</span><br><span class="line">CP -&gt; 将上下文里面的东西复制到容器里面 会将源文件的各种元数据都保留(所有者,所属组) 我们可以通过 --chown=user:group来更改</span><br><span class="line">ADD -&gt; 将压缩包解压,也可以使用--chown=user:group 这个参数</span><br><span class="line">CMD -&gt; 相当于 docker run -d CMD 这样,所有我们不要瞎写CMD,如果CMD命令执行完了,那么这个进程就执行完了,容器一起来就结束(cmd与ENTRYPOINT只会执行一次,多写了没用)</span><br></pre></td></tr></table></figure><p>再以上面commit的例子来一遍dockerfile的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir mynginx &amp;&amp; cd mynginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认支持dockerfile Dockerfile 可以构建的时候使用-f指定dockerfile的路径</span></span><br><span class="line">vim Dockerfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写dockerfile</span></span><br><span class="line">FROM nginx</span><br><span class="line">RUN echo &quot;&lt;h1&gt;hello world DJM NB&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建dockerfile</span> </span><br><span class="line">docker build -t mynginx:v2 .  #这个.是上下文路径,不是dockerfile的路径哦</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出的东西</span></span><br><span class="line">Sending build context to Docker daemon 2.048 kB #将上下文的东西发给docker守护进程</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">88736fe82739</span></span><br><span class="line">Step 2/2 : RUN echo &quot;&lt;h1&gt;hello world DJM NB&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> fbccf519f6af</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">873049df2a75</span></span><br><span class="line">Removing intermediate container fbccf519f6af</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看我们的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行容器</span></span><br><span class="line">docker run -d --name nginx2 -p 8082:80 mynginx:v2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看网页</span></span><br></pre></td></tr></table></figure><p>docker build 的流程</p><p>首先将上下文中不在.dockerignore里面的文件全部(是全部哦,所以你的上下文中,不要多一些乱七八糟没有用的东西)发送给docker服务端(守护进程),然后再依次执行dockerfile里面的指令</p><p>注意点:</p><ul><li>默认情况下,是在上下文里面找dockerfile,不过我们可以通过-f 来指定dockerfile的路径</li><li>在dockerfile的编写时,使用cp 或者 add命令的时候, 要访问上下文里面的文件时候,要使用./ 开头,不能使用绝对路径这样,除非你把上下文放到了根目录下面,这样你会将硬盘里面的文件全部发送给守护进程</li></ul><p>挖个坑</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">touch</span> /data/file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请问我将上面这个dockerfile build生成镜像然后运行容器的时候,这个文件会存在吗?</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 答案是:不会</span></span><br><span class="line">我们来分析一下流程:</span><br><span class="line">首先拿到基础镜像,启动一个挂在了本地无名容器卷的容器,这样容器里面就有了/data目录,然后在/data里面创建文件,然后进行提交</span><br><span class="line">但是/data目录的东西并不会被打包,它不属于容器,提交后,docker再把这个无名卷删掉了,所有压根就不会有这个文件存在,只会有/data目录</span><br><span class="line">总结: 要判断创建文件会不会存在镜像中,我们只需要判断这个文件的创建是在挂在容器卷之前还是之后,如果是挂在容器卷之前,而且正好是在容器卷下面创建的,那么不会存在,不然就会存在</span><br><span class="line">这个<span class="keyword">VOLUME</span><span class="language-bash"> 选项就是为了防止用户不设置容器卷,也能有一个匿名卷,还有就是能给给使用者留点讯息</span></span><br></pre></td></tr></table></figure><h2 id="对比">对比</h2><p><code>docker commit</code> 和 <code>docker build</code> 都用于创建 Docker 镜像，但它们之间存在一些关键差异。以下是它们之间的对比：</p><ol><li><p><strong>构建过程</strong>：</p><ul><li><p><code>docker commit</code>：从现有的容器创建新的镜像。首先，您需要启动一个容器，对其进行更改（例如安装软件或修改配置文件），然后使用 <code>docker commit</code> 命令将这些更改保存到新的镜像。</p></li><li><p><code>docker build</code>：使用 Dockerfile 描述的一系列指令来创建镜像。Docker 会根据 Dockerfile 中的指令自动执行容器的更改、提交和删除。这为镜像构建过程提供了自动化和可重复性。</p></li></ul></li><li><p><strong>可重复性和可维护性</strong>：</p><ul><li><p><code>docker commit</code>：<strong>手动执行更改和提交可能导致不一致和难以追踪的结果。当需要修改镜像时，您需要记住并手动执行所有更改和提交。</strong></p></li><li><p><code>docker build</code>：Dockerfile <strong>提供了一种声明式的方式来描述镜像构建过程。这使得在不同环境中构建相同镜像变得简单，也有助于团队成员之间共享构建过程。此外，当需要修改镜像时，可以轻松地查看和编辑 Dockerfile。</strong></p></li></ul></li><li><p><strong>层次结构和缓存</strong>：</p></li></ol><ul><li><p><code>docker commit</code>：当您使用 <code>docker commit</code> 创建镜像时，所有更改都会保存在单个镜像层中。这可能导致较大的镜像和较低的缓存效率。</p></li><li><p><code>docker build</code>：<code>docker build</code> 会为 Dockerfile 中的每个指令创建一个新的镜像层。这有助于更好地管理镜像的大小和缓存。例如，如果只更改了 Dockerfile 中的一个指令，那么 Docker 只需要重新构建该指令对应的层，而无需重新构建整个镜像。这有助于加速构建过程。</p></li></ul><p>总的来说，虽然 <code>docker commit</code> 可以用于从现有容器创建新镜像，但在大多数情况下，建议使用 <code>docker build</code> 和 Dockerfile 来构建镜像。这样可以确保镜像构建过程的可重复性、可维护性以及更高效的层次结构和缓存管理。</p><h1>docker-compose</h1><p>这个东西是用来管理docker容器的,那么多docker容器,难道我们每次部署都要去一一启动并且配置吗?那多麻烦,得用docker-compose去管理</p><h2 id="安装">安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">赋予权限</span></span><br><span class="line">chmod o+x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>配置好自动自动补全</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -L https://raw.githubusercontent.com/docker/compose/1.27.4/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span></span><br></pre></td></tr></table></figure><h2 id="卸载">卸载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="常用命令">常用命令</h2><p>​我们使用docker-compose的时候可以指定一些参数</p><ul><li>-f 指定docker-compse.yml的位置(默认就在当前目录)</li><li>-p 指定项目名字(默认就是目录名字)</li></ul><blockquote><p>docker-compose只有在具有docker-compose.yml目录下使用才有用(<strong>除非指定docker-compse.yml的位置</strong>),否则会提示<br>no configuration file provided: not found</p></blockquote><h3 id="build">build</h3><p>构建项目中的镜像,就是构建在配置文件中使用了build配置项的服务,如果有的话,则会构建一个镜像到仓库中,默认名字是当前目录名字+service对应的名字</p><h3 id="config">config</h3><p>检查配置文件是否正确,正确则显示完整配置文件,否则说明错误原因</p><h3 id="down">down</h3><p>删掉项目中通过up启动的服务,并且删除网络</p><h3 id="exec">exec</h3><p>进入项目中的容器</p><h3 id="images">images</h3><p>列出compose文件中启动的容器对应的镜像</p><h3 id="kill">kill</h3><p>杀掉一个项目中的服务(得使用服务名字哦)</p><h3 id="stop">stop</h3><p>停止一个服务</p><h3 id="up">up</h3><p>这个命令巨屌好吧,帮我们省了不少事,它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作</p><h3 id="scale">scale</h3><p>指定开启服务个数,如果服务多于这个就停止,少了就增加</p><h2 id="docker-compose-yml-模板">docker-compose.yml 模板</h2><h3 id="build">build</h3><p>如果镜像存在则不会构建镜像,否则根据指定文件夹路径(可以是相对docker-compose.yml的路径,也可以是绝对路径)构建镜像,构建镜像的名字为当前docker-compose 文件所在目录的目录名+服务名字版本为最新版本,子命令</p><ul><li>context 指定dockerfile的位置</li></ul><h3 id="command">command</h3><p>覆盖容器启动的时候执行的命令,也就是相当于在dockerfile后面多加一条CMD</p><h3 id="devices">devices</h3><p>设备映射关系</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span></span><br></pre></td></tr></table></figure><h3 id="depends-on">depends_on</h3><p>解决容器依赖关系,比如先得启动哪些服务,在启动自己</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p>比如这个先启动,db,redis 然后就启动自己(不是等db,redis,完全启动后再启动自己哦)</p><h3 id="dns">dns</h3><p>指定DNS服务器,可以是单个数据,也可以是列表</p><h3 id="environment">environment</h3><p>指定环境变量</p><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。</p><h3 id="expose">expose</h3><p>暴露端口,但是不映射,互联在一个网络中的容器可以访问</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure><h3 id="extra-hosts">extra_hosts</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;mysql:123.323.12.12&quot;</span></span><br></pre></td></tr></table></figure><p>这个时候/etc/hosts下面会多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.323.12.12 mysql</span><br></pre></td></tr></table></figure><h3 id="healthcheck">healthcheck</h3><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="image">image</h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像,用这个镜像启动作为容器</p><h3 id="logging">logging</h3><p>配置日志</p><h3 id="port">port</h3><p>与docker run -p 里面的作用是差不多的</p><h1>额外补充</h1><h2 id="build使用缓存问题">build使用缓存问题</h2><p>Docker 使用镜像层的概念来构建和存储镜像。在构建过程中，Docker 会根据 Dockerfile 中的每个指令创建一个新的镜像层。每个层都会在前一个层的基础上应用更改。<strong>Docker 使用内容寻址的方式来存储这些层，这意味着每个层都有一个唯一的哈希值，该哈希值取决于层的内容。</strong></p><p><strong>当 Docker 遇到一个已经构建过的指令时，它会检查该指令对应的缓存层是否存在。如果存在，Docker 将直接使用该缓存层，而无需重新构建。这可以显著加速构建过程。Docker 根据指令内容和上下文来确定缓存层的有效性。</strong></p><p>当您在 Dockerfile 中新增一条指令时，Docker 将从头开始执行 Dockerfile。在遇到新增指令之前，Docker 会尝试使用之前构建过程中产生的缓存。一旦到达新增指令，Docker 将根据该指令创建一个新的层。此时，Docker 会重新构建该指令之后的所有层，因为它们取决于新增指令所创建的层。</p><p>简而言之，Docker 通过镜像层的唯一哈希值来记住缓存，这些哈希值取决于指令内容和上下文。当 Dockerfile 更改时，Docker 会尽可能使用现有的缓存，但在遇到更改点时，它将重新构建受影响的层。这样可以确保构建出的镜像始终是最新的。</p><h2 id="export-和-import注意点">export 和 import注意点</h2><p>首先，<code>export</code> 和 <code>import</code> 命令在 Docker 中的用途主要是将容器的文件系统导出到 tar 归档文件中，然后再将这个 tar 文件导入到 Docker 以创建一个新的镜像。它并不包含完整的镜像信息，例如环境变量，用户，工作目录，入口点等。<strong>这些信息在 Dockerfile 中被定义，但并不会被保存到 tar 文件中。例如容器的元数据（如CMD，ENTRYPOINT，ENV等）并不会被导出和导入</strong>, 因此，当你从导入的镜像启动一个新的容器时，可能需要手动指定这些参数。</p><h2 id="容器运行状态">容器运行状态</h2><p>容器的运行状态是由主进程决定的, 只要主进程一直在运行,容器就不会退出,对比一下下面这两个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=pause centos</span><br><span class="line">docker run -itd --name=pause centos</span><br></pre></td></tr></table></figure><p>第一个容器一启动就结束了,  第二个的话, 开启了一个交互式的终端, 这个shell就是主进程</p><h1>遇到的坑</h1><ul><li><p>开启或者关闭防火墙后,一定要重启docker,不然会报错</p></li><li><p>如果挂载好容器卷发现在容器里面无法访问数据,权限出问题,那大概率是selinux没有设置成disabled   修改/etc/selinux/config 里面的SELINUX为disabled</p></li><li><p><strong>Failed to get D-Bus connection: Operation not permitted</strong> ,Docker的设计理念是在容器里面不运行后台服务，容器本身就是宿主机上的一个独立的主进程，也可以间接的理解为就是容器里运行服务的应用进程。一个容器的生命周期是围绕这个主进程存在的，所以正确的使用容器方法是将里面的服务运行在前台。但是要在容器里面运行一个服务也不是不可以,创建容器的时候使用 /usr/sbin/init作为启动执行命令,然后加入–privileged=true</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id -p 8081:22 --name centos7 --privileged=true  centos:7 /usr/sbin/init</span><br></pre></td></tr></table></figure></li></ul><h2 id="daemon-json">daemon.json</h2><p>这里面的东西必须严格按照json规范,什么逗号多一个都不行</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建</title>
      <link href="/2022/12/01/hexo/hexo%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/12/01/hexo/hexo%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我觉得hexo是一个非常不错的博客系统,非常轻量,非常适合程序员,我用过WordPress,我感觉它使用起来比较笨重,功能比较多,容易迷失自我,最最最让我受不了的是,你必须在那上面写文章,这是我最不能接受的(我不知道有没有什么可以改进的,至少我不知道)</p><h2 id="安装nodejs">安装nodejs</h2><p>可以参考我的另一篇文章</p><h2 id="安装git">安装git</h2><p>这个比较简单,自行百度即可</p><h2 id="安装hexo">安装hexo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局安装hexo包</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查安装是否成功</span></span><br><span class="line">hexo -v </span><br></pre></td></tr></table></figure><h2 id="搭建博客">搭建博客</h2><h3 id="初始化博客">初始化博客</h3><blockquote><p>注意,这里是去GitHub克隆仓库,所以最好是能翻墙</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">来到一个空目录,用来存放博客</span></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="/2022/12/01/hexo/hexo%E6%90%AD%E5%BB%BA/../img/hexo%E6%90%AD%E5%BB%BAassets/image-20221229114729089.png" alt="image-20221229114729089"></p><p>成功后会产生上面文件</p><p>然后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动博客</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/2022/12/01/hexo/hexo%E6%90%AD%E5%BB%BA/../img/hexo%E6%90%AD%E5%BB%BAassets/image-20221229114512443.png" alt="image-20221229114512443"></p><p>访问后就能看到自己的博客了</p><p><img src="/2022/12/01/hexo/hexo%E6%90%AD%E5%BB%BA/../img/hexo%E6%90%AD%E5%BB%BAassets/image-20221229114540169.png" alt="image-20221229114540169"></p><h3 id="博客文件解释">博客文件解释</h3><h4 id="scaffolds">scaffolds</h4><p>用来存放模板文件,比如文章的Front-matter内容,每次都会使用这里面的模板填充</p><h4 id="source">source</h4><p>用来存放文章,资源,标签,分类…这些东西的</p><h4 id="config-yml">_config.yml</h4><p>用于配置网站信息的</p><h4 id="package-json">package.json</h4><p>用来存放下载的包,或者是插件这些</p><h4 id="themes">themes</h4><p>存放主题</p><h4 id="public">public</h4><p>这个并没有出现在上面,是因为我们还没有hexo g 生成,这个是存放静态页面的,就是存放文章对应的html的地方</p><h3 id="博客配置">博客配置</h3><blockquote><p>下面只列出了我觉得有用的配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 博客标题</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">戴晶明的个人博客</span></span><br><span class="line"><span class="comment"># 博客描述,感觉也可以当座右铭</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;不积跬步,无以至千里&quot;</span></span><br><span class="line"><span class="comment"># 关键字</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">博客系统</span></span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">戴晶明</span></span><br><span class="line"><span class="comment"># 语言</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章链接</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://djmnb.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用的主题(我这里用的是butterfly)</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署的时候,自动</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:djmnb/djmnb.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="主题配置">主题配置</h3><h4 id="下载主题">下载主题</h4><p>直接在博客目录下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>然后修改_config.yml里面的theme 为 butterfly</p><p>然后官方的建议的把 themes/butterfly/__config.yml (主题配置文件)这个文件复制一份出来到博客目录下命名为_config.butterfly.yml,我们修改这个文件就可以,以后我们更新了主题,也不用担心主题配置文件里面的内容丢了,这个确实有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp themes/butterfly/_config.yml ./_config.butterfly.yml</span><br></pre></td></tr></table></figure><h4 id="安装插件">安装插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="解决图片路径问题">解决图片路径问题</h3><p>我是通过typora本地写好博客,然后推送到远程去的,但是啊,这个图片路径有时候会对不上,我的typora默认设置是…/…/img/${filename}assets,因此推送到服务器的时候肯定是找不到这个图片的,但是这个图片又存在服务器上,这个时候我们要动动脑子了,用js把图片和视频的路径属性改一下不就行了么,我们只需要在theme/butterfly/source/js/main.js(自己主题文件中)中加入下面这段js代码就行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;img&quot;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">img</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(img == <span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">let</span> pos = img.<span class="property">src</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;/img/&quot;</span>); <span class="comment">// 这个路径要跟你hexo生成的图片路径对应上哈</span></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">img.<span class="property">src</span> = img.<span class="property">src</span>.<span class="title function_">substring</span>(pos);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;video&quot;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">video</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(video == <span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">let</span> pos = video.<span class="property">src</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;/img/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">video.<span class="property">src</span> = video.<span class="property">src</span>.<span class="title function_">substring</span>(pos);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义js与css">自定义js与css</h3><p>我们只需要把我们的js和css放到theme/主题/source/js或者css 里面就可以了</p><h3 id="搭建评论区">搭建评论区</h3><p>去leancloud注册好账号,添加好应用,然后修改相应配置,具体方法自行百度</p><h2 id="文件放置问题">文件放置问题</h2><p>我的建议是source目录下只放文章和一些图片就行, 书籍和代码这些放在根目录下,这些东西本就没必要渲染成html,只需要提交到GitHub就行</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习总结</title>
      <link href="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我是跟着B站<a href="https://www.bilibili.com/video/BV1Mb411e7re/?share_source=copy_web&amp;vd_source=25bfa760964880528c6259566561afed">江科大自化协</a>学习并且总结</p><blockquote><p>学习资料: <a href="https://pan.baidu.com/s/1vDTN2o8ffvczzNQGfyjHng">https://pan.baidu.com/s/1vDTN2o8ffvczzNQGfyjHng</a> 提取码：gdzf，链接里压缩包的解压密码：51</p></blockquote><h2 id="前期准备">前期准备</h2><h3 id="硬件">硬件</h3><ul><li>一台51单片机(stc89c52)</li></ul><h3 id="软件安装">软件安装</h3><blockquote><p>这些软件都在学习资料里面安装</p></blockquote><h4 id="keil5">Keil5</h4><h5 id="功能">功能</h5><p>用来编写程序</p><h5 id="安装">安装</h5><p>来到这个目录下(相对路径),点击这个exe文件然后安装好程序</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104211051121.png" alt="image-20230104211051121"></p><p>然后点击下面这个安装包,点击里面的应用程序破解</p><h4 id="stc-isp">STC-ISP</h4><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104212416596.png" alt="image-20230104212416596"></p><p>直接双击运行</p><p>用来将程序烧进单片机</p><h4 id="驱动程序">驱动程序</h4><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104212922490.png" alt="image-20230104212922490"></p><p>运行这个程序安装驱动</p><h2 id="单片机介绍">单片机介绍</h2><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104213311606.png" alt="image-20230104213311606"></p><p>单片机可不止是一个CPU,它包含了CPU,可以算一台小型计算机了</p><p>因为英特尔开发了8051单片机内核,所以是8051内核的单片机都称为51单片机(8位)</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104214719089.png" alt="image-20230104214719089"></p><h2 id="keil5新建工程">keil5新建工程</h2><p>点击project,然后选择新建一个工程</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104223307800.png" alt="image-20230104223307800"></p><p>选择好路径后</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104223448268.png" alt="image-20230104223448268"></p><p>搜索这个东西,选择好后点击OK</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104223500615.png" alt="image-20230104223500615"></p><p>是和否都可以</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104225814382.png" alt="image-20230104225814382"></p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104225849236.png" alt="image-20230104225849236"></p><h2 id="烧录程序">烧录程序</h2><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104231251788.png" alt="image-20230104231251788"></p><p>我这里要选择STC89C52RC</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104231324088.png" alt="image-20230104231324088"></p><p>然后打开程序找到hex文件</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104231343328.png" alt="image-20230104231343328"></p><p>然后点下载/编程,然后重新开关单片机电源</p><h2 id="点亮第一个led灯">点亮第一个LED灯</h2><p>查看LED模块的电路图</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104224323937.png" alt="image-20230104224323937"></p><p>观察这个图以及结合二极管的特性我们需要设置io口为低电平为才能让二极管发光,我们接下来写代码只让P20发光</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">// 对应的为 p28 p27 p26 .... p20</span></span><br><span class="line"><span class="comment">//P2 = 11111110  </span></span><br><span class="line"><span class="comment">// 我们需要变成16进制</span></span><br><span class="line">P2 = <span class="number">0xFE</span>;</span><br><span class="line"><span class="comment">// 如果不兜圈子的话,单片机会一直执行这个程序</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>烧录程序后成功点亮</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230104231451399.png" alt="image-20230104231451399"></p><h2 id="闪烁一个led灯">闪烁一个LED灯</h2><p>这里我们需要用到一个延时函数</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105101107184.png" alt="image-20230105101107184"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">// 引入一个头文件</span><br><span class="line">#include &lt;INTRINS.H&gt;</span><br><span class="line">void Delay500ms()//@11.0592MHz</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">i = 4;</span><br><span class="line">j = 129;</span><br><span class="line">k = 119;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">while (--k);</span><br><span class="line">&#125; while (--j);</span><br><span class="line">&#125; while (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">P2 = 0xFE;</span><br><span class="line">// 延时</span><br><span class="line">Delay500ms();</span><br><span class="line">P2 = 0xFF;</span><br><span class="line">//这里也不要忘记延时,不然直接就亮了</span><br><span class="line">Delay500ms();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="led流水灯">LED流水灯</h2><p>有了上面的基础,这个就简单了,我们自己封装一个延时函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> times)</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(times &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 里面代表延时1ms</span></span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">199</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">times--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">P2 = <span class="number">0xFE</span>;</span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">P2 = P2 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">P2 += <span class="number">1</span>;</span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独立按键控制led灯">独立按键控制LED灯</h2><h3 id="独立按键">独立按键</h3><p>轻触按键相当于一种电子开关,按下时开关接通,松开时开关断开,实现原理是通过内部金属片受力弹动来实现接通和断开</p><p>当我们按下按键的时候**,io口对应的电压就会变成0**,会被寄存器检测到并且写入寄存器中,然后供我们使用</p><blockquote><p>这里有人就有疑惑了,我们按下然后松开,这样寄存器的值不是没变吗?,对,最终结果是没变,但是单片机的频率好歹也有兆赫兹级别的吧,你按下后,程序在飞速运转,肯定能够检测到寄存器这个值的变化</p></blockquote><p>独立按键的电路图</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105113348488.png" alt="image-20230105113348488"></p><p>按下亮,松手熄灭</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P2_0 = P3_1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按一下取反LED灯亮灭情况</p><p>由于金属弹片会有抖动效果,因此当我们按下按键或者松开按键的时候,金属弹片都会抖动几下后才会进入静止状态,这个时间段的时候电压会上下摆动不稳定,会干扰单片机的检测,因此我们需要消抖,一是物理消抖(需要硬件支持),二是程序消抖(在按下之后等一段时间再去判断io口对应的寄存器数值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1ms</span><span class="params">()</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">199</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">int</span> times)</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(times &gt; <span class="number">0</span>)&#123;</span><br><span class="line">Delay1ms();</span><br><span class="line">times--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下和抬起后才改变LED灯的状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 按下</span></span><br><span class="line"><span class="keyword">if</span>(P3_1 == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 一直按下</span></span><br><span class="line"><span class="keyword">while</span>(P3_1 == <span class="number">0</span>);</span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//抬起</span></span><br><span class="line">P2_0 = !P2_0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>独立按键控制LED显示二进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1ms</span><span class="params">()</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">199</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">int</span> times)</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(times &gt; <span class="number">0</span>)&#123;</span><br><span class="line">Delay1ms();</span><br><span class="line">times--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">P2 = <span class="number">0xFE</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( P3_1 == <span class="number">0</span> )&#123;</span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span>(P3_1 == <span class="number">0</span>);</span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>( i == <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">P2 = <span class="number">0xFF</span> ^ (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( P3_0 == <span class="number">0</span> )&#123;</span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span>(P3_0 == <span class="number">0</span>);</span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">if</span>( i &lt; <span class="number">0</span> ) i = <span class="number">7</span>;</span><br><span class="line">P2 = <span class="number">0xFF</span> ^ (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数码管显示">数码管显示</h2><h3 id="介绍">介绍</h3><p>简单,廉价的显示器,是由多个发光二极管封装在一起组成的8字型的器件</p><blockquote><p>8个发光二极管灯组成,7个段,一个点</p></blockquote><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105161547862.png" alt="image-20230105161547862"></p><h3 id="电路图">电路图</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105160938565.png" alt="image-20230105160938565"></p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105160956646.png" alt="image-20230105160956646"></p><p>这个数码管跟138译码器一起工作的</p><blockquote><p>138 译码器就是将3个二进制位表示成8个二进制位, 2^3 = 8,</p></blockquote><p>驱动方式: 通过38译码器选择好某个LED,然后通过P0口给数据,看点亮哪些二极管</p><h3 id="控制某个数码管显示数字">控制某个数码管显示数字</h3><p>给第三个数码管显示6</p><p>三八译码器给101</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105171638254.png" alt="image-20230105171638254"></p><p>P0 口给 01111101</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105171554250.png" alt="image-20230105171554250"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">P2_2 = <span class="number">1</span>;</span><br><span class="line">P2_3 = <span class="number">0</span>;</span><br><span class="line">P2_4 = <span class="number">1</span>;</span><br><span class="line">P0 = <span class="number">0x7D</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105172221898.png" alt="image-20230105172221898"></p><p>我们可以封装一个函数出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数码管数字对应的P0io口的16进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Numbers[] = &#123;</span><br><span class="line"><span class="comment">// 0011 1111   0</span></span><br><span class="line"><span class="number">0x3F</span>,</span><br><span class="line"><span class="comment">// 0000 0110   1</span></span><br><span class="line"><span class="number">0x06</span>,</span><br><span class="line"><span class="comment">// 0101 1001   2</span></span><br><span class="line"><span class="number">0x59</span>,</span><br><span class="line"><span class="comment">// 0100 1111   3</span></span><br><span class="line"><span class="number">0x4F</span>,</span><br><span class="line"><span class="comment">// 0110 0110   4</span></span><br><span class="line"><span class="number">0x66</span>,</span><br><span class="line"><span class="comment">// 0110 1101   5</span></span><br><span class="line"><span class="number">0x6D</span>,</span><br><span class="line"><span class="comment">// 0111 1101   6</span></span><br><span class="line"><span class="number">0x7D</span>,</span><br><span class="line"><span class="comment">// 0000 0111   7</span></span><br><span class="line"><span class="number">0x07</span>,</span><br><span class="line"><span class="comment">// 0111 1111   8</span></span><br><span class="line"><span class="number">0x7F</span>,</span><br><span class="line"><span class="comment">// 0110 1111   9</span></span><br><span class="line"><span class="number">0x6F</span>,</span><br><span class="line"><span class="comment">// 0111 0111   A</span></span><br><span class="line"><span class="number">0x77</span>,</span><br><span class="line"><span class="comment">// 0111 1100   b</span></span><br><span class="line"><span class="number">0x7C</span>,</span><br><span class="line"><span class="comment">// 0011 1001   C</span></span><br><span class="line"><span class="number">0x39</span>,</span><br><span class="line"><span class="comment">// 0101 1110   d</span></span><br><span class="line"><span class="number">0x5E</span>,</span><br><span class="line"><span class="comment">// 0111 1001   E</span></span><br><span class="line"><span class="number">0x79</span>,</span><br><span class="line"><span class="comment">// 0111 0001   F</span></span><br><span class="line"><span class="number">0x71</span>,</span><br><span class="line"><span class="comment">// 0000 0000   空</span></span><br><span class="line"><span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 该函数可以用来给指定位置的数码管指定显示数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,<span class="type">unsigned</span> <span class="type">char</span> Number)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(Location)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P0 = Numbers[Number];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给第一个数码管循环显示0-f">给第一个数码管循环显示0-F</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">int</span> times)</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(times &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 里面代表延时1ms</span></span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">199</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">times--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数码管数字对应的P0io口的16进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Numbers[] = &#123;</span><br><span class="line"><span class="comment">// 0011 1111   0</span></span><br><span class="line"><span class="number">0x3F</span>,</span><br><span class="line"><span class="comment">// 0000 0110   1</span></span><br><span class="line"><span class="number">0x06</span>,</span><br><span class="line"><span class="comment">// 0101 1011   2</span></span><br><span class="line"><span class="number">0x5B</span>,</span><br><span class="line"><span class="comment">// 0100 1111   3</span></span><br><span class="line"><span class="number">0x4F</span>,</span><br><span class="line"><span class="comment">// 0110 0110   4</span></span><br><span class="line"><span class="number">0x66</span>,</span><br><span class="line"><span class="comment">// 0110 1101   5</span></span><br><span class="line"><span class="number">0x6D</span>,</span><br><span class="line"><span class="comment">// 0111 1101   6</span></span><br><span class="line"><span class="number">0x7D</span>,</span><br><span class="line"><span class="comment">// 0000 0111   7</span></span><br><span class="line"><span class="number">0x07</span>,</span><br><span class="line"><span class="comment">// 0111 1111   8</span></span><br><span class="line"><span class="number">0x7F</span>,</span><br><span class="line"><span class="comment">// 0110 1111   9</span></span><br><span class="line"><span class="number">0x6F</span>,</span><br><span class="line"><span class="comment">// 0111 0111   A</span></span><br><span class="line"><span class="number">0x77</span>,</span><br><span class="line"><span class="comment">// 0111 1100   b</span></span><br><span class="line"><span class="number">0x7C</span>,</span><br><span class="line"><span class="comment">// 0011 1001   C</span></span><br><span class="line"><span class="number">0x39</span>,</span><br><span class="line"><span class="comment">// 0101 1110   d</span></span><br><span class="line"><span class="number">0x5E</span>,</span><br><span class="line"><span class="comment">// 0111 1001   E</span></span><br><span class="line"><span class="number">0x79</span>,</span><br><span class="line"><span class="comment">// 0111 0001   F</span></span><br><span class="line"><span class="number">0x71</span>,</span><br><span class="line"><span class="comment">// 0000 0000   空</span></span><br><span class="line"><span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 该函数可以用来给指定位置的数码管指定显示数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,<span class="type">unsigned</span> <span class="type">char</span> Number)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(Location)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P0 = Numbers[Number];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt; <span class="number">16</span> )&#123;</span><br><span class="line">Nixie(<span class="number">1</span>,i);</span><br><span class="line">i++;</span><br><span class="line">Delay(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态数码管显示">动态数码管显示</h3><p>因为单片机的速度比较快,数码管的数字变化的也非常快,上一次在我们眼里显示的数码管数字在我们眼里的成像还没消失,就又产生了,因此的话数字就一直在我们眼中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">Nixie(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">Nixie(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">Nixie(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">```c</span><br><span class="line"></span><br><span class="line">那有人就说了,我这样写不就行了么,其实还有点问题</span><br><span class="line"></span><br><span class="line">这样显示的数据会有上一次的数据,,因为单片机显示数码管是这样的,</span><br><span class="line"></span><br><span class="line">位选  段选  位选  段选 位选  段选  位选  段选  </span><br><span class="line"></span><br><span class="line">但是啊,可能会出现这种情况,因为上一次段选并没有清<span class="number">0</span>,下一次的位选到来的时候,会先显示上一次的段选数据</span><br><span class="line"></span><br><span class="line">位选  **段选  位选**  段选 位选  段选  位选  段选  </span><br><span class="line"></span><br><span class="line">然后下一个段选过来了,又显示一个数据,上一个数据之所以能够显示是因为单片机变化的很快,那为什么比较暗,那是因为电压不够稳定,一下子就变成了下一次的段选,而下一次的段选之后,这个电压能够稳定一段时间,因为下一次的位选不是它,因此会更亮一些,所以我们需要在每一次段选后面进行消影</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,<span class="type">unsigned</span> <span class="type">char</span> Number)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(Location)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: P2_4 = <span class="number">1</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">1</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: P2_4 = <span class="number">0</span>;P2_3 = <span class="number">0</span>;P2_2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P0 = Numbers[Number];</span><br><span class="line">Delay(<span class="number">1</span>);</span><br><span class="line">P0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在段选后立马把段选数据变成0,这样当下一个位选来的时候不会显示上一个数据</p><h2 id="lcd1062调试工具">LCD1062调试工具</h2><p>将这个工具插到对应的接口上,插上去之后就不能使用p0io口了,因为已经被LCD占用了,还有P2_5,P2_6,P2_7</p><p>我们还需要引入驱动程序</p><h2 id="矩阵键盘">矩阵键盘</h2><p>为了减少I/O 口的占用,通常将按键排列从矩阵形式,采用逐行或者逐列扫描,就可以读出任意位置按键的状态</p><p>数码管的扫描是输出扫描,一个数据一个数据的显示,利用人眼暂留最终看起来是同时输出</p><p>矩阵键盘是输入扫描, 一个数据一个数据输入,最终汇总一起处理,这样看起来是同时检测</p><blockquote><p>我们可以逐行和逐列扫描得到那个按键按下,这里我们按照逐列扫描,因为逐行扫描的时候,会有io口冲突,影响蜂鸣器响,比较头痛</p><p>如果是逐行扫描,那就是依次给行对应的io口低电平,然后读取列io口,看哪些是低电平,就代表被按下了</p></blockquote><h3 id="电路图">电路图</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230106093606872.png" alt="image-20230106093606872"></p><h3 id="获取按下的数字">获取按下的数字</h3><p>我们先选中某一列,再看这一行上的按键是否被按下,然后就能得到这个数字</p><p>我们自己封装获取数字的函数</p><p>MatrixKey.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选出这一列中哪个数字被选中</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">GetKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> startnum)</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line"><span class="comment">// 如果按下</span></span><br><span class="line"><span class="keyword">if</span>(((P1&gt;&gt;(<span class="number">7</span>-i)) &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span>( ((P1&gt;&gt;(<span class="number">7</span>-i)) &amp; <span class="number">1</span>) == <span class="number">0</span> );  <span class="comment">// 一直按下</span></span><br><span class="line">Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> startnum + i*<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">MatrixKey</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">P1 = (~(<span class="number">1</span>&lt;&lt;(<span class="number">3</span>-i))) &amp; <span class="number">0xFF</span>;</span><br><span class="line">Key = GetKey(i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>( Key != <span class="number">0</span> ) <span class="keyword">return</span> Key; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遇到个小坑,就是 == 的优先级比 &amp; 高 操蛋</p></blockquote><p>main.c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">LCD_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">num = MatrixKey();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,num,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="密码判断">密码判断</h3><p>这个就简单了,直接上源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> password = <span class="number">0</span>;</span><br><span class="line">LCD_Init();</span><br><span class="line"></span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Password:&quot;</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,password,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">num = MatrixKey();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 1-10 代表输入密码</span></span><br><span class="line"><span class="keyword">if</span>( num &lt;= <span class="number">10</span> )&#123;</span><br><span class="line">password = password*<span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">password %= <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( num == <span class="number">11</span> ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( password == <span class="number">1234</span>)&#123;</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">11</span>, <span class="string">&quot;RIGHT&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">11</span>, <span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( num == <span class="number">12</span> )&#123;</span><br><span class="line">password = <span class="number">0</span>;</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">11</span>, <span class="string">&quot;     &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,password,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中断系统">中断系统</h2><p>stc89c52中断源个数有8个:外部中断0,定时器0中断,外部中断1,定时器1中断,串口中断,外部中断2,外部中断3</p><p>各个定时器对应的中断号</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109155526537.png" alt="image-20230109155526537"></p><h3 id="电路图">电路图</h3><p>最新的电路图</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109142306355.png" alt="image-20230109142306355"></p><p>传统电路图</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109155118613.png" alt="image-20230109155118613"></p><h3 id="中断寄存器">中断寄存器</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109140937247.png" alt="image-20230109140937247"></p><h4 id="中断允许寄存器ie和xicon">中断允许寄存器IE和XICON</h4><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109143557727.png" alt="image-20230109143557727"></p><h4 id="中断优先级控制寄存器ip-xicon和iph">中断优先级控制寄存器IP/XICON和IPH</h4><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109143436901.png" alt="image-20230109143436901"></p><h2 id="定时器">定时器</h2><p>51单片机的定时器属于单片机的内部资源,其他电路连接和运转均在单片机内完成</p><p>delay的时候,单片机是不能做其他操作的,但是定时器不同,开启定时器后,我们还能做其他的事</p><p>STC89C52 有三个定时器: T0 T1 T2,  T0 和 T1 与传统的51单片机兼容, T2是此型号单片机增加的资源</p><blockquote><p>定时器的资源和单片机的型号是关联在一起的,不同型号可能会有不同的定时器个数和操作方式,但是一般来说,T0 和 T1 的操作方式是51单片机共有的</p></blockquote><p>STC89C52 的 T0 和 T1 均有几种工作模式:</p><ul><li>模式0: 13位定时器</li><li>模式0: 16位定时器( 常用)   能计2^16=65536 这个么多个数</li><li>模式2: 8位自动重装  当TL溢出的时候,自动将TH的值装载到TL,这样比模式0更精确,因为少了两条赋值语句</li><li>模式3: 两个8位计数器</li></ul><p>定时器分为三个部分: 计数系统,时钟,中断系统</p><p>工作流程:时钟每来一个脉冲就加1,加到65535的时候就会溢出变成0,然后将TF0标志位变成1,就会发生中断</p><p>时钟脉冲可以来自两个地方,一个是系统时钟(定时器模式),另外可以由外部引脚提供(计数器模式),我们可以通过配置C/T这个寄存器来选择</p><p>系统时钟是由晶振提供一个固定的频率,一个周期就是1us</p><h3 id="电路图">电路图</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230108143633122.png" alt="image-20230108143633122"></p><h3 id="定时器相关寄存器">定时器相关寄存器</h3><p>寄存器是连接软硬件的媒介,在单片机中寄存器就是一段特殊的RAM存储器,一方面,寄存器可以存储数据,另一方每一个寄存器背后可以控制电路的连接方式</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109135931239.png" alt="image-20230109135931239"></p><h4 id="控制寄存器-tcon-可位寻址">控制寄存器 TCON (可位寻址)</h4><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230108142152058.png" alt="image-20230108142152058"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每一位名字后面的0 1 代表定时器0 1</span><br><span class="line">列如TF1 代表计时器1的溢出标志位 TF0代表计时器0的溢出标志位</span><br><span class="line">TF: 溢出标志位,当计数器满了之后由硬件置1,向CPU发起中断,中断处理时由硬件置0</span><br><span class="line">TR: 定时器的运行控制位,由软件置位和清零,当工作模式寄存器的GATE为为0时  TR = 1时开始计数,TR = 0 时停止计数 GATE为1时 需要TR=1 INT为高电压的时候开始计数</span><br><span class="line">IE: 外部中断使能位</span><br><span class="line">IT: 外部中断触发方式</span><br></pre></td></tr></table></figure><h4 id="工作模式寄存器tmod-不可位选址">工作模式寄存器TMOD(不可位选址)</h4><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230108142525105.png" alt="image-20230108142525105"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GATE: 选择 控制定时器的模式,有两种:0 代表 TR单独控制 1代表TR和INT一起控制</span><br><span class="line">C/T: 选择时钟系统: 0是内部系统时钟,1外部时钟系统</span><br><span class="line">M1,M0  控制定时器的工作模式 0 0 模式0  0 1 模式 1 ... </span><br></pre></td></tr></table></figure><h4 id="计数单元寄存器-tl-th">计数单元寄存器(TL TH)</h4><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230109140722773.png" alt="image-20230109140722773"></p><p>如果是16位计数器工作模式的话,TL和TH一起控制计数大小</p><h3 id="定时器配置">定时器配置</h3><p>以定时器0为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置TMOD,不可位寻址   后四位控制T0   </span></span><br><span class="line"><span class="comment">// 门控端 内部时钟还是外部时钟  M1 M0  (定时器模式)</span></span><br><span class="line"><span class="comment">// 0 0 0 1</span></span><br><span class="line"></span><br><span class="line">TMOD = TMOD &amp; <span class="number">0xF0</span>; <span class="comment">// 清0</span></span><br><span class="line">TMOD = TMOD | <span class="number">0xF1</span>; <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 TCON 可位寻址</span></span><br><span class="line">TR0 = <span class="number">1</span>;  <span class="comment">// 开启定时器0</span></span><br><span class="line">TF0 = <span class="number">0</span>;  <span class="comment">// 清0标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置计数单元,1us计数加一次,因此65536us 中断一次 我们需要配置成1ms 产生一次中断,给初始值为64536</span></span><br><span class="line"><span class="comment">// 64536 = 0xFC18</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;</span><br><span class="line">TH0 = <span class="number">0xFC</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置中断寄存器</span></span><br><span class="line">ET0 = <span class="number">1</span>;  <span class="comment">// 开启T0计时器中断</span></span><br><span class="line">EA = <span class="number">1</span>;   <span class="comment">// 开启总开关中断</span></span><br><span class="line">PT0 = <span class="number">0</span>; <span class="comment">// 设置优先级</span></span><br></pre></td></tr></table></figure><h3 id="按键控制流水灯的移动方向">按键控制流水灯的移动方向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> keyNumber,keyMode = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">Timer0_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">P2 = <span class="number">0xFE</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> </span><br><span class="line">keyNumber = Key();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(keyNumber == <span class="number">1</span>) keyMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(keyNumber == <span class="number">2</span>) keyMode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">count++;</span><br><span class="line">TL0 = <span class="number">0x18</span>;</span><br><span class="line">TH0 = <span class="number">0xFC</span>;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">1000</span>)&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(keyMode == <span class="number">0</span>) P2 = _cror_(P2,<span class="number">1</span>);  <span class="comment">// 循环向右移位</span></span><br><span class="line"><span class="keyword">if</span>(keyMode == <span class="number">1</span>) P2 = _crol_(P2,<span class="number">1</span>);  <span class="comment">// 循环向左移位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="时钟系统">时钟系统</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_Clock</span><span class="params">()</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hour = <span class="number">23</span>,min = <span class="number">59</span>,second = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">Timer0_Init();</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;CLOCKS:&quot;</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;  :  :  &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> Show_Clock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_Clock</span><span class="params">()</span>&#123;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,hour,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">4</span>,min,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">7</span>,second,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">count++;</span><br><span class="line">TL0 = <span class="number">0x18</span>;</span><br><span class="line">TH0 = <span class="number">0xFC</span>;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">1000</span>)&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">second++;</span><br><span class="line"><span class="keyword">if</span>(second&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">min++;</span><br><span class="line">second = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(min&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">hour++;</span><br><span class="line">min = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(hour&gt;=<span class="number">24</span>)&#123;</span><br><span class="line">hour = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="串口通信">串口通信</h2><p>串口是一种应用十分广泛的通讯接口,串口成本低,容易使用,通信线路简单,可实现两个设备的互相通信.</p><p>单片机的串口可以使单片机与单片机,单片机与电脑,单片机与各样的模块互相通信,极大的扩展了单片机的应用范围,增强了单片机系统的硬件实力( 一个单片机的能力有限,如果可以通信,可以让其他模块处理数据,然后再发送给单片机)</p><p>51单片机内部自带UART(通用异步收发器),可实现单片机的串口通信</p><p>电平标准是数据1和数据0的表示方式,是规定的电压与数据对应的关系,串口常用电平标准:</p><ul><li>TTL 电平: +5V表示1,0v表示0</li><li>RS232电平: -3~-15v表示1,+3~+15表示0</li><li>RS485电平: 两线压差+2~+6v表示1,-2~-6V表示0,需要两根线传输一端到另一端的数据</li></ul><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110152737361.png" alt="image-20230110152737361"></p><p>STC89C52 有1个UART,有四种工作模式:</p><ul><li>模式0: 同步移位寄存器</li><li><strong>模式1</strong>: 8位UART,波特率可变</li><li>模式2: 9位UART,波特率固定</li><li>模式3: 9位UART,波特率可变</li></ul><blockquote><p>9位UART 多一位校验位(奇偶校验)</p></blockquote><h3 id="简单电路图">简单电路图</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110172007692.png" alt="image-20230110172007692"></p><h3 id="串口相关寄存器">串口相关寄存器</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110164331194.png" alt="image-20230110164331194"></p><h3 id="串行口控制寄存器scon和pcon">串行口控制寄存器SCON和PCON</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110165607831.png" alt="image-20230110165607831"></p><h3 id="串行口数据缓冲寄存器sbuf">串行口数据缓冲寄存器SBUF</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110171737754.png" alt="image-20230110171737754"></p><p>这个寄存器不需要配置,我们只需要将我们的数据写入这个寄存器或者读取这个寄存器的数据就行</p><h3 id="寄存器配置">寄存器配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//SM0 SM1 SM2 REN TB8 RB8 TI RI</span></span><br><span class="line"><span class="comment">//SM0 SM1  一起构成串口工作模式,这里选第1种  0 1</span></span><br><span class="line"><span class="comment">// SM2 多机位通信,不用管 0</span></span><br><span class="line"><span class="comment">// REN 接收使能控制  1</span></span><br><span class="line"><span class="comment">// TB8 发送的第9位数据,只有工作在2,3模式的时候才有用 0</span></span><br><span class="line"><span class="comment">// RB8 接受的第9位数据,只有工作在2,3模式的时候才有用 0</span></span><br><span class="line"><span class="comment">// TI 发送中断请求,由硬件置1,软件置0</span></span><br><span class="line"><span class="comment">// RI 接收中断请求,由硬件置1,软件置0</span></span><br><span class="line"><span class="comment">// 为什么两个中断位需要软件置0呢? 因为中断响应函数只有一个,我们需要通过这个位去判断是什么中断,如果硬件直接置0了,那就无法判断</span></span><br><span class="line"><span class="comment">// 0 1 0 1 0 0 0 0</span></span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">PCON |= <span class="number">0x80</span>;<span class="comment">//使能波特率倍速位SMOD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置定时器1</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//清除定时器1模式位</span></span><br><span class="line">TMOD |= <span class="number">0x20</span>;<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line"></span><br><span class="line">TL1 = <span class="number">0xF4</span>;<span class="comment">//设定定时初值</span></span><br><span class="line">TH1 = <span class="number">0xF4</span>;<span class="comment">//设定定时器重装值</span></span><br><span class="line">ET1 = <span class="number">0</span>;<span class="comment">//禁止定时器1中断</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//启动定时器1</span></span><br><span class="line"></span><br><span class="line">EA = <span class="number">1</span>; <span class="comment">// 开启总中断开关</span></span><br><span class="line">ES = <span class="number">1</span>; <span class="comment">// 开启串口中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串口向电脑发送数据">串口向电脑发送数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//SM0 SM1 SM2 REN TB8 RB8 TI RI</span></span><br><span class="line"><span class="comment">//SM0 SM1  一起构成串口工作模式,这里选第1种  0 1</span></span><br><span class="line"><span class="comment">// SM2 多机位通信,不用管 0</span></span><br><span class="line"><span class="comment">// REN 接收使能控制  1</span></span><br><span class="line"><span class="comment">// TB8 发送的第9位数据,只有工作在2,3模式的时候才有用 0</span></span><br><span class="line"><span class="comment">// RB8 接受的第9位数据,只有工作在2,3模式的时候才有用 0</span></span><br><span class="line"><span class="comment">// TI 发送中断请求,由硬件置1,软件置0</span></span><br><span class="line"><span class="comment">// RI 接收中断请求,由硬件置1,软件置0</span></span><br><span class="line"><span class="comment">// 为什么两个中断位需要软件置0呢? 因为中断响应函数只有一个,我们需要通过这个位去判断是什么中断,如果硬件直接置0了,那就无法判断</span></span><br><span class="line"><span class="comment">// 0 1 0 1 0 0 0 0</span></span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">PCON |= <span class="number">0x80</span>;<span class="comment">//使能波特率倍速位SMOD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置定时器1</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//清除定时器1模式位</span></span><br><span class="line">TMOD |= <span class="number">0x20</span>;<span class="comment">//设定定时器1为8位自动重装方式</span></span><br><span class="line"></span><br><span class="line">TL1 = <span class="number">0xF4</span>;<span class="comment">//设定定时初值</span></span><br><span class="line">TH1 = <span class="number">0xF4</span>;<span class="comment">//设定定时器重装值</span></span><br><span class="line">ET1 = <span class="number">0</span>;<span class="comment">//禁止定时器1中断</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//启动定时器1</span></span><br><span class="line"></span><br><span class="line">EA = <span class="number">1</span>; <span class="comment">// 开启总中断开关</span></span><br><span class="line">ES = <span class="number">1</span>; <span class="comment">// 开启串口中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span>&#123;</span><br><span class="line">SBUF = Data;</span><br><span class="line"><span class="comment">//等待数据发送完</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 软件置0</span></span><br><span class="line">TI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">UART_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">UART_SendData(i++);</span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="电脑控制led">电脑控制LED</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">UART_Init();</span><br><span class="line"></span><br><span class="line">P2 = <span class="number">0xFE</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Routine</span><span class="params">()</span> interrupt 4&#123;</span><br><span class="line"><span class="keyword">if</span> ( RI == <span class="number">1</span> )&#123;</span><br><span class="line">P2 = SBUF;</span><br><span class="line">UART_SendData(SBUF);</span><br><span class="line">RI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="led-点阵屏">LED 点阵屏</h2><p>LED点阵屏由若干个独立的LED组成,LED以矩阵形式排列</p><p>按颜色分为: 单色,双色,全彩</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110203255541.png" alt="image-20230110203255541"></p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110203324331.png" alt="image-20230110203324331"></p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110203229637.png" alt="image-20230110203229637"></p><blockquote><p>SERCLK控制移位,SER提供数据,RECLK负责将数据给到输出缓存区</p></blockquote><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110203914841.png" alt="image-20230110203914841"></p><p>观看这个电路图我们可以发现,点阵屏的8个接口直接与P0串口相接,另外八个接口与74HC595的八个输出口相连</p><p>这个其实跟数码管很像,先段选,然后位选</p><p>我们通过列扫描来点亮点阵屏,先设置P0 然后设置 74HC595</p><h3 id="led点阵屏显示图形">LED点阵屏显示图形</h3><p>MatrixLED.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit SER = P3^<span class="number">4</span>;   <span class="comment">//SER</span></span><br><span class="line">sbit SCK = P3^<span class="number">6</span>; <span class="comment">// SRCLK</span></span><br><span class="line">sbit RCK = P3^<span class="number">5</span>;   <span class="comment">// RCLK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIXLED_RES P0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 74HC595写入一个字节</span></span><br><span class="line"><span class="comment">  * @param 要写入的数据,一个字节</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="type">void</span> _74HC595_WriteByte(<span class="type">unsigned</span> <span class="type">char</span> Byte)&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0x80</span>,i = <span class="number">0</span>;</span><br><span class="line">SCK = <span class="number">0</span>;</span><br><span class="line">RCK = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">SER = Byte&amp;(temp&gt;&gt;i);</span><br><span class="line">SCK = <span class="number">1</span>;</span><br><span class="line">SCK = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">RCK = <span class="number">1</span>;</span><br><span class="line">RCK = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  点阵屏显示一列数据</span></span><br><span class="line"><span class="comment">  * @param  Column 要选择的列 0-7  ,0在最左边</span></span><br><span class="line"><span class="comment">  * @param  要显示的数据</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">MatrixLED_ShowColumn</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> Data)</span>&#123;</span><br><span class="line">_74HC595_WriteByte(Data);</span><br><span class="line">MATRIXLED_RES = ~(<span class="number">0x80</span> &gt;&gt; Column);</span><br><span class="line">Delay(<span class="number">1</span>);</span><br><span class="line">MATRIXLED_RES = <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">MatrixLED_ShowColumn(<span class="number">1</span>,<span class="number">0xAA</span>);</span><br><span class="line">MatrixLED_ShowColumn(<span class="number">2</span>,<span class="number">0x55</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="led点阵屏显示动画">LED点阵屏显示动画</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Animation[]=&#123;</span><br><span class="line"><span class="number">0x3C</span>,<span class="number">0x42</span>,<span class="number">0xA9</span>,<span class="number">0x85</span>,<span class="number">0x85</span>,<span class="number">0xA9</span>,<span class="number">0x42</span>,<span class="number">0x3C</span>,</span><br><span class="line"><span class="number">0x3C</span>,<span class="number">0x42</span>,<span class="number">0xA1</span>,<span class="number">0x85</span>,<span class="number">0x85</span>,<span class="number">0xA1</span>,<span class="number">0x42</span>,<span class="number">0x3C</span>,</span><br><span class="line"><span class="number">0x3C</span>,<span class="number">0x42</span>,<span class="number">0xA5</span>,<span class="number">0x89</span>,<span class="number">0x89</span>,<span class="number">0xA5</span>,<span class="number">0x42</span>,<span class="number">0x3C</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>,j = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">MatrixLED_ShowColumn(i,Animation[i+j]);</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">30</span>)&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">j+=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span>( j &gt; <span class="number">16</span> ) j=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ds1302">DS1302</h2><p>时钟芯片(RTC): 实时时钟,是一种集成电路</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230111135009092.png" alt="image-20230111135009092"></p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230111134930952.png" alt="image-20230111134930952"></p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230111135053623.png" alt="image-20230111135053623"></p><h3 id="寄存器">寄存器</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230111141718216.png" alt="image-20230111141718216"></p><blockquote><p>每个命令字已经写在开头了,比如0x80 代表写入一个字节数据到秒寄存器</p><p>秒寄存器里面的第7位数据是控制时钟的开关,如果置为1,那么就代表时钟停止了,所以我们需要初始化为0,寄存器表里面有许多的位是控制不同的东西的,需要仔细看看</p><p>时钟芯片里面的寄存器的数据是BCD码,前四位代表十位数据,后四位代表个位数(BCD所表示的十六进制数据就是正常的十进制数据),所以0x1A 是不合法的,A代表10</p><p>因此我们直接显示16进制数据就是正常的10进制</p><p>BCD码转10进制   BCD/16*10+BCD%16</p><p>10进制转BCD码  num/10*16+num%10</p></blockquote><h3 id="读写数据">读写数据</h3><p>首先先写入命令字,如果命令字是读数据,且是下降沿,那么数据会从内部寄存器读出来放到IO口,如果命令字是写数据,且是上升沿,那么数据会从IO口写到内部寄存器</p><blockquote><p>每次都需要先写入命令字,然后根据命令字是读还是写再操作</p><p>我们在写数据前要先打开写保护 DS1302_WriteByte(0x8E,0x00);</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">bit DS1302_SCLK = P3^<span class="number">6</span>;</span><br><span class="line">sbit DS1302_IO = P3^<span class="number">4</span>;</span><br><span class="line">sbit DS1302_CE = P3^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302_WriteByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command,<span class="type">unsigned</span> <span class="type">char</span> Data)</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">DS1302_CE = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写入指令字</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">DS1302_IO = Command&amp;(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">DS1302_IO = Data&amp;(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">DS1302_CE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302_ReadByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,Data = <span class="number">0</span>;</span><br><span class="line">DS1302_CE = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写入指令字</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">DS1302_IO = Command&amp;(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入数据</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(DS1302_IO)Data |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line">DS1302_CE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="蜂鸣器">蜂鸣器</h2><p>分类:</p><p>有源蜂鸣器: 内部自带震荡源,频率固定,用直流电压就能响</p><p>无源蜂鸣器: 内部不带震荡源,需要控制器控制震荡脉冲才可以发声,可以发出不同频率的声音</p><p>我们只需要修改P2_5 这个值发生变化,然后设置不同的延时,就能产生不同的音频</p><h3 id="电路图">电路图</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230111170435263.png" alt="image-20230111170435263"></p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230111170459512.png" alt="image-20230111170459512"></p><h3 id="按键发声">按键发声</h3><p>Buzzer.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit Buzzer = P2^<span class="number">5</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Time</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;ms;i++)&#123;</span><br><span class="line">Buzzer = ~Buzzer;</span><br><span class="line">Delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Nixie.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buzzer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit Buzzer = P2^<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> keyNum;</span><br><span class="line">Nixie(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">keyNum = Key();</span><br><span class="line"><span class="keyword">if</span>(keyNum)&#123;</span><br><span class="line">Buzzer_Time(<span class="number">500</span>);</span><br><span class="line">Nixie(<span class="number">1</span>,keyNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="at24c02">AT24C02</h2><p>存储介质:非易失性存储器用的是E2PROM</p><p>通讯接口: I2C 总线</p><p>容量: 256Byte</p><h3 id="电路图">电路图</h3><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230113112256605.png" alt="image-20230113112256605"></p><h3 id="i2c总线-inter-ic-bus">I2C总线(Inter IC BUS)</h3><p>两根通信线:SCL(Serial Clock),SDA(Serial Data),同步,半双工,带数据应答</p><p>所有I2C设备的SCL连在一起,SDA连在一起</p><h4 id="时序结构">时序结构</h4><p><strong>起始条件</strong>: SCL 高电平期间,SDA从高电平切换到低电平</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230113115106905.png" alt="image-20230113115106905"></p><p><strong>终止条件</strong>: SCL高电平期间,SDA从低电平切换到高电平</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230113115113202.png" alt="image-20230113115113202"></p><p><strong>发送一个字节</strong>:  SCL 低电平期间,主机将数据位一次放到SDA先上(高位在前),然后拉高SCL,从机将在SCL高电平期间读取数据位,所有SCL高电平期间SDA<strong>不允许有数据位变化</strong>,依次循环上述过程八次,即可发送一个字节</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230113115425745.png" alt="image-20230113115425745"></p><p><strong>接收一个字节</strong>: 这个其实就跟发送一个字节一样,只不过目标对象对调了,主机在接收之前,需要释放SDA</p><p><strong>发送应答</strong>: 在接收完一个字节后,主机需要在下一个时钟发送一位数,数据0表示应答,数据1表示非应答</p><p><strong>接收应答</strong>: 在发送完一个字节之后,主机在下一个时钟接收一位数据,判断从机是否应答,主机需要释放SDA</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230113130535517.png" alt="image-20230113130535517"></p><p>地址前四位固定,后三位是设备地址</p><h2 id="中途解释">中途解释</h2><h3 id="寄存器">寄存器</h3><p>单片机里面有很多的特殊的寄存器,每个寄存器后面都连接了控制电路,当我们修改寄存器里面的值的时候,也会更改电路的连接,因此做到控制硬件</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230110210736117.png" alt="image-20230110210736117"></p><blockquote><p>sfr 关键字就是用来告诉编译器,寄存器所在的地址,以后我们对这个变量的操作就是操作寄存器</p><p>sfr P0 = 0x80;</p><p>sbit 就是声明寄存器里面的某一位</p><p>sbit P0_0 = 0x80;</p><p>sbit P0_1 = 0x81;</p><p>特殊用法:</p><p>sbit P02 = P0 ^ 2;</p></blockquote><h2 id="原理小结">原理小结</h2><p>单片机就是通过寄存器里面的值,控制各个io的电压,如果各个io的电压发生改变,也会被检测到修改寄存器里面的值</p><p>电压稳定的时候会比电压不稳定的灯亮</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">P2_1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">P2_0 = <span class="number">0</span>;</span><br><span class="line">P2_0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p2_0 的电压一直在变,p2_1的电压稳定,观察之后,p2_1 确实比p2_0亮</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105192210425.png" alt="image-20230105192210425"></p><p>我们可以做一个反实验对比一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">P2_0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">P2_1 = <span class="number">0</span>;</span><br><span class="line">P2_1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230105192242327.png" alt="image-20230105192242327"></p><p>是不是p2_0 又比 p2_1 亮</p><p><img src="/2022/12/01/%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/../img/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0assets/image-20230106100755264.png" alt="image-20230106100755264"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2022/11/25/git/git%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/25/git/git%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>什么是git</h1><p>git是一个**“分布式”** <strong>“版本控制”</strong> 系统,简明扼要</p><p>什么是版本控制: 就是当你进行了修改,它会帮你保存原先的版本,当你想用原先版本的时候,它能帮你找到原先版本并且恢复过来</p><p>什么是分布式: 就是你可以从任何一个远程仓库中克隆过来,也可以提交到任何一个远程仓库,而不局限于某一个仓库</p><h1>基本概念</h1><p>工作空间:就是创建git仓库的目录(.git除外)</p><p>暂存区: 用于存放于 git add 文件的地方,可能有人会说了,直接提交到仓库不就好了吗?对,确实可以,但是你想啊,每次改变一个文件就要提交一次,你不烦啊,我们可以改变以后一次提交嘛,而且你提交之后,就会有新纪录,如果你改一个文件就提交一次那不得产生很多版本吗?,到时候回退都不知道咋整,所以得整体改变完了后再做一次提交,改了部分就直接放到暂存区,还有就是,你暂存了之后,如果不对还能把它拿出来修改,如果直接提交了再做修改则又是一次提交</p><p>仓库: 就是存放你历史信息的地方(.git)</p><blockquote><p>在这里最需要补充的一点是,git不会管理那些没有被追踪的文件,比如你新创建一个文件,没有git add 它也就是没有追踪, 这样的文件,git是不会去管的,你的其他任何git命令都对他无效</p></blockquote><h1>基本命令</h1><h2 id="init">init</h2><ul><li>git init 当前目录初始化仓库</li><li>git init path 指定目录初始化仓库</li><li>git</li></ul><h2 id="add">add</h2><p>将修改的文件提交到暂存区</p><h2 id="commit">commit</h2><p>将暂存区的文件提交到仓库中,<strong>而不是将工作目录中的文件提交到仓库中</strong></p><ul><li><strong>-m</strong> 添加提交消息</li><li><strong>-a</strong> 将<strong>所有追踪的而且修改的文件</strong>放入暂存区,一次提交</li><li><strong>–amend</strong> 如果我们已经提交了暂存区的东西,但是我们发现还有已经修改的文件没有提交到暂存区,我们需要把修改的文件提交到暂存区,然后使用–amend参数提交,这样就只有一次提交记录</li></ul><h2 id="diff">diff</h2><ul><li>git diff 输出 工作目录与暂存区的区别(如果暂存区没有,则输出工作区与最近一次提交版本的区别)</li><li>git diff --staged/cache 输出暂存区与最近一次提交版本的区别</li></ul><p>输出信息说明:</p><p>diff --git a/test4.txt b/test4.txt  (a/test4.txt 是修改前 b/test4.txt 是修改后)<br>index d00491f…0cfbf08 (修改前后的hash值) 100644(文件权限)<br>— a/test4.txt (修改前文件)<br>+++ b/test4.txt (修改后文件)<br>@@ -1 +1,2 @@ (修改前文件从第一行开始,总共一行(默认一行), 修改后文件从第一行开始,总共两行)<br>- 修改前文件位置内容<br>+ 修改后文件对应内容<br>+ 修改后文件对应内容</p><h2 id="rm">rm</h2><p>这里是一个难以理解的点,请先看额外补充中git rm 与 rm 的区别</p><ul><li>git rm 直接删除文件而且提交&quot;修改文件&quot;到暂存区</li><li>git rm --cached 不删除文件 提交&quot;修改文件&quot;到暂存区</li></ul><h2 id="mv">mv</h2><p>移动文件(可以做改名和删除操作)</p><h2 id="log">log</h2><p>输出<strong>这个分支版本</strong>以前的历史版本信息,因为我们有时候会回退,所有当前版本不一定是最新版本</p><p>常用参数</p><ul><li>-p 输出版本信息的同时,输出两次对比</li><li>–stat 输出这个版本的简略信息,有多少行被增加,多少行被删除</li><li>–pretty=oneline 将hash值与提交信息放在一行</li><li>-n 显示最近n次提交记录</li><li>–since, --after  仅显示指定时间之后的提交。</li><li>–until, --before 仅显示指定时间之前的提交。</li><li>–author 显示作者匹配字符的提交</li><li>–grep 显示提交说明中包含指定字符的提交</li></ul><h2 id="reflog">reflog</h2><p>显示可引用的历史版本记录,就是显示在本地仓库的操作的历史版本记录,如果你不小心回退了回去,又不记得以前版本的hash值,你可以通过这个查看,如果是克隆远程仓库下来,你是看不了别人操作记录的,我觉得这个也很合理,别人没有创建分支来记录这个东西,确实没有必要看这些操作,只需要本地能够操作就行</p><h2 id="clone">clone</h2><p>将远程仓库克隆到本地,默认创建orgin远程用户</p><ul><li><p>git clone url  克隆仓库的所有分支</p></li><li><p>git clone url -b 分支 克隆仓库的指定分支</p></li></ul><h2 id="checkout">checkout</h2><p>可以切换分支,也可以创建分支,还可以移动HEAD指针位置</p><ul><li>git checkout name 切换分支</li><li>git checkout -b name 创建分支并且切换分支</li><li>git checkout commitid 移动HEAD 指针到这个位置,但是并不会创建分支</li></ul><h2 id="switch">switch</h2><ul><li>git switch name 切换分支</li><li>git switch -c name 创建分支(在当前版本上创建)并且切换分支</li><li>git switch -c name commitid 创建commitid对应版本的分支并且切换分支</li></ul><h2 id="branch">branch</h2><ul><li>git branch 查看所有分支</li><li>git branch name 创建分支 不会检出分支</li><li>git branch -v 查看所有分支的最后一次提交</li><li>git branch --merged name(默认为当前分支名字) 查看和name已经合并的分支</li><li>git branch --no-merged  name(默认为当前分支名字) 查看和name没有合并的分支</li><li>git branch -d name 删除分支 如果当前分支没有被合并的话,会删除失败</li><li>git branch -D name 强制删除分支</li><li>git branch -r 显示远程仓库的分支</li></ul><p>在a分支合并b a变成a和b合并体 但是b还在原地, 所以在 a 分支下 git branch --merged  是b 但是在b分支下 git branch --merged 是没有a的, 如果两个分支在同一个版本下,默认它两是合并的</p><h2 id="merge">merge</h2><p>合并分支,如果两个分支都在同一条线上,就会快速合并(不会产生冲突),否则就看有没有冲突,如果有冲突则会将将不同的东西给列出来,生成一个新的同名文件到工作空间,等着我们去修改,修改完后再提交到暂存区,在提交到仓库</p><ul><li>git merge branchname    合并本地分支</li><li>git merge 远程仓库明/branchname   合并远程分支</li></ul><h2 id="tag">tag</h2><p>给当前版本打标签,就跟书签是一样的概念</p><ul><li>git tag tagname commitid 给commitid这个版本打一个简单标签</li><li>git tag -a tagname commitid -m 标注信息   给commitid这个版本打一个注解标签</li><li>git tag -d tagname 删除标签</li></ul><h2 id="撤销操作">撤销操作</h2><ul><li>restore file  取消对工作目录文件的一切操作  恢复到和暂存区,或者上一个版本的样子,</li><li>restore --staged  file  取消暂存, 将文件变成已修改</li><li>如果想同时撤销暂存区和工作目录的修改  直接用 git reset --hard</li></ul><h2 id="reset">reset</h2><p>重置到某个版本,但是这个版本之后的记录将不会出现在历史记录中(也就是git log 是看不到这个版本之后的提交记录的,可以通过git reflog 找到上一次重置的版本号,再一次重置回去,就能找到历史记录了)</p><p><code>git reset</code> 用于将当前分支的 HEAD 指针重置为指定的提交，同时可以选择性地更新索引和工作目录。这使得你可以丢弃一些未提交或已提交的更改。<code>git reset</code> 有三种模式：</p><ul><li><code>--soft</code>：仅重置 HEAD 指针，保留索引和工作目录不变。这样可以撤销一次提交，但保留已暂存和未暂存的更改。</li><li><code>--mixed</code>（默认）：重置 HEAD 指针和索引，但保留工作目录不变。这样可以撤销提交并取消暂存的更改，但保留未暂存的更改。</li><li><code>--hard</code>：重置 HEAD 指针、索引和工作目录。这样可以彻底撤销所有更改，回到指定的提交状态。</li></ul><blockquote><p>这里的索引就是暂存区</p></blockquote><h2 id="revert">revert</h2><p>回滚提交,也就是将<strong>历史记录的某一个版本给取消掉,取消掉它对文件的修改</strong>,但是这个版本之后的提交依然生效,如果之后的版本修改了这个版本修改的地方,那么会产生冲突,需要我们自己去解决冲突</p><ul><li>git revert &lt;commit-hash&gt; 回滚某个历史版本</li></ul><h2 id="rebase">rebase</h2><p><strong>能进行分支合并</strong>,与merge的区别请看额外补充,这个还能修改历史提交,也请看额外补充</p><ul><li>git rebase branchname 合并分支 每一个不同的提交都需要去操作一下如果有冲突,就需要解决冲突</li><li>git rebase -i commitid或者HEAD  修改历史提交</li></ul><h2 id="remote">remote</h2><ul><li>git remote add name url  添加远程仓库(不写name 默认为orgin)</li><li>git remote 查看远程仓库名字</li><li>git remote -v  查看远程仓库名字对应url</li><li>git remote rename oldname newname 修改名字</li><li>git remote remove name 删除远程仓库</li><li>git remote set-url name url 更改url</li></ul><h2 id="fetch">fetch</h2><p>拉取远程仓库的最新分支到本地,</p><ul><li>git fetch repositoryname  更新所有分支</li><li>git fetch repositoryname branch 更新指定分支</li></ul><h2 id="pull">pull</h2><p>拉取远程仓库最新分支并且进行合并,如果远程仓库版本低于当前分支则会生成对比文件,需要我们自己去修改,然后再提交</p><ul><li>git pull 远程仓库名字 分支</li><li>git pull --rebase 远程仓库名字 分支 合并的时候选择用rebase这个方式</li></ul><h2 id="push">push</h2><ul><li>git push repositoryname localbranchname:remotebranchname 推送本地分支到远程分支上</li><li>git push repositoryname :remotebranchname == git push name --delete remotebranchname 删除远程仓库分支</li><li>git push repositoryname 推送所有分支到远程仓库</li><li><strong>git push -u 远程仓库名字 分支名</strong>  推送分支到远程仓库,并且创建与之对应的上流分支关系,以后在这个分支上可以直接执行git push命令就能将这个分支推送上去</li><li>-f  强制推送</li></ul><h2 id="stash">stash</h2><p>我们在一个分支上修改了很多文件,但是我们现在需要切换到另一个分支去工作,我们又不想提交一次当前分支,所以我们需要储藏当前分支的内容,当我们回到这个分支的时候,再将数据恢复过来,</p><ul><li>git stash 将当前工作区,<strong>已追踪的文件放到贮藏区里面</strong>,<strong>这个结构是堆栈结构</strong></li><li>git stash list 查看贮藏区所有的东西</li><li>git stash apply stash@{编号} --index 将贮藏区的东西恢复到当前目录,如果不加–index 则不会恢复已暂存的</li></ul><blockquote><p>要注意是的是已追踪哦,如果没有是追踪的文件的话,如果修改了或者删除了,到时候是回不来的</p></blockquote><h1>额外补充</h1><p>记住，在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的,也可以说任何已经提交的东西都是无法删除的,除非你删掉.git。</p><h2 id="git-rm-与-rm-有什么区别">git rm 与 rm 有什么区别?</h2><p>rm 是删除本地文件 这也算是对文件的一种操作,和修改这个文件是一样的,这个时候git会把它当成已修改文件处理,所以这个文件不在暂存区中,当你直接commit的时候你commit不了,必须使用commit -am 提交</p><p>当前使用 git rm的时候 git会直接把这个以修改文件直接暂存起来 当你直接使用commit的时候也能commit</p><p>无论使用git rm(后面不带–cached) 还是 rm 都可以删除文件 只要提交成功 git 都不会再追踪这个文件,它两的区别就在与提交的时候 需要使用的参数不同罢了,就跟跳过暂存区与不跳过暂存区一样</p><p>总结:  rm a  + git add a == git rm a</p><p>同理 mv a b + git rm a + git add b == git mv a b</p><h2 id="switch-与-checkout的区别">switch 与 checkout的区别</h2><ul><li>首先在创建分支不同  git switch -c newbranch 和 git checkout -b newbranch</li><li>安全性不同：<code>git switch</code>比<code>git checkout</code>更安全。如果有未提交的更改，<code>git switch</code>会拒绝切换分支或检出提交的操作，以防止更改丢失。<code>git checkout</code>没有这种保护措施。(<strong>不过新版本貌似如果有改变,都不能切换了</strong>)</li></ul><h2 id="本地远程分支">本地远程分支</h2><p>当我们使用clone 或者 remote add 的时候, 我们本地会创建一个本地远程仓库分支 比如 origin/master,这个分支是远程仓库的内容,我们是无法直接使用这个分支的,我们只能新创建一个分支去引用它,然后做提交到远程服务器,才能修改它,所以当我们使用git fetch 时,是把本地远程分支更新,不会影响到本地分支,我们也可以再通过git merge 去合并这个远程分支</p><h2 id="补丁">补丁</h2><p>在 Git 中，补丁（patch）是一种表示代码更改的文本格式，通常用于在开发者之间共享和讨论更改。补丁文件包含了一系列修改，描述了如何从一个代码状态转变到另一个状态。它们通常包含添加（+）的行、删除（-）的行以及上下文行（未更改的代码行，有助于定位更改的位置）。</p><h2 id="reset-revert-rebase">reset revert rebase</h2><p>这三个都能操作历史版本,那有什么区别呢?</p><p>如果我们只是想回到某个历史版本,<strong>这个版本到历史版本之间的修改,我不要了</strong>,我们可以使用reset(适合单文件一个地方改了很多次,然后回退回去)</p><p><strong>如果我们想留着这个版本到历史版本之间的修改,可以使用revert,但是会再产生一次提交记录,就相当于记录一下,我修改了历史版本</strong></p><p>如果我们需要这个版本与历史版本之间提交了的东西,我们需要使用rebase命令,去依次修改有冲突的版本,如果是两个人开发一个分支,那么这个命令就要小心的用了,首先使用了这个命令修改了历史版本后,必须强制推送,那边开发的人要先合并解决冲突才能继续干活</p><p><strong>只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作</strong></p><p>rebase命令会给你提供一个文档,让你更改里面的文字选择对哪个版本进行修改,退出后,会依次来到要修改的版本,然后进行修改,提交,这样其实是产生新的提交,原来的提交其实还在,只是我们看不到了**,所以rebase修改历史记录的本质,不是修改,而是新建,隐藏旧提交,这样让我们看起来像是修改了**</p><p>我们来对比一下三个方法把</p><p>现在有一个这样的提交历史</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A--B--C--D--E (master)</span><br></pre></td></tr></table></figure><p>我现在要修改C的提交信息</p><p>reset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A--B--C(master)</span><br></pre></td></tr></table></figure><p>revert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A--B--C--D--E--C&#x27;(master)</span><br></pre></td></tr></table></figure><p>rebase</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A--B--C&#x27;--D&#x27;--E&#x27;(master)</span><br></pre></td></tr></table></figure><h2 id="rebase-与-merge的区别">rebase 与 merge的区别</h2><p>两个都能合并分支,但是merge合并的时候,不是线性合并,只是两个提交版本间的合并,而rebase合并的时候,会将发起合并所在分支中的所有在待合并的分支中没有的提交进行合并,这样的话,看起来是线性的,其实也不是线性的,只是原先那些提交记录,没有人去管他们,变成了游离分支,所以用git log查看不到原先的那些提交版本,而且<strong>我们用rebase可以将多个提交合并成一个提交</strong></p><p>要注意rebase命令不要用反了, 它和merge正好是反过来的, 如果我们要将feature分支合并到master分支</p><ul><li>如果是merge命令 在master分支上执行  git merge feature</li><li>如果是热吧色命令 在feature分支上执行  git rebase master  然后 git checkout master git merge feature(这样就能直接线性合并)</li></ul><p>现在有一个提交历史如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A--B--C  (master)</span><br><span class="line"> \</span><br><span class="line">  D--E--F  (feature)</span><br></pre></td></tr></table></figure><p>我们将fearture合并到master上</p><p>merge</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A--B--C------G  (master)</span><br><span class="line"> \         /</span><br><span class="line">  D--E--F       (feature)</span><br></pre></td></tr></table></figure><p>rebase</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A--B--C          (master)</span><br><span class="line">         \</span><br><span class="line">          D&#x27;--E&#x27;--F&#x27;  (feature)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行git checkout master git merge feature</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A--B--C--D&#x27;--E&#x27;--F&#x27;  (master, feature)</span><br></pre></td></tr></table></figure><h2 id="git钩子">git钩子</h2><p>所谓钩子就是,再某一时刻,会被自动执行的代码,我们可以通过编写钩子代码,做到很多自动化的事,比如提交前干嘛,提交后干嘛,这个还是有点用处的,我么可以在用户提交后把提交来的东西转交给别处</p><h2 id="搭建git服务器">搭建git服务器</h2><p>为了方便,首先先创建一个git用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd git</span><br><span class="line">passwd git # 修改登录密码</span><br><span class="line">su git # 切换到git用户</span><br></pre></td></tr></table></figure><p>创建git仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir git</span><br><span class="line">cd git</span><br><span class="line">git init --bare test.git</span><br></pre></td></tr></table></figure><p>现在可以克隆这个仓库了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@ip地址:/home/git/test.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入密码就可以了,如果不想输入密码,可以将本机的公钥放到/home/git/.ssh/authorized_keys 文件里面</span></span><br></pre></td></tr></table></figure><h2 id="sourcetree">sourceTree</h2><p>其实吧,命令会一些基本就行了,咱们主要还是得用可视化啊,建议不要对这些命令钻的太深,但是一定要记住git可以做哪些操作,下面讲讲sourceTree中的操作对应哪些命令</p><p><img src="/2022/11/25/git/git%E6%80%BB%E7%BB%93/../img/git%E6%80%BB%E7%BB%93assets/image-20221122140208434.png" alt="image-20221122140208434"></p><p><img src="/2022/11/25/git/git%E6%80%BB%E7%BB%93/../img/git%E6%80%BB%E7%BB%93assets/image-20221122140542104.png" alt="image-20221122140542104"></p><h2 id="个人尝试删掉记录">个人尝试删掉记录</h2><p>我们可能在工作的时候,心里不爽,骂了两句老板,在代码里面,然后我们还提交到了远程库,第二天,又怂了,想从远程库里面吧骂老板那句话给删掉</p><h3 id="方法一-不能删除-但是也难被发现">方法一(不能删除,但是也难被发现)</h3><p>直接把远程分支删掉,然后在本地修改好后再推送上去,看起来很好,但是,远程库里面会多出来一条游离分支,虽然不能直接看到,但是只要checkout到那个游离分支里面去,就会看到我骂老板的话,如果不是可视化的平台,像gittee,gitlab这种,是无法被发现的(如果不记得commitid,以我目前的水平还不知道怎么发现)</p><h3 id="方法二">方法二</h3><p>直接本地修改,再进行强制推送,好像这个和方法一也没什么区别(我可真是个大聪明)</p><p>总结:咱们还是不要乱骂老板,只要推送上去了,就会有记录,除非你直接删掉公司的仓库</p><h3 id="方法三">方法三</h3><p>安装git-filter-repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install  git-filter-repo</span><br></pre></td></tr></table></figure><p>清理文件 这个文件路径是相对于.git文件夹来说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --path file.txt --invert-paths --force</span><br></pre></td></tr></table></figure><p>强制推送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure><blockquote><p>不过这里需要你对仓库有足够的权限,能够强制推送覆盖别人的代码</p></blockquote><h2 id="不在当前文件夹操作这个仓库">不在当前文件夹操作这个仓库</h2><p>有时候,我们需要使用本地的git的钩子去操作另一个本地仓库(不知道你们有没有,我可以举个例子,比如我有一个服务器,我本地push一个页面到服务器的git仓库,但是它是一个裸仓库,看不到里面的东西的,而我的服务器部署的nginx需要这个页面,我需要把这个页面拿出来,这个时候我需要给服务器中心仓库设置钩子去自动更新服务器另一个不是裸仓库的仓库),但是这个路径有时候我把握不定,会造成更新失败,这个时候我们使用下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=仓库路径 --git-dir=仓库路径/.git 命令</span><br></pre></td></tr></table></figure><h2 id="设置代理">设置代理</h2><p>在使用 Git 进行代码版本控制的过程中，有时我们需要通过代理服务器来访问远程仓库。而 Clash 是一款非常强大的代理软件，可以帮助我们实现代理服务</p><h3 id="设置-http-代理">设置 HTTP 代理</h3><p>在终端中输入以下命令来设置 HTTP 代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>其中，7890 是 Clash 所监听的端口号，如果您的 Clash 监听的端口号不是 7890，那么您需要将命令中的端口号修改为您的 Clash 监听端口号。</p><p>如果需要取消代理，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure><h3 id="设置-https-代理">设置 HTTPS 代理</h3><p>在终端中输入以下命令来设置 HTTPS 代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>同样，如果您的 Clash 监听的端口号不是 7890，那么您需要将命令中的端口号修改为您的 Clash 监听端口号。</p><p>如果需要取消代理，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h3 id="使用-socks5-代理">使用 SOCKS5 代理</h3><p>如果您想要使用 SOCKS5 代理，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.gitproxy &#x27;socks5://127.0.0.1:7891&#x27;</span><br></pre></td></tr></table></figure><p>其中，7891 是 Clash 监听的 SOCKS5 端口号，如果您的 Clash 监听的端口号不是 7891，那么您需要将命令中的端口号修改为您的 Clash 监听端口号。</p><p>如果需要取消代理，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset core.gitproxy</span><br></pre></td></tr></table></figure><h2 id="配置常用命令">配置常用命令</h2><h3 id="查看全局配置">查看全局配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 需要复习 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署到远程服务器</title>
      <link href="/2022/11/24/hexo/hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/11/24/hexo/hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1>hexo+git+docker/nginx</h1><p>怎么安装,这些就自行百度,或者关注我之后的博客</p><h1>服务器端</h1><h2 id="创建一个用户">创建一个用户</h2><p>由于需要使用到ssh免密操作,所有不好直接把公钥放到root用户下,新建一个用户来管理(当然,你也可以用root用户)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地创建好的公钥放到/home/git/.ssh/authorized_keys 里面,这样就能免密登录了</span></span><br><span class="line">mkdir /home/git/.ssh</span><br><span class="line">vim  /home/git/.ssh/authorized_keys  #输入你的秘钥</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置不能通过git用户登录服务器,但是可以使用git操作仓库</span></span><br><span class="line">vim /etc/passwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git:x:1002:1002::/home/git:/usr/bin/git-shell  只需要将/bin/bash 改成 /usr/bin/git-shell 这个就好了 ,需要改成自己git-shell的路径哦,每个人的git环境路径可能是不一样的</span></span><br></pre></td></tr></table></figure><h2 id="搭建git服务器">搭建git服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在服务器上搭建一个裸仓库,用来当git服务器,目录自己选</span></span><br><span class="line">git init --bare /opt/git/repository </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录所有者给git</span></span><br><span class="line">chown -R git:git /opt/git </span><br></pre></td></tr></table></figure><h2 id="编写post-update钩子">编写post-update钩子</h2><p>方便我们推送文章后,自动让另一个服务器本地仓库更新页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将钩子变的可用</span></span><br><span class="line">mv /opt/git/repository/hooks/post-update.sample /opt/git/repository/hooks/post-update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空钩子内容</span></span><br><span class="line">echo &quot;&quot; &gt; /opt/git/repository/hooks/post-update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编写git服务器的post-update钩子</span></span><br><span class="line">vim /opt/git/repository/hooks/post-update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################将下面的脚本全部复制进去######################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器给web服务器访问的博客目录</span></span><br><span class="line">blogpath=/opt/git/blog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git服务器地址</span></span><br><span class="line">repositorypath=/opt/git/repository</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果博客还不存在,则先<span class="built_in">clone</span>,如果存在直接拉取</span></span><br><span class="line">if [ ! -d $blogpath ]; </span><br><span class="line">then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">克隆好服务器本地仓库</span></span><br><span class="line">  git clone $repositorypath $blogpath</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">让本地仓库拉取本地远程仓库</span></span><br><span class="line">  git --work-tree=$blogpath --git-dir=$blogpath/.git pull -f</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="设置web服务器">设置web服务器</h2><h3 id="方式一-nginx">方式一  nginx</h3><p>现在我们已经有了所有的静态资源在/opt/git/blog/public目录下,我们只需要把这个目录交给web服务器就行,设置nginx的根目录为这个目录就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf  # 每个人的环境变量不一样哦,注意自己安装在哪</span><br><span class="line"></span><br><span class="line">listen       80;</span><br><span class="line">listen       [::]:80;</span><br><span class="line">server_name  _;</span><br><span class="line">root        /opt/git/blog/public;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改成这样就OK啦</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方式二-docker">方式二 docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name hexonginx -v /opt/git/blog/public:/usr/share/nginx/html -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这个是不是巨方便啊,哈哈哈哈</p><h1>客户端</h1><h2 id="创建本地博客仓库">创建本地博客仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己选好路径</span></span><br><span class="line">git init </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加远程仓库,上面写好的,这里的ip需要写成服务器ip地址哦</span></span><br><span class="line">git remote add origin git@ip:/opt/git/repository </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加Gitee 仓库地址 主要也是做个备份,安全起见,万一哪天服务器不小心<span class="built_in">rm</span> -rf / 了,那我不得哭死啊</span></span><br><span class="line">git remote add gitee git仓库地址</span><br></pre></td></tr></table></figure><p>编写好.gitignore文件 我们只需要配置文件,以及source,public,其他的基本都不需要,下面是gitignore文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">.deploy*/</span><br><span class="line">_multiconfig.yml</span><br><span class="line">themes</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure><h2 id="编写好钩子">编写好钩子</h2><p>在.git/hook下面</p><p>编写一个pre-commit 文件,不要带任何后缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动生成html文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">自动暂存(主要是为了将那些新创建的文件给添加到暂存区,不然commit -a 也没用)</span></span><br><span class="line">git add .</span><br><span class="line">echo &quot;添加到暂存区完成&quot;</span><br></pre></td></tr></table></figure><p>编写一个post-commit 文件,不要带任何后缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;开始推送&quot;</span><br><span class="line">git push gitee master</span><br><span class="line">echo &quot;推送到gittee成功&quot;</span><br><span class="line">git push origin master</span><br><span class="line">echo &quot;推送到自己服务器成功&quot;</span><br></pre></td></tr></table></figure><h2 id="推送">推送</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当我们在<span class="built_in">source</span>/_post目录下写好文章之后</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接commit</span></span><br><span class="line">git commit -am &quot;终于完成了&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2022/11/24/linux/linux/"/>
      <url>/2022/11/24/linux/linux/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>以下总结全部基于CentOS Linux release 7.6.1810 (Core) 总结出来的命令,不同版本对应的命令可能不同</p><blockquote><p>小技巧: 当我们不会某个命令时,我们可以使用 命令 --help 来查看它的参数及使用</p></blockquote><h1>系统目录结构</h1><h2 id="必须存在的目录">必须存在的目录</h2><ul><li>/bin 里面存放着一些经常使用的命令</li><li>/boot 存放着linux启动时的核心文件</li><li>/dev 里面存放着linux外部设备文件</li><li>/etc 里面存放系统管理需要的配置文件</li><li>/lib 存放着基本的动态链接共享库</li><li>/media 放置可移除的设备,U盘 DVD这些</li><li>/mnt 临时挂在其他设备,与media差不多</li><li>/opt 给额外软件所摆放的目录</li><li>/run 用来放置系统启动的时候产生的信息 /var/run 软连接了这个目录</li><li>/sbin 超级管理员使用的系统管理工具</li><li>/srv 用于放某些服务器所需要的数据</li><li>/temp 临时文件 系统会开机自动删除</li><li>/usr (unix software resource) 很多用户的应用程序和文件都放在这个文件下面(可分享,不变动),和windows的C:\Program Files 类似</li><li>/usr/bin  /bin就是软连接了这个目录,所以与/bin的作用一样</li><li>/usr/sbin  /sbin 也是软连接了这个目录</li><li>/usr/lib  /lib 就是软连接了这个目录</li><li>/usr/local 放置我们安装软件的地方</li><li>/usr/share 放置共享只读的数据</li><li>/var(variable) 里面放着不断扩充的东西,比如一些日志信息,mysql的数据文件</li></ul><h2 id="建议存在的目录">建议存在的目录</h2><ul><li><p>/proc 是系统内存的映射文件,它是虚拟文件,在内存中,并不在硬盘中,里面包含了很多进程的信息</p></li><li><p>/home 用户家目录</p></li><li><p>/lost + found 非法关机存放的文件</p></li><li><p>/root 超级用户的家目录</p></li><li><p>/sys 也是虚拟目录,记录核心与系统硬件的信息</p></li></ul><h1>文件与目录管理</h1><h2 id="文件基本属性">文件基本属性</h2><p>d rwx r-x r-x 3 root root 4096 Nov  6 21:14</p><p>文件类型 文件拥有者的权限 文件组用户权限 其他人的权限 硬链接计数 文件拥有者 文件所属组 大小 最后修改时间</p><p>这些文件拥有者,所属组,其他人其实都只是为了把权限分配的清楚点</p><h3 id="文件类型">文件类型</h3><ul><li>d 目录(direction)</li><li>L(l) 软连接(ln)</li><li>c 字符块设备(char)</li><li>b 块设备(block)</li><li>p 管道文件(pipe)</li><li>s 本地套接字文件(socket)</li><li>- 普通文件(使用find命令的时候,f代表普通文件)</li></ul><h2 id="文件-目录属性操作">文件/目录属性操作</h2><p>文件/目录权限: rwx  读写执行</p><h3 id="默认权限">默认权限</h3><p>文件默认权限  -rw-rw-rw- 就所有人都只有读写权限</p><p>目录默认权限 -rwxrwxrwx 所有人都有读写执行权限  (至于目录为什么要有执行权限,请看额外补充<a href="#t1">目录权限与文件权限的区别</a>)</p><p>有人就会说了,我明明创建一个目录,不是所有人都有这个权限啊,比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir testdir</span><br><span class="line">ll -ld ./testdir</span><br><span class="line"></span><br><span class="line">drwxr-xr-x. 2 root root 6 11月 27 15:22 testdir</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看输出的权限,明明跟你说的不是一回事.</p><p>别急,后面还有个umask呢</p><h3 id="umask">umask</h3><p>这个东西就是在默认权限上,需要减掉的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入这个命令看输出什么</span></span><br><span class="line">[root@localhost ~]# umask</span><br><span class="line">0022</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出0022</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一个数字是特殊权限,暂时不管 第二个数字代表拥有者要减去的权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第三个数字代表所有组要减去的权限,第四个数字代表其他人要减去的权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个数字是可以自己更改的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umask 002 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如我们默认创建文件的时候,不想其他人读,我们就可以设置成这样</span></span><br></pre></td></tr></table></figure><p>umask设置仅在设置它的终端会话中有效。当你在终端中设置umask值时，<strong>它只会影响当前会话，不会影响其他终端或用户会话</strong>。umask是一个用于控制文件和目录默认权限的设置，当用户在当前会话中创建新的文件或目录时，这些默认权限将会应用。</p><p>如果你想要永久更改umask设置，可以在用户的配置文件（例如，~/.bashrc、~/.bash_profile或~/.profile）中设置。这样，在每次新的终端会话开始时，这些设置都会被应用。</p><p>对于系统范围的umask设置，可以在全局配置文件（例如，/etc/profile或/etc/bash.bashrc）中进行更改。c</p><h3 id="chattr">chattr</h3><p>chattr 命令（change attributes）用于更改文件或目录的扩展属性。这些扩展属性控制文件或目录在文件系统上的行为。例如，你可以设置一个文件为不可修改（immutable），这样就无法对其进行删除、重命名或更改</p><ul><li>-   取消某一个属性   + 增加某一个属性</li><li>+a 只能增加内容,不能修改和删除 -a代表取消</li><li>+i 不能被删除、改名、设置链接也无法写入或新增数据！-i代表取消</li></ul><h3 id="lsattr">lsattr</h3><p>查看隐藏属性(不是查看隐藏文件哦)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsattr -d test4</span><br><span class="line">-----a---------- test4</span><br></pre></td></tr></table></figure><p>你会看到这个与ls输出还是有区别的</p><h3 id="chown">chown</h3><p>更改文件所有者命令:    chown [-R] 所有者:所属组  文件/目录               -R代表递归下去,否则的话只变当前目录</p><h3 id="chmod">chmod</h3><p>常用参数:</p><ul><li>a 对所有人操作</li><li>u 对所有者操作</li><li>g 所属对用户组操作</li><li>o 对其他人操作</li></ul><p>更改文件权限:</p><ul><li>chmod [-R] 777 用数字代表修饰的权限 1执行 2 写 4读取  和位置刚好对应上   比如  rwx   4 2 1</li><li>chmod [-R] a+x-w 用符号去更改权限</li><li>chmod 7777 还有一种下面这个特殊权限的写法 第一个代表特殊权限   后三个就是跟上面的一样</li></ul><h3 id="特殊权限suid-sgid-sbit">特殊权限SUID ,SGID,SBIT</h3><h4 id="suid-set-uid">SUID(set uid)</h4><p>在具有执行权限的应用程序上(而不是shell脚本哈),对拥有者新增s权限,</p><p>这个权限的作用是,在可执行的文件的基础上,让<strong>执行者</strong>暂时具有<strong>拥有者的权限</strong>,什么意思呢? 我举个栗子,比如/etc/shadow普通用户用cat是无法查看里面的内容的,但是我们用chmod <strong>u+s</strong>  /usr/bin/cat之后, 普通用户再执行cat /etc/shadow是能够看到里面内容了,还有就是passwd命令,它修改了/etc/shadow里面的东西,普通用户是不是也能通过这个命令修改密码?但是我们不能够手动的去修改/etc/passwd吧!!,所以这些特殊权限的出现都是为了解决问题的,感觉这个特殊权限的出现就是为了解决,<strong>让普通用户只有用指定命令,才能查看或者修改文件或者目录里面的东西</strong>,<strong>重点还是修改,一般连看都不会让看</strong></p><p>这里我们自己做一个演示</p><p>这里有root 和 djm 两个用户 操作目录在/root/test4中</p><p>首先root用户编写一段c++代码命名为test.cpp查看/etc/shdow(这个文件的权限是000)里面的东西</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;/etc/shadow&quot;</span>)</span></span>;</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">80</span>];</span><br><span class="line">        in&gt;&gt;buff;</span><br><span class="line">        cout&lt;&lt;buff&lt;&lt;endl;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test4] g++ -o test test.cpp  #编译</span><br><span class="line">[root@localhost test4] ./test  #运行</span><br><span class="line">root:$1$6TJ77l9F$sizoIqVNB4hGQWtYlu5.S.::0:99999:7:::  # 我们看到是能够出现东西的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切换到djm这个用户去执行这个脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[djm@localhost test4]$ ./test</span><br><span class="line"></span><br><span class="line">[djm@localhost test4]$</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们发现什么都没有输出,因为里面肯定出错了,没有权限去读这个文件</span></span><br></pre></td></tr></table></figure><p>我们将这个应用程序拥有者加上s权限,再让djm去执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test4] chmod u+s test</span><br><span class="line">[root@localhost test4] su djm</span><br><span class="line">[djm@localhost test4] ./test</span><br><span class="line">root:$1$6TJ77l9F$sizoIqVNB4hGQWtYlu5.S.::0:99999:7:::</span><br><span class="line">[djm@localhost test4]  #发现能够顺利的读出来了 </span><br></pre></td></tr></table></figure><h4 id="sgid">SGID</h4><ul><li>在所属组具有执行权限的应用程序上(而不是shell脚本哈),对所属组新增s权限,这样的话执行者暂时拥有了用户组的权限</li><li>在所属组具有执行权限的目录上,对所属组新增s权限,执行者就能够拥有目录的所属组的权限了,<strong>而且这个执行者创建的东西,所属组会变成跟目录所属组一样(默认创建文件的所属组是用户的当前组哦)</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod g+s test</span><br><span class="line">chmod g-s test</span><br></pre></td></tr></table></figure><h4 id="sbit">SBIT</h4><p>在具有<strong>执行权限的目录</strong>上,对其他人新增t权限,在这个目录下,除了root和我自己还有目录所有者,别人都不能删掉我的文件(包括跟我一个组的人),纵使他在这个目录下有写权限</p><h3 id="file">file</h3><p>查看文件的类型,这个函数还是挺有用的,可以准确的判断出文件里面的东西,以及文件的特殊权限,还有打包方式这些啊</p><h2 id="文件和目录的操作">文件和目录的操作</h2><h3 id="mv">mv</h3><p>移动文件 mv 源地址 目标地址</p><h3 id="r-m">r m</h3><p>统一用 rm -rf 目标地址 (强烈不推荐使用这个命令 要删除文件时候,直接使用mv 移动到回收站 到时候定期删除回收站就行)</p><h3 id="cp">cp</h3><p>复制文件  统一用 cp -r  源文件或者目录 目标文件或者目录</p><ul><li>-p 连同属性一起复制过去(不使用这个参数,使用cp命令的时候,可能改变文件的属性, 比如源文件所有者是djm这个用户,我在root用户使用命令复制的话,目标文件的所有者就会变成root)</li><li>-d 如果是链接文件,则复制链接文件属性,而不是链接文件指向的那个文件(如果不加这个参数,复制的是链接文件所链接的那个文件)</li><li>-r 复制目录</li><li>-u 如果目的地址文件存在且比源地址文件时间旧或者目的地址文件不存在才进行复制</li></ul><h3 id="ln">ln</h3><p>硬链接计数或者创建软链接</p><p>创建硬链接 ln 源文件(<strong>这里必须使用绝对路径</strong>) 目标文件</p><p>创建软连接 ln -s 源文件 目标文件</p><p>软连接与硬链接的区别: 软链接相当于快捷方式 当别人使用它时,先找到目标地址再使用,硬链接相当于指向同一个物理块</p><h3 id="mkdir">mkdir</h3><p>创建目录 统一用 mkdir -p 目录</p><h2 id="查看文件">查看文件</h2><h3 id="ls">ls</h3><p>查看指定文件或者目录信息,ls 可以用来查看文件大小,但是并不能用来查看目录总共大小,它查看的只是这个目录的大小</p><p>常用参数:</p><ul><li>-a 显示所有文件</li><li>-l 显示文件信息</li><li>-h 显示文件大小(带单位)</li><li>-F 显示目录后缀</li></ul><h3 id="cat">cat</h3><p>可以查看文件内容,建议查看小文件内容(毕竟终端缓存有限) 也可以写入内容 cat &gt; file</p><h3 id="tac">tac</h3><p>倒着查看文件内容 和 cat正好反着来</p><h3 id="nl">nl</h3><p>打印文件带有行号</p><h3 id="more">more</h3><p>可以翻页查看</p><h3 id="head">head</h3><p>默认查看前十行,可以指定行数 head -行数</p><h3 id="tail">tail</h3><p>跟head差不多 不过是看后面</p><h3 id="basename">basename</h3><p>查看路径中最后一个/对应的字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">basename</span> /home/user/documents/file.txt <span class="comment"># 输出file.txt</span></span><br></pre></td></tr></table></figure><h3 id="dirname">dirname</h3><p>查看路径在倒数第二个/对应的目录名字(如果没有就输出/)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename /home/user/documents/file.txt # 输出documents</span><br></pre></td></tr></table></figure><h1>用户信息与管理</h1><h2 id="uid">UID</h2><ul><li>UID=0 这个代表是系统管理员,我们可以在创建用户的时候指定它的UID让他也成为系统管理员,拥有root权限</li><li>UID = 1-999 系统账号 1-200 系统自己创建 201-999 用户可以创建</li><li>UID = 1000+  这个是给用户自己用的</li></ul><h2 id="su">su</h2><p>切换用户</p><ul><li>su username  切换到另一个用户</li><li>su -l username 连带环境变量这些过去</li></ul><h2 id="sudo">sudo</h2><p>这是个动词,然后后面的用户做</p><ul><li>sudo 命令 默认是root用户执行</li><li>sudo -u user  命令 让 user用户执行</li></ul><h2 id="useradd">useradd</h2><p>添加一个用户(<strong>如果没有让设置密码,可以通过passwd 用户名 设置密码</strong>),这个命令必须是具有sudo权限的用户才可以使用</p><h2 id="userdel">userdel</h2><p>删除一个用户 sudo userdel <strong>-r</strong> username 这里如果不使用-r 的话,不会删除用户的家目录,这个命令要慎用哦,它会把/etc/passwd,/etc/shadow,这些记录了它的数据都删掉哦,这样的话,这个用户就彻底不能用啦,如果我们只是不想让这个用户使用了,我们可以设置用户密码失效,或者过期</p><h2 id="usermod">usermod</h2><p>修改用户信息,其实是为了修改当时useradd里面设置或者默认的参数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user -c </span><br><span class="line">usermod -a -G 用户组 用户名  #将用户添加到某个组</span><br><span class="line">usermod -g 用户组 用户名 #将用户改成某个组</span><br><span class="line">usermod -l 新用户名字 旧用户名</span><br><span class="line">usermod -s 修改登录shell</span><br><span class="line"></span><br><span class="line">usermod --help 更多的请看这个</span><br></pre></td></tr></table></figure><h2 id="groups">groups</h2><p>查看当前用户属于哪些组</p><h2 id="newgrp">newgrp</h2><p>一个用户可能属于多个用户组,当用户创建文件的时候,那这个文件是属于当前这个用户所在的组的,我们可以通过这个命令修改当前用户所在组,然后改变创建的文件的用户组,前提是这个用户必须属于待转变的组</p><h2 id="gpasswd">gpasswd</h2><p>让用户成为一个群组的管理员,可以添加删除用户,也可以更改群组密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gpasswd -A djm project  # 让djm成为project的管理员</span><br><span class="line">[djm@localhost ~]$ gpasswd -a root project # djm 让root加入这个组</span><br><span class="line">[djm@localhost ~]$ gpasswd -d root project # djm 让root退出这个组</span><br></pre></td></tr></table></figure><h2 id="passwd">passwd</h2><ul><li>-S 查看用户的密码相关信息(失效时间,加密方式,…)    djm PS 2022-11-18 0 99999 7 -1 (密码已设置，使用 MD5 算法。)</li><li>passwd username 修改密码</li><li>-l 让用户密码失效(用户则无法登陆)</li><li>-u 让用户密码生效</li></ul><h2 id="chage">chage</h2><p>修改密码的相关信息,但是不能修改密码哦, 如果对passwd -S 列出来的信息看不太明白,可以使用chage -l看的更加详细</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost shelltest]# chage -l djm</span><br><span class="line">最近一次密码修改时间                                    ：11月 18, 2022</span><br><span class="line">密码过期时间                                    ：从不</span><br><span class="line">密码失效时间                                    ：从不</span><br><span class="line">帐户过期时间                                            ：从不</span><br><span class="line">两次改变密码之间相距的最小天数          ：0</span><br><span class="line">两次改变密码之间相距的最大天数          ：99999</span><br><span class="line">在密码过期之前警告的天数        ：7</span><br></pre></td></tr></table></figure><h2 id="pwck">pwck</h2><p>检查/etc/passwd与/etc/shadow里面的信息是否一致,如果不一致,会提示修改</p><h2 id="查看所有用户信息">查看所有用户信息</h2><p>cat /etc/passwd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line"></span><br><span class="line">格式:  用户名 用户密码(x代表设有密码,加密密码在/etc/shadow里面)  用户id 用户组id 描述信息 主目录(也就是家目录,登录后的目录) 默认shell(用户登录后启动这个shell进程,将用户的操作传递给内核,我们可以通过设置这个shell程序,让用户只能运行指定程序,而不登录)</span><br></pre></td></tr></table></figure><h2 id="查看所有用户名">查看所有用户名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看所有用户组">查看所有用户组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看所有用户密码-加密了的">查看所有用户密码(加密了的)</h2><p>cat /etc/shadow</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户名：加密密码：最后一次修改密码时间：最小修改密码时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</span><br><span class="line">root:$1$Mladfbadfdsqyh$x/vIgIfuiYp.XZybGThAB1:19302:0:99999:7:::</span><br><span class="line">bin:*:17834:0:99999:7:::</span><br><span class="line">polkitd:!!:17962::::::</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果加密密码为*,!这些就是为了让密码失效</span></span><br></pre></td></tr></table></figure><h2 id="查看所有用户组信息">查看所有用户组信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dockerroot:x:980:</span><br><span class="line">hjc:x:1001:</span><br><span class="line">project:x:1003:djm,hjc</span><br><span class="line">git:x:1002:</span><br><span class="line">docker:x:979:</span><br><span class="line">用户组名称:密码:用户组id:属于该组的用户</span><br></pre></td></tr></table></figure><h1>磁盘管理</h1><h2 id="df">df</h2><p>用于查看文件系统(已经格式化好的分区会显示, 没有格式化的分区不会显示, 这里的格式化就是指有没有安装文件系统)的总容量 剩余容量 以及用掉的容量</p><ul><li>-a 列出所有分区</li><li>-h 将大小变成人容易看懂的大小</li><li>-k 以KB为单位显示分区大小</li><li>-m 以MB为单位显示分区大小</li><li>df 文件或者目录 会显示这个文件或者目录所在分区的情况</li></ul><h2 id="du">du</h2><p>用于查看文件或者目录所占大小</p><ul><li>-a 查看所有子目录和文件的大小,默认是只看所有子目录大小的</li><li>-h 就是说人话啦</li><li>-s 只显示指定目录大小,不列出它的子目录所占大小</li><li>-S 子目录大小与我的大小分开计算  就是当前目录的大小就是文件所占大小 不包括子目录</li><li>-k 以kB显示</li><li>-m 以MB显示</li></ul><h2 id="lsblk">lsblk</h2><ul><li><p><code>lsblk</code> 是一个用于显示系统中块设备信息的命令，特别是有关磁盘和分区的信息。它可以清晰地展示出块设备的层次结构，包括磁盘、分区以及挂载点等。</p><h3 id="常用参数">常用参数</h3><ul><li><code>-a</code> 或 <code>--all</code>：显示所有设备，包括空的设备。</li><li><code>-b</code> 或 <code>--bytes</code>：以字节为单位显示大小。</li><li><code>-d</code> 或 <code>--nodeps</code>：仅显示磁盘，不显示分区。</li><li><code>-e</code> 或 <code>--exclude</code>：排除指定的设备。可以指定设备的主次设备号。</li></ul><p><code>lsblk</code> 命令非常直观，常用于系统管理员查看磁盘和分区的状态以及挂载情况。通过使用不同的参数，可以获得详细而特定的信息，以便更好地管理和监控系统存储设备。</p></li></ul><h2 id="fdisk">fdisk</h2><p><code>fdisk</code> 是一个用于在 Linux 和 Unix 系统中管理磁盘分区的命令。它可以创建、删除、修改和查看分区表。以下是 <code>fdisk</code> 命令的一些常见用途和参数：</p><h3 id="常见用途">常见用途</h3><ol><li><strong>查看分区表</strong>：显示指定磁盘的分区表。</li><li><strong>创建新分区</strong>：在磁盘上创建新的分区。</li><li><strong>删除分区</strong>：删除指定的分区。</li><li><strong>修改分区</strong>：修改已有分区的属性，如分区类型。</li><li><strong>保存和写入更改</strong>：保存对分区表的更改并写入磁盘。</li></ol><h3 id="常用参数">常用参数</h3><ul><li><code>-l</code>：列出所有磁盘的分区表信息。例如 <code>fdisk -l</code>。</li><li><code>-u</code>：显示分区表时使用扇区单位而不是柱面单位。例如 <code>fdisk -lu</code>。</li><li><code>-s</code>：显示指定设备的大小。例如 <code>fdisk -s /dev/sda1</code>。</li><li><code>-b</code>：指定磁盘扇区大小。例如 <code>fdisk -b 4096 /dev/sda</code>。</li><li><code>-c</code>：兼容模式，不重新计算柱面和扇区。</li><li><code>-n</code>：非交互模式，用于脚本。例如 <code>fdisk -n /dev/sda</code>。</li></ul><h3 id="使用示例">使用示例</h3><ul><li><p>查看所有磁盘的分区表：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式编辑某个磁盘的分区：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure><p>在交互模式中可以使用以下命令：</p><ul><li><code>p</code>：打印分区表。</li><li><code>n</code>：新增分区。</li><li><code>d</code>：删除分区。</li><li><code>t</code>：修改分区类型。</li><li><code>w</code>：保存并退出。</li><li><code>q</code>：不保存退出。</li></ul></li><li><p>显示指定设备的分区大小：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -s /dev/sda1</span><br></pre></td></tr></table></figure></li></ul><p>使用 <code>fdisk</code> 时，请小心操作，因为错误地修改分区表可能会导致数据丢失。在进行任何修改之前，建议备份重要数据。</p><blockquote><p>如果需要使用逻辑分区, 得先创建扩展分区, 然后创建逻辑分区</p></blockquote><h2 id="partprobe">partprobe</h2><p>用于通知操作系统内核有关磁盘分区表更改的命令。当你对磁盘分区进行修改后，例如使用 <code>fdisk</code> 或 <code>parted</code> 添加、删除或更改分区，操作系统内核可能不会立即识别到这些更改。<code>partprobe</code> 通过强制内核重新读取分区表，使这些更改立即生效。</p><h2 id="mkfs">mkfs</h2><p><code>mkfs</code> 是一个用于在分区上创建文件系统的命令。<code>mkfs</code> 是 “make filesystem” 的缩写，通过它可以在一个设备（如硬盘分区、USB驱动器等）上创建新的文件系统。不同类型的文件系统有不同的命令，通常 <code>mkfs</code> 命令是一个前端，可以调用具体的文件系统创建工具，例如 <code>mkfs.ext4</code>、<code>mkfs.ntfs</code> 等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makfs.ext4 /dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="mount">mount</h2><p><code>mount</code> 命令用于将设备或分区挂载到文件系统树中的一个目录上。</p><h4 id="基本语法">基本语法</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] &lt;设备&gt; &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><h4 id="示例">示例</h4><ol><li><p><strong>挂载分区</strong><br>将 <code>/dev/sda1</code> 分区挂载到 <code>/mnt</code> 目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda1 /mnt</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载ISO文件</strong><br>将一个ISO映像文件挂载到 <code>/mnt/iso</code> 目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop /path/to/file.iso /mnt/iso</span><br></pre></td></tr></table></figure></li><li><p><strong>查看挂载的文件系统</strong><br>使用以下命令查看当前系统中所有挂载的文件系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载网络文件系统（例如NFS）</strong><br>将远程NFS文件系统挂载到本地目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t nfs 192.168.1.100:/exported/path /mnt/nfs</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>重启后, mount挂载的分区会失效的,  需要重新挂载,  如果希望自动挂载就需要写入到 /etc/fstab里面去</p></blockquote><h2 id="umount">umount</h2><p><code>umount</code> 命令用于卸载已经挂载的文件系统。</p><h4 id="基本语法">基本语法</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [选项] &lt;挂载点或设备&gt;</span><br></pre></td></tr></table></figure><h4 id="示例">示例</h4><ol><li><p><strong>卸载分区</strong><br>从 <code>/mnt</code> 目录卸载文件系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure></li><li><p><strong>卸载设备</strong><br>卸载 <code>/dev/sda1</code> 分区：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /dev/sda1</span><br></pre></td></tr></table></figure></li><li><p><strong>强制卸载</strong><br>如果文件系统正在使用，可以使用 <code>-f</code> 选项强制卸载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount -f /mnt</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项">注意事项</h3><ol><li><p><strong>确保没有进程使用挂载点</strong><br>在卸载之前，确保没有进程在使用挂载点上的文件，否则卸载操作可能会失败。可以使用 <code>lsof</code> 或 <code>fuser</code> 命令查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /mnt</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -vm /mnt</span><br></pre></td></tr></table></figure></li><li><p><strong>使用挂载选项</strong><br>在挂载时，可以使用各种选项来控制挂载行为。例如，以只读模式挂载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o ro /dev/sda1 /mnt</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结">总结</h3><ul><li><code>mount</code> 命令用于将设备或文件系统挂载到文件系统树的一个目录中，使得该设备或文件系统可以被访问和使用。</li><li><code>umount</code> 命令用于卸载已经挂载的文件系统，从而断开设备或文件系统的连接。</li></ul><p>了解并正确使用这两个命令是进行系统和存储管理的基础。</p><h1>压缩与解压</h1><h2 id="tar">tar</h2><p>涉及的参数:</p><ul><li>c 压缩</li><li>x 解压</li><li>z 以gzip方式解压缩</li><li>j 以bzip2方式解压缩</li><li>v 显示解压缩过程</li><li>f 指定压缩包名字</li><li>-C  如果要解压到其他目录去</li></ul><h3 id="压缩">压缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar czvf  压缩包名字.tar(.tar.gz 它两压缩方式一样) 待压缩文件</span><br><span class="line">tar cjvf  压缩包名字.tar.bz2 待压缩文件</span><br></pre></td></tr></table></figure><h3 id="解压">解压</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf 压缩包名字.tar -C 解压到的目录(必须存在)</span><br><span class="line">tar xjvf 压缩包名字.tar.bz2 -C</span><br></pre></td></tr></table></figure><h2 id="zip">zip</h2><h3 id="压缩">压缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r 压缩包名字.zip 待压缩文件</span><br></pre></td></tr></table></figure><h3 id="解压">解压</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip 压缩包名字 -d 解压路径</span><br></pre></td></tr></table></figure><h2 id="xz">xz</h2><p>先压缩成tar 在压缩成tar.xz  xz -z 压缩包.tar</p><p>先解压缩成tar  xz -d 压缩包的.tar.xz</p><h1>查找命令</h1><h2 id="find">find</h2><p>主要功能 根据指定的信息 查找文件/目录的路径 这个查找比较慢,一般也不太常用</p><p>格式是 : find 查找路径 参数类型 参数</p><p>常用参数:</p><ul><li><p>-name 根据文件名字进行查询  可以进行模糊查询 * 代表任意多字符 ? 代表一个字符</p></li><li><p>-type 根据文件类型进行查找</p></li><li><p>-size 根据文件大小进行查找 +4M 代表(4M,无穷大) -4M 代表(0,3M] 4M 代表(3M,4M]</p></li><li><p>-maxdepth 最多搜索到第几层</p></li><li><p>-mindepth 最少从第几层搜索</p><blockquote><p>如果想把搜索出来的结果当成参数传递给后面的命令 直接使用管道是不行的, 管道是将后一个命令的输入流和前一个的输出流结合到一起,而不是将它变成参数给后一个命令</p></blockquote></li></ul><p>同时执行多个操作</p><ul><li>-exec 后面可以接待执行的命令,最后得接{} ; 代表结束</li><li>-ok 它跟exec的功能时相似的 不过它是询问式的 问用户是否要进行后面的操作</li><li>xargs 它是一个单独的命令 可以将前一个命令的输出流解析成参数给后面的命令 find -name test -type d | xargs ls</li></ul><h2 id="locate">locate</h2><p>这个命令是去linux系统自己维护的数据库中查找,每天自动更新,所以实时更新的文件它会找不到必须先更新它的数据库</p><blockquote><p>sudo updatedb</p></blockquote><ul><li>单纯根据名字查找文件 locate 文件名 (查找数据库中所有路径包含关键字的文件或者目录)</li><li>根据路径查找(必须是绝对路径) locate 绝对路径  (<strong>查找所有路径中</strong> 以这个<strong>路径开头的路径对应的文件或者目录</strong>)</li><li>-i 忽略大小写</li><li>-n 显示前几个</li><li>-r 使用正则表达式</li></ul><h2 id="whereis">whereis</h2><p>在预定义目录下找文件  whereis filename</p><ul><li>-l 查看预定义的目录</li><li>-b 查找二进制文件</li></ul><p><code>whereis</code> 命令默认搜索的路径在各种系统中可能有所不同，但通常，它会在下列路径中搜索：</p><ul><li><code>/bin</code></li><li><code>/sbin</code></li><li><code>/usr/bin</code></li><li><code>/usr/sbin</code></li><li><code>/usr/local/bin</code></li><li><code>/usr/local/sbin</code></li><li><code>/usr/include</code></li><li><code>/usr/share/man</code></li><li><code>/usr/share/info</code></li></ul><p>这些路径通常包含了大部分的系统命令、库文件、头文件和文档</p><h1>文本三剑客</h1><h2 id="grep">grep</h2><p>grep 和 find 的区别 在于 grep是查找文件里面的东西</p><p>格式: grep “搜索内容” 搜索目录/文件 参数</p><p>常用参数:</p><ul><li>-r 如果要搜索目录下文件内容的东西 必须使用这个参数</li><li>-i 忽略大小写</li><li>-n 显示搜索内容所在文件行</li><li>-v 排除掉满足要求的行</li><li>-w 整个单词匹配</li><li>-C 指定匹配行的前后几行</li><li>-B 指定匹配行的前面几行</li><li>-A 指定匹配行的后面几行</li></ul><p>如果不写搜索文件 而且也没有使用-r 参数 则会根据输入内容进行匹配</p><p>如果不写搜索文件 但是使用了-r 参数 则会执行执行这样的命令 grep “搜索内容” -r /  相当于全盘文件内容查找</p><p>常见用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep -v grep | grep ssh  # 搜索进程的时候排除grep进程</span><br><span class="line">cat /etc/passwd | grep -n djm  # 显示行号</span><br></pre></td></tr></table></figure><h2 id="sed">sed</h2><p>sed可以利用脚本处理文件或者输入流,可以编辑,删除,新增文件里面的东西</p><p>参数:</p><ul><li>-e 以指定脚本操作文本</li><li>-f 以指定脚本文件操作文本</li><li>-n 仅显示脚本操作后的文本</li><li>-i 修改源文件</li></ul><p>动作:</p><ul><li>a 新增</li><li>c 取代</li><li>d 删除</li><li>i 插入</li><li>p 打印</li><li>s 取代(可以使用正则)</li></ul><p>关于s 取代:</p><ol><li><strong>默认替换</strong>：<code>sed 's/old/new/' file</code>。这将会替换每一行中的第一个匹配到的<code>old</code>。</li><li><strong>全局替换</strong>：<code>sed 's/old/new/g' file</code>。添加<code>g</code>选项（代表 global），这将会替换每一行中所有匹配到的<code>old</code>。</li><li><strong>替换第n个匹配</strong>：<code>sed 's/old/new/n' file</code>。这里的<code>n</code>是一个数字，代表替换每一行中的第<code>n</code>个<code>old</code>。例如，<code>s/old/new/2</code>将会替换每一行中的第二个<code>old</code>。</li><li><strong>替换在指定行范围内的匹配</strong>：<code>sed '1,3 s/old/new/g' file</code>。这将会替换在第一行到第三行中所有匹配到的<code>old</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;1a hello world&quot; log.txt</span><br><span class="line">sed -i &quot;1a 你好&quot; log.txt</span><br><span class="line">sed -i &quot;2c hello world hello world&quot; log.txt</span><br><span class="line">sed -i &quot;1d&quot; log.txt</span><br><span class="line">sed -i &quot;1i 你好&quot; log.txt</span><br><span class="line">sed -i &quot;s/hello world/你好/g;s/你好/nihao/g&quot; log.txt</span><br></pre></td></tr></table></figure><h2 id="awk">awk</h2><p>将文件或者输入流的一行按照 <strong>空格或者制表符(我们也能指定分隔符)拆开分成若干个参数供后面函数使用</strong></p><p>基本语法:  awk ‘pattern {action}’ file   pattern 是模式 相当于一个if   action是执行动作, 里面可以使用</p><p>常用参数</p><ul><li>-F 指定输入分割符</li><li>-f 指定脚本文件读取命令</li><li>-v 用户指定一个变量的值(可以用于内置变量,也可以用于自定义变量)</li></ul><p>内置变量</p><ul><li><p>FS 指定输入分割符</p></li><li><p>OFS 指定输出分割符 <strong>只有print里面用逗号分割的变量才会被输出分割符替代</strong></p></li><li><p>NF 字段数量(主要用于取倒数的第一个,减几个就是倒数几个)</p></li><li><p>NR 表示当前在多少行</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取出用户名字和它的shell</span></span><br><span class="line">cat /etc/passwd | awk -v FS=&quot;:&quot; -v a=&quot; 的登录shell是 &quot; &#x27;&#123;print NR  $1 a $(NF)&#125;&#x27;</span><br></pre></td></tr></table></figure><p>在 <code>awk</code> 中，美元符号 <code>$</code> 的使用主要取决于你想要访问的是字段（field）还是变量（variable）。</p><ol><li><p><strong>字段（Field）</strong>：如果你想要访问输入行的特定字段，你需要使用 <code>$</code> 符号。例如，<code>$1</code> 代表第一个字段，<code>$2</code> 代表第二个字段，等等。<code>$0</code> 是一个特例，它代表整行内容。</p></li><li><p><strong>变量（Variable）</strong>：如果你想要访问一个变量，就不应该使用 <code>$</code> 符号。例如，<code>NR</code> 是一个内置变量，代表当前行号，<code>NF</code> 是一个内置变量，代表当前行的字段数量。你也可以使用 <code>-v</code> 选项来定义自己的变量，这种情况下同样不应该使用 <code>$</code> 符号。</p></li></ol><p>所以总的来说，在 <code>awk</code> 的 <code>action</code> 部分，如果你想要访问字段，就应该使用 <code>$</code> 符号；如果你想要访问变量，就不应该使用 <code>$</code> 符号。</p><h1>vim的使用</h1><h2 id="命令模式">命令模式</h2><h3 id="进入输入模式">进入输入模式</h3><p>命令模式下的光标比较大,是覆盖了当前字符的,光标前就是这个字符前面,光标后就是这个字符后面</p><ul><li>i 当前光标前输入</li><li>a 光标后输入</li><li>I行首输入</li><li>A行尾输入</li><li>o向下插入新行</li><li>O向上插入新行</li></ul><h3 id="移动">移动</h3><p>h 向左 j向下 k向上 l 向右</p><ul><li>0 移动到行首</li><li>^ 移动到行首字母</li><li>$ 移动到行尾</li><li>gg 移动到文件第一行行首</li><li>G 移动到文件最后一行行尾</li><li>nG 移动到第几行</li><li>n+回车 向下移动多少行</li><li>w 下一个字开头</li><li>b 上一个字开头</li><li>fx 移动到本行的下一个x字符开头</li><li>ctrl + u (up)向上翻半页</li><li>ctrl + d (down)向下翻半页</li></ul><h3 id="代码格式化">代码格式化</h3><p>gg=G</p><h3 id="删除命令">删除命令</h3><ul><li>x 删除光标所在位置</li><li>X 删除光标前一个位置</li><li>dw 删除当前光标到这个单词结束的部分  比如 aa光标位置ww  会删除 ww</li><li>d0 删除当前位置到这一行开头的字符串</li><li>d$ 删除当前位置到这一行结尾的字符串</li><li>dd 删除当前行</li><li>ndd 删除n行</li></ul><h3 id="撤销与重做">撤销与重做</h3><ul><li>u 撤销命令</li><li>Ctrl + r 重做</li></ul><h3 id="复制与粘贴">复制与粘贴</h3><ul><li>yy 复制当前行</li><li>p 粘贴 小写粘贴到当前行下边 大写粘贴到当前行上边</li><li>nyy 复制n行</li></ul><h3 id="打开到指定行">打开到指定行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file +100</span><br></pre></td></tr></table></figure><h2 id="末行模式">末行模式</h2><h3 id="查找">查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/word  向后查找</span><br><span class="line">?word 向前查找</span><br><span class="line">按 n 执行上一次操作</span><br><span class="line">按 N 反向执行上一次操作</span><br></pre></td></tr></table></figure><h3 id="替换">替换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1,$ s/查找字符/替换字符/g  等价于 %s/查找字符/替换字符/g</span><br><span class="line">替换1-最后一行的所有字符</span><br><span class="line"></span><br><span class="line">s/查找字符/替换字符/g</span><br><span class="line">替换当前行的所有字符</span><br><span class="line"></span><br><span class="line">s/查找字符/替换字符/</span><br><span class="line">替换当前行第一个匹配的字符</span><br></pre></td></tr></table></figure><h1>yum的使用</h1><p>yum为什么会出现? 它解决了什么问题?</p><p>在最开始的时候,linux一般使用编译源码的方式安装应用程序,这样太麻烦了,后来出现了rpm包管理工具 只需要下载好.rpm包(这个包是编译好了的包)然后使用rpm安装就行,但是它有个缺点就是如果一个应用程序需要其他依赖,还得自己手动再去下载其他依赖,所以yum诞生了, 它将所有rpm包放在仓库中,安装一个rpm包时会自动下载它依赖的rpm包,我们也可以更改/etc/yum.repos.d/ 里面的文件更改yum仓库源</p><h2 id="更改为阿里源">更改为阿里源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum clean all #清除原先缓存</span><br><span class="line">yum makecache # 构建现在仓库缓存</span><br><span class="line">yum update # 更新程序</span><br></pre></td></tr></table></figure><h2 id="常用命令">常用命令</h2><ul><li>yum check-update 列出所有可以更新的软件</li><li>yum update (软件名字) 如果没有跟软件名字则更新所有软件 这个更新不会删除原来的软件</li><li>yum insall 软件名字   安装软件,这个过程可以会下载其他依赖,系统会询问你是否下载, 如果不想系统询问 可以 yum -y install</li><li>yum list 查看服务器提供的所有软件</li><li>yum upgrade  它和update功能差不多 不过它会删除过时的软件 而且还会更新系统内核</li><li>yum remove 删除软件包(也就是卸载)</li><li>yum search 搜索软件包</li><li>yum list updates 查看哪些软件可以更新</li></ul><h1>查看/操作系统信息命令</h1><h2 id="systemctl">systemctl</h2><p>常用参数</p><ul><li>start 开启服务</li><li>stop 关闭服务</li><li>status 查看服务状态</li><li>enable 设置服务开机自启动</li><li>disable 关机开启自启动</li><li>restart 重启服务</li></ul><h2 id="hostname">hostname</h2><p>查看当前主机名</p><h2 id="hostnamectl">hostnamectl</h2><p>修改主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname name</span><br></pre></td></tr></table></figure><h2 id="fuser">fuser</h2><p>查看哪个进程正在使用当前文件或者目录</p><h2 id="lsof">lsof</h2><p>主要用于查看进程打开的文件名称和数目 (非root用户使用时,可能看不到root用户的某些信息),linux 万物皆文件,所以也能查看进程对应的网络信息</p><p>这个命令的功能太强大了,下面就只写几个好用一点的</p><ul><li>lsof -i :port 显示使用port 端口的进程信息 (把-i 看成Internet)</li><li>lsof -i  tcp(udp) 显示所有tcp(udp)的网络信息</li><li>上面两个是可以组合的 比如 lsof -i tcp:22</li><li>lsof -c vsftpd 显示 vsftpd 打开的文件</li><li>lsof -p pid 显示pid对应的进程打开的文件</li><li>lsof -u djm 显示djm这个用户打开的文件</li><li>lsof 文件  显示占用这个文件的进程</li></ul><h2 id="ps">ps</h2><p>查看系统进程</p><ul><li>ps -a 查看当前用户的所有进程</li><li>ps -aux 显示所有用户的进程,并且列出进程所属用户</li></ul><h2 id="top">top</h2><p>可以查看内存和交换区已经用了多少,还剩多少,cpu的状态</p><p>各个进程的占用资源的实时信息</p><p>类似于windows的资源管理器</p><h2 id="uptime">uptime</h2><p>查看系统运行的时间,当前登录用户,工作负载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost shelltest]# uptime </span><br><span class="line"> 11:12:42 up  1:25,  3 users,  load average: 6.26, 4.86, 3.35</span><br></pre></td></tr></table></figure><h2 id="sysctl">sysctl</h2><p><code>sysctl</code> 是一个在 Unix 和 Linux 操作系统中用于<strong>读取和修改内核参数的命令</strong>。这些内核参数存储在 <code>/proc/sys/</code> 目录下，可以影响操作系统的各种行为。</p><p><strong>这些内核参数包括网络设置、内存使用、文件系统行为等等</strong>。例如，<code>net.ipv4.ip_forward</code> 参数控制着是否开启 IPv4 转发（也就是是否允许作为路由器使用），而 <code>vm.swappiness</code> 参数控制着操作系统在什么情况下开始使用交换空间。</p><p><code>sysctl</code> 命令可以有以下形式：</p><ul><li><code>sysctl parameter_name</code>：显示指定参数的当前值。</li><li><code>sysctl -w parameter_name=value</code>：修改指定参数的值。这个操作可能需要 root 权限**，并且只会对当前会话生效。在重启后，修改将失效。**</li><li><code>sysctl -p file</code>：加载指定的配置文件，通常用于在系统启动时设置参数。如果没有指定文件，那么默认加载 <code>/etc/sysctl.conf</code> 文件。</li></ul><p>需要注意的是，不是所有的参数都可以修改，一些核心的参数可能是只读的。此外，修改内核参数可能会影响系统的稳定性和安全性，所以在没有明确的理由和了解可能的影响之前，不建议随便修改。</p><h2 id="查看系统版本">查看系统版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/os-release</span><br><span class="line">cat /etc/centos-release</span><br></pre></td></tr></table></figure><h2 id="查看日志信息-journalctl">查看日志信息(journalctl)</h2><p>我们平时开启了很多服务,这些服务都是后台运行,那它们的日志信息我们就不能看到,不过linux提供了Systemd来管理所有日志信息,我们只需要通过journalctl这个命令就能查看</p><ul><li><strong>journalctl -u 查看指定服务的日志</strong></li><li>journalctl -k 查看内核日志</li><li>journalctl -b 查看启动日志</li><li>-n 查看最近几行的</li><li>-r 查看最旧的几行</li><li>-f 实时显示</li></ul><h2 id="查看cpu型号">查看CPU型号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-version</span><br></pre></td></tr></table></figure><h2 id="查看cpu详细信息">查看CPU详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><h2 id="查看物理cpu个数">查看物理cpu个数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq|wc -l</span><br></pre></td></tr></table></figure><h2 id="查看一个cpu是几核">查看一个CPU是几核</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cores&quot;|uniq</span><br></pre></td></tr></table></figure><h2 id="查看cpu逻辑核心数">查看CPU逻辑核心数</h2><p>逻辑核心数 = CPU个数*CPU核数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;processor&quot; |wc -l</span><br></pre></td></tr></table></figure><h2 id="例行性工作调度">例行性工作调度</h2><h1>其他命令</h1><h2 id="kill">kill</h2><p>用于杀死或者停止一个进程</p><ul><li>kill -1 重新加载进程</li><li>kill -9 杀死进程</li></ul><h2 id="wc">wc</h2><p>用于统计文件中 字符数 行数 单词数目</p><ul><li>wc -l 统计行数</li><li>wc -w 统计单词数目</li><li>wc -c 统计字符数</li><li>wc  依次显示上面三个</li></ul><h2 id="watch">watch</h2><p>可以设置运行同一个命令的间隔</p><ul><li>-n 设置时间间隔</li><li>-d 显示变化的部分</li></ul><h2 id="tee">tee</h2><p>这个命令主要将输入流的东西写到文件里面去</p><ul><li>-i  忽略中断</li><li>-a 追加到文件里面去,而不是覆盖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls | tee test.txt  #将ls的输出全部放到test.txt中去</span><br><span class="line">tee test.txt # 将我们自己的输入写到文件里面去</span><br></pre></td></tr></table></figure><h2 id="pwd">pwd</h2><p>显示当前工作目录</p><h2 id="touch">touch</h2><p>文件不存在则创建文件,文件存在更新修改时间</p><h2 id="which">which</h2><p>查看非内建命令的位置</p><h2 id="date">date</h2><p>查看或者设置系统时间</p><h2 id="clock">clock</h2><p>查看或者设置硬件时间</p><h2 id="tzselect">tzselect</h2><p>选择时区</p><h2 id="lastlog">lastlog</h2><p>查看用户上一次登录时间</p><h1>shell 编程</h1><h2 id="set">set</h2><p>定义一个变量</p><h2 id="unset">unset</h2><p>删除一个变量</p><h2 id="变量的使用方式">变量的使用方式</h2><p>比如有个变量x</p><p>赋值  x=1</p><p>取值 $x  或者 ${x} 推荐使用后者 ,  不要和$()搞混哦,$() 是执行里面的</p><p>计算 $(($x+1))</p><h2 id="decalre">decalre</h2><ul><li>-i 声明为 整数类型</li><li>+i 删除为整数类型</li><li>-f 显示函数内容</li><li>-p 显示属性名字和值</li><li>-r 增加为只读属性</li><li>-x 设置为全局变量</li><li>+x 设置为自订变量</li></ul><h2 id="变量的测试与替换">变量的测试与替换</h2><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">str没有设定</th><th style="text-align:center">str为空字符串</th><th style="text-align:center">str设定了且不为空字符串</th></tr></thead><tbody><tr><td style="text-align:center">var=${str-expr}    |  var=$expr</td><td style="text-align:center">var=$str    |    var=$str</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>var=${str:-expr}</strong></td><td style="text-align:center">var=$expr</td><td style="text-align:center">var=$expr</td><td style="text-align:center">var=$str</td></tr><tr><td style="text-align:center">var=${str+expr}</td><td style="text-align:center">var=$str</td><td style="text-align:center">var=$expr</td><td style="text-align:center">var=$expr</td></tr><tr><td style="text-align:center">var=${str:+expr}</td><td style="text-align:center">var=$str</td><td style="text-align:center">var=$str</td><td style="text-align:center">var=$expr</td></tr><tr><td style="text-align:center">这个也太难记住了吧</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="变量的数值运算">变量的数值运算</h2><p>$( <strong>($a*$b)</strong> ) 中间这个括号不能省</p><p>举个例子    a=1,b=2   $($a*$b) =&gt; $(1*2)  这个式子bash是看不懂的哦 因为 $()是代表执行里面的命令  而 $((1*2)) 会被计算是因为(1*2)代表的命令是计算</p><h2 id="test">test</h2><p>test命令主要用于判断</p><h3 id="文件是否存在或者权限判定">文件是否存在或者权限判定</h3><ul><li>-e name 是否有文件名或者目录名为name</li><li>-f name 文件是否存在</li><li>-d name 目录是否存在</li><li>-r name 是否可读</li><li>-w name 是否可写</li><li>-x name 是否可执行</li><li>-u name 是否具有suid权限</li><li>-g name 是否具有sgid权限</li><li>-k name 是否具有 sbit权限</li></ul><h3 id="整数判定">整数判定</h3><ul><li>-eq 是否相等</li><li>-ne 是否不相等</li><li>-gt 大于</li><li>-lt 小于</li><li>-ge &gt;=</li><li>-le &lt;=</li></ul><h3 id="字符串判定">字符串判定</h3><ul><li>-z string 是否是空串</li><li>-n string 是否不是空串</li><li>== 两个字符串是否相等</li><li>!= 两个字符串是否不相等</li></ul><h3 id="多重判定">多重判定</h3><ul><li>-a and</li><li>-o or</li><li>! 取反</li></ul><h3 id="代替test">[]代替test</h3><p>我们经常用[] 代替test 这里要主要格式</p><p>[  “a” == “b” ] 要注意空格哦 ,还有就是使用变量名的时候最好用&quot;$a&quot; 这种</p><h2 id="预设变量">预设变量</h2><ul><li>$0 文件名字</li><li>$# 变量个数</li><li>$@ 全部变量</li><li>$* 全部变量</li><li>$1…n 输入的参数</li></ul><h2 id="条件判断">条件判断</h2><h3 id="if">if</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [];then</span><br><span class="line">elif [];then</span><br><span class="line">else</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="case">case</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">变量|常量)</span><br><span class="line">代码段</span><br><span class="line">;;</span><br><span class="line">变量)</span><br><span class="line">代码段</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="for">for</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var in a b c</span><br><span class="line">do</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="while">while</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while [ 判断表达式 ] </span><br><span class="line">do</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="函数">函数</h2><p>函数里面也有预设变量哦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">函数的定义</span></span><br><span class="line">function func()&#123;</span><br><span class="line">echo $@</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须先定义才能使用</span></span><br><span class="line">func 1 2 3</span><br></pre></td></tr></table></figure><h2 id="shell-脚本debug">shell 脚本debug</h2><ul><li>-n 检查语法不执行</li><li>-v 执行前将命令输出到屏幕</li><li>-x 将用到的命令才输出到屏幕</li></ul><h1>例行性工作</h1><h2 id="at">at</h2><h2 id="crontab">crontab</h2><h1>程序管理</h1><h2 id="none">&amp;</h2><p>我们在一个终端中,是可以在后台执行多个任务的,只需要使用 &amp; 跟在最后面就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zpcvf /tmp/etc.tar.gz /etc &amp;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份/etc目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个时候,我们还是可以操作前台的</span></span><br></pre></td></tr></table></figure><h2 id="jobs">jobs</h2><p>我们可以通过这个命令来查看当前终端的后台任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost shelltest]# jobs</span><br><span class="line">[1]+  运行中               sh test.sh &gt; test.txt &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>-l 列出pid</li><li>-r 列出正在背景中进行工作</li><li>-s 列出停止了的工作</li></ul><h2 id="fg">fg</h2><p>如果我们想让后台的工作拿到前台来,可以使用这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fg 工作号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比如上列中将工作号为1的拿到前台来工作</span></span><br><span class="line">fg 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不输入工作号,则会拿取有+号的任务,列如下面会那去2号任务</span></span><br><span class="line">[1]-  运行中               sh test.sh &gt; test.txt &amp;</span><br><span class="line">[2]+  运行中               sh test.sh &gt; test1.txt &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拿到前台来工作后,我们可以使用Ctrl+z来停止这个任务并且丢到后台去,但是没有删除哦(ctrl+c 会删除这个任务)</p><h2 id="bg">bg</h2><p>这个命令可以使后台的停止了的任务重新执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们将上面的2号任务拿到前台</span></span><br><span class="line">[root@localhost shelltest]# fg </span><br><span class="line">sh test.sh &gt; test1.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后按ctrl+z 停止它</span></span><br><span class="line">^Z</span><br><span class="line">[2]+  已停止               sh test.sh &gt; test1.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以输入下面这个命令重新后台运行那个任务</span></span><br><span class="line">bg 2 </span><br><span class="line"></span><br><span class="line">[root@localhost shelltest]# bg 2</span><br><span class="line">[2]+ sh test.sh &gt; test1.txt &amp;</span><br><span class="line">[root@localhost shelltest]# jobs</span><br><span class="line">[1]-  运行中               sh test.sh &gt; test.txt &amp;</span><br><span class="line">[2]+  运行中               sh test.sh &gt; test1.txt &amp;</span><br><span class="line">[root@localhost shelltest]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="kill">kill</h2><p>如果我们想结束一个工作,可以使用kill命令  格式 kill   -singnal %number  (必须是%number哦,不然默认是进程号)</p><ul><li>-9 %number 强制删除</li><li>-15 %number 正常删除</li></ul><h2 id="nohub">nohub</h2><p>默认情况下,所有的工作都是在当前终端的背景下执行的哦,当我们终端退出后,所有的工作都将结束,这当然是我们不想看到的,所有我们可以通过这个命令,可以让终端机退出后依然执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohub sh test.sh &gt; test4.txt &amp; </span><br></pre></td></tr></table></figure><h1>网络相关</h1><h2 id="测试桥接哪些ip能用">测试桥接哪些ip能用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> <span class="string">&quot;10.8.38&quot;</span> <span class="string">&quot;10.8.39&quot;</span>  <span class="comment"># 这里的ip得换成自己的</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt 255 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        str1=<span class="string">&quot;<span class="variable">$str</span>.<span class="variable">$i</span>&quot;</span></span><br><span class="line">        sed -i  <span class="string">&quot;1,\$s/^IPADD.*\$/IPADDR=<span class="variable">$str1</span>/g&quot;</span>  ./ifcfg-ens33 &gt; log.txt</span><br><span class="line"></span><br><span class="line">        systemctl restart network <span class="comment"># 这里是可以优化的地方,但是我</span></span><br><span class="line">        <span class="comment"># ifconfig ens33 $str1 </span></span><br><span class="line">        <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">                curl  --connect-timeout 1  -s http://www.baiud.com &gt; log.txt <span class="comment"># 如果局域网里面能够ping的话建议用ping</span></span><br><span class="line">                <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">                         <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span> isok&quot;</span></span><br><span class="line">                         <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span> isok&quot;</span> &gt;&gt; ok.txt</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span> not ok&quot;</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">                        i=$((<span class="variable">$i</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">sleep</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个/etc/sysconfig/network-scripts执行这个命令</p><h2 id="firewall-cmd">firewall-cmd</h2><ul><li>firewall-cmd --state 查看运行状态</li><li>firewall-cmd --zone=public --list-posts 查看开放的端口</li><li>firewall-cmd --zone=public --add-port=80/tcp --permanent 打开端口</li><li>firewall-cmd --zone=public --remove-port=80/tcp --permanent 关闭端口</li><li><strong>firewall-cmd --reload</strong>  所有开放端口关闭端口,都需要重新使用这个命令才能生效</li></ul><p>增加端口开关脚本</p><p>openport (输入参数为一个时,开启一个端口,两个时,开启[a,b) 左闭右开 )</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$#&quot; -gt &quot;0&quot; ]; then</span><br><span class="line">        if [ &quot;$#&quot; -eq &quot;1&quot; ]; then</span><br><span class="line">                firewall-cmd --zone=public --add-port=$1/tcp --permanent &gt; /dev/null</span><br><span class="line">        elif [ &quot;$#&quot; -eq &quot;2&quot; ]; then</span><br><span class="line">                a=$1</span><br><span class="line">                b=$2</span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;a=$2                 </span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;b=$1</span><br><span class="line">                for((i=$a;i&lt;$b;i++))</span><br><span class="line">                do</span><br><span class="line">                        firewall-cmd --zone=public --add-port=$i/tcp --permanent &gt; /dev/null</span><br><span class="line">                done            </span><br><span class="line">        fi</span><br><span class="line">        if [ &quot;$?&quot; -eq &quot;0&quot; ]; then</span><br><span class="line">                firewall-cmd --reload &gt; /dev/null</span><br><span class="line">                echo &quot;success&quot;</span><br><span class="line">        fi</span><br><span class="line"> </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>closeport(参数与openport同理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$#&quot; -gt &quot;0&quot; ]; then</span><br><span class="line">        if [ &quot;$#&quot; -eq &quot;1&quot; ]; then</span><br><span class="line">                firewall-cmd --zone=public --remove-port=$1/tcp --permanent &gt; /dev/null</span><br><span class="line">        elif [ &quot;$#&quot; -eq &quot;2&quot; ]; then</span><br><span class="line">                a=$1</span><br><span class="line">                b=$2</span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;a=$2                 </span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;b=$1</span><br><span class="line">                for((i=$a;i&lt;$b;i++))</span><br><span class="line">                do</span><br><span class="line">                        firewall-cmd --zone=public --remove-port=$i/tcp --permanent &gt; /dev/null</span><br><span class="line">                done            </span><br><span class="line">        fi</span><br><span class="line">        if [ &quot;$?&quot; -eq &quot;0&quot; ]; then</span><br><span class="line">                firewall-cmd --reload &gt; /dev/null</span><br><span class="line">                echo &quot;success&quot;</span><br><span class="line">        fi</span><br><span class="line"> </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="netstat">netstat</h2><p>查看网络状态</p><ul><li>-t 显示tcp相关选项</li><li>-u 显示udp相关选项</li><li>-n 拒绝使用别名 能用数字的用数字(不然看不了端口号)</li><li>-l 仅显示正在监听的网络的信息</li><li>-p 显示对应进程pid 以及其名字</li><li>-a 显示所有连线的socket</li></ul><h2 id="ifconfig">ifconfig</h2><p>查看电脑网卡信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有网卡信息</span></span><br><span class="line">ipconfig </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定网卡信息</span></span><br><span class="line">ipconfig ens33</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置网卡ip (临时有效,但是用了这个之后,路由什么的都没有了,很烦,就上不了网ss)</span></span><br><span class="line">ifconfig ens33 192.168.100.1 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开关网卡(临时</span></span><br><span class="line">ifconfig ens33 up/down</span><br></pre></td></tr></table></figure><h2 id="ip">ip</h2><p>这个命令操作的所有信息都是零时的,关机后再重启就没有了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ip link show                     # 显示网络接口信息</span><br><span class="line">ip link set ens33 up             # 开启网卡</span><br><span class="line">ip link set ens33 down            # 关闭网卡</span><br><span class="line">ip link set ens33 promisc on      # 开启网卡的混合模式</span><br><span class="line">ip link set ens33 promisc offi    # 关闭网卡的混个模式</span><br><span class="line">ip link set ens33 txqueuelen 1200 # 设置网卡队列长度</span><br><span class="line">ip link set ens33 mtu 1400        # 设置网卡最大传输单元</span><br><span class="line">ip addr show     # 显示网卡IP信息</span><br><span class="line">ip addr add 192.168.0.1/24 dev ens33 # 设置ens33网卡IP地址192.168.0.1</span><br><span class="line">ip addr del 192.168.0.1/24 dev ens33 # 删除ens33网卡IP地址</span><br><span class="line"></span><br><span class="line">ip route show # 显示系统路由</span><br><span class="line">ip route add default via 192.168.1.254   # 设置系统默认路由</span><br><span class="line">ip route list                 # 查看路由信息</span><br><span class="line">ip route add 192.168.4.0/24  via  192.168.0.254 dev ens33 # 设置192.168.4.0网段的网关为192.168.0.254,数据走ens33接口</span><br><span class="line">ip route add default via  192.168.0.254  dev ens33        # 设置默认网关为192.168.0.254</span><br><span class="line">ip route del 192.168.4.0/24   # 删除192.168.4.0网段的网关</span><br><span class="line">ip route del default          # 删除默认路由</span><br><span class="line">ip route delete 192.168.1.0/24 dev ens33 # 删除路由</span><br><span class="line">ip neigh list # 查看邻居表</span><br><span class="line"></span><br><span class="line">ip netns add nstest # 增加网络命名空间</span><br><span class="line">ip netns exec nstest bash # 进入某个网络命名空间</span><br><span class="line">ip netns exec nstest ip a # 在某个网络命明空间里面执行命令</span><br><span class="line"></span><br><span class="line">ip link add veth-a type veth peer name veth-b # 建立两张虚拟网卡,这两个网卡是直连的,协议是以太网</span><br><span class="line">ip link set veth-b netns nstest # 把网卡交给某个命名空间</span><br></pre></td></tr></table></figure><h2 id="route">route</h2><h2 id="iptables">iptables</h2><p>它是linux内核中的包过滤防火墙,它包含四个表(filter(包过滤表),nat(地址转化表),mangle(修改数据标记位规则表),raw(跟踪数据规则表)), 5 个规则链。每个规则表中可能包含多个数据链：INPUT（入站数据过滤）、OUTPUT（出站数据过滤）、FORWARD（转发数据过滤）、PREROUTING（路由前过滤）和POSTROUTING（路由后过滤）</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221215110855463.png" alt="image-20221215110855463"></p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/61db8ee6e3f5b58f914ae9a26a60a039.jpeg" alt="61db8ee6e3f5b58f914ae9a26a60a039"></p><p>语法格式</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221215112303404.png" alt="image-20221215112303404"></p><p>iptables [-t table] COMMAND [chain] CRETIRIA -j ACTION</p><p>常用参数</p><ul><li>-t 指定要操作的规则表,默认为filter表</li><li>COMMAND 子命令</li><li>chain 指明链路</li><li>CRETIRIA 匹配参数</li><li>ACTION 触发动作</li></ul><p>子命令常用选项</p><ul><li>-L 列出表规则</li><li>-F 清空表规则</li><li>-A 添加防火墙规则</li><li>-D 删除防火墙规则</li><li>-I 插入表规则</li><li>-R 替换防火墙规则</li></ul><p>触发动作</p><ul><li>ACCEPT 允许包通过</li><li>DROP 丢弃包</li><li>REJECT 拒绝数据包</li><li>LOG 将数据包信息记录 syslog 曰志</li><li>DNAT 目标地址转换</li><li>SNAE 源地址转换</li><li>MASQUERADE 地址欺骗</li><li>REDIRECT 重定向</li></ul><p><strong>设置规则的时候就是这样    对一个表里的一个链,如果数据包满足这个要求, 就执行这个表对应的操作</strong></p><p><strong>在处理数据包的时候就是这样:  查看这个链上所有的表规则, 根据之前的设置的匹配规则,执行相应的操作</strong></p><h2 id="设置代理">设置代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare -x all_proxy=&quot;socks://192.168.100.1:7890/&quot;</span><br><span class="line">declare -x http_proxy=&quot;http://192.168.100.1:7890/&quot;</span><br><span class="line">declare -x no_proxy=&quot;localhost,127.0.0.0/8,::1&quot;</span><br></pre></td></tr></table></figure><h2 id="配置网络信息">配置网络信息</h2><p>配置文件位置：</p><ol><li><strong>CentOS / RHEL / Fedora</strong>：在这些基于 Red Hat 的系统中，网络接口配置文件通常位于 <code>/etc/sysconfig/network-scripts/</code> 目录下，文件名为 <code>ifcfg-&lt;interface&gt;</code>，例如 <code>ifcfg-eth0</code>。</li><li><strong>Debian / Ubuntu</strong>：在这些基于 Debian 的系统中，网络接口配置文件通常在 <code>/etc/network/interfaces</code> 或者 <code>/etc/netplan/</code> 目录下。Ubuntu 18.04 及以上版本默认使用 Netplan，配置文件通常以 <code>.yaml</code> 结尾。</li><li><strong>Arch Linux / Manjaro</strong>：在这些系统中，网络接口的配置通常在 systemd-networkd 或 NetworkManager 中完成。</li><li><strong>openSUSE / SLES</strong>：在这些系统中，网络接口的配置文件通常位于 <code>/etc/sysconfig/network/</code> 目录下。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;        # 网卡类型</span><br><span class="line">PROXY_METHOD=&quot;none&quot;    # 代理方式</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;   </span><br><span class="line">BOOTPROTO=&quot;none&quot;   # ip设置方式  none:不使用协议,自己指定  static: 静态ip,自己指定  dhcp: 动态获取</span><br><span class="line">DEFROUTE=&quot;yes&quot;   # 默认路由</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot; </span><br><span class="line">IPV6INIT=&quot;yes&quot;    </span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;  # 网卡物理设备名称</span><br><span class="line">UUID=&quot;3ebc507c-6401-4454-b5ff-4108c88f230a&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;           # 网卡设备名称,必须和name一样</span><br><span class="line">ONBOOT=&quot;yes&quot;# 是否开机自启动</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果没有用 dhcp协议的话,下面这些就得自己指定</span></span></span><br><span class="line">IPADDR=&quot;192.168.100.3&quot;   # ip地址</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;  # 子网掩码   PREFIX=24  推荐用这个,写起来方便</span><br><span class="line">GATEWAY=&quot;192.168.100.2&quot;  # 网关</span><br><span class="line">DNS1=&quot;192.168.100.2&quot;     # dns服务器,可以指定多个 比如 DNS2=&quot;114.114.1&quot;</span><br></pre></td></tr></table></figure><h2 id="networkmanager-与-network的区别">NetworkManager  与 network的区别</h2><p><code>NetworkManager</code> 和 <code>network</code> 都是 Linux 系统中用来管理网络连接的服务，但它们有一些重要的不同：</p><ol><li><p><strong>NetworkManager</strong> 是一个动态的网络控制和配置系统，主要用于桌面环境，也可用于移动设备如笔记本电脑。NetworkManager 试图让网络配置尽可能简单和自动化，它会自动连接到以前的网络，处理 Wi-Fi 连接，管理 VPN 连接等。NetworkManager 还可以管理各种类型的网络接口，包括有线、无线和移动宽带。</p></li><li><p><strong>network（或 network.service）</strong> 是一种更传统的网络管理服务，通常用于服务器或不经常改变网络配置的系统。它通常用于在系统启动时应用静态的网络配置，例如 IP 地址，网关，DNS 服务器等。一旦网络配置被设置，除非管理员手动改变，否则通常不会改变。</p></li></ol><p>简单来说，NetworkManager 更适合需要动态和自动网络配置的系统，例如桌面系统或笔记本电脑，而 network 服务更适合需要静态和稳定网络配置的系统，例如服务器。</p><p>你选择使用哪种服务取决于你的特定需求。如果你需要动态处理多种网络连接，或者你的网络设置经常改变，那么 NetworkManager 可能是更好的选择。如果你的网络设置相对固定，你希望有完全的控制权，那么 network 服务可能是更好的选择。</p><p>如果我们希望手动配置网络的话,我们得把NetworkManager 禁用掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager </span><br><span class="line">systemctl disable NetworkManager </span><br></pre></td></tr></table></figure><h1>玩转linux network namespace</h1><h2 id="创建一个网络命令空间并且与主机相通">创建一个网络命令空间并且与主机相通</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip netns add nstest</span><br><span class="line">ip link add veth-a type veth peer name veth-b  # 创建两张虚拟网卡</span><br><span class="line">ip link set veth-b netns nstest # 将网卡分给nstest</span><br><span class="line">ip netns exec nstest ip a # 查看nstest的网卡信息</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在还不能通信,除非你可以在数据链路层发送帧</span></span><br><span class="line">ip addr add 10.0.0.1/24 dev veth-a # 为主机上的veth-a网卡添加ip</span><br><span class="line">ip netns exec nstest ip addr add 10.0.0.2/24 dev veth-b # 为nstest上的veth-b网卡添加ip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动两张网卡</span></span><br><span class="line">ip link set dev veth-a up</span><br><span class="line">ip netns exec nstest  ip link set dev veth-b up</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看路由,这个时候会多出来一条路由记录</span></span><br><span class="line">ip route </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测是否能够ping通</span></span><br><span class="line">ping 10.0.0.2 -c 4 </span><br><span class="line">ip netns exec nstest ping 10.0.0.1 -c 4</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>删掉网络空间就会把两个相连的网卡删掉   ip netns delete nstest</p></blockquote><h2 id="创建两个网络空间并且能够互通">创建两个网络空间并且能够互通</h2><blockquote><p>其实也差不多,这不过一头在另外一个ns中</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加两个命名空间</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建两张互连网卡</span></span><br><span class="line">ip link add veth-a type veth peer name veth-b</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给两张网卡分配到两个命名空间中</span></span><br><span class="line">ip link set veth-a netns ns1</span><br><span class="line">ip link set veth-b netns ns2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动网卡</span></span><br><span class="line">ip netns exec ns1 ip link set veth-a up</span><br><span class="line">ip netns exec ns2 ip link set veth-b up</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分配ip</span></span><br><span class="line">ip netns exec ns1 ip addr add 10.0.0.1/24 dev veth-a</span><br><span class="line">ip netns exec ns2 ip addr add 10.0.0.2/24 dev veth-b</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试连通</span></span><br><span class="line">ip netns exec ns1 ping 10.0.0.2 -c 4</span><br><span class="line">ip netns exec ns2 ping 10.0.0.1 -c 4</span><br></pre></td></tr></table></figure><blockquote><p>ping 不通自己的原因是 lo本地回环网卡没开</p><p>ip netns list 是在/var/run/netns 里面查找ns</p></blockquote><h1>SELinux</h1><h1>额外补充</h1><h2 id="span-id-t1-目录权限与文件权限的区别-span"><span id="t1">目录权限与文件权限的区别  </span></h2><p><strong>文件权限</strong>: 给了某个权限就能用某个权限,没给权限就不能用,比如没给x权限,你就不能执行这个程序,哎,有人就刚我了,它说我这里有个shell脚本,<strong>用sh能够执行啊,大哥,你那是把脚本里面的东西读出来一句一句给sh去执行</strong>呢,你把读权限关了试试,如果我们不是文件的拥有者(root除外),我们无法更改文件的路径,权限,所有者</p><p><strong>目录权限</strong>: 如果我们没有 这个目录的 x权限,我们是无法进入这个目录的(也就是把当前工作目录变成这个目录,例如cd命令就无法使用),也无法查看里面的东西(最多看到文件名),也就没有办法对这个目录执行任何命令, 在 x权限的基础上,有了r权限,我们才能这个这个目录下面的文件的属性,这个目录下的东西又有它们的权限, 在有了x权限的基础上,有了w权限,我们可以在这个文件夹里删除任何数据,创建任何数据(没有特殊权限参与),不管这个文件或者文件夹属于谁.</p><p><strong>工作目录</strong>:就是pwd显示的目录,如果我们不能把某个目录当成我们的工作目录(即 没有x权限,那么我们是无法对这个目录执行任何命令的</p><p>总结:<strong>如果我们开放一个目录的权限,首先要开放x权限,只给r,w是没有用的</strong>,如果我们要给一个文件权限,我们可以看着给,是只给读还是只给执行,还是混着来</p><h2 id="sudoers文件如何编写">sudoers文件如何编写</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为单独一个用户设置</span> </span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名  可以在哪些主机上下达命令 可以切换的账号  可以执行的命令</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为一个群组设置(只要是这个群组的人就可以享受下面的这个配置)</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">wheel  ALL=(ALL)       ALL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">群组名称 可以在哪些主机上下达命令 可以切换的账号  可以执行的命令</span>  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面配置好后,使用sudo的时候,需要输入自己的密码,还是挺麻烦的</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">无密码使用sudo</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">wheel  ALL=(ALL)       NOPASSWD:ALL</span></span><br><span class="line">root    ALL=(ALL)       NOPASSWD:ALL</span><br></pre></td></tr></table></figure><h2 id="重定向">重定向</h2><p>&gt; 代表 覆盖</p><p>&gt;&gt; 代表追加</p><h2 id="什么是管道命令">什么是管道命令(|)</h2><blockquote><p>用来连接多条命令,前一个<strong>命令正确</strong>后,其<strong>输出流会变成后一个命令的输入流</strong>(此时前一个命令的输出不会再打印到终端),<strong>而不是参数</strong></p><p>我个人当时难以区分的就是参数与输入流 参数的参数,输入流是输入流,不要搞混了,有些命令可以带参数,但是不具备输入流</p><p><strong>管道命令还可以当连接命令来用,可以连接很多命令,这些命令都会执行</strong></p></blockquote><h2 id="配置path环境变量的方法">配置PATH环境变量的方法</h2><h3 id="方式一">方式一</h3><p>可以在 ~/.bash_profile(只有当前用户可以用) 或者 /etc/profile(全部用户都可以用) 的末尾加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:目录的绝对路径(必须是目录和绝对路径)</span><br></pre></td></tr></table></figure><p>然后 再 source  ~/.bash_profile 或者 /etc/profile</p><p>这两个的区别在于 一个只有当前用户生效,一个全局生效</p><p>其实也可以在 ~/.bashrc里面更改</p><h3 id="方式二">方式二</h3><p>通过软连接把应用程序连接到已经在PATH的路径下 列如 /urs/bin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 程序绝对地址 /usr/bin</span><br></pre></td></tr></table></figure><h2 id="命令与服务的区别">命令与服务的区别</h2><p>命令运行一次就结束了,比如ls,cd 这些,都是放在环境变量下面的,而服务是启动后就一直再后台跑,接收请求,响应请求</p><h2 id="设置回收站">设置回收站</h2><p>建议使用rm 命令的时候一定要格外注意特别是 rm -rf ./ 与 rm -rf / 我的建议是都是用绝对路径,另外也不要配置管道命令来使用</p><p>用别名把rm替换成mv这个命令,然后移动到回收站中,我这里做一个简易的回收站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建回收站目录</span></span><br><span class="line">mkdir /trash</span><br><span class="line"></span><br><span class="line">vim /etc/bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在最后面输入</span></span><br><span class="line"></span><br><span class="line">alias rm=trash</span><br><span class="line"></span><br><span class="line">trash()&#123;</span><br><span class="line">    mv $@ /trash #这个路径必须和回收站路径一样</span><br><span class="line">&#125;</span><br><span class="line">rmtrash()&#123;</span><br><span class="line">         read -p &quot;确定要清空回收站吗?[y/n]&quot; confirm</span><br><span class="line">    [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ] &amp;&amp; /bin/rm -rf /trash/* #这个路径也要和回收站路径一样</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入完成后退出,更新</span></span><br><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure><p>千万不要用 mv /* 所以这个回收站还是没啥用</p><h2 id="如何设置系统时间">如何设置系统时间</h2><p>linux有系统时间与硬件时间的区别,我们更改系统时间的同时,也要同步硬件时间</p><h3 id="方式一">方式一</h3><p>使用date命令更改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2022-11-11 20:00:00&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同步硬件时间</span></span><br><span class="line">clock --systohc</span><br></pre></td></tr></table></figure><p>这种方式只能一次生效,当你的系统没有运行了,时间也会停止.</p><h3 id="方式二-推荐">方式二(推荐)</h3><p>使用tzselect更改时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tzselect</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入完后根据提示选择即可</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选择完后会输出下面一段信息</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ou can make this change permanent <span class="keyword">for</span> yourself by appending the line</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span>; <span class="built_in">export</span> TZ</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">to the file <span class="string">&#x27;.profile&#x27;</span> <span class="keyword">in</span> your home directory; <span class="keyword">then</span> <span class="built_in">log</span> out and <span class="built_in">log</span> <span class="keyword">in</span> again.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最后一定要进行下一步,将上面选择的时区信息加到启动配置文件中去(系统启动之后才会看到时间更改)</span></span><br><span class="line">echo &quot;TZ=&#x27;Asia/Shanghai&#x27;; export TZ&quot; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure><h2 id="export">export</h2><p>终端分 自订变量与环境变量 通过set 或者 直接赋值的变量是 自订变量,<strong>通过export的会变成环境变量</strong>,<strong>每个子程序会复制父程序的环境变量,而不会复制父程序的自订变量</strong>,</p><h2 id="source与sh的区别">source与sh的区别</h2><p>source 或者 . <strong>不另开进程执行脚</strong>本,而sh 或者 ./ 会另开进程执行脚本,<strong>source 能够使用 当前终端的自订变量,sh不能</strong></p><h2 id="nonloginshell和loginshell的区别">nonloginshell和loginshell的区别</h2><p>在Unix和类Unix系统中，shell通常分为两种类型：登录shell（login shell）和非登录shell（non-login shell）。他们之间的主要区别在于他们启动时执行的配置文件不同。</p><ol><li><p><strong>登录shell（login shell）</strong>：当用户从命令行界面登录到系统（例如通过SSH或在控制台上登录），或者使用<code>su - username</code>命令切换用户时，会启动一个登录shell。登录shell在启动时会读取并执行一些配置文件，例如<code>/etc/profile</code>，<code>~/.bash_profile</code>，<code>~/.bash_login</code>，<code>~/.profile</code>（取决于具体的shell类型）。</p></li><li><p><strong>非登录shell（non-login shell）</strong>：当用户在已登录的会话中启动一个新的shell（例如通过运行<code>bash</code>或<code>sh</code>命令），或者通过图形用户界面（如GNOME或KDE）启动一个终端模拟器时，会启动一个非登录shell。非登录shell不会读取上述的配置文件，但会读取其他的配置文件，例如<code>~/.bashrc</code>。</p></li></ol><p>因此，你可以根据需要在不同的配置文件中设置不同的环境变量和别名。例如，你可能希望一些只在登录时需要的环境变量（例如，设置启动程序或会话路径）在<code>~/.bash_profile</code>中设置，而一些在每次启动shell时都需要的设置（例如，命令别名或提示符设置）在<code>~/.bashrc</code>中设置。</p><p>另外，<code>/sbin/nologin</code>和<code>/bin/false</code>是特殊类型的shell，它们被称为禁止shell（disallowed shell）。这些shell被分配给那些不需要或不应该拥有shell访问权限的用户（例如，系统用户或服务用户）。尝试登录到这样的用户会失败，因为这些shell会立即退出，而不提供交互式命令行界面。</p><p><code>/sbin/nologin</code>是<strong>为那些不需要或不应该拥有完全shell访问权限的用户设置的shell类型</strong>。<strong>这些用户通常是系统用户或服务用户，它们主要用于运行系统服务或进程，而不是供人类用户登录和交互</strong>。</p><p>举个例子，你可能有一个运行web服务器（例如Apache）的用户，这个用户可能会被设置为<code>/sbin/nologin</code>。这意味着没有人可以登录到这个用户账户进行交互，<strong>但是Apache服务可以以这个用户的身份运行，可以访问这个用户拥有的文件和资源</strong>。</p><p>这样设置的主要原因是出于安全考虑。如果一个攻击者能够通过某种方式获取到这个用户的密码，他们也无法登录到这个账户，因为它的shell被设置为了<code>/sbin/nologin</code>。这增加了系统的安全性。</p><h2 id="各个环境配置文件的区别">各个环境配置文件的区别</h2><p>我们得先区分loginshell 与 nonloginshell 的区别,loginshell是用户登录取得bash的时候需要完整的登录流程,nologinshell 是 当我们登录后,再启动子bash程序,是不需要再登录的,这个就是nologinshell</p><p>/etc/profile (loginshell 才会去读) 是 <strong>每个用户登录取得bash的时候会读取一遍的文件</strong></p><p>~/.bash_profile(loginshell 才会去读)  bash 读取完全局的/etc/profile 后 会读取用户自己的配置文件, 它其实有个顺序,  .bash_profile .bash_login  .profile  <strong>只要前面的文件存在,后面的文件就不会被读取</strong>,我们可以看一下.bash_profile 的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then    </span><br><span class="line">        . ~/.bashrc   </span><br><span class="line">fi</span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们发现它还会去找 家目录下的 bashrc文件</p><p>~/.bashrc(nonloginshell 才会去读),我们每启动一个子终端,就回去读取一次的文件,我们可以看一下文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>我么发现它还去读了/etc/bashrc 这个配置文件</p><p>这些东西都是在root用户下看的哦,不同的用户可能不同</p><p><strong>总结:  在loginshell 中 bash 会去读取/etc/profile   ~/.bash_profile ,在 nonloginshell中bash 会去读取~/.bashrc里面的东西,这些是bash会帮我们自动读取的,如果需要读其他配置文件,我们需要在上面的shell中写好读取哪些文件</strong></p><h2 id="特殊变量中-与-的区别">特殊变量中$* 与 $@ 的区别</h2><p>如果直接使用$* 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">@</mi><mtext>他们没有任何区别</mtext><mo separator="true">,</mo><mtext>如果加上双引号</mtext><mo separator="true">,</mo><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">@ 他们没有任何区别,如果 加上双引号,&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">@</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">没</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">何</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">别</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">号</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">&quot;</span></span></span></span>*“循环遍历的时候是一个整体,而”$@&quot; 则是 分开遍历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">传入参数 1 2 3 4</span></span><br><span class="line">for i in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出 1 2 3 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看端口占用情况">查看端口占用情况</h2><h3 id="查看端口是否被占用">查看端口是否被占用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :80</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">netstat -tunlp | grep 80</span><br></pre></td></tr></table></figure><h3 id="查看进程占用哪个端口">查看进程占用哪个端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep nginx(进程大概名字)</span><br></pre></td></tr></table></figure><h2 id="测试远程端口是否开放">测试远程端口是否开放</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install telnet</span><br><span class="line"></span><br><span class="line">telnet ip port</span><br></pre></td></tr></table></figure><h2 id="如何上传文件到服务器">如何上传文件到服务器</h2><h3 id="使用ftp">使用ftp</h3><p>这里有一个容易搞混的地方就是,linux 里面是不是带有一个ftp 命令,这个是一个命令,而不是一个服务,它相当于ftp客户端,可以上传文件到服务器,所以要想使用ftp传输文件到服务器需要先在服务器中启动一个ftp服务</p><p>安装ftp服务器并且启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装ftp服务器</span></span><br><span class="line">yum install vsftpd -y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动ftp服务器</span></span><br><span class="line">systemctl start vsftpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记得关闭防火墙,如果不关闭防火墙就需要开启端口</span></span><br></pre></td></tr></table></figure><p>启动后需要注意的是它的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls  /etc/vsftpd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ftpusers  user_list  vsftpd.conf  vsftpd_conf_migrate.sh</span></span><br><span class="line">user_list: 里面的用户无法登陆ftp服务器</span><br><span class="line">vsftpd.conf: 里面ftp服务器的相关配置</span><br></pre></td></tr></table></figure><p>推荐一款客户端ftp工具</p><p><a href="https://filezilla-project.org/">https://filezilla-project.org/</a></p><p>其实也可以直接使用windows自带的,直接在资源管理器的路径里面输入 <a href="ftp://192.168.183.128/">ftp://192.168.183.128/</a></p><p>注意点: 使用ftp时,就只能操作当前ftp用户的家目录,其他的目录是操作不了的</p><h3 id="使用scp">使用scp</h3><p>格式:</p><p>scp 参数 源地址 目的地址</p><p>将源地址的东西 放到目的地址上面 ,所以可以实现上传与下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传普通文件</span></span><br><span class="line">scp root@192.168.183.128:路径 ./ </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传目录文件</span></span><br><span class="line">scp -r root@192.168.183.128:路径 ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载相反就可以了</span></span><br></pre></td></tr></table></figure><h2 id="如何下载网上文件">如何下载网上文件</h2><h3 id="wget">wget</h3><ul><li>-b 后台下载 输出的东西会写到日志文件中去</li><li>-q 就是不输出日志</li><li>-O 就是起别名 wget -O 别名  url</li><li>可以支持多个文件下载 url之间用空格隔开就行</li><li>-i 可以实现批量下载 wget -i test.txt  test.txt里面写上要下载的url路径</li><li>-c 适合下载大文件,如果网路被中断,就会暂停之前的下载,如果我们不使用这个参数就会从头下载,所以这个参数可以继续之前的下载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.75/bin/apache-tomcat-9.0.75.zip</span><br></pre></td></tr></table></figure><h3 id="curl">curl</h3><p>这个命令的功能可以充当一个http客户端,可以发起http请求,所以也可以下载文件</p><ul><li>-O url</li><li></li></ul><h2 id="network服务启动失败">network服务启动失败</h2><p>在CentOS系统上，目前有NetworkManager和network两种网络管理工具。如果两种都配置会引起冲突。由于一般我们都是使用 network 配置静态ip，可能是关机（某种缘故）导致NetWorkManager自动配置，发生了冲突，所以把它禁用掉就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl disable NetworkManager</span><br></pre></td></tr></table></figure><h2 id="通过公钥远程连接">通过公钥远程连接</h2><p>如果两边机器都没有秘钥的话得先生成秘钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>一路回车下去</p><h3 id="手动放入公钥">手动放入公钥</h3><p>将本地的公钥放入被登录机器的authorized_keys中,如果文件不存在就需要创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">touch authorized_keys # 创建文件,然后将公钥放入这里面就可以了</span><br></pre></td></tr></table></figure><h3 id="通过命令放入公钥">通过命令放入公钥</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@192.168.100.101</span><br></pre></td></tr></table></figure><p>然后输入对方密码即可</p><h3 id="修改authorized-keys权限">修改authorized_keys权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="ssh-设置好公钥还是需要密码验证">ssh 设置好公钥还是需要密码验证</h2><p>这个大概率是权限问题,我们可以通过下面这个查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">journalctl --unit=sshd</span><br><span class="line"></span><br><span class="line">Nov 21 10:09:47 localhost.localdomain sshd[2760]: Authentication refused: bad ownership or modes for file /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>发现权限出了错误,我们只需要更改权限就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">chmod 700 .</span><br><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><h2 id="同一个服务开启多个">同一个服务开启多个</h2><p>我们有时候可能需要多个一样的服务,下面以ftp服务器为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制一份配置文件</span></span><br><span class="line">cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd2.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改端口</span></span><br><span class="line">vim /etc/vsftpd/vsftpd2.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加一行</span></span><br><span class="line">listen_port=555</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置启动服务脚本</span></span><br><span class="line">cp /usr/lib/systemd/system/vsftpd.service /usr/lib/systemd/system/vsftpd2.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改配置文件位置</span></span><br><span class="line">vim /usr/lib/systemd/system/vsftpd2.service</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd2.conf  # 改成我们刚刚新增的配置文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新载入配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看我们的服务是否加载进来了</span></span><br><span class="line"> systemctl list-unit-files | grep vsftpd</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">输出下面这个vsftpd2就代表加载进来了</span></span><br><span class="line">vsftpd.service                                disabled</span><br><span class="line">vsftpd2.service                               disabled</span><br><span class="line">vsftpd@.service                               disabled</span><br><span class="line">vsftpd.target                                 disabled</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">systemctl status vsftpd2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动服务</span></span><br><span class="line">systemctl start vsftpd2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关闭交换区">关闭交换区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除交换区的内容</span></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让交换区启动不挂载</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line">UUID=053918e3-e0ed-4a26-be89-61424b5d40ab /                       xfs     defaults        0 0</span><br><span class="line">UUID=32920875-4523-4302-a295-1267fd27952d /boot                   xfs     defaults        0 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">UUID=9c3b3cd9-6cd2-4b4c-8395-38f081300bd8 swap                    swap    defaults        0 0 <span class="comment"># 注释掉这一行</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="桌面系统开关">桌面系统开关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭桌面,开启命令模式</span></span><br><span class="line">systemctl set-default multi-user.target</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启桌面</span></span><br><span class="line">systemctl set-default graphical.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得重启</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="忘记密码了怎么办-centos-7">忘记密码了怎么办(centos 7)</h2><p>没忘记root密码 直接passwd修改用户密码</p><p>忘记root密码  采用单用户进入</p><p>方式一</p><p>刚启动系统时 就按 e 键 跳转到启动配置页面 <strong>将 ro 及其后面的这一行的字符全部删掉变成</strong> rw init=/bin/sh crashkernel=auto</p><p>然后 <strong>Ctrl+x</strong>  就会进入单用户模式 然后输入passwd 就能更改密码</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111145547.png" alt="image-20221205111145547"></p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111314908.png" alt="image-20221205111314908"></p><p>方式二</p><p>刚启动系统时 就按 e 键 跳转到启动配置页面 ,然后新增rd.break,ctrl+x然后chroot /sysroot 然后 passwd就行了</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111748610.png" alt="image-20221205111748610"></p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111850903.png" alt="image-20221205111850903"></p><h1>踩过的坑</h1><h2 id="1-selinux策略">1.SELinux策略</h2><p>这是一个安全策略,它默认是开启的,只要任何违反策略的行动都会被禁止,我们对这个策略不了解当然不知道怎么才能访问,怎么就不可以访问,我当时在centos7上,安装了一个nginx,然后把访问根目录放在了root目录下,权限也都开放了,还是403,最后把这个玩意弄成disable就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br><span class="line">把SELINUX=enforceing</span><br><span class="line">改成SELINUX=disable</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然,这样我们就失去了selinux的防护,作为一个爱好linux的人,当然要借此把linux的权限搞清楚</p><h1>小技巧</h1><p>1.当我们的服务起不来,没有提示信息的时候,一定要去找报错信息,起服务的时候把它能显示信息的参数全部带上,没找到解决办法,就去用systemctl status 去看看有什么提示没</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云模型概述</title>
      <link href="/2022/11/24/%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/11/24/%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不同的人对于云计算的要求是不一样的,有的需要灵活,有的需要方便,因此诞生出了几种云服务模型,我们可以根据自己的需要,选择不同的云计算模型</p><h2 id="iaas-基础设施即服务">IaaS(基础设施即服务)</h2><p>云服务商帮我们管理那些硬件,服务器啊,网络啊,存储啊,不需要我们去操心,如果你不想自己去购买与维护这些硬件,那么Iaas是一个很好的选择,在这个模型下我们仍有很大的工作量要去做,管理操作系统,数据库,应用程序,但是也相对灵活</p><h2 id="paas-平台即服务">PaaS(平台即服务)</h2><p>云服务商,提供了基本的操作系统,数据库,web服务器,中间件这些,我们只要专心的写我们的代码和少量的平台搭建</p><h2 id="saas-软件即服务">SaaS(软件即服务)</h2><p>云服务商给我提供好已经可以开箱即用的应用程序,我们只需要关心怎么去运营就好了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/2021/10/01/python/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/10/01/python/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>字符串三种格式:</p><p>‘hello’  “hello”  “”“hello”&quot;&quot;  前面两种没有什么区别,第三种跟前面两种的区别在于 里面是可以直接换行的,不需要\n</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
